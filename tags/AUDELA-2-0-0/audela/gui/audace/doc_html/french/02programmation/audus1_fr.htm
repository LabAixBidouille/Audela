<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>LibAudeLA</title>
</head>

<body>
<p class="date">Date de mise &agrave; jour : 03 mars 2007</p>
<h1>LibAudeLA</h1>
<h1>Librairie d'extension Tcl pour l'astronomie - Manuel Utilisateur</h1>
<h2> 1. Principes g&eacute;n&eacute;raux</h2>
<p>LibAudeLA ajoute, &agrave; Tcl, des fonctions sp&eacute;cialis&eacute;es &agrave; l'astronomie : gestion d'images au format FITS, traitement d'image, pilotage de cam&eacute;ras et de t&eacute;lescopes, etc. Pour faciliter l'utilisation, de nombreuses fonctions ont &eacute;t&eacute; rassembl&eacute;es en familles appel&eacute;es objets. Faisons un rapide tour d'horizon de ces objets : </p>
<ul>
  <li><a href="#buf">buffer</a> : les fonction de buffer permettent de charger une image en m&eacute;moire, la sauver sur le disque et permet quelques traitements d'images. </li>
  <li><a href="#cam">cam&eacute;ra</a> : les fonctions de cam&eacute;ra permettent de param&eacute;trer l'acquisition d'image par des cam&eacute;ras CCD. </li>
  <li><a href="#visu">visualisation</a> : les fonctions de visualisation permettent de param&eacute;trer l'affichage des images dans une fen&ecirc;tre du logiciel. </li>
  <li><a href="#tel">t&eacute;lescope</a> : les fonctions de t&eacute;lescope permettent de param&eacute;trer le pointage et le suivi de t&eacute;lescopes.</li>
</ul>
<p>Ces fonctions sont d&eacute;finies dans le fichier libaudela.dll (sous Windows) et libaudela.so (sous Linux). LibAudeLA g&egrave;re la lecture et l'&eacute;criture disque des images, aux formats FITS et Jpeg, est assur&eacute; par la librairie <a href="ttus1-fr.htm">LibTT.</a> Cette librairie est appel&eacute;e automatiquement par LibAudeLA. LibTT ajoute aussi de nombreuses fonctions de traitement d'images &agrave; LibAudeLA (appelables &agrave; partir de l'objet buffer). </p>
<p>Pour fonctionner correctement, LibAudeLA n&eacute;cessite de charger les extensions Tcl <a href="gzipus-fr.htm">LibGzip</a>, <a
 href="mcusr_fr.htm">LibMC</a>. </p>
<p>Enfin, LibAudeLA ajoute aussi <a href="#biblio">quelques fonctions utiles</a> &agrave; l'interpr&eacute;teur Tcl </p>
<h2> <a name="obj" id="obj"></a>2. Utilisation des objets de AudeLA</h2>
<p>Le principe de fond de AudeLA est de travailler avec des objets qui ont une t&acirc;che sp&eacute;cifique. Ainsi il existe quatre types d'objets : l'objet cam&eacute;ra, t&eacute;lescope, buffer, et visualisation. Ils sont configurables afin de r&eacute;pondre aux exigences de l'utilisateur. Il est aussi possible d'avoir plusieurs objets de chaque type. Les commandes de base suivantes permettent de cr&eacute;er des objets de chaque type, de les d&eacute;truire, et de savoir combien il en existe dans le syst&egrave;me AudeLA. La cr&eacute;ation de ces objets donne lieu &agrave; la cr&eacute;ation des structures de donn&eacute;es internes &agrave; AudeLA qui permettent de les g&eacute;rer. Les diff&eacute;rents objets d'un m&ecirc;me type sont num&eacute;rot&eacute;s : si le num&eacute;ro n'est pas impos&eacute;, alors c'est le plus petit disponible qui est utilis&eacute; (&agrave; partir de 1). Une commande sp&eacute;cifique est alors cr&eacute;&eacute;e pour acc&eacute;der &agrave; ses donn&eacute;es. Par exemple si on souhaite cr&eacute;er un buffer, il faut utiliser la commande "<code>::buf::create</code>" qui met en place toutes les structures de donn&eacute;es du buffer. Si c'est le premier buffer cr&eacute;&eacute; alors il port le num&eacute;ro 1 : la commande permettant d'y acc&eacute;der par la suite est alors <code>buf1</code>. Si on cr&eacute;&eacute; d'autres buffers, d'autres commandes sont cr&eacute;&eacute;es, et elles commencent toutes par <code>buf</code>, suivi du num&eacute;ro du buffer.</p>
<p>La commande cr&eacute;&eacute;e avec chaque &eacute;l&eacute;ment permet d'acc&eacute;der &agrave; ses donn&eacute;es, mais aussi d'agir dessus. Par exemple pour effectuer un offset sur un image, la commande "<code>buf1 offset 100</code>" doit &ecirc;tre utilis&eacute;e. De m&ecirc;me pour conna&icirc;tre les coordonn&eacute;es d'un t&eacute;lescope (informatis&eacute;) if faut ex&eacute;cuter "<code>tel1 coord</code>". </p>
<p>Par exemple, pour cr&eacute;er un buffer et y charger l'image du fichier toto.fit, on proc&eacute;dera ainsi : </p>
<code>set num [::buf::create]</code> <code>buf$num load toto.fit</code>
<p>L'ensemble des fonctions de pilotage de cam&eacute;ra, de t&eacute;lescope et d'affichage d'image fonctionnent sur ce principe. Les objets de type cam&eacute;ra ou t&eacute;lescopes peuvent appeler des drivers externes. Le chargement est automatique et transparent &agrave; l'utilisateur. Si un driver externe existe et a le m&ecirc;me nom qu'un driver interne alors c'est le driver externe qui est choisi. Par exemple, la fonction <code>::cam::create audine lpt1</code> utilise le driver externe libaudine.dll (libaudine.so sous Linux) si ce fichier existe. </p>
<h2> <a name="buf" id="buf"></a>2.1. <a href="buf.htm">buffers</a></h2>
<p>La commande "<code>::buf::create</code>" a pour r&ocirc;le de cr&eacute;er un buffer, c'est &agrave; dire un ensemble de donn&eacute;es capables de contenir une image, et des mots-cl&eacute;s FITS pour l'identifier. Bien entendu juste apr&egrave;s la cr&eacute;ation le buffer ne contient pas d'image, ni de mots-cl&eacute;s. La liste des commandes pour la gestion de buffer est donn&eacute;e ci-dessous :</p>
<table>
  <tr>
    <td>Commande</td>
    <td>Arguments</td>
    <td>R&ocirc;le</td>
  </tr>
  <tr>
    <td><code>::buf::create</code></td>
    <td><code>?numero?</code></td>
    <td>Cr&eacute;er un buffer vide, sans mots-cl&eacute;s FITS. Si aucun num&eacute;ro n'est sp&eacute;cifi&eacute;.</td>
  </tr>
  <tr>
    <td><code>::buf::delete</code></td>
    <td><code>numero</code></td>
    <td>Efface le buffer dont le num&eacute;ro est donn&eacute; en param&egrave;tre, donc son contenu est effac&eacute;, son num&eacute;ro est retir&eacute; de la liste des buffers, et &agrave; nouveau disponible pour en recr&eacute;er un.</td>
  </tr>
  <tr>
    <td><code>::buf::list</code></td>
    <td></td>
    <td>Renvoie une liste des num&eacute;ros de buffers utilis&eacute;s.</td>
  </tr>
</table>
<p>La liste des <a href="buf.htm">fonctions de buffer sont d&eacute;crites en d&eacute;tail</a> en cliquant ici. Voici un r&eacute;sum&eacute; :</p>
<ul>
  <li> Chargement et sauvegarde d'images au format FITS. Tous les formats de donn&eacute;es d'images (BITPIX) sont autoris&eacute;s. </li>
  <li>Chargement et sauvegarde des en-t&ecirc;tes des images FITS. Il est possible de lire, de retirer ou d'ajouter des mot cl&eacute;s, de modifier des valeurs, etc. </li>
  <li>Analyse &eacute;l&eacute;mentaire de l'image : Photocentre, flux d'une r&eacute;gion. Statistiques sur une image. </li>
  <li>Traitements d'images. de nombreuses fonctions sont de type <a
 href="ttus1-fr.htm#functions">IMA/SERIES</a> de la <a
 href="ttus1-fr.htm">librairie TT</a>.</li>
</ul>
<p>Exemple. Nous allons effectuer l'analyse statistique de image M57.fit. La s&eacute;quence Tcl suivante montre la cr&eacute;ation d'un buffer, le chargement de l'image, le calcul des param&egrave;tres statistiques puis le destruction du buffer. </p>
<code>set numbuf [::buf::create]</code> <br />
<code>buf$numbuf load m57.fit</code> <br />
<code>set mystatistics [buf$numbuf stat]</code> <br />
<code>::buf::delete $numbuf</code>
<p>A la fin de cette s&eacute;quence, il est possible de r&eacute;cup&eacute;rer la valeur moyenne du fond de ciel de l'image (septi&egrave;me &eacute;l&eacute;ment de la liste de retour), par exemple :</p>
<code>set skyback [lindex $mystatistics 6]</code>
<p>Attention, bien se souvenir que l'indexation des listes commence &agrave; z&eacute;ro (le septi&egrave;me &eacute;l&eacute;ment &agrave; l'indice six). </p>
<h2> <a name="cam" id="cam"></a>2.2. <a href="cam.htm">cam&eacute;ras</a></h2>
<p>La commande "<code>::cam::create</code>" permet de cr&eacute;er une cam&eacute;ra, c'est &agrave; dire de cr&eacute;er une commande commen&ccedil;ant par <code>cam</code> qui permet de r&eacute;aliser des acquisitions, dans diff&eacute;rents modes possibles.</p>
<table>
  <tr>
    <td>Commande</td>
    <td>Arguments</td>
    <td>R&ocirc;le</td>
  </tr>
  <tr>
    <td><code>::cam::create</code></td>
    <td><code>libcam_driver</code> <br />
      <code>?options?</code> </td>
    <td>Cr&eacute;er une cam&eacute;ra. Le pilote de la cam&eacute;ra sera d&eacute;crit dans le fichier d'extension Tcl libcam_driver. Par exemple, pour utiliser une cam&eacute;ra audine dont le pilote est le fichier libaudine.dll, "libcam_driver" vaudra "audine". Ainsi, on ne met, dans libcam_driver, que le nom sans le suffixe lib et sans l'extension. Chaque driver poss&egrave;de ses propres options. Se renseigner. Il est possible de sp&eacute;cifier le num&eacute;ro de l'objet cam&eacute;ra ainsi que le nom du composant CCD dans le cas o&ugrave; une m&ecirc;me cam&eacute;ra peut &ecirc;tre &eacute;quip&eacute;e de capteurs diff&eacute;rents. Le num&eacute;ro sera d&eacute;sign&eacute; apr&egrave;s l'option -num.</td>
  </tr>
  <tr>
    <td><code>::cam::delete</code></td>
    <td><code>numero</code></td>
    <td>Efface la cam&eacute;ra dont le num&eacute;ro est donn&eacute; en param&egrave;tre. La commande <code>cam</code> associ&eacute;e est &eacute;galement supprim&eacute;e.</td>
  </tr>
  <tr>
    <td><code>::cam::list</code></td>
    <td></td>
    <td>Renvoie une liste des num&eacute;ros de cam&eacute;ras utilis&eacute;s.</td>
  </tr>
</table>
<p>La liste des <a href="cam.htm">fonctions de cam&eacute;ra sont d&eacute;crites en d&eacute;tail</a> en cliquant ici.</p>
<p>Exemple. La s&eacute;quence Tcl suivante montre la cr&eacute;ation d'une cam&eacute;ra dans AudeLA et le lancement d'une pose de 30 secondes en binning 2x2 : </p>
<code>set numcam [::cam::create audine lpt1 -ccd kaf400]</code> <br />
<code>cam$numcam buf 1</code> <br />
<code>cam$numcam exptime 30</code> <br />
<code>cam$numcam bin {2 2}</code> <br />
<code>cam$numcam acq</code> <br />
<code>vwait status_cam$numcam</code>
<p>La fonction vwait permet d'attendre la fin de la pose avant de passer &agrave; la fonction Tcl suivante. Noter que la fonction acq n'est donc pas bloquante. On peut donc profiter du temps de pose pour effectuer quelques calculs rapides (par exemple, pr&eacute;traitement de la pr&eacute;c&eacute;dente image acquise). </p>
<h2> <a name="tel" id="tel"></a>2.3. <a href="tel.htm">t&eacute;lescopes</a></h2>
<p>La commande "<code>::tel::create</code>" permet de cr&eacute;er un t&eacute;lescope. Les commandes automatiquement cr&eacute;&eacute;es &agrave; cette occasion sont <code>tel</code> suivi d'un num&eacute;ro. Par le biais de ces commandes il est possible de d&eacute;placer un t&eacute;lescope informatis&eacute;, et d'en conna&icirc;tre la position. Il est possible d'avoir plusieurs t&eacute;lescopes reli&eacute;s au m&ecirc;me ordinateur sous r&eacute;serve d'avoir le nombre suffisant de ports de communication.</p>
<table>
  <tr>
    <td>Commande</td>
    <td>Arguments</td>
    <td>R&ocirc;le</td>
  </tr>
  <tr>
    <td><code>::tel::create</code></td>
    <td><code>libtel_driver</code> <br />
      <code>?options?</code></td>
    <td>Cr&eacute;er un t&eacute;lescope. Le pilote du t&eacute;lescope sera d&eacute;crit dans le fichier d'extension Tcl libtel_driver. Par exemple, pour utiliser un t&eacute;lescope LX200 dont le pilote est le fichier liblx200.dll, "libtel_driver" vaudra "lx200". Ainsi, on ne met, dans libtel_driver, que le nom sans le suffixe lib et sans l'extension. Chaque driver poss&egrave;de ses propres options. Se renseigner. Il est possible de sp&eacute;cifier le num&eacute;ro de l'objet t&eacute;lescope. Le num&eacute;ro sera d&eacute;sign&eacute; apr&egrave;s l'option -num.</td>
  </tr>
  <tr>
    <td><code>::tel::delete</code></td>
    <td><code>numero</code></td>
    <td>Efface le t&eacute;lescope dont le num&eacute;ro est donn&eacute; en param&egrave;tre. La commande <code>tel</code> associ&eacute;e est &eacute;galement supprim&eacute;e.</td>
  </tr>
  <tr>
    <td><code>::tel::list</code></td>
    <td></td>
    <td>Renvoie une liste des num&eacute;ros de t&eacute;lescopes utilis&eacute;s.</td>
  </tr>
</table>
<p>La liste des <a href="tel.htm">fonctions de t&eacute;lescope sont d&eacute;crites en d&eacute;tail</a> en cliquant ici.</p>
<p>Exemple. La s&eacute;quence Tcl suivante montre la cr&eacute;ation d'un t&eacute;lescope dans AudeLA et le pointage &agrave; des coordonn&eacute;es pr&eacute;cis&eacute;es (J2000) :</p>
<code>set numtel [::tel::create lx200 com2]</code> <br />
<code>tel$numtel goto "20h45m34s -16d54m"</code>
<h2> <a name="visu" id="visu"></a>2.4. <a href="visu.htm">visualisation</a></h2>
<p>La commande "<code>::visu::create</code>" permet de cr&eacute;er un lien entre un buffer (qui contient une image) et une image Tk (TkImage). C'est ce lien qui permet de d&eacute;finir des seuils de visualisation, et des palettes. Pour cr&eacute;er une visualisation il faut deux arguments obligatoires : un num&eacute;ro de buffer, et un num&eacute;ro d'image. Le num&eacute;ro de buffer permet de savoir d'o&ugrave; viennent les images &agrave; afficher. Le num&eacute;ro d'image sert &agrave; rep&eacute;rer dans quelle image Tk afficher le contenu du buffer. Il faut que les images Tk soient appel&eacute;es <code>image</code> suivi du num&eacute;ro d'image. Ces images Tk sont cr&eacute;&eacute;es par la commande "<code>image create photo <em>nom_image</em></code>", ou automatiquement par "<code>::visu::create</code>".</p>
<table>
  <tr>
    <td>Commande</td>
    <td>Arguments</td>
    <td>R&ocirc;le</td>
  </tr>
  <tr>
    <td><code>::visu::create</code></td>
    <td><code>bufNo imgNo ?numero?</code></td>
    <td>Cr&eacute;er une visualisation qui affiche les donn&eacute;es du buffer num&eacute;ro <code>bufNo</code> dans l'image <code>image$imgNo</code>. Ces deux arguments sont obligatoires, et on peut &eacute;ventuellement choisir son num&eacute;ro.</td>
  </tr>
  <tr>
    <td><code>::visu::delete</code></td>
    <td><code>numero</code></td>
    <td>Efface la visualisation dont le num&eacute;ro est donn&eacute; en param&egrave;tre. La commande <code>visu</code> associ&eacute;e est &eacute;galement supprim&eacute;e.</td>
  </tr>
  <tr>
    <td><code>::visu::list</code></td>
    <td></td>
    <td>Renvoie une liste des num&eacute;ros de visualisation utilis&eacute;s.</td>
  </tr>
</table>
<p>La liste des <a href="visu.htm">fonctions de visualisation sont d&eacute;crites en d&eacute;tail</a> en cliquant ici. Voici un r&eacute;sum&eacute; :</p>
<ul>
  <li>R&eacute;glage des seuils de visualisation </li>
  <li>Lien entre un buffer image et une Tk_PhotoImage d'un canvas. </li>
  <li>Changement de palette d'affichage.</li>
</ul>
<p>Exemple. Nous allons visualiser l'image de M57.fit. La s&eacute;quence Tcl suivante montre la cr&eacute;ation d'un &eacute;cran de visu &agrave; l'int&eacute;rieur d'une fen&ecirc;tre appel&eacute;e ici .test. Tout d'abord, cr&eacute;ation d'un widget Tk de type canvas (.imag1) dans une fen&ecirc;tre (.test) : </p>
<code>toplevel .test</code> <br />
<code>canvas .test.imag1 -width 384 -height 256</code> <br />
<code>pack .test.imag1</code>
<p>Il faut ensuite cr&eacute;er une zone de visu pour AudeLA qui va faire le lien entre le num&eacute;ro de buffer qui sera visualis&eacute; et le num&eacute;ro de la Tk_PhotoImage qui sera pr&eacute;sente dans le canvas : </p>
<code>set b [::buf::create]</code> <br />
<code>set v [::visu::create $b 5]</code>
<p>Le $b reprend le num&eacute;ro du buffer cr&eacute;&eacute; : c'est celui qui sera affich&eacute;. Le 5 signifie que l'image sera affich&eacute;e dans l'image Tk <code>image5</code>, qui est elle-m&ecirc;me plac&eacute;e dans le canvas (un canvas permet de regrouper des objets graphiques divers) :</p>
<code>image create photo image5</code> <br />
<code>.test.imag1 create image 1 1 -image image5 -anchor nw</code>
<p>Il faut charger une image dans le buffer :</p>
<code>buf$b load images/m57</code>
<p>Ainsi, la visualisation de l'image pr&eacute;sente dans le buffer $b dans le canvas se fera simplement par :</p>
<code>visu$v disp</code>
<p>La modification des seuils suivie de la revisualisation sera : <code>visu$v cuts [8000 4000]</code></p>
<code>visu$v disp</code>
<p>Pour essayer, copiez les lignes pr&eacute;c&eacute;dentes dans un fichier texte (toto.tcl par exemple), et dans la console Aud'ACE entrez "<code>source toto.tcl</code>" ... </p>
<h2> <a name="biblio" id="biblio"></a>3. Fonctions de biblioth&egrave;que de AudeLA</h2>
<h3> <a name="fits2colorjpeg" id="fits2colorjpeg"></a>fits2colorjpeg filenamer filenameg filenameb filenamejpg ?quality? ?locutr hicutr locutg hicutg locutb hicutb?</h3>
<p>Enregistre le contenu des images de trois fichiers FITS sous la forme d'une seul fichier Jpeg couleur. Les fichiers FITS contiennent les images rouge, verte et bleu (respectivement filenamer filenameg filenameb). Le nom du fichier Jpeg est donn&eacute; par le param&egrave;tre filenamejpeg. L'option <em>quality</em> permet de r&eacute;gler le taux de perte lors de la compression (=100 compression sans perte. =75 par d&eacute;faut). Les param&egrave;tres optionnels <em>locutr hicutr locutg hicutg locutb hicutb</em> permettent d'indiquer les valeurs num&eacute;riques des seuils haut et bas dans chaque couleur. Par d&eacute;faut les valeurs des seuils sont lues comme les valeurs des mots cl&eacute; MIPS-Hi et MIPS-LO de l'en-t&ecirc;te FITS. </p>
<h3> <a name="ttscript" id="ttscript"></a>ttscript filename</h3>
<p>Ex&eacute;cute <a href="ttus1-fr.htm#mode%20script">un script TT</a>. contenu dans le fichier texte <em>filename</em>. cf. fonction <a
 href="#ttscript2">ttscript2</a> pour de plus amples explications.</p>
<h3> <a name="ttscript2" id="ttscript2"></a>ttscript2 string</h3>
<p>Ex&eacute;cute <a href="ttus1-fr.htm#mode%20script">un script TT</a>.<em>string</em> est une cha&icirc;ne de caract&egrave;res contenant un script sp&eacute;cifique pour le traitement d'images. Il ne s'agit plus de scripts Tcl mais de scripts TT. Il convient donc de d&eacute;tailler la forme des scripts.</p>
<p>Un script TT est compos&eacute; d'une seule cha&icirc;ne de caract&egrave;res contenant des lignes (s&eacute;parateurs \n) ou bien d'une seule ligne termin&eacute;e par le caract&egrave;re final nul (caract&egrave;re \0). Chaque ligne est analys&eacute;e s&eacute;quentiellement. Au sein d'une ligne, la premi&egrave;re cha&icirc;ne de caract&egrave;res rencontr&eacute;e doit contenir le mot cl&eacute; de d&eacute;finition. Si le mot cl&eacute; n'est pas reconnu, le restant de la ligne est interpr&eacute;t&eacute; comme une simple remarque. Le s&eacute;parateur blanc est utilis&eacute; pour les param&egrave;tres suivants de la ligne. </p>
<p>Il existe actuellement trois mots cl&eacute; de d&eacute;finition : </p>
<ul>
  <li>SET/VAR : initialise la valeur d'une variable de substitution. Cette d&eacute;finition comporte deux arguments : le mot initial &agrave; substituer et le mot qui le remplacera. Cette substitution sera effective pour toutes les lignes suivantes, jusqu'&agrave; la fin du script TT. </li>
  <li>IMA/SERIES : traitement d'une s&eacute;rie d'images et g&eacute;n&egrave;re autant d'images en sortie qu'en entr&eacute;e. </li>
  <li>IMA/STACK : traitement d'une pile d'images et g&eacute;n&egrave;re une seule image en sortie.</li>
</ul>
<p>Les param&eacute;trages des fonctions IMA/SERIES et IMA/STACK sont expos&eacute;s en d&eacute;tail dans une page sp&eacute;cifique concernant <a
 href="ttus1-fr.htm#mode%20script">la syntaxe des scripts TT. L'exemple</a> Tcl suivant montre comment corriger le dark d'une image par la m&eacute;thode de l'optimisation du noir sur l'image i.fit : <code>ttscript2 "IMA/SERIES c:/ccd/ i . . .fit c:/ccd/prt/ i . .fit OPT dark=d60.fit bias=d0.fit unsmearing=0.0005"</code> Noter l'utilisation du / au lieu du \ pour d&eacute;finir les dossiers sous Windows. Ceci est normal et fonctionne parfaitement. Le symbole \ n'est pas employ&eacute; car il est utilis&eacute; par Tcl en tant qu'identificateur de remplacement. Si l'on souhaite quant m&ecirc;me utiliser le symbolisme \ pour d&eacute;signer les chemins Windows, alors il faut remplacer \ par deux \\. Exemple : </p>
<code>ttscript2 "IMA/SERIES c:\\ccd\\ i . . .fit c:\\ccd\\prt\\ i . .fit OPT dark=d60.fit bias=d0.fit unsmearing=0.0005"</code>
<h3> <a name="combit" id="combit"></a>combit ComNumber PinNumber ?BitValue?</h3>
<p>Lit ou &eacute;crit des &eacute;tats binaires sur les broches du port s&eacute;rie num&eacute;ro <em>ComNumber</em> (1, 2, etc.). BitValue vaut 0 ou 1 et n'agit que sur les broches disponibles en &eacute;criture. PinNumber est le num&eacute;ro de la broche sur une prise DB9 ou bien la d&eacute;signation de la broche:</p>
<table>
  <tr>
    <td>d&eacute;signation</td>
    <td>lecture/&eacute;criture</td>
    <td>DB9</td>
    <td>DB25</td>
  </tr>
  <tr>
    <td> DCD </td>
    <td> lecture </td>
    <td> 1 </td>
    <td> 8 </td>
  </tr>
  <tr>
    <td> RxD </td>
    <td></td>
    <td> 2 </td>
    <td> 3 </td>
  </tr>
  <tr>
    <td> TxD </td>
    <td>&eacute;criture </td>
    <td> 3 </td>
    <td> 2 </td>
  </tr>
  <tr>
    <td> DTR </td>
    <td>&eacute;criture </td>
    <td> 4 </td>
    <td> 20 </td>
  </tr>
  <tr>
    <td> GND </td>
    <td> (masse 0V) </td>
    <td> 5 </td>
    <td> 7 </td>
  </tr>
  <tr>
    <td> DSR </td>
    <td> lecture </td>
    <td> 6 </td>
    <td> 6 </td>
  </tr>
  <tr>
    <td> RTS </td>
    <td>&eacute;criture </td>
    <td> 7 </td>
    <td> 4 </td>
  </tr>
  <tr>
    <td> CTS </td>
    <td> lecture </td>
    <td> 8 </td>
    <td> 5 </td>
  </tr>
  <tr>
    <td> RI </td>
    <td> lecture </td>
    <td> 9 </td>
    <td> 22 </td>
  </tr>
</table>
<p>Exemple : <code>combit 2 DTR 1</code>, passe au niveau 1 la broche num&eacute;ro 4 (DTR) du port COM2.</p>
<p>Il faut pr&eacute;alablement ouvrir le port de communication pour envoyer ou recevoir les bits. Exemple: </p>
<code>set tty [open com2 w]</code> <br />
<code>combit 2 DTR 1</code> <br />
<code>close $tty</code>
<p>Les fonctions open et close proviennent de l'interpr&eacute;teur Tcl. </p>
<h3> <a name="libstd_id" id="libstd_id"></a>libstd_id</h3>
<p>Retourne la date de la compilation de la librairie LibAudeLA utilis&eacute;e.</p>
<h3> <a name="libstd_debugserial" id="libstd_debugserial"></a>libstd_debugserial ?on?</h3>
<p>Fonction obsol&egrave;te de d&eacute;buggage.</p>
<h3> <a name="historik" id="historik"></a>historik add|before|after|synchro|list</h3>
<p>G&egrave;re une liste interne qui peut servir &agrave; garder l'historique de commandes. Les options sont les suivantes:</p>
<ul>
  <li>add chaine : ajoute une cha&icirc;ne de caract&egrave;res. </li>
  <li>before : renvoie la cha&icirc;ne avant la position courante. </li>
  <li>after : renvoie la cha&icirc;ne apr&egrave;s la position courante. </li>
  <li>synchro : synchro du point courant sur le point d'insertion et ajoute une cha&icirc;ne de caract&egrave;res. </li>
  <li>list : renvoie la liste des commandes entr&eacute;es.</li>
</ul>
<h3> <a name="getclicks" id="getclicks"></a>getclicks</h3>
<p>Retourne un nombre qui s'incr&eacute;mente d'une unit&eacute; &agrave; chaque milliseconde.</p>
<h3> <a name="hostaddress" id="hostaddress"></a>hostaddress</h3>
<p>Retourne une liste compos&eacute;e d'au moins deux &eacute;l&eacute;ments. Le dernier &eacute;l&eacute;ment contient le nom de la machine locale. Les premiers &eacute;l&eacute;ments sont des listes contenant les quatre nombres de l'adresse IP locale. Par exemple : {192 168 0 1} {62.134.25.67} mycomputer.</p>
<h3><a name="ping" id="ping"></a>ping IPAddress ?timeout?</h3>
<p>Effectue la fonction ping &agrave; une adresse IP donn&eacute;e. Retourne une liste compos&eacute;e de deux &eacute;l&eacute;ments. Le premier &eacute;l&eacute;ment vaut 0 en cas d'&eacute;chec &agrave; la connexion et 1 en cas de succ&egrave;s. Le second &eacute;l&eacute;ment est un texte donnant des explications compl&eacute;mentaires.</p>
</body>

</html>
