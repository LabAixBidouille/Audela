<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <title>Librairie TT : Manuel Utilisateur</title>
</head>
<body>
<p class="date">Date de mise &#224; jour : 18 septembre
2010</p>
<h1>LIB TT - Librairie de pr&#233;traitement d'images
astronomiques</h1>
<h1>Manuel Utilisateur</h1>
<p>Ce guide de l'utilisateur s'adresse aux astronomes qui veulent
&#233;crire des scripts de traitement d'image utilisant la
librairie TT. Rappelons que seul le format d'images FITS est
reconnu et que seules les images monochromes (naxis=2) peuvent
&#234;tre trait&#233;es.</p>
<h1>1. Guide de r&#233;f&#233;rence du mode script de TT</h1>
<p>L'int&#233;r&#234;t principal de la librairie TT est de
pouvoir ex&#233;cuter des commandes entr&#233;es sous la
forme de scripts. Un script TT est compos&#233; d'une seule
cha&#238;ne de caract&#232;res contenant des lignes
(s&#233;parateurs \n du langage C). Chaque ligne est
analys&#233;e s&#233;quentiellement. Au sein d'une ligne, la
premi&#232;re cha&#238;ne de caract&#232;res
rencontr&#233;e doit contenir le mot cl&#233; de
d&#233;finition.</p>
<p>Si le mot cl&#233; n'est pas reconnu, le restant de la ligne
est interpr&#233;t&#233; comme une simple remarque. Le
s&#233;parateur blanc est utilis&#233; pour les
param&#232;tres suivants de la ligne.</p>
<p>Il existe actuellement quatre mots-cl&#233;s de
d&#233;finition :</p>
<p>SET/VAR : initialise la valeur d'une variable de substitution.
Cette d&#233;finition comporte deux arguments : le mot &#224;
substituer et le mot substitu&#233;.</p>
<p>Les lignes suivantes se verront ainsi remplacer les mots
&#224; substituer par le mot substitu&#233;.</p>
<p>IMA/SERIES : traitement d'une s&#233;rie d'images et
cr&#233;ation d'autant d'images en sortie qu'en
entr&#233;e.</p>
<p>IMA/STACK : traitement d'une pile d'images et cr&#233;ation
d'une seule image en sortie.</p>
<p>TMPFILE/EXT : assignation d'un mot qui sera ajout&#233; au
nom des fichiers temporaires (extensions .lst).</p>
<h2>1.1. Param&#233;trages des d&#233;finitions IMA/</h2>
<p>La forme g&#233;n&#233;rale d'une ligne d&#233;finie par
un mot cl&#233; de type IMA/ est la suivante :d&#233;finition
rep_in nom_in ext_in indice_deb indice_fin rep_out nom_out
ext_out indice_out fonction param&#232;tres ...</p>
<p>d&#233;finition : IMA/SERIES ou IMA/STACK</p>
<p>rep_in : chemin d'acc&#232;s aux fichiers d'image
d'entr&#233;e (mettre un point si c'est le r&#233;pertoire
courant de libtt).</p>
<p>nom_in : nom g&#233;n&#233;rique (ou liste de noms
d&#233;pareill&#233;s) des images d'entr&#233;e</p>
<p>indice_deb : nombre correspondant &#224; l'indice de la
premi&#232;re image (mettre un point s'il n'y a pas d'indice,
ou une &#233;toile si c'est une liste de noms
d&#233;pareill&#233;s)</p>
<p>indice_fin : nombre correspondant &#224; l'indice de la
derni&#232;re image (mettre un point s'il n'y a pas d'indice,
ou une &#233;toile si c'est une liste de noms
d&#233;pareill&#233;s)</p>
<p>ext_in : nom de l'extension (suffixe) des fichiers images
d'entr&#233;e</p>
<p>rep_out : chemin d'acc&#232;s aux fichiers d'images de
sortie (mettre un point si c'est le r&#233;pertoire courant de
libtt).</p>
<p>nom_out : nom g&#233;n&#233;rique des images de
sortie.</p>
<p>indice_out : nombre correspondant &#224; l'indice de la
premi&#232;re image de sortie (mettre un point s'il n'y a pas
d'indice)</p>
<p>ext_out : nom de l'extension (suffixe) des fichiers images de
sortie.</p>
<p>fonction : nom de la fonction (voir ci-apr&#232;s).</p>
<p>param&#232;tres ... : liste de param&#232;tres propres
&#224; chaque fonction</p>
<p>Exemple d'une ligne de script :IMA/STACK . i 1 5 .fit c:\toto
j . .fit SK bitpix=32 kappa=1.5 nullpixel=-1000 jpegfile</p>
<p>Ce script demande d'effectuer un pile kappa-sigma (fonction
SK) des images i1.fit &#224; i5.fit du r&#233;pertoire
courant en une image j.fit dans le r&#233;pertoire c:\toto.
L'image j.fit sera enregistr&#233;e en entiers de 4 octets
(bitpix=32), le coefficient kappa vaut 1.5 et les pixels de
valeur inf&#233;rieure ou &#233;gale &#224; -1000 ADU ne
seront pas pris en compte dans calcul des kappa-sigma.</p>
<p>A noter : dans ce propos, le terme de nom complet signifie le
nom du fichier incluant le r&#233;pertoire et le suffixe. Ainsi
: c:\toto\j.fit est un nom complet alors que le nom de l'image
est j.</p>
<p>Si un param&#232;tre doit contenir des caract&#232;res
blancs, encadrer le param&#232;tre par des doubles quotes. Par
exemple :</p>
<p>IMA/SERIES . i 1 5 .fit c:\toto j 1 .fit RESAMPLE
"paramresample=1.5 0 0 0 1.5 0 0"</p>
<p>les double quotes doivent encadrer aussi le mot
d&#233;signant le param&#232;tre.</p>
<p>Noter que l'extension .mt pour le format FITS g&#232;re le
syst&#232;me d'indexation des images diff&#233;remment des
autres extensions. Des z&#233;ros sont ajout&#233;s
automatiquement devant les indices pour que l'indice contienne 4
chiffres. Par exemple IMA/SERIES . i 1 5 .mt c:\toto j 1 .fit
COPY, va chercher les fichiers i0001.mt &#224; i0005.mt en
lecture.</p>
<h3>1.1.1. Liste g&#233;n&#233;rale des fonctions disponibles
pour IMA/</h3>
<table>
  <tbody>
    <tr>
      <td>mot cl&#233; de d&#233;finition [et param&#232;tres
disponibles]</td>
      <td>mot cl&#233; de la fonction [et param&#232;tres
disponibles]</td>
    </tr>
    <tr>
      <td>IMA/STACK [bitpix jpegfile skylevel nullpixel<br>
jpeg_quality]</td>
      <td><a href="#stackADD">ADD</a><br>
      <a href="#MEAN">MEAN</a><br>
      <a href="#MED">MED</a><br>
      <a href="#stackPROD">PROD</a> [powernorm]<br>
      <a href="#PYTHAGORE">PYTHAGORE</a><br>
      <a href="#SHUTTER">SHUTTER</a><br>
      <a href="#SIG">SIG</a><br>
      <a href="#SK">SK</a> [kappa]<br>
      <a href="#SORT">SORT</a> [percent]</td>
    </tr>
    <tr>
      <td>IMA/SERIES [bitpix jpegfile skylevel nullpixel<br>
jpeg_quality]</td>
      <td><a href="#seriesADD">ADD</a> [file offset]<br>
      <a href="#ASTROMETRY">ASTROMETRY</a> [file_ascii]<br>
      <a href="#BACK">BACK</a> [back_kernel] [back_threshold] [sub]
[div]<br>
      <a href="#CATCHART">CATCHART</a> [path_astromcatalog]
[astromcatalog] [catafile] [jpegfile_chart] [jpegfile_chart2]
[magrlim] [magblim]<br>
      <a href="#CONV">CONV</a> [kernel_type] [sigma]<br>
      <a href="#COPY">COPY</a> [nbsubseries]<br>
      <a href="#CUTS">CUTS</a> [hicut] [locut] [keytype]
[cutscontrast]<br>
      <a href="#DELETE">DELETE</a><br>
      <a href="#DIV">DIV</a> [file] [constant]<br>
      <a href="#FILTER">FILTER</a> [threshold] [type_threshold]
[kernel_width] [kernel_type] [kernel_coef]<br>
      <a href="#FITELLIP">FITELLIP</a> [x1] [x2] [y1] [y2] [xcenter]
[ycenter] [backgound] [fitorder6543] [file_ascii]
[threshold]<br>
      <a href="#HEADERFITS">HEADERFITS</a> [file]<br>
      <a href="#HOUGH">HOUGH</a> [threshold] [binary]<br>
      <a href="#INVERT">INVERT</a> [mirror] [flip] [xy]
[normaflux]<br>
      <a href="#MULT">MULT</a> [constant]<br>
      <a href="#NORMGAIN">NORMGAIN</a> [normgain_value]<br>
      <a href="#NORMOFFSET">NORMOFFSET</a> [normoffset_value]<br>
      <a href="#OFFSET">OFFSET</a> [offset]<br>
      <a href="#OPT">OPT</a> [dark] [bias] [therm_kappa]
[unsmearing]<br>
      <a href="#seriesPROD">PROD</a> [file] [constant]<br>
      <a href="#RADIAL">RADIAL</a> [radius] [sigma] [power] [xcenter]
[ycenter]<br>
      <a href="#REGISTER">REGISTER</a> [translate] [normaflux]
[matchwcs]<br>
      <a href="#REGISTERFINE">REGISTERFINE</a> [oversampling] [delta]
[file]<br>
      <a href="#RESAMPLE">RESAMPLE</a> [paramresample]
[normaflux]<br>
      <a href="#RGRADIENT">RGRADIENT</a> [xcenter] [ycenter] [radius]
[angle]<br>
      <a href="#SMILEX">SMILEX</a> [ycenter] [coef_smile2]
[coef_smile4]<br>
      <a href="#SMILEY">SMILEY</a> [xcenter] [coef_smile2]
[coef_smile4]<br>
      <a href="#SUB">SUB</a> [file offset] [hot_pixel_list]
[cosmic_threshold]<br>
      <a href="#STAT">STAT</a> [pixelsat_value] [fwhm] [objefile]
[pixefile] [border] [detect_kappa] [pixint]<br>
      <a href="#UNSMEARING">UNSMEARING</a> [unsmearing]<br>
      <a href="#SUBDARK">SUBDARK</a> [dark] [bias] [exptime] [dexptime]
[unsmearing] [hot_pixel_list] [cosmic_threshold]<br>
      <a href="#SORTX">SORTX</a> [x1] [x2] [width]<br>
      <a href="#SORTY">SORTY</a> [y1] [y2] [height]<br>
      <a href="#TILT">TILT</a> [trans_x] [trans_y]<br>
      <a href="#TRANS">TRANS</a> [trans_x] [trans_y]<br>
      <p><br>
Fonctions &#233;crites par tt_user2</p>
      <a href="#LOPT">LOPT</a> [y1] [y2] [height]<br>
      <a href="#PROFILE2">PROFILE2</a> [offset] [direction]
[filename]<br>
      <p><br>
Fonctions &#233;crites par tt_user3</p>
      <a href="#BINX">BINX</a> [x1] [x2] [width]<br>
      <a href="#BINY">BINY</a> [y1] [y2] [height]<br>
      <a href="#LOG">LOG</a> [offsetlog] [coeff]<br>
      <a href="#MATRIX">MATRIX</a> [x1] [x2] [y1] [y2]
[filematrix]<br>
      <a href="#MEDIANX">MEDIANX</a> [x1] [x2] [width]<br>
      <a href="#MEDIANY">MEDIANY</a> [y1] [y2] [height]<br>
      <a href="#POL2REC">POL2REC</a> [y0] [x0] [scale_theta]
[scale_rho] [width] [height]<br>
      <a href="#PROFILE">PROFILE</a> [offset] [direction]
[filename]<br>
      <a href="#REC2POL">REC2POL</a> [y0] [x0] [scale_theta]
[scale_rho]<br>
      <a href="#ROT">ROT</a> [y0] [x0] [angle]<br>
      <a href="#WINDOW">WINDOW</a> [x1] [x2] [y1] [y2]<br>
      <p><br>
Fonctions &#233;crites par tt_user4</p>
      <a href="#ASTROMETRY2">ASTROMETRY2</a><br>
      <p><br>
Fonctions &#233;crites par tt_user6</p>
      <a href="#HOTPIXEL">HOTPIXEL</a> [hot_pixel_list]<br>
      <a href="#COSMIC">COSMIC</a> [cosmic_threshold]</td>
    </tr>
  </tbody>
</table>
<h4>1.1.2. Param&#232;tres optionnels de la d&#233;finition
IMA/SERIES</h4>
<p>[bitpix] permet de choisir le format de donn&#233;es
enregistr&#233;es dans le fichier FITS. On distingue les cas
suivants :</p>
<p>bitpix=8 : octets non sign&#233;s.</p>
<p>bitpix=16 : entiers &#224; 2 octets sign&#233;s.</p>
<p>bitpix=+16 : entiers &#224; 2 octets non sign&#233;s.</p>
<p>bitpix=32 : entiers &#224; 4 octets sign&#233;s.</p>
<p>bitpix=+32 : entiers &#224; 4 octets non sign&#233;s.</p>
<p>bitpix=-32 : flottants &#224; 4 octets (float).</p>
<p>bitpix=-64 : entiers &#224; 8 octets (double).</p>
<p>Par d&#233;faut, les images de sortie prennent le m&#234;me
type de donn&#233;es que les images d'entr&#233;e.</p>
<p>[jpegfile] (pas d'arguments) permet de sauver une ou plusieurs
images au format JPEG apr&#232;s traitement. Les seuils sont
pris &#233;gaux &#224; ceux trouv&#233;s dans
l'en-t&#234;te de l'image (cf. fonction IMA/SERIES STAT pour les
calculer). Il y aura autant d'images JPEG
g&#233;n&#233;r&#233;es que d'images finales FITS
g&#233;n&#233;r&#233;es. Chaque fichier JPEG porte le
m&#234;me nom que le fichier FITS correspondant dont le suffixe
est remplac&#233; par .jpg. Les fichiers JPEG sont
enregistr&#233;s dans le m&#234;me r&#233;pertoire que les
images FITS de sortie.</p>
<p>[jpeg_quality] (= valeur enti&#232;re entre 5 et 100) permet
de fixer la valeur du crit&#232;re de qualit&#233; de l'image
JPEG (cf. utilisation de [jpegfile]). Ce crit&#232;re peut
varier entre 5 (image tr&#232;s d&#233;grad&#233;e)
&#224; 100 (image compress&#233;e sans perte). Par
d&#233;faut, cette valeur est fix&#233;e &#224; 75.</p>
<p>[skylevel] (pas d'argument) permet de sauver la valeur du fond
de ciel, avant traitement, dans l'en-t&#234;te de l'image
trait&#233;e (mot cl&#233; SKYLEVEL dans l'en-t&#234;te
FITS).</p>
<p>[nullpixel] (= valeur en ADU). Permet d'indiquer &#224; la
fonction de ne pas prendre en compte les pixels dont les valeurs
sont inf&#233;rieures ou &#233;gales &#224; la valeur seuil
de nullpixel. Nullpixel employ&#233; sans argument signifie que
la valeur seuil vaut z&#233;ro.</p>
<h4>1.1.3. Param&#232;tres optionnels de la d&#233;finition
IMA/STACK</h4>
<p>A ce jour, les param&#232;tres optionnels sont les
m&#234;mes que pour IMA/SERIES</p>
<h2>1.2. Fonctions de la d&#233;finition IMA/STACK</h2>
<p>Chacune des fonctions de IMA/STACK peut &#234;tre
associ&#233;e aux param&#232;tres optionnels
g&#233;n&#233;raux de IMA/STACK. Les param&#232;tres
optionnels (et leur argument) sp&#233;cifiques &#224; chaque
fonction sont d&#233;crits maintenant :</p>
<h4><a name="stackADD" id="stackADD"></a>1.2.1. Fonction ADD</h4>
<p>Addition pixel &#224; pixel des images de la pile. La date
(DATE-OBS) et le temps de pose (EXPOSURE) sont chang&#233;s en
fonction des poids de chacune des images entrant dans la
pile.</p>
<h4><a name="MEAN" id="MEAN"></a>1.2.2. Fonction MEAN</h4>
<p>Moyenne pixel &#224; pixel des images de la pile. La date
(DATE-OBS) et le temps de pose (EXPOSURE) sont chang&#233;s en
fonction des poids de chacune des images entrant dans la
pile.</p>
<h4><a name="MED" id="MED"></a>1.2.3. Fonction MED</h4>
<p>M&#233;diane pixel &#224; pixel des images de la pile. La
date (DATE-OBS) et le temps de pose (EXPOSURE) sont
chang&#233;s en fonction des poids de chacune des images
entrant dans la pile.</p>
<h4><a name="stackPROD" id="stackPROD"></a>1.2.4. Fonction
PROD</h4>
<p>Produit pixel &#224; pixel des images de la pile. La date
(DATE-OBS) et le temps de pose (EXPOSURE) sont chang&#233;s en
fonction des poids de chacune des images entrant dans la pile.
L'option [powernorm], si elle est indiqu&#233;e (sans valeur)
impose une normalisation en puissance 1/n pour n images
constituant chaque point.<br>
</p>
<h4><a name="PYTHAGORE" id="PYTHAGORE"></a>1.2.5. Fonction
PYTHAGORE</h4>
<p>Racine carr&#233;e de la somme des carr&#233;s de pixel
&#224; pixel des images de la pile. La date (DATE-OBS) et le
temps de pose (EXPOSURE) sont chang&#233;s en fonction des
poids de chacune des images entrant dans la pile.</p>
<h4><a name="SHUTTER" id="SHUTTER"></a>1.2.6. Fonction
SHUTTER</h4>
<p>Synth&#232;se l'image des d&#233;lais de
l'ouverture-fermeture d'un obturateur m&#233;canique &#224;
partir d'un lot d'images prises avec des dur&#233;es de pose
diff&#233;rentes. Le temps de pose (EXPOSURE) est pris comme
r&#233;f&#233;rence pour chaque image.<br>
</p>
<h4><a name="SIG" id="SIG"></a>1.2.7. Fonction SIG</h4>
<p>Ecart type, pixel &#224; pixel, des images de la pile. La
date (DATE-OBS) et le temps de pose (EXPOSURE) sont
chang&#233;s en fonction des poids de chacune des images
entrant dans la pile.</p>
<h4><a name="SK" id="SK"></a>1.2.8. Fonction SK</h4>
<p>moyenne kappa-sigma, pixel &#224; pixel, des images de la
pile. Le param&#232;tre optionnel [kappa] permet de choisir le
seuil de r&#233;jection pour calculer la moyenne. Par
d&#233;faut [kappa=3]. La date (DATE-OBS) et le temps de pose
(EXPOSURE) sont chang&#233;s en fonction des poids de chacune
des images entrant dans la pile.</p>
<h4><a name="SORT" id="SORT"></a>1.2.9. Fonction SORT</h4>
<p>Valeur tri&#233;e, pixel &#224; pixel, des images de la
pile. Le calcul de la valeur tri&#233;e est le suivant. La
valeur de chaque pixel (x,y) de toutes les images de la pile sont
tri&#233;es dans l'ordre croissant. Le param&#232;tre
optionnel [percent] permet de choisir la valeur tri&#233;e. La
valeur tri&#233;e est prise &#233;gale au minimum si
[percent=0], &#224; la valeur m&#233;diane si [percent=50] et
au maximum si [percent=100]. percent peut prendre n'importe
quelle valeur entre 0 et 100. Par d&#233;faut [percent=50].</p>
<p>La date (DATE-OBS) et le temps de pose (EXPOSURE) sont
chang&#233;s en fonction des poids de chacune des images
entrant dans la pile.</p>
<h2>1.3. Fonctions de la d&#233;finition IMA/SERIES</h2>
<p>Chacune des fonctions de IMA/SERIES peut &#234;tre
associ&#233;e aux param&#232;tres optionnels
g&#233;n&#233;raux de IMA/SERIES. Les param&#232;tres
optionnels (et leur argument) sp&#233;cifiques &#224; chaque
fonction sont d&#233;crits maintenant :</p>
<h4><a name="seriesADD" id="ADD"></a>1.3.1. Fonction ADD</h4>
<p>Addition pixel &#224; pixel avec une image dont le nom
complet est d&#233;fini par l'argument de [file]. Une valeur
d'offset peut &#234;tre ajout&#233;e et vaut l'argument de
[offset].</p>
<h4><a name="SUB" id="SUB"></a>1.3.2. Fonction SUB</h4>
<p>Soustraction pixel &#224; pixel avec une image dont le nom
complet est d&#233;fini par l'argument de [file]. Une valeur
d'offset peut &#234;tre ajout&#233;e et vaut l'argument de
[offset].</p>
<p>Si l'argument HOT_PIXEL_LIST="P x1 y1 P x2 y2 ..." est
pr&#233;sent, les pixels chauds sont retir&#233;s de chaque
image avant la soustraction (la syntaxe est identique &#224; la
fonction <a href="#HOTPIXEL">HOTPIXEL</a> ).</p>
<p>Si l'argument COSMIC_THRESHOLD=400 est pr&#233;sent, les
cosmiques sont retir&#233;s de chaque image avant la
soustraction (la syntaxe est identique &#224; la fonction
<a href="#COSMIC">COSMIC</a> )</p>
<h4><a name="DIV" id="DIV"></a>1.3.3. Fonction DIV</h4>
<p>Division pixel &#224; pixel avec une image dont le nom
complet est d&#233;fini par l'argument de [file]. Une valeur
constante peut &#234;tre multipli&#233;e et vaut l'argument de
[constant].</p>
<h4><a name="seriesPROD" id="seriesPROD"></a>1.3.4. Fonction
PROD</h4>
<p>Produit pixel &#224; pixel avec une image dont le nom
complet est d&#233;fini par l'argument de [file]. Une valeur
constante peut &#234;tre divis&#233;e et vaut l'argument de
[constant].<br>
</p>
<h4><a name="MULT" id="MULT"></a>1.3.5. Fonction MULT</h4>
<p>Multiplication de la valeur de tous les pixels par une
constante d&#233;finie par l'argument de [constant].</p>
<h4><a name="OFFSET" id="OFFSET"></a>1.3.6. Fonction OFFSET</h4>
<p>Ajoute, &#224; tous les pixels, une valeur constante qui
vaut l'argument de [offset].</p>
<h4><a name="NORMGAIN" id="NORMGAIN"></a>1.3.7. Fonction
NORMGAIN</h4>
<p>Normalise, par une multiplication, la valeur du fond de ciel
&#224; la valeur sp&#233;cifi&#233;e par [normgain_value].
Par d&#233;faut, la valeur de [normgain_value] vaut la valeur
de fond de ciel de la premi&#232;re image.</p>
<h4><a name="NORMOFFSET" id="NORMOFFSET"></a>1.3.8. Fonction
NORMOFFSET</h4>
<p>Normalise, par un offset, la valeur du fond de ciel &#224;
la valeur sp&#233;cifi&#233;e par [normoffset_value]. Par
d&#233;faut, la valeur de [normoffset_value] vaut
z&#233;ro.</p>
<h4><a name="LOG" id="LOG"></a>1.3.9. Fonction LOG</h4>
<p>Effectue une op&#233;ration math&#233;matique de
logarithme selon la formule :</p>
<p>[coeff] *log10(value-[offsetlog])</p>
<p>La valeur [nullpixel] (z&#233;ro par d&#233;faut)
appara&#238;t lorsque (value-[offsetlog]) est n&#233;gatif
(log non d&#233;fini).</p>
<h4><a name="MEDIANX" id="MEDIANX"></a>1.3.10. Fonction
MEDIANX</h4>
<p>Attribue, &#224; chaque ligne, une valeur constante
&#233;gale &#224; la m&#233;diane de tous les pixels de
cette ligne entre les pixels [x1] et [x2]. L'image finale
comporte [width] colonnes (20 par d&#233;faut).</p>
<h4><a name="MEDIANY" id="MEDIANY"></a>1.3.11. Fonction
MEDIANY</h4>
<p>Attribue, &#224; chaque colonne, une valeur constante
&#233;gale &#224; la m&#233;diane de tous les pixels de
cette colonne entre les pixels [y1] et [y2]. L'image finale
comporte [height] colonnes (20 par d&#233;faut).</p>
<h4><a name="RESAMPLE" id="RESAMPLE"></a>1.3.12. Fonction
RESAMPLE</h4>
<p>Effectue une transformation lin&#233;aire de type :</p>
<p>x_out = a[0]*x_in + a[1]*y_in + a[2]<br>
y_out = a[3]*x_in + a[4]*y_in + a[5]</p>
<p>La valeur des coefficients a[0] &#224; a[5] est cod&#233;e
dans le param&#232;tre [paramresample] sous la forme de la
suite des coefficients 0 &#224; 5. Par exemple, pour effectuer
une r&#233;duction homog&#232;ne de l'image d'un facteur 2,
on &#233;crira :</p>
<p>IMA/SERIES ... RESAMPLE "paramresample=0.5 0 0 0 0.5 0"</p>
<p>Par d&#233;faut, l'int&#233;grale du flux est
conserv&#233;e (par exemple, si l'image est dilat&#233;e d'un
facteur deux sur les deux axes, sa dynamique sera r&#233;duite
d'un facteur quatre). Pour imposer une normalisation autre du
flux, utiliser le param&#232;tre [normaflux]. Par exemple, pour
garder la dynamique originelle, utiliser normaflux=1.</p>
<p>Les mots cl&#233; d'astrom&#233;trie (WCS),
&#233;ventuellement pr&#233;sents dans l'en-t&#234;te FITS,
sont modifi&#233;s en cons&#233;quence de la transformation
g&#233;om&#233;trique.</p>
<h4><a name="INVERT" id="INVERT"></a>1.3.13. Fonction INVERT</h4>
<p>Echange les pixels de l'image en fonction de l'option
pr&#233;cis&#233;e :</p>
<p>MIRROR : l'image est invers&#233;e gauche droite.</p>
<p>FLIP : l'image est invers&#233;e haut bas.</p>
<p>XY : l'image est transpos&#233;e (&#233;change des lignes
et des colonnes).</p>
<p>Les mots cl&#233; d'astrom&#233;trie (WCS),
&#233;ventuellement pr&#233;sents dans l'en-t&#234;te FITS,
sont modifi&#233;s en cons&#233;quence.</p>
<h4><a name="WINDOW" id="WINDOW"></a>1.3.14. Fonction WINDOW</h4>
<p>Extrait une image de sortie dans la fen&#234;tre [x1] [x2]
[y1] [y2] de l'image d'entr&#233;e.</p>
<p>Exemple de script pour fen&#234;trer trois images de nom
g&#233;n&#233;rique $img, indic&#233;es de 1 &#224; 3 et
d'extension $ext, $x1,$y1 et $x2,$y2 repr&#233;sentant les
coordonn&#233;es d'un rectangle de s&#233;lection, on peut
ex&#233;cuter dans un script Tcl :</p>
<pre>ttscript2 "IMA/SERIES . $img 1 3 $ext . $img 1 $ext WINDOW x1=$x1 x2=$x2 y1=$y1 y2=$y2 bitpix=16"<br></pre>
Pour des plans couleurs portant le nom ${img}r ${img}g
${img}b il faudra traiter les images comme une liste
d&#233;pareill&#233;e :
<pre>set liste_images [ list ${img}r ${img}g ${img}b ]<br>ttscript2 "IMA/SERIES . \"$liste_images\" * * $ext . $img 1 $ext WINDOW x1=$x1 x2=$x2 y1=$y1 y2=$y2 bitpix=16"<br></pre>
Les images produites porteront le nom ${img}1 ${img}2 ${img}3
<h4><a name="TRANS" id="TRANS"></a>1.3.15. Fonction TRANS</h4>
<p>Effectue une translation constante de [trans_x] [trans_y]
pixels de toutes les images. Les mots cl&#233;
d'astrom&#233;trie (WCS), &#233;ventuellement pr&#233;sents
dans l'en-t&#234;te FITS, sont modifi&#233;s en
cons&#233;quence.<br>
</p>
<p><a name="TRANS" id="TRANS">Par exemple, pour effectuer une
translation sur l'image $img.$ext</a></p>
<pre><a name="TRANS" id="TRANS">ttscript2 "IMA/SERIES . $img . . $ext . $img . $ext TRANS trans_x=12 trans_y=34 nullpixel=0<br></a></pre>
<p><a name="TRANS" id="TRANS">L'option nullpixel=0 peut s'av&#233;rer
importante pour le
compositage ult&#233;rieur&nbsp;des images. En effet, le mot
cl&#233; NULLPIXEL pourra &#234;tre &#224; nouveau utilis&#233;
par les fonctions d'empilage (IMA/STACK) pour &#233;viter de tenir
compte des "bords noirs" des&nbsp;images.</a></p>
<h4><a name="ROT" id="ROT"></a>1.3.16. Fonction ROT</h4>
<p>Effectue une rotation d'un [angle] (en degr&#233;s) autour
du point d&#233;fini par les coordonn&#233;es [x0] [y0]. Les
mots cl&#233; d'astrom&#233;trie (WCS), &#233;ventuellement
pr&#233;sents dans l'en-t&#234;te FITS, sont modifi&#233;s
en cons&#233;quence.</p>
<p>Exemple de script pour tourner une image 15&#176; autour de son
centre x0,y0 :</p>
<pre>ttscript2 "IMA/SERIES . $file . . $ext . rot$file . $ext ROT x0=$x0 y0=$y0 angle=15.0"<br></pre>
<p>L'image produite garde les m&#234;mes dimensions naxis1 et
naxis2 que l'image originale. Une partie (les coins) de l'image
originale est perdue. La perte est d'autant plus importante que
l'angle de rotation est grand.</p>
<h4><a name="ROTENTIERE" id="ROTENTIERE"></a>1.3.17. Fonction
ROTENTIERE</h4>
<p>A la diff&#233;rence de ROT, les dimensions de l'image
finale sont modifi&#233;es pour contenir toute l'image originale
tourn&#233;e autour du centre</p>
<h4><a name="REC2POL" id="REC2POL"></a>1.3.18. Fonction
REC2POL</h4>
<p>Projection polaire centr&#233;e en [y0] [x0] de l'image
d'entr&#233;e. Par d&#233;faut, les axes polaires ont
1degr&#233;/pix pour l'angle et 1 pix/pix pour
l'&#233;loignement. Il est possible de modifier ces valeurs en
utilisant les facteurs d'&#233;chelle [scale_theta]
[scale_rho].<br>
</p>
<p>Exemple de script pour passer l'image en coordonn&#233;es
polaires centr&#233;es sur x0 et y0, l'image de sortie ayant
pour nom pol$file :</p>
<pre>ttscript2 "IMA/SERIES . $file . . $ext . pol$file . $ext REC2POL x0=$x0 y0=$y0 scale_theta=1. scale_rho=1."<br></pre>
<h4><a name="POL2REC" id="POL2REC"></a>1.3.19. Fonction
POL2REC</h4>
<p>Projection cart&#233;sienne centr&#233;e en [y0] [x0]
&#224; partir de l'image d'une projection polaire. Il est
possible de modifier les valeurs des facteurs d'&#233;chelle
[scale_theta] [scale_rho]. Enfin, [width] et [height] sont les
largeur et hauteur de l'image finale.</p>
<p>Exemple de script pour repasser en coordonn&#233;es
cart&#233;siennes en retrouvant la taille (naxis1 et naxis2) de
l'image d'origine :</p>
<pre>ttscript2 "IMA/SERIES . pol$file . . $ext . $file . $ext POL2REC x0=$x0 y0=$y0 scale_theta=1. scale_rho=1. width=$naxis1 height=$naxis2"<br></pre>
<h4><a name="BINX" id="BINX"></a>1.3.20. Fonction BINX</h4>
<p>Attribue, &#224; chaque ligne, une valeur constante
&#233;gale &#224; la somme de tous les pixels de cette ligne
entre les pixels [x1] et [x2]. L'image finale comporte [width]
colonnes (20 par d&#233;faut).</p>
<p>Exemple de script pour additionner tous les pixels de chaque
ligne entre les pixels 1 et naxis1, $file est le nom de l'image
d'entr&#233;e , $ext l'extension et binx_$file le nom de
l'image de sortie :</p>
<pre>ttscript2 "IMA/SERIES . $file . . $ext . binx_$file . $ext BINX x1=1 x2=$naxis1 width=1 bitpix=32"<br></pre>
<p>L'image finale contient une seule colonne (width=1),
d'o&#249; un petit fichier. Comme on additionne tous les
valeurs, on passe en 32 bits pour garder une grande amplitude de
valeurs.</p>
<h4><a name="BINY" id="BINY"></a>1.3.21. Fonction BINY</h4>
<p>Attribue, &#224; chaque colonne, une valeur constante
&#233;gale &#224; la somme de tous les pixels de cette
colonne entre les pixels [y1] et [y2]. L'image finale comporte
[height] colonnes (20 par d&#233;faut).</p>
<p>Exemple de script pour additionner tous les pixels de chaque
colonne. L'image finale ne contient qu'une seule ligne ; comme on
additionne tous les valeurs, on passe en 32 bits pour garder une
grande amplitude de valeur ; $in est le nom de l'image
d'entr&#233;e , $ext l'extension, bin_y$in le nom de l'image de
sortie :</p>
<pre>ttscript2 "IMA/SERIES . $in . . $ext . biny_$in . $ext BINY y1=1 y2=$naxis2 height=1 bitpix=32"<br></pre>
<p>L'image finale contient une seule ligne (height=1).</p>
<h4><a name="HOUGH" id="HOUGH"></a>1.3.22. Fonction HOUGH</h4>
<p>Transform&#233;e de Hough. Chaque point de l'image,
sup&#233;rieur &#224; [threshold] (=0 par d&#233;faut), est
repr&#233;sent&#233;, dans l'espace de Hough (T, R) par une
sinuso&#239;de d'intensit&#233; I, d'&#233;quation R =
y*sin(T) - x*cos(T) avec -90&lt;=T&lt;90. La valeur R=0 est
situ&#233;e &#224; la ligne telle que y=naxis2/2 et la valeur
T=0 est situ&#233;e &#224; la colonne x=naxis1/2 (T=0, R=0
est donc au milieu de l'image). L'&#233;chelle de T vaut 1
degr&#233; par pixel (R est en pixel de l'image initiale). I
vaut 1 si on a pr&#233;cis&#233; [binary] sinon il vaut la
valeur d'intensit&#233; du pixel de l'image initiale. La
transform&#233;e de Hough permet de rep&#233;rer la position
de pixels align&#233;s (tra&#238;n&#233;e de smearing,
satellite, avion, etc.).</p>
<h4><a name="COPY" id="COPY"></a>1.3.23. Fonction COPY</h4>
<p>Recopie sans rien changer, les images vers un autre nom,
r&#233;pertoire, suffixe.</p>
<p>Il est possible de changer le num&#233;ro d'ordre des
indices des fichiers de sortie en sp&#233;cifiant le nombre de
sous s&#233;ries (param&#232;tre [nbsubseries]=1 par
d&#233;faut). Par exemple, si l'on a r&#233;alis&#233;
douze images i1 &#224; i12 en quatre sous s&#233;ries de
trois images ([nbsubseries]=4) l'indexation des images de sortie
(j1 &#224; j12) sera faite ainsi :</p>
<p>entr&#233;e (1 2 3) (4 5 6) (7 8 9) (10 11 12)<br>
sortie (1 4 7 10) (2 5 8 11) (3 6 9 12)</p>
<p>De cette fa&#231;on, la premi&#232;re s&#233;rie en
sortie contient les premi&#232;res images de chaque
s&#233;rie d'entr&#233;e, le deuxi&#232;me s&#233;rie en
sortie contient les deuxi&#232;mes images de chaque
s&#233;rie d'entr&#233;e et ainsi de suite. En pratique, cela
permet de trier les images en vue de la r&#233;alisation d'un
superflat &#224; partir de s&#233;ries d'images. Dans notre
exemple, (1 2 3) sont trois images du m&#234;me champ, (4 5 6)
trois images d'un autre champ, etc. La s&#233;rie de sortie (1
4 7 10) c'est &#224; dire j1 &#224; j4 contient les images de
champs diff&#233;rents et peuvent synth&#233;tiser un
superflat. La deuxi&#232;me s&#233;rie de sortie (2 5 8 11)
permet de r&#233;aliser un deuxi&#232;me superflat et ainsi
de suite. Il suffit ensuite de combiner les superflats pour
r&#233;aliser un superflat total.</p>
<p>Exemple de script pour copier un fichier d'un
r&#233;pertoire externe au r&#233;pertoire de travail :</p>
<pre>ttscript2 "IMA/SERIES \"$dir\" $in . . $ext . $in . $ext COPY"<br></pre>
<h4><a name="DELETE" id="DELETE"></a>1.3.24. Fonction DELETE</h4>
<p>Efface les fichiers.</p>
<p>Exemple de script pour effacer une liste de fichiers de noms
d&#233;pareill&#233;s :</p>
<pre>ttscript2 "IMA/SERIES .  \"$liste_de_noms_courts_sans_extension\" * * $ext . . . . DELETE"<br></pre>
<h4><a name="STAT" id="STAT"></a>1.3.25. Fonction STAT</h4>
<p>Effectue le calcul des param&#232;tres statistiques de
l'image (moyenne, &#233;cart type, minimum, maximum, moyenne du
fond, &#233;cart type du fond, seuil haut, seuil bas,
contraste). Calcule le nombre de pixels satur&#233;s si on
d&#233;finit la valeur de [pixelsat_value]. Calcule la largeur
&#224; mi-hauteur moyenne des &#233;toiles du champ si le
param&#232;tre optionnel [fwhm] est pr&#233;sent.</p>
<p>Si l'option [objefile] est pr&#233;sente,
g&#233;n&#232;re une liste d'objets dont le nom complet du
fichier FITS est l'argument de [objefile]. De m&#234;me, on peut
g&#233;n&#233;rer une liste de pixels dont le nom complet du
fichier FITS est l'argument de [pixefile]. [pixefile] et
[objefile] peuvent avoir le m&#234;me nom. Il est possible de
r&#233;duire la fen&#234;tre de recherche pour [objefile] et
[pixefile]. Pour cela, on utilise le mot [border] suivit d'un
pourcentage. Ce pourcentage vaut 0 pour calculer sur toute
l'image (valeur par d&#233;faut), et vaut au maximum 90 pour
effectuer le calcul sur une petite zone au centre de l'image.
[border] n'affecte pas le calcul des param&#232;tres
statistiques moyenne, etc. Enfin, il est possible de
r&#233;gler le seuil de d&#233;tection en agissant sur la
valeur de [detect_kappa]. Par d&#233;faut, [detect_kappa] vaut
3 (en unit&#233;s d'&#233;cart type du fond).</p>
<p>Si le mot cl&#233; [pixint] est pr&#233;sent alors le
calcul de la liste d'objet est effectu&#233; avec des
coordonn&#233;es (x,y) en pixels entier et non pas
fractionnaires (option par d&#233;faut).</p>
<h4><a name="CUTS" id="CUTS"></a>1.3.26. Fonction CUTS</h4>
<p>Calcule les seuils de visualisation de l'image par analyse de
l'histogramme. La valeur des seuils est compl&#233;t&#233;e
dans l'en-t&#234;te FITS. Le mot cl&#233; correspondant au
seuil haut est d&#233;finit par [hicut] (MIPS-HI par
d&#233;faut) et celui du seuil bas est d&#233;finit par
[locut] (MIPS-LO par d&#233;faut). Le type de valeur pour
l'en-t&#234;te FITS est donn&#233;e par [keytype] et peut
valoir INT, FLOAT ou STRING (INT par d&#233;faut). Par exemple
:</p>
<p>IMA/SERIES ... CUTS hicut=SH locut=SB keytype=FLOAT</p>
<p>Les param&#232;tres [lofrac] et [hifrac] servent &#224;
fixer la fraction de l'histogramme o&#249; seront
calcul&#233;s les seuils. [lofrac] (=0.05 par d&#233;faut)
est la fraction pour le seuil bas et [lofrac] (=0.05 par
d&#233;faut) est la fraction pour le seuil haut. ces valeurs
peuvent varier de 0 &#224; 1.</p>
<p>Le param&#232;tre [cutscontrast] (=1 par d&#233;faut) sert
&#224; adoucir le contraste. Plus sa valeur est grande, plus
doux sera le contraste. La valeur doit &#234;tre une
quantit&#233; r&#233;elle positive ou nulle.</p>
<p>La m&#233;thode de calcul de la fonction CUTS fourni un
r&#233;sultat bien plus rapide que le calcul des seuils par la
fonction STAT. Cependant, la qualit&#233; du calcul est un peu
meilleure pour la fonction STAT que l'on pr&#233;f&#233;rera
pour des petites images (inf&#233;rieures &#224; 500x500
typiquement). La fonction CUTS pr&#233;sente un grand
int&#233;r&#234;t sur les grandes images car seuls 100 000
points servent au calcul. Le temps de calcul est donc le
m&#234;me quelque soit la taille de l'image (alors qu'il peu
devenir long pour la fonction STAT).</p>
<h4><a name="HEADERFITS" id="HEADERFITS"></a>1.3.27. Fonction
HEADERFITS</h4>
<p>Ajoute des mots cl&#233; &#224; l'en-t&#234;te FITS. Les
mots cl&#233;s sont d&#233;finis dans un fichier texte ASCII
dont le nom complet est l'argument de [file]. Chaque mot
cl&#233; est d&#233;fini par 5 lignes dans le fichier texte
:</p>
<p>ligne 1 : nom du mot cl&#233; (en majuscules &lt;= 8
lettres)</p>
<p>ligne 2 : valeur associ&#233;e au mot cl&#233;.</p>
<p>ligne 3 : type de la valeur (short, int, float, double,
string)</p>
<p>ligne 4 : commentaire</p>
<p>ligne 5 : unit&#233;s</p>
<p>S'il n'y a pas de commentaire, laisser la ligne blanche. De
m&#234;me pour l'unit&#233;. On peut ajouter autant de
mots-cl&#233;s que l'on veut.</p>
<p>Exemple de script pour modifier l'en-t&#234;te FITS des
images avec les donn&#233;es du kwdfile.txt contenu dans le
r&#233;pertoire de travail :</p>
<pre>ttscript2 "IMA/SERIES . $img 1 3 $ext . $img 1 $ext HEADERFITS file=kwdfile.txt"<br></pre>
<h4><a name="PROFILE" id="PROFILE"></a>1.3.28. Fonction
PROFILE</h4>
<p>Extrait la valeur num&#233;rique des pixels d'une ligne ou
d'une colonne dans un fichier texte [filename]. [direction]=x ou
y respectivement pour effectuer le profil selon les lignes ou les
colonnes. [offset] repr&#233;sente le num&#233;ro de ligne ou
de colonne sur lequel sera effectu&#233; le profil. Si
[direction]=x, alors [offset] peut &#234;tre compris entre 1 et
le nombre de colonnes. Si [direction]=y, alors [offset] peut
&#234;tre compris entre 1 et le nombre de lignes. Le fichier
[filename] contient une ent&#234;te de 1 ligne sur 2
colonnes.</p>
<p>Exemple de script pour extraire la colonne (direction=y) de
coordonn&#233;e x (offset) vers un fichier profile.txt :</p>
<pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext PROFILE direction=y offset=1 filename=profile.txt"<br></pre>
<p>Le fichier profile.txt se pr&#233;sente ainsi :<br>
pixel value of the pixel<br>
1 13.000000<br>
2 9.275490<br>
3 9.827091</p>
<p>Le fichier est directement copiable dans Excel ou peut
&#234;tre lu pour recopier les valeurs dans un vecteur (liste de
3474 valeurs pour un .CR2 !)</p>
<p>Dans l'exemple ci-dessus on a extrait les valeurs d'un fichier
binn&#233; n'ayant qu'une seule colonne. Pour extraire une
ligne particuli&#232;re d'une image :</p>
<pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext PROFILE direction=x offset=$y filename=profile.txt"<br></pre>
Pour extraire une seule colonne particuli&#232;re :
<pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext PROFILE direction=y offset=$x filename=profile.txt"<br></pre>
Cette fonction produit le fichier profile.txt et ne doit traiter
qu'une image &#224; la fois : si on traitait une s&#233;rie
ou une liste d&#233;pareill&#233;e, les fichiers produits
seraient &#233;cras&#233;s &#224; l'exception du dernier.
<h4><a name="PROFILE2" id="PROFILE2"></a>1.3.29. Fonction
PROFILE2</h4>
<p>Extrait la valeur num&#233;rique des pixels d'une ligne ou
d'une colonne dans un fichier texte [filename]. [direction]=x ou
y respectivement pour effectuer le profil selon les lignes ou les
colonnes. [offset] repr&#233;sente le num&#233;ro de ligne ou
de colonne sur lequel sera effectu&#233; le profil. Si
[direction]=x, alors [offset] peut &#234;tre compris entre 1 et
le nombre de colonnes. Si [direction]=y, alors [offset] peut
&#234;tre compris entre 1 et le nombre de lignes. A la
diff&#233;rence de PROFIL le fichier [filename] ne contient pas
d'ent&#234;te.</p>
<h4><a name="MATRIX" id="MATRIX"></a>1.3.30. Fonction MATRIX</h4>
<p>Extrait une fen&#234;tre [x1] [x2] [y1] [y2] de l'image et
&#233;crit les valeurs de ces pixels dans un fichier texte
[filematrix]. L'image de sortie est la m&#234;me que celle
d'entr&#233;e.</p>
<h4><a name="FILTER" id="FILTER"></a>1.3.31. Fonction FILTER</h4>
<p>Filtrage spatial d'image avec un filtre kernel. Le masque de
kernel est carr&#233; est comporte [kernel_width] pixels. Les
valeurs du kernel sont pr&#233;d&#233;finies en fonction du
[kernel_type]</p>
<p>kernel_type=fh : filtre passe haut</p>
<p>kernel_type=fb : filtre passe bas</p>
<p>kernel_type=med : filtre m&#233;dian</p>
<p>kernel_type=min : filtre minimum</p>
<p>kernel_type=max : filtre maximum</p>
<p>kernel_type=mean : filtre moyen</p>
<p>kernel_type=gradleft : filtre gradient &#233;clair&#233; par la gauche</p>
<p>kernel_type=gradright : filtre gradient &#233;clair&#233; par la droite</p>
<p>kernel_type=gradup : filtre gradient &#233;clair&#233; par le haut</p>
<p>kernel_type=graddown : filtre gradient &#233;clair&#233; par le bas</p>
<p>L'argument de [kernel_coef] permet de r&#233;gler
l'efficacit&#233; d'action du filtre. Cette efficacit&#233;
est nulle (le filtre n'a aucun effet) si la valeur vaut 1.
L'efficacit&#233; est maximale si la valeur vaut 0. En pratique
l'efficacit&#233; est calcul&#233;e de la fa&#231;on
suivante : value est la valeur initiale du pixel central du
kernel, val0 est la valeur filtr&#233;e par le kernel, valmax
est l'avant derni&#232;re valeur maximale des pixels sous le
kernel et valmin est la deuxi&#232;me valeur minimale des
pixels sous le kernel. On calcule val1 et val2 de la fa&#231;on
suivante :</p>
<p>val1=fabs((double)(val0-value));</p>
<p>val2=kernel_coef*(valmax-valmin);</p>
<p>La valeur initiale est remplac&#233;e par la valeur
filtr&#233;e si val1&lt;val2.</p>
<p>Le param&#232;tre [threshold] permet d'assigner un seuil de
limite du calcul du filtre et [type_threshold] permet de
distinguer la condition du calcul par rapport &#224; ce
seuil.</p>
<p>type_threshold=-1 : le filtre est appliqu&#233; si le pixel
central initial a une valeur inf&#233;rieure ou &#233;gale au
seuil [threshold]</p>
<p>type_threshold=0 : le filtre est appliqu&#233; &#224; tous
les pixels de l'image (valeur par d&#233;faut).</p>
<p>type_threshold=+1 : le filtre est appliqu&#233; si le pixel
central initial a une valeur sup&#233;rieure ou &#233;gale au
seuil [threshold]</p>
<h4><a name="CONV" id="CONV"></a>1.3.32. Fonction CONV</h4>
<p>Convolution d'image par un filtre de type
d&#233;termin&#233; par [kernel_type] :</p>
<p>GAUSSIAN : pour un filtre gaussien.</p>
<p>MEXICAN : pour une ondelette de type chapeau mexicain.</p>
<p>MORLET : pour une ondelette de type Morlet.</p>
<p>La largeur des filtres est d&#233;termin&#233;e par la
valeur de l'option [sigma]. Si ce param&#232;tre n'est pas
pr&#233;cis&#233;, sigma sera d&#233;termin&#233;e
&#224; partir de la valeur associ&#233;e au mot cl&#233;
FWHM de l'en-t&#234;te de l'image (sigma = fwhm * 0.601). Si le
mot cl&#233; FWHM n'est pas trouv&#233; dans l'en-t&#234;te,
la valeur de sigma, par d&#233;faut, vaut 2 pixels.</p>
<h4><a name="RGRADIENT" id="RGRADIENT"></a>1.3.33. Fonction
RGRADIENT</h4>
<p>Effectue un gradient rotationnel, centr&#233; sur la
position pixel d&#233;finie par [xcenter] [ycenter]. Le
gradient a pour param&#232;tre radial [radius] (en pixel) et
pour param&#232;tre angulaire [angle] (en degr&#233;s).</p>
<h4><a name="RADIAL" id="RADIAL"></a>1.3.34. Fonction RADIAL</h4>
<p>Applique le poids (1-1/(1+(r/[sigma])^[power]))) &#224;
chaque pixel distant de r au centre d&#233;fini par [xcenter],
[ycenter]. Tous les pixels inf&#233;rieurs &#224; la distance
[radius] du centre ne sont pas affect&#233;s. Noter qu'il
s'agit d'un masque utile pour mettre en &#233;vidence les jets
coronnaux lors d'&#233;clipses de Soleils.</p>
<h4><a name="OPT" id="OPT"></a>1.3.35. Fonction OPT</h4>
<p>Correction du dark avec optimisation. Les images sont
corrig&#233;es des images [bias] et [dark] (noms complets).
L'image [dark] est optimis&#233;e avant d'&#234;tre
soustraite. L'optimisation se fait sur les pixels dont la valeur
est sup&#233;rieure &#224; un certain seuil dans l'image
dark. Ce seuil est calcul&#233; comme la moyenne +
[therm_kappa] sigma. Par d&#233;faut, [therm_kappa]=0.25.</p>
<p>A la suite des corrections pr&#233;c&#233;dentes, il est
possible d'effectuer une correction de tra&#238;n&#233;e
(deconvflat) dans le cas d'une image effectu&#233;e avec une
cam&#233;ra sans obturateur. Pour ce faire, indiquer la valeur
du rapport de lecture (en g&#233;n&#233;ral proche de 0.0005)
dans le param&#232;tre [unsmearing].</p>
<h4><a name="UNSMEARING" id="UNSMEARING"></a>1.3.36. Fonction
UNSMEARING</h4>
<p>Effectue une correction de tra&#238;n&#233;e (deconvflat)
dans le cas d'une image effectu&#233;e avec une cam&#233;ra
sans obturateur. Pour ce faire, indiquer la valeur du rapport de
lecture (en g&#233;n&#233;ral proche de 0.0005) dans le
param&#232;tre [unsmearing]. Le coefficient
UNSMEARING=[unsmearing] correspond au rapport du temps de lecture
d'une ligne par rapport a l'image enti&#232;re.</p>
<p>Cette correction doit &#234;tre effectu&#233;e apr&#232;s
correction du bias et du dark.</p>
<p>Remarque : Le smearing peut supprim&#233; aussi avec les
commandes <a href="#OPT">OPT</a> et <a href="#SUBDARK">SUBDARK</a> .</p>
<p>Exemple : Supprimer le smearing de 3 images ugc192-1.fit ,
ugc192-2.fit , ugc192-3.fit acquises avec une Audine Kaf400 avec
512 lignes en binning 2x2 . Le coefficient vaut environ 1 /
(binningx * binningy * nb lignes) = 0.0005 . On suppose que les
images sont dans le r&#233;pertoire par d&#233;faut
d&#233;fini dans la variable ::audace(rep_images) .</p>
<pre>set in "ugc192-"<br><br>set first 1<br><br>set ni 3<br><br>set ext ".fit"<br><br>set out "ugc192unsmear-"<br><br>set coefficientUnsmear 0.0005<br></pre>
<pre>ttscript2 "IMA/SERIES \"$::audace(rep_images)\" \"$in\" $first $ni \"$ext\" \"$::audace(rep_images)\" \"$out\" 1 \"$ext\" UNSMEARING UNSMEARING=$coefficientUnsmear"<br></pre>
<p>La commande cr&#233;e les 3 images trait&#233;es :
ugc192unsmear-1.fits , ugc192unsmear-2.fits ,
ugc192unsmear-3.fits</p>
<h4><a name="SUBDARK" id="SUBDARK"></a>1.3.37. Fonction
SUBDARK</h4>
<p>Soustraction d'un dark de temps de pose diff&#233;rent des
images brutes. Le nom du dark est [dark] et celui du bias est
[bias]. Si [exptime] est le temps d'int&#233;gration des images
et [dexptime] le temps d'exposition du dark, le dark est
corrig&#233; du rapport de ces valeurs. Si [exptime] et
[dexptime] sont des cha&#238;nes de caract&#232;res, alors la
valeur des temps d'int&#233;gration sera recherch&#233;e
comme la valeur de ces mots cl&#233;.</p>
<p>Par d&#233;faut, [exptime]="EXPTIME" et
[dexptime]="EXPTIME".</p>
<p>Si l'argument UNSMEARING=[unsmearing] est pr&#233;sent, il
est possible d'effectuer une correction de tra&#238;n&#233;e
(deconvflat) dans le cas d'une image effectu&#233;e avec une
cam&#233;ra sans obturateur. Pour ce faire, indiquer la valeur
du rapport de lecture (en g&#233;n&#233;ral proche de 0.0005)
dans le param&#232;tre [unsmearing].</p>
<p>Si l'argument HOT_PIXEL_LIST="P x1 y1 P x2 y2 ..." est
pr&#233;sent, les pixels chauds sont retir&#233;s de chaque
image avant la soustraction du dark (la syntaxe est identique
&#224; la fonction <a href="#HOTPIXEL">HOTPIXEL</a> ).</p>
<p>Si l'argument COSMIC_THRESHOLD=400 est pr&#233;sent, les
cosmiques sont retir&#233;s de chaque image avant la
soustraction du dark (la syntaxe est identique &#224; la
fonction <a href="#COSMIC">COSMIC</a> )</p>
<h4><a name="BACK" id="BACK"></a>1.3.38. Fonction BACK</h4>
<p>Synth&#233;tise une image du fond de ciel. L'image est
d'abord d&#233;coup&#233;e en pav&#233;s carr&#233;s de
c&#244;t&#233; [back_kernel] (=8 par d&#233;faut) pixels.
Dans chaque carr&#233; est calcul&#233;e la valeur du fond de
ciel en prenant la fraction [back_threshold] (=0.1 par
d&#233;faut) des valeurs de pixels tri&#233;s dans l'ordre
d'intensit&#233; croissante (back_threshold=0 pour ne prendre
que les valeurs minimales et =1 pour les valeurs maximales).</p>
<p>Ajouter [sub] sans argument si l'on souhaite obtenir
directement le r&#233;sultat de la soustraction du fond
&#224; l'image initiale (une valeur constante &#233;gale
&#224; la moyenne du fond synth&#233;tique est ajout&#233;e
au r&#233;sultat de fa&#231;on &#224; retrouver la
dynamique initiale).</p>
<p>Ajouter [div] sans argument si l'on souhaite obtenir
directement le r&#233;sultat de la division du fond &#224;
l'image initiale (une valeur constante &#233;gale &#224; la
moyenne du fond synth&#233;tique est multipli&#233;e au
r&#233;sultat de fa&#231;on &#224; retrouver la dynamique
initiale).<br>
</p>
<p>Pour soustraire le fond de ciel &#224; une image dont les
&#233;toiles sont &#233;tal&#233;es d'environ 3 pixels, on
essaiera par exemple :<br>
</p>
<pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext BACK back_kernel=12 back_threshold=0.2 sub"</pre>
<h4><a name="HOTPIXEL" id="HOTPIXEL"></a>1.3.39. Fonction
HOTPIXEL</h4>
<p>Corrige les pixels chauds, les colonnes d&#233;fectueuses et
les lignes d&#233;fectueuses en rempla&#231;ant les valeurs
d&#233;fectueuses par la moyenne des pixels voisins.</p>
<p>La fonction re&#231;oit en param&#232;tre la liste des
pixels &#224; corriger sous la forme d'une cha&#238;ne de
caract&#232;res contenant les &#233;l&#233;ments suivants
:</p>
<blockquote>
  <p>"P x y" repr&#233;sente les coordonn&#233;es d'un pixel
chaud<br>
"C x" repr&#233;sente l'abscisse d'une colonne
d&#233;fectueuse<br>
"L y" repr&#233;sente l'ordonn&#233;e d'une ligne
d&#233;fectueuse<br>
  </p>
</blockquote>
<p>L'exemple suivant corrige le pixel (232,133), le pixel (456
198), la colonne 400 et la ligne 200 :</p>
<pre>IMA/SERIES ./images/ i- 1 9 .fit ./images/ j . .fit HOTPIXEL HOT_PIXEL_LIST="P 232 133 P 456 198 C 400 L 200"<br></pre>
<p>Remarque : Pour optimiser les traitements, il est possible de
corriger aussi les pixels chauds avec les fonctions de
soustraction des images ou de soustraction des darks (voir les
commandes SUB et SUBDARK)<br>
</p>
<h4><a name="COSMIC" id="COSMIC"></a>1.3.40. Fonction COSMIC</h4>
<p>Corrige les cosmiques en rempla&#231;ant les valeurs
alt&#233;r&#233;es par un cosmique par la moyenne des pixels
voisins.</p>
<p>La fonction re&#231;oit en param&#232;tre un seuil qui
permet d'adapter le niveau de d&#233;tection des cosmiques dans
l'image. La valeur par d&#233;faut est 400. Il est
conseill&#233; d'utiliser une valeur entre 100 et 500.</p>
<p>Exemple :</p>
<pre>IMA/SERIES ./images/ i- 1 9 .fit ./images/ j . .fit COSMIC COSMIC_THRESHOLD=350<br></pre>
<p>Remarque : Pour optimiser les traitements, il est possible de
corriger aussi les cosmiques avec les fonctions de soustraction
des images ou de soustraction des darks (voir les commandes SUB
et SUBDARK<br>
</p>
<h4><a name="REGISTER" id="REGISTER"></a>1.3.41. Fonction
REGISTER</h4>
<p>Effectue la r&#233;gistration des images par rapport
&#224; la premi&#232;re. Il faut pr&#233;alablement que
toutes les images aient un liste d'objets associ&#233;e (cf.
fonction STAT). [translate] permet de contraindre le mode de
calcul de la r&#233;gistration :</p>
<p>translate=only : on contraint le passage d'une image &#224;
l'autre par une translation.</p>
<p>translate=before : on effectue d'abord le calcul de
r&#233;gistration par une translation, puis si aucun accord
n'est trouv&#233;, on effectue une transformation
lin&#233;aire quelconque.</p>
<p>translate=after : on effectue d'abord le calcul de
r&#233;gistration par une transformation lin&#233;aire
quelconque. puis si aucun accord n'est trouv&#233;, on effectue
une translation.</p>
<p>translate=never : on effectue le calcul de r&#233;gistration
uniquement par une transformation lin&#233;aire quelconque.</p>
<p>Le mot d'option [matchwcs] indique que le recentrage ne sera
fait qu'avec les mots cl&#233; WCS de l'image.</p>
<p>Par d&#233;faut, l'int&#233;grale du flux est
conserv&#233;e (par exemple, si l'image est dilat&#233;e d'un
facteur deux, sa dynamique sera r&#233;duite d'un facteur 2).
Pour imposer une normalisation autre du flux, utiliser le
param&#232;tre [normaflux]. Par exemple, pour garder la
dynamique originelle, utiliser normaflux=1.</p>
<p>Les mots cl&#233; d'astrom&#233;trie (WCS),
&#233;ventuellement pr&#233;sents dans l'en-t&#234;te FITS,
sont modifi&#233;s en cons&#233;quence.</p>
<h4><a name="REGISTERFINE" id="REGISTERFINE"></a>1.3.42. Fonction
REGISTERFINE</h4>
<p>Effectue une translation de fa&#231;on &#224; minimiser la
somme des carr&#233;s des r&#233;sidus avec une image de
r&#233;f&#233;rence [file]. La translation sera
recherch&#233;e entre les bornes en pixels
d&#233;limit&#233;s par [delta] avec un
sur&#233;chantillonnage [oversampling].</p>
<h4><a name="SORTX" id="SORTX"></a>1.3.43. Fonction SORTX</h4>
<p>Attribue, &#224; chaque ligne, une valeur constante
&#233;gale &#224; la valeur tri&#233;e &#224; [percent]
(=50 pour la m&#233;diane, =100 pour le maximum) de tous les
pixels de cette ligne entre les pixels [x1] et [x2]. L'image
finale comporte [width] colonnes (20 par d&#233;faut).</p>
<h4><a name="SORTY" id="SORTY"></a>1.3.44. Fonction SORTY</h4>
<p>Attribue, &#224; chaque colonne, une valeur constante
&#233;gale &#224; la valeur tri&#233;e &#224; [percent]
(=50 pour la m&#233;diane, =100 pour le maximum) de tous les
pixels de cette colonne entre les pixels [y1] et [y2]. L'image
finale comporte [height] colonnes (20 par d&#233;faut).</p>
<h4><a name="TILT" id="TILT"></a>1.3.45. Fonction TILT</h4>
<p>Effectue une translation de colonnes
Dy=(x-0.5*NAXIS1/2)*[trans_y] puis une translation de lignes
Dx=(y-0.5*NAXIS2)*[trans_x] afin de corriger les effets
d'inclinaison des raies dans un spectre.</p>
<h4><a name="SMILEX" id="SMILEX"></a>1.3.46. Fonction SMILEX</h4>
<p>Effectue une translation de lignes
Dx=[coef_smile2]*(y-[ycenter])^2+[coef_smile4]*(y-[ycenter])^4
pour corriger les effets de distorsions de type smile des raies
dans un spectre.</p>
<h4><a name="SMILEY" id="SMILEY"></a>1.3.47. Fonction SMILEY</h4>
<p>Effectue une translation de lignes
Dy=[coef_smile2]*(x-[xcenter])^2+[coef_smile4]*(x-[xcenter])^4
pour corriger les effets de distorsions de type smile des raies
dans un spectre.<br>
</p>
<h4><a name="LOPT" id="LOPT"></a>1.3.48. Fonction LOPT</h4>
<p>Calcul la somme normalis&#233;e &#224; 32767 et
optimis&#233;e entre les lignes [y1] et [y2] d'apr&#232;s J.
G. Robertson, PASP 98, 1220-1231, November 1986. Le code est
copi&#233; du logiciel IRIS.<br>
</p>
<h4><a name="ASTROMETRY" id="ASTROMETRY"></a>1.3.49. Fonction
ASTROMETRY</h4>
<p>Calcule les param&#232;tres astrom&#233;triques de l'image
(mots cl&#233; CRVAL1, CRVAL2, CD1_1, CD1_2, CD2_1, CD2_2 de
l'en-t&#234;te FITS dans le cas d'une transformation
lin&#233;aire). Il faut pr&#233;alablement que les images
soient associ&#233;es &#224; des listes d'objets (voir
fonction STAT) et des listes de catalogue (voir fonction
CATCHART). De plus, pour initialiser le calcul des coefficients
astrom&#233;triques, il faut pr&#233;d&#233;finir la valeur
de RA, DEC, PIXSIZE1, PIXSIZE2 et FOCLEN dans l'en-t&#234;te
FITS (cf. fonction HEADERFITS) :</p>
<p>RA : coordonn&#233;e approximative d'ascension droite du
centre de l'image (en degr&#233;s)</p>
<p>DEC : coordonn&#233;e approximative de d&#233;clinaison du
centre de l'image (en degr&#233;s)</p>
<p>PIXSIZE1 : taille du pixel sur l'axe x (en microns)</p>
<p>PIXSIZE2 : taille du pixel sur l'axe y (en microns)</p>
<p>FOCLEN : longueur focale approximative (en m&#232;tres).</p>
<p>Le param&#232;tre [epsilon] permet de r&#233;gler le rayon
d'appariement de la m&#233;thode des triangles (=0.002 par
d&#233;faut). [delta] permet de r&#233;gler le nombre de
pixels d'appariement final (=1 par d&#233;faut).</p>
<p>Si le param&#232;tre [objefile] est pr&#233;sent, il
indique le nom du catalogue g&#233;n&#233;r&#233; par
Sextractor &#224; utiliser comme liste d'objets. Le catalogue
est de la forme suivante :</p>
<p>Indice</p>
<p>Flux ErrFlux Mag ErrMag</p>
<p>Backgnd X Y X2</p>
<p>Y2 XY a b</p>
<p>theta fwhm flag</p>
<p>avec</p>
<p>X2 : moment d'ordre 2 selon X</p>
<p>Y2 : moment d'ordre 2 selon Y</p>
<p>XY : moment d'ordre 2 selon X-Y</p>
<p>a : grand axe de l'ellipse repr&#233;sentant au mieux
l'objet</p>
<p>b : petit axe de l'ellipse repr&#233;sentant au mieux
l'objet</p>
<p>theta : angle de l'ellipse repr&#233;sentant au mieux
l'objet</p>
<p>flag : flag sextractor</p>
<h4><a name="ASTROMETRY2" id="ASTROMETRY2"></a>1.3.50. Fonction
ASTROMETRY2</h4>
<p>Effectue l'astrom&#233;trie de la m&#234;me mani&#232;re
que ASTROMETRY mais calcule les coefficients de
d&#233;formation du second ordre. ces coefficients sont
cod&#233;s par les mots cl&#233;s FITS standards PV* dans
l'en-t&#234;te de l'image de sortie.</p>
<h4><a name="CATCHART" id="CATCHART"></a>1.3.51. Fonction
CATCHART</h4>
<p>Dresse un liste d'objets d'un catalogue correspondant au champ
&#224; l'image d'entr&#233;. La liste est enregistr&#233;e
dans le fichier FITS de nom complet l'argument de [catafile]. Par
d&#233;faut (catafile employ&#233; sans argument) le fichier
FITS est celui de l'image de sortie. Ainsi, la liste du catalogue
est ajout&#233;e derri&#232;re l'image. Si l'on souhaite
g&#233;n&#233;rer une liste catalogue &#224; part de
l'image, il suffit de sp&#233;cifier son nom comme argument de
[catafile]. Dans ce cas, ce fichier FITS contiendra toutes les
listes catalogues de la s&#233;rie d'image.</p>
<p>[path_astromcatalog] est le chemin d'acc&#232;s au
catalogue. [astromcatalog] est le nom du catalogue choisit :</p>
<p>astromcatalog=USNO : pour utiliser l'USNO A ou SA</p>
<p>astromcatalog=MICROCAT : pour utiliser le catalogue
astrom&#233;trique compact&#233; Microcat.</p>
<p>Sinon, il s'agit d'un nom de fichier ASCII d'un catalogue
personnel contenant des lignes de type "ra dec mag" o&#249; ra
et dec sont exprim&#233;s en degr&#233;s d&#233;cimaux et
mag est la magnitude.</p>
<p>[jpegfile_chart] est le nom du fichier jpeg qui simule l'image
du champ des &#233;toiles du catalogue.</p>
<p>[jpegfile_chart2] est le nom du fichier jpeg qui simule
l'image du champ des &#233;toiles du catalogue qui se
superposent en rouge sur le champ observ&#233;.</p>
<p>Il est possible de r&#233;duire la fen&#234;tre de la carte
des &#233;toiles du catalogue. Pour cela, on utilise le mot
[border] suivit d'un pourcentage. Ce pourcentage vaut 0 pour
calculer sur toute l'image (valeur par d&#233;faut), et vaut au
maximum 90 pour effectuer le calcul sur une petite zone au centre
de l'image (cf. fonction STAT de IMA/SERIES).</p>
<p>On peut fixer une limite de magnitude au-del&#224; de
laquelle on ne lit pas les donn&#233;es dans le catalogue. Les
arguments de [magrlim] [magblim] fixent ces limites (99 par
d&#233;faut). Dans le cas d'un catalogue personnel, seul
[magrlim] est actif.</p>
<h4><a name="FITELLIP" id="FITELLIP"></a>1.3.52. Fonction
FITELLIP</h4>
Synth&#233;tise une image par ajustement d'ellipses. Cette
fonction permet de synth&#233;tiser l'image non bruit&#233;
d'une galaxie elliptique (pour &#233;ventuellement la
soustraire &#224; l'image originale). Avant d'utiliser
Fitellip, il est n&#233;cessaire d'enlever les &#233;toiles
les plus brillantes de l'image. On peut travailler uniquement sur
une partie de l'image d&#233;limit&#233;e par [x1] [x2] [y1]
[y2]. Il faut d&#233;finir un centre approximatif (&#224;
quelques pixels pr&#232;s) avec [xcenter] et [ycenter]. Il faut
d&#233;finir le niveau (en ADU) du fond de ciel avec
[backgound]. Il est possible de raffiner l'ajustement en
introduisant un d&#233;veloppement de Fourier par dessus les
ellipses afin de tenir compte des effets boxy ou lemon en
utilisant [fitorder6543]. Ce param&#232;tre comprend quatre
entiers: par exemple 0000 signifie qu'il ne faut faire aucun
d&#233;veloppement d'ordre sup&#233;rieur &#224; 2. Pour un
d&#233;veloppement d'ordre 4 uniquement, [fitorder6543]=0010.
Les param&#232;tres du profil final sont dans le fichier
d&#233;finit par [file_ascii]. Le format de sortie est le
suivant:: indice, rayon^1/4 (arcmin), magnitude surfacique
(mag/arcsec^2), xce et yce les centres de l'ellipse, csa (?),
l'angle au nord, et les coefficients de Fourier: a3 b3 a4 b4 a5
b5 a6 b6. Le param&#232;tre [threshold] s'il n'est pas =0,
permet de synth&#233;tiser une image &#224; partir de l'image
originale (o) &#224; qui l'on remplace les pixels par l'image
de l'ajustement d'ellipses (c) si o-c&gt;[threshold].<br>
<br>
Pour mod&#233;liser l'image d'une galaxie centr&#233;e au pixel (32,99)
avec un fond de ciel de 150 A.D.U.&nbsp; :
<pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext FITELLIP xcenter=32 ycenter=99 background=150 "<br></pre>
Cette fonction produit le fichier profile.txt et ne doit traiter
qu'une image &#224; la fois : si on traitait une s&#233;rie
ou une liste d&#233;pareill&#233;e, les fichiers produits
seraient &#233;cras&#233;s &#224; l'exception du dernier.
<br>
<h1>2. Exemples de scripts</h1>
<p>Nous allons &#233;tudier ici quelques cas classiques de
traitement d'images astronomiques.</p>
<h2>2.1. Pr&#233;traitement des images CCD</h2>
<p>Le pr&#233;traitement des images consiste &#224;
soustraire le dark aux images brutes puis de diviser par le
flatfield. Tout cet exemple traite des images acquises suivantes
:</p>
<p>images de bias : de bias-1.fit &#224; bias-9.fit dans le
chemin ./bias</p>
<p>images de dark : de dark-1.fit &#224; dark-9.fit dans le
chemin ./dark</p>
<p>images de flat : de flat-1.fit &#224; flat-9.fit dans le
chemin ./flat</p>
<p>images &#224; pr&#233;traiter : de sky-1.fit &#224;
sky-9.fit dans le chemin ./sky</p>
<p>Nous allons d'abord pr&#233;parer des images
synth&#233;tiques de bias, dark et flat, r&#233;sultant
d'empilements, afin d'att&#233;nuer le bruit. Enfin, nous
allons pr&#233;traiter les images en utilisant la
m&#233;thode de l'optimisation du thermique. Les images
pr&#233;trait&#233;es seront plac&#233;es dans le chemin
./prt</p>
<h3>2.1.1. Pr&#233;paration du bias</h3>
<p>Le bias est une image de tr&#232;s court temps
d'int&#233;gration, obtenue dans le noir absolu. Le
pr&#233;traitement propos&#233; consiste &#224; faire une
pile m&#233;diane : IMA/STACK ./bias/ bias- 1 9 .fit ./bias/
bias . .fit MED</p>
<h3>2.1.2. Pr&#233;paration du dark</h3>
<p>Le dark est une image de temps d'int&#233;gration proche de
celui des images sky, obtenue dans le noir absolu. Le
pr&#233;traitement propos&#233; consiste &#224; faire une
pile m&#233;diane : IMA/STACK ./dark/ dark- 1 9 .fit ./dark/
dark . .fit MED</p>
<h3>2.1.3. Pr&#233;paration du flat</h3>
<p>Le bias est une image obtenue sur une surface lumineuse la
plus uniforme possible. Le pr&#233;traitement propos&#233;
consiste &#224; faire une correction de dark, suivie d'une
normalisation en gain et d'une pile m&#233;diane.SET/VAR
$smearing 0</p>
<p>IMA/SERIES ./flat/ flat- 1 9 .fit ./flat/ f . .fit OPT
bias=./bias/bias.fit dark=./dark/dark.fit
unsmearing=$smearing</p>
<p>IMA/SERIES ./flat/ f- 1 9 .fit ./flat/ f . .fit NORMGAIN
normgain_value=10000</p>
<p>IMA/STACK ./flat/ f- 1 9 .fit ./flat/ flat . .fit MED</p>
<p>IMA/SERIES ./flat/ f- 1 9 .fit . . . .fit DELETE</p>
<p>Si les images ont &#233;t&#233; obtenues avec un
obturateur, la valeur de $smearing doit &#234;tre &#233;gale
&#224; z&#233;ro. Avec des images obtenues sans obturateur,
il est n&#233;cessaire de placer une valeur non nulle &#224;
$smearing.</p>
<h3>2.1.4. Pr&#233;traitement des images brutes</h3>
<p>SET/VAR $sky sky<br>
SET/VAR $smearing 0<br>
IMA/SERIES ./sky/ $sky- 1 9 .fit ./prt/ i . .fit OPT
bias=./bias/bias.fit dark=./dark/dark.fit
unsmearing=$smearing<br>
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit DIV
file=./flat/flat.fit constant=10000<br>
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit NORMOFFSET
normoffset_value=200 skylevel Si les images ont &#233;t&#233;
obtenues avec un obturateur, la valeur de $smearing doit
&#234;tre &#233;gale &#224; z&#233;ro. Avec des images
obtenues sans obturateur, il est n&#233;cessaire de placer une
valeur non nulle &#224; $smearing.</p>
<h3>2.1.5. R&#233;gistration et empilement des images
pr&#233;trait&#233;es</h3>
<p>SET/VAR $sky sky<br>
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit STAT
objefile=./prt/x$sky.fit<br>
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit REGISTER
translate=before nullpixel=-1000<br>
IMA/STACK ./prt/ i- 1 9 .fit ./prt/ $sky . .fit MED
nullpixel=-1000<br>
IMA/SERIES ./prt/ i- 1 9 .fit . . . .fit DELETE<br>
IMA/SERIES ./prt/ x$sky . . .fit . . . .fit DELETE</p>
<h3>2.1.6. Mise en forme de l'image pr&#233;trait&#233;e</h3>
SET/VAR $sky sky<br>
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit STAT fwhm
jpegfile=./prt/$sky.jpg
<h2>2.2. Calibration astrom&#233;trique d'une image
pr&#233;trait&#233;e</h2>
<p>IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit STAT
objefile=./prt/x$sky.fit<br>
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit CATCHART
path_astromcatalog=/cdrom/ astromcatalog=Microcat
catafile=./prt/c$sky.fit<br>
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit
ASTROMETRY<br>
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit CATCHART
path_astromcatalog=/cdrom/ astromcatalog=Microcat
catafile=./prt/c$sky.fit jpegfile_chart2=./prt/$skyb.jpg<br>
IMA/SERIES ./prt/ x$sky . . .fit . . . .fit DELETE<br>
IMA/SERIES ./prt/ c$sky . . .fit . . . .fit DELETE<br>
</p>
</body>
</html>
