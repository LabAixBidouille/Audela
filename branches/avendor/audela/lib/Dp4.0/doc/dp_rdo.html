<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content>
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<title>dp_RDO</title>
</head>

<body bgcolor="#C0C0C0" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<h3>dp_RDO</h3>

<p><b>Syntax</b></p>

<p><tt>dp_RDO&nbsp;rdoChan ?-events </tt><em><tt>evtList</tt></em><tt>?
?-onerror </tt><em><tt>errScript</tt></em><tt>? ?-callback </tt><em><tt>callScript</tt></em><tt>?
rdoCmd ?args ...?</tt></p>

<p><b>Comments</b></p>

<p>RDO&nbsp;is akin to an RPC&nbsp;except there is no return
value. Since there is no return value, dp_RDO&nbsp;does not wait
for a response and therefore there is no need for the timeout
code that dp_RPC&nbsp;requires.</p>

<p>RDOs can be hard to debug because they generate no response at
all, even if something catastrophic happens. Therefore, one can
track errors by using <em>errScript</em>; the RDO sender's
errorInfo will be set to the RDO executer's errorInfo and <em>errScript</em>
will be called with the error message generated by the RDO as an
argument.</p>

<p>In the same vein, <em>callScript</em> will be evaluted when
the RDO has finished evaluting on the remote machine.</p>

<p>If both -onerror and -callback are specified, <em>callScript</em>
will be called unless the RDO generated an error.</p>

<p><b>Examples</b></p>

<dl>
    <dt><tt>dp_RDO&nbsp;$myChan -events all puts stdout foobar</tt></dt>
    <dt><tt>dp_RDO&nbsp;$myChan -onerror WhatError wackyProc</tt></dt>
    <dt>&nbsp;</dt>
</dl>
</body>
</html>


