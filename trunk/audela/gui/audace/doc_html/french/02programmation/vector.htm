<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>Usage des vecteurs</title>
</head>
<body>
<p class="date">Date de mise &agrave; jour : 16 octobre 2010</p>
<h1>Usage des vecteurs</h1>
<p>Ce document pr&eacute;sente des possibilit&eacute;s
d'application de ::blt::vector. Il est n&eacute;cessairement
incomplet. Pour de plus amples informations, consulter
<a href="http://tcltk.free.fr/blt/vector.html">http://tcltk.free.fr/blt/vector.html</a></p>
<p>L'usage des vecteurs a pour principal avantage la
simplicit&eacute; d'&eacute;criture du code et donc sa
maintenance et il &eacute;vite d'&eacute;crire de tr&egrave;s
nombreuses boucles.</p>
<p>La plupart des exemples pr&eacute;sent&eacute;s peuvent
&ecirc;tre tap&eacute;s directement dans la Console d'Aud'ACE et
le lecteur peut v&eacute;rifier le r&eacute;sultat.</p>
<h2>1. Qu'est-ce qu'un vecteur ?</h2>
<p>La r&eacute;ponse est simple : C'est une liste (au sens Tcl)
de valeurs num&eacute;riques.<br>
En Tcl on l'&eacute;crit d'une des deux mani&egrave;res :</p>
<code>set liste_de valeurs [ list 1 2 3 4 ]<br>
set liste_de valeurs { 1 2 3 4 }<br>
</code>
<p>Pour d&eacute;clarer un vecteur, on &eacute;crit (le nom du
vecteur doit obligatoirement commencer par une lettre et contenir
des lettres, des nombres ou des underscores) :</p>
<p><code>::blt::vector create v_1</code></p>
<p>Au fait est-ce qu'il existe ?</p>
<p><code>::blt::vector names</code></p>
<p>Surprise, il n'est pas tout seul.<br>
Combien d'&eacute;l&eacute;ments a-t-il ?</p>
<p><code>set a [ v_1 length ]</code></p>
<p>Nouvelle surprise : Le vecteur existe mais il a 0
&eacute;l&eacute;ment, exactement comme une liste qui aurait
&eacute;t&eacute; cr&eacute;&eacute;e par [ list ].<br>
Pour le
remplir on peut utiliser plusieurs mani&egrave;res :</p>
<p><code>v_1 set [ list 1 2 3 4 ]<br>
v_1 set { 1 2 3 4 }<br>
v_1 set $liste_de valeurs<br>
v_1 append ...(un vecteur, une liste, une valeur, une succession des
trois)<br>
</code></p>
<h2>2. Et alors ?</h2>
<p>Pour traiter une liste Tcl, par exemple rechercher son
minimum, son maximum, des valeurs n&eacute;gatives, traiter les
&eacute;l&eacute;ments, il faut &eacute;crire une proc&eacute;dure
qui lit chaque valeur de la liste, la compare,
&eacute;ventuellement sort de la boucle si une condition est
remplie et retourne le r&eacute;sultat final. Ce n'est pas
tr&egrave;s compliqu&eacute; mais harassant d'&eacute;crire des
boucles du type :</p>
<p><code>for { set i 0 } { $i &lt; [ length $liste_valeurs ] } { incr i
} {<br>
...faire quelque chose<br>
}<br>
</code></p>
<p>Pour conna&icirc;tre le minimum ou le maximum d'un vecteur, il
suffit d'&eacute;crire :</p>
<p><code>set minimum $v_1(min)<br>
set maximum $v_1(max)</code></p>
<p>La r&eacute;ponse est imm&eacute;diate.
</p>
<p>En pur Tcl, le calcul de la somme des &eacute;l&eacute;ments
n&eacute;cessiterait de cr&eacute;er une boucle
d'accumulation.<br>
Avec un vecteur, on &eacute;crit :</p>
<p><code>set sum $v_1(sum)<br>
</code></p>
Il n'est pas n&eacute;cessaire de faire :
<code>set mean [ expr { $sum/[llength $liste_de valeurs ] } ] <br>
</code>
<p>pour conna&icirc;tre la moyenne. Il suffit d'&eacute;crire :</p>
<p><code>set mean $v_1(mean)</code></p>
<h2>3. Comment &eacute;diter un vecteur dans la Console ?</h2>
<p><code>::console::affiche_resultat "$v_1(:)"</code></p>
<p>permet d'&eacute;diter la totalit&eacute; du vecteur. Le (:)
&eacute;quivaut &agrave; (d&eacute;but : end).</p>
<p>Pour &eacute;diter les valeurs comprises entre l'indice i et j
:</p>
<p><code>::console::affiche_resultat "$v_1($i:$j)"</code></p>
<p>ou mieux :</p>
<p><code>::console::affiche_resultat "[ v_1 range $i $j ]"</code></p>
<p>Cette commande retourne une sous-liste. Elle peut donc aussi
servir pour cr&eacute;er ou compl&eacute;ter un autre vecteur
:</p>
<code>vecteur2 append [ v_1 range $i $j ]<br>
</code>
<h2>4. Comment calculer avec un vecteur ?</h2>
<p><code>v_1 expr { v_1+10 }</code></p>
<p>Ajoute la valeur 10 &agrave; chaque &eacute;l&eacute;ment du
vecteur.<br>
Les op&eacute;rations usuelles + - / * % ^ sont valables.</p>
<p>D'autres op&eacute;rations n&eacute;cessitent un style analogue
&agrave; celui du Tcl :</p>
<p><code>abs round random norm<br>
acos cos hypot sinh <br>
asin cosh log sqrt <br>
atan exp log10 tan <br>
ceil floor sin tanh</code></p>
<p>Par exemple :</p>
<p><code>v_1 expr { log(v_1) }</code></p>
<p>Il est aussi possible d'op&eacute;rer sur deux vecteurs de
longueur identique (les &eacute;l&eacute;ments &eacute;tant
trait&eacute;s deux &agrave; deux), &agrave; condition de ne pas
oublier de cr&eacute;er le second vecteur :</p>
<p><code>::blt::vector create resultat<br>
resultat expr { v_1*vecteur2 }</code></p>
Si chaque vecteur contient 1000 &eacute;l&eacute;ments, on
&eacute;crit 1000 multiplications avec une seule ligne de code !
<p>Les comparateurs &lt; &gt; &lt;= &gt;= == =! et les
op&eacute;rateurs logiques &amp;&amp; || peuvent &ecirc;tre
utilis&eacute;s : le vecteur r&eacute;sultat contient des 1 pour
les &eacute;l&eacute;ments remplissant la condition, sinon 0.</p>
<p>Des op&eacute;rations de d&eacute;placements circulaires vers
la droite &gt;&gt; ou vers la gauche &lt;&lt; des
&eacute;l&eacute;ments sont possibles :</p>
<p><code>v_1 expr { v_1 &gt;&gt; 2 }</code></p>
<p>Le dernier &eacute;l&eacute;ment devient le second et
l'avant-dernier le dernier.
</p>
<p>On remarquera que :</p>
<ul>
  <li>le $ si courant en Tcl n'appara&icirc;t gu&egrave;re que pour
d&eacute;signer une valeur particuli&egrave;re de la liste,</li>
  <li>la commande 'set', si fr&eacute;quente en Tcl, est &eacute;crite
selon le cas apr&egrave;s le nom du vecteur (exemple : v_1 set $liste)
ou devant le rep&egrave;re d'un &eacute;l&eacute;ment (exemple : set
v_1(2) ),</li>
  <li>la commande 'expr' n'est pas entour&eacute;e de [ ].</li>
</ul>
<h2>5. Comment rep&eacute;rer les points ayant une valeur
particuli&egrave;re ?</h2>
<p>Pour isoler la valeur situ&eacute;e &agrave; l'indice j du
vecteur :</p>
<p><code>set valeur $v_1($j)</code></p>
<p>Pour rep&eacute;rer les positions ayant une valeur donn&eacute;e</p>
<p><code>set liste_des_index [ v_1 search $cette_valeur ]</code></p>
<p>Pour rechercher les valeurs comprises dans un intervalle :</p>
<p><code>set liste_des_index [ v_1 search $borne1 $borne2 ]</code></p>
<h2>6. Et la gestion des indices ?</h2>
<p>Qui n'a pas oubli&eacute; une fois qu'une liste Tcl
d&eacute;marre &agrave; l'indice 0 et que end est en fait
&eacute;gal &agrave; [ expr {[length $liste_de valeurs]-1 }]
?</p>
<p>Pour les vecteurs c'est pareil (par d&eacute;faut) sauf que
l'indice de d&eacute;but est modifiable par :</p>
<p><code>v_1 offset 1</code></p>
<p>L'exemple ci-dessus est particuli&egrave;rement pratique lorsque
le but est d'analyser les valeurs d'une ligne ou d'une colonne de
pixels car celles-ci commence toujours &agrave; l'index 1.<br>
Dans cet exemple, la position d'un point dans la ligne serait
exactement &eacute;gale &agrave; l'indice de la valeur du point
dans le vecteur.</p>
<p>Comment extraire une sous-liste d'une liste, la modifier puis
replacer les valeurs au bon endroit ?<br>
En Tcl il faut m&eacute;moriser les indices puis,
ult&eacute;rieurement, ne pas se tromper sur leur rappel.</p>
<p><code>vecteur2 set [ v_1 range $i $j ]<br>
vecteur2 offset $i</code></p>
<p>vecteur2 est le reflet fid&egrave;le (indices et valeurs) du
morceau de vecteur.<br>
Apr&egrave;s traitement, on peut le remettre en place avec :</p>
<p><code>v_1 index $i $j [ vecteur2 range $i $j ]</code></p>
<p>ou</p>
<p><code>set start [ vecteur2 offset ]<br>
v_1 index $i $j [ vecteur2 range $start end ]</code></p>
<p>Pour conna&icirc;tre l'indice initial d'un vecteur :</p>
<code>set offset [ v_1 offset ]<br>
</code>
<h2>7. Plus ...</h2>
<p>D'autres fonctions particuli&egrave;res (adev, kurtosis,
median, q1, q3, prod, sdev, skew, var) existent mais elles ne
peuvent pas &ecirc;tre appel&eacute;es directement comme min,
max, mean et sum.<br>
La raison en est que les vecteurs disposent d'indices
sp&eacute;ciaux pour min, max , sum et mean permettant d'appeler
directement les valeurs. La documentation n'est pas tr&egrave;s
explicite sur la mani&egrave;re de mettre en &#339;uvre les autres
fonctions.<br>
Une solution qui marche est de consid&eacute;rer
qu'elles retournent un vecteur &agrave; une seule composante
:</p>
<p><code>resultat expr { adev(v_1) }<br>
set adev $resultat(:) (&eacute;cart moyen par rapport &agrave; la
moyenne)<br>
resultat expr { kurtosis(v_1) }<br>
set kurtosis $resultat(:) (moment d'ordre 4)<br>
resultat expr { median(v_1) }<br>
set median $resultat(:) (valeur m&eacute;diane)<br>
resultat expr { q1(v_1) }<br>
set q1 $resultat(:) (premier quartile)<br>
resultat expr { q3(v_1) }<br>
set q3 $resultat(:) (troisi&egrave;me quartile)<br>
resultat expr { prod(v_1) }<br>
set prod $resultat(:) (produit des &eacute;l&eacute;ments)<br>
resultat expr { sdev(v_1) }<br>
set sdev $resultat(:) (racine carr&eacute;e de la variance var)<br>
resultat expr { skew(v_1) }<br>
set skew $resultat(:) (moment d'ordre 3)<br>
resultat expr { var(v_1) }<br>
set var $resultat(:) (somme des carr&eacute;s des &eacute;carts
&agrave; la moyenne, divis&eacute;e par le nombre
d'&eacute;l&eacute;ments)</code></p>
<p>D'autres fonctions retournent un vecteur de longueur identique au
vecteur initial :</p>
<p><code>resultat expr { norm(v_1) } (vecteur norm&eacute; entre 0 et 1)<br>
resultat expr { sort(v_1) } (vecteur tri&eacute; par ordre croissant)</code></p>
<p>Il existe une autre solution pour sort:</p>
<p><code>v_1 sort (tri par ordre croissant)<br>
v_1 sort -reverse (tri par ordre d&eacute;croissant)<br>
v_1 sort vecteur2 (tri par ordre croissant de v_1 et
r&eacute;arrangement du vecteur2 pour que les indices restent
coh&eacute;rents).</code></p>
Le lecteur peut aussi essayer random ou srandom.
<h2>8. Cr&eacute;ation (2)</h2>
<p>Le vecteur v_1 cr&eacute;&eacute; plus haut n'existait que par
son nom et avait une longueur initiale nulle (si si).</p>
<p>La commande :</p>
<p><code>::blt::vector create vecteur(20)</code></p>
<p>cr&eacute;&eacute;e un vecteur de 20 &eacute;l&eacute;ments
initialis&eacute;s &agrave; la valeur 0, l'indice initial
&eacute;tant 0 et l'indice final 19 (soit 20 valeurs).</p>
<p>Si on veut cr&eacute;er un vecteur dont l'index initial est 1
(0 par d&eacute;faut) et de longueur 20 on &eacute;crit :</p>
<p><code>::blt::vector create vecteur(1:20)</code></p>
<p>Plusieurs modes d'affectation de valeurs sont disponibles :</p>
<p><code>set v_1(:3) 12 (le premier &eacute;l&eacute;ment ayant pour
indice 1, les &eacute;l&eacute;ments de rang 1 &agrave;
3 valent 12)<br>
set v_1(4:5) 2 (les &eacute;l&eacute;ments de rang 4 &agrave; 5 valent
2) <br>
v_1 index 2 0.5 (le second &eacute;l&eacute;ment vaut maintenant 0.5) <br>
set i 6<br>
set v_1($i) 10 (le sixi&egrave;me &eacute;l&eacute;ment vaut 10) <br>
set v_1{7:2*$i) 20 (les &eacute;l&eacute;ments de rang 7 &agrave; rang
12 valent 20)<br>
set v_1(2*$i+1:) 0.34 (les &eacute;l&eacute;ments de rang
sup&eacute;rieur 12 valent 0.34)<br>
set v_1(end) 45 (le dernier &eacute;l&eacute;ment, le vingti&egrave;me,
vaut 45)<br>
set v_1(++end) 9 (rajoute un &eacute;l&eacute;ment de valeur 9 au
vecteur)<br>
v_1 delete 11 15 (supprime le 11&egrave;me et le 15&egrave;me
&eacute;l&eacute;ment, la longueur du vecteur diminue)<br>
v_1 length 20 (rajoute des 0 pour que le nombre
d'&eacute;l&eacute;ments redevienne &eacute;gal &agrave; 20) <br>
v_1 length 5 (supprime tous les &eacute;l&eacute;ments de rang &gt; 5)</code></p>
<p>Il est aussi possible de cr&eacute;er un vecteur avec des valeurs
&eacute;chelonn&eacute;es :</p>
<p><code>v_1 seq 5 10 1</code></p>
Ce mode cr&eacute;&eacute;e automatiquement un vecteur dont le premier <code></code>&eacute;l&eacute;ment
vaut 5 et le dernier 10 avec un
intervalle de 1.
<p>Il est aussi possible de fusionner des vecteurs :</p>
<p><code>v_1 merge v_2 v_3</code></p>
<h2>9. Et destruction</h2>
<p>Contrairement aux variables locales d'une proc&eacute;dure
Tcl, qui sont d&eacute;truites &agrave; la fin de la
proc&eacute;dure, les vecteurs subsistent ce qui conduit &agrave;
encombrer inutilement l'espace m&eacute;moire et surtout &agrave;
des r&eacute;sultats inattendus si on a recours &agrave; des
'append' ou si on utilise le non d'un vecteur existant.<br>
Il est donc prudent de d&eacute;clarer les vecteurs avec l'option
watchunset :</p>
<p><code>::blt::vector create v_1 vecteur2 -watchunset 1</code></p>
<p>Et &agrave; la fin de la proc&eacute;dure de tuer les vecteurs:</p>
<p><code>::blt::vector destroy v_1 vecteur2</code></p>
<p>ou &agrave; tout le moins, dans les proc&eacute;dures
it&eacute;ratives, &agrave; utiliser la commande :</p>
<p><code>v_1 length 0</code></p>
<p>Ce qui a pour effet de supprimer toutes les valeurs
ant&eacute;rieures : Le vecteur est comme au moment de sa
cr&eacute;ation.</p>
<h2>10. Quelques exemples pratiques</h2>
<h3>10.1 Obtention du minimum ou du maximum d'une liste</h3>
<p>Les fonctions min et max constituent des solutions
alternatives &agrave; des fonctions telles que lmin et lmax.<br>
Il est aussi possible d'obtenir la liste des indices des valeurs
&eacute;gales au minimum :</p>
<p><code>set indexes [ v_1 search $v_1(min) ]</code></p>
<p>Puis de demander le niveau de cette valeur :</p>
<p><code>set min $v_1([ lindex $indexes 0 ])</code></p>
<h3>10.2 Moyenne dynamique d'une s&eacute;rie de mesures (dans
une boucle de rafra&icirc;chissement)</h3>
<p><code>vecteur_mesure append $nouvelle_mesure<br>
set moyenne $vecteur_mesure(mean)</code></p>
<h3>10.3 V&eacute;rification qu'une liste ne comporte que des
valeurs num&eacute;riques</h3>
<p>Un vecteur n'admet que des valeurs num&eacute;riques, autrement
il y erreur.</p>
<p><code>set liste_a_analyser [ list 1 2 3 blabla ]<br>
v_1 set $liste_a_analyser</code></p>
<p>Retourne :</p>
<p><code>invalid bareword "blabla" .....</code></p>
<p>On peut mettre &agrave; profit cette erreur pour d&eacute;tecter
l'absence d'erreur sans avoir &agrave; analyser chaque
&eacute;l&eacute;ment :</p>
<p><code>if ![ catch { v_1 set $liste_a_analyser } ErrInfo ] {<br>
&nbsp;&nbsp;&nbsp;#-- c'est bien une liste de valeurs num&eacute;riques<br>
&nbsp;&nbsp;&nbsp;todo ...<br>
} else {<br>
&nbsp;&nbsp;&nbsp;#-- ce n'est une liste de valeurs num&eacute;riques<br>
}</code></p>
<h3>10.4 V&eacute;rification qu'une s&eacute;rie de nombres ne
comporte pas de trou</h3>
<p>La somme des termes d'une suite arithm&eacute;tique est
donn&eacute;e par la formule
Somme=Nombre_de_termes*(Premier_terme+Dernier_terme)/2.<br>
On pourra donc &eacute;crire :</p>
<p><code>v_1 set $liste_de_valeurs<br>
v_1 sort<br>
if { $v_1(sum) == [ expr { [ v_1 length ]*($v_1(0)+$v_1(end))/2 } ] }
{<br>
&nbsp;&nbsp;&nbsp;#-- c'est une s&eacute;rie sans trou<br>
&nbsp;&nbsp;&nbsp;todo<br>
}</code></p>
<h3>10.5 Filtrage et rep&eacute;rage de valeurs en dehors d'un
intervalle</h3>
<p><code>set seuil_bas 20<br>
set seuil_haut 50<br>
v_1 expr { v_1 &lt; $seuil_bas || v_1 &gt; $seuil_haut }</code></p>
<p>Toutes les valeurs sont remplac&eacute;es par des 0 ou des 1
selon que la valeur est dans l'intervalle ou en dehors.<br>
Pour conna&icirc;tre les positions des &eacute;l&eacute;ments en
dehors :</p>
<p><code>set indexes [ v_1 search 1 ]</code></p>
<h3>10.6 Calcul des points d'une courbe param&eacute;trique</h3>
<p>Pour calculer 100 points d'une courbe y=a+bx+c*x&sup2;, on
cr&eacute;&eacute;e deux vecteurs :</p>
<p><code>set a 1.2<br>
set b 3.5 <br>
set c -1.56<br>
::blt::vector create x y -watchunset 1<br>
x seq 1 100 1<br>
y expr { $a+$b*x+$c*x^2}</code></p>
<p>Et pour afficher le r&eacute;sultat :</p>
<p><code>::plotxy::plot $x(:) $y(:)</code></p>
<h3>10.7 Passage par nom au lieu de valeur</h3>
<p>Pour indiquer &agrave; une proc&eacute;dure les valeurs &agrave;
traiter,
il suffit de lui donner le nom du vecteur &agrave; traiter au
lieu de lui passer la liste des valeurs :</p>
<p><code>proc todo { nom_du_vecteur } {<br>
&nbsp;&nbsp;&nbsp;$nom_du_vecteur expr { log($nom_du_vecteur^3) }<br>
}<br>
todo v_1</code></p>
<p>Les valeurs de v_1 sont modifi&eacute;es sans qu'il soit
n&eacute;cessaire de retourner la liste des valeurs.</p>
<p>Une autre application concerne ::blt::graph. Pour cr&eacute;er une
courbe, on &eacute;crit :</p>
<p><code>$w element create courbe -xdata -x $liste_des abscisses -ydata
$liste_des ordonn&eacute;es</code></p>
<p>Avec les vecteurs il suffit d'&eacute;crire :</p>
<p><code>$w element create courbe -xdata vecteur_abscisses -ydata
vecteur_ordonnees</code></p>
<p>La modification du contenu des vecteurs modifie automatiquement
le graphique.</p>
<h3>10.8 Interpolation</h3>
<p>Admettons l'existence d'un vecteur n'ayant que deux valeurs
ayant pour abscisses 150 et 151 (pixels).</p>
<p><code>v_1 set [ list 102 98 ]<br>
v_1 offset 150</code></p>
<p>Pour d&eacute;terminer l'abscisse interm&eacute;diaire ayant pour
valeur 100 (le cas est simple = 150.5) :</p>
<p><code>v_1 populate resultat 9 (cr&eacute;ation d'un vecteur z
comportant 11 &eacute;l&eacute;ments et donc 10 intervalles)<br>
z offset [ expr { [ v_1 offset ]*10 } ] (l'indice de d&eacute;but de z
vaut 10 fois l'indice soit 1500)<br>
set index [ expr { [ resultat search 99.9 100.1 ]/10 } ] (la
r&eacute;ponse est divis&eacute;e par 10 et vaut 150.5)</code></p>
<h3>10.9 Calcul matriciel</h3>
<p>Dans le calcul matriciel gsl_mfitmultilin on recourt &agrave;
un vecteur w de pond&eacute;ration des valeurs.<br>
Comment obtenir ce vecteur en sachant qu'il doit avoir le
m&ecirc;me nombre d'&eacute;l&eacute;ments que le vecteur des
mesures :</p>
<p><code>::blt::vector create w([vecteur_mesures length])</code></p>
<p>Le vecteur est cr&eacute;&eacute; mais tous ses
&eacute;l&eacute;ments valent 0.</p>
<p><code>w expr { w == 0 }</code></p>
<p>Maintenant il sont tous &eacute;gaux &agrave; 1 !<br>
On aurait aussi pu &eacute;crire :</p>
<p><code>set w(:) 1</code></p>
</body>
</html>
