<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>Usage des vecteurs</title></head><body>
<p class="date">Date de mise à jour : 27 mars 2011</p>
<h1>Usage des vecteurs</h1>
<p>Ce document présente des possibilités
d'application de ::blt::vector. Il est nécessairement
incomplet. Pour de plus amples informations, consulter
<a href="http://tcltk.free.fr/blt/vector.html">http://tcltk.free.fr/blt/vector.html</a></p>
<p>L'usage des vecteurs a pour principal avantage la
simplicité d'écriture du code et donc sa
maintenance et il évite d'écrire de très
nombreuses boucles.</p>
<p>La plupart des exemples présentés peuvent
être tapés directement dans la Console d'Aud'ACE et
le lecteur peut vérifier le résultat.</p>
<h2>1. Qu'est-ce qu'un vecteur ?</h2>
<p>La réponse est simple : C'est une liste (au sens Tcl)
de valeurs numériques.<br>
En Tcl on l'écrit d'une des deux manières :</p>
<code>set liste_de valeurs [ list 1 2 3 4 ]<br>
set liste_de valeurs { 1 2 3 4 }<br>
</code>
<p>Pour déclarer un vecteur, on écrit (le nom du
vecteur doit obligatoirement commencer par une lettre et contenir
des lettres, des nombres ou des underscores) :</p>
<p><code>::blt::vector create v_1</code></p>
<p>Au fait est-ce qu'il existe ?</p>
<p><code>::blt::vector names</code></p>
<p>Surprise, il n'est pas tout seul.<br>
Combien d'éléments a-t-il ?</p>
<p><code>set a [ v_1 length ]</code></p>
<p>Nouvelle surprise : Le vecteur existe mais il a 0
élément, exactement comme une liste qui aurait
été créée par [ list ].<br>
Pour le
remplir on peut utiliser plusieurs manières :</p>
<p><code>v_1 set [ list 1 2 3 4 ]<br>
v_1 set { 1 2 3 4 }<br>
v_1 set $liste_de valeurs<br>
v_1 append ...(un vecteur, une liste, une valeur, une succession des
trois)<br>
</code></p>
<h2>2. Et alors ?</h2>
<p>Pour traiter une liste Tcl, par exemple rechercher son
minimum, son maximum, des valeurs négatives, traiter les
éléments, il faut écrire une procédure
qui lit chaque valeur de la liste, la compare,
éventuellement sort de la boucle si une condition est
remplie et retourne le résultat final. Ce n'est pas
très compliqué mais harassant d'écrire des
boucles du type :</p>
<p><code>for { set i 0 } { $i &lt; [ length $liste_valeurs ] } { incr i
} {<br>
...faire quelque chose<br>
}<br>
</code></p>
<p>Pour connaître le minimum ou le maximum d'un vecteur, il
suffit d'écrire :</p>
<p><code>set minimum $v_1(min)<br>
set maximum $v_1(max)</code></p>
<p>La réponse est immédiate.
</p>
<p>En pur Tcl, le calcul de la somme des éléments
nécessiterait de créer une boucle
d'accumulation.<br>
Avec un vecteur, on écrit :</p>
<p><code>set sum $v_1(sum)<br>
</code></p>
Il n'est pas nécessaire de faire :
<code>set mean [ expr { $sum/[llength $liste_de valeurs ] } ] <br>
</code>
<p>pour connaître la moyenne. Il suffit d'écrire :</p>
<p><code>set mean $v_1(mean)</code></p>
<h2>3. Comment éditer un vecteur dans la Console ?</h2>
<p><code>::console::affiche_resultat "$v_1(:)"</code></p>
<p>permet d'éditer la totalité du vecteur. Le (:)
équivaut à (début : end).</p>
<p>Pour éditer les valeurs comprises entre l'indice i et j
:</p>
<p><code>::console::affiche_resultat "$v_1($i:$j)"</code></p>
<p>ou mieux :</p>
<p><code>::console::affiche_resultat "[ v_1 range $i $j ]"</code></p>
<p>Cette commande retourne une sous-liste. Elle peut donc aussi
servir pour créer ou compléter un autre vecteur
:</p>
<code>vecteur2 append [ v_1 range $i $j ]<br>
</code>
<h2>4. Comment calculer avec un vecteur ?</h2>
<p><code>v_1 expr { v_1+10 }</code></p>
<p>Ajoute la valeur 10 à chaque élément du
vecteur.<br>
Les opérations usuelles + - / * % ^ sont valables.</p>
<p>D'autres opérations nécessitent un style analogue
à celui du Tcl :</p>
<p><code>abs round random norm<br>
acos cos hypot sinh <br>
asin cosh log sqrt <br>
atan exp log10 tan <br>
ceil floor sin tanh</code></p>
<p>Par exemple :</p>
<p><code>v_1 expr { log(v_1) }</code></p>
<p>Il est aussi possible d'opérer sur deux vecteurs de
longueur identique (les éléments étant
traités deux à deux), à condition de ne pas
oublier de créer le second vecteur :</p>
<p><code>::blt::vector create resultat<br>
resultat expr { v_1*vecteur2 }</code></p>
Si chaque vecteur contient 1000 éléments, on
écrit 1000 multiplications avec une seule ligne de code !
<p>Les comparateurs &lt; &gt; &lt;= &gt;= == =! et les
opérateurs logiques &amp;&amp; || peuvent être
utilisés : le vecteur résultat contient des 1 pour
les éléments remplissant la condition, sinon 0.</p>
<p>Des opérations de déplacements circulaires vers
la droite &gt;&gt; ou vers la gauche &lt;&lt; des
éléments sont possibles :</p>
<p><code>v_1 expr { v_1 &gt;&gt; 2 }</code></p>
<p>Le dernier élément devient le second et
l'avant-dernier le dernier.
</p>
<p>On remarquera que :</p>
<ul>
  <li>le $ si courant en Tcl n'apparaît guère que pour
désigner une valeur particulière de la liste,</li>
  <li>la commande 'set', si fréquente en Tcl, est écrite
selon le cas après le nom du vecteur (exemple : v_1 set $liste)
ou devant le repère d'un élément (exemple : set
v_1(2) ),</li>
  <li>la commande 'expr' n'est pas entourée de [ ].</li>
</ul>
<h2>5. Comment repérer les points ayant une valeur
particulière ?</h2>
<p>Pour isoler la valeur située à l'indice j du
vecteur :</p>
<p><code>set valeur $v_1($j)</code></p>
<p>Pour repérer les positions ayant une valeur donnée</p>
<p><code>set liste_des_index [ v_1 search $cette_valeur ]</code></p>
<p>Pour rechercher les valeurs comprises dans un intervalle :</p>
<p><code>set liste_des_index [ v_1 search $borne1 $borne2 ]</code></p>
<h2>6. Et la gestion des indices ?</h2>
<p>Qui n'a pas oublié une fois qu'une liste Tcl
démarre à l'indice 0 et que end est en fait
égal à [ expr {[length $liste_de valeurs]-1 }]
?</p>
<p>Pour les vecteurs c'est pareil (par défaut) sauf que
l'indice de début est modifiable par :</p>
<p><code>v_1 offset 1</code></p>
<p>L'exemple ci-dessus est particulièrement pratique lorsque
le but est d'analyser les valeurs d'une ligne ou d'une colonne de
pixels car celles-ci commence toujours à l'index 1.<br>
Dans cet exemple, la position d'un point dans la ligne serait
exactement égale à l'indice de la valeur du point
dans le vecteur.</p>
<p>Comment extraire une sous-liste d'une liste, la modifier puis
replacer les valeurs au bon endroit ?<br>
En Tcl il faut mémoriser les indices puis,
ultérieurement, ne pas se tromper sur leur rappel.</p>
<p><code>vecteur2 set [ v_1 range $i $j ]<br>
vecteur2 offset $i</code></p>
<p>vecteur2 est le reflet fidèle (indices et valeurs) du
morceau de vecteur.<br>
Après traitement, on peut le remettre en place avec :</p>
<p><code>v_1 index $i $j [ vecteur2 range $i $j ]</code></p>
<p>ou</p>
<p><code>set start [ vecteur2 offset ]<br>
v_1 index $i $j [ vecteur2 range $start end ]</code></p>
<p>Pour connaître l'indice initial d'un vecteur :</p>
<code>set offset [ v_1 offset ]<br>
</code>
<h2>7. Plus ...</h2>
<p>D'autres fonctions particulières (adev, kurtosis,
median, q1, q3, prod, sdev, skew, var) existent mais elles ne
peuvent pas être appelées directement comme min,
max, mean et sum.<br>
La raison en est que les vecteurs disposent d'indices
spéciaux pour min, max , sum et mean permettant d'appeler
directement les valeurs. La documentation n'est pas très
explicite sur la manière de mettre en &#339;uvre les autres
fonctions.<br>
Une solution qui marche est de considérer
qu'elles retournent un vecteur à une seule composante
:</p>
<p><code>resultat expr { adev(v_1) }<br>
set adev $resultat(:) (écart moyen par rapport à la
moyenne)<br>
resultat expr { kurtosis(v_1) }<br>
set kurtosis $resultat(:) (moment d'ordre 4)<br>
resultat expr { median(v_1) }<br>
set median $resultat(:) (valeur médiane)<br>
resultat expr { q1(v_1) }<br>
set q1 $resultat(:) (premier quartile)<br>
resultat expr { q3(v_1) }<br>
set q3 $resultat(:) (troisième quartile)<br>
resultat expr { prod(v_1) }<br>
set prod $resultat(:) (produit des éléments)<br>
resultat expr { sdev(v_1) }<br>
set sdev $resultat(:) (racine carrée de la variance var)<br>
resultat expr { skew(v_1) }<br>
set skew $resultat(:) (moment d'ordre 3)<br>
resultat expr { var(v_1) }<br>
set var $resultat(:) (somme des carrés des écarts
à la moyenne, divisée par le nombre
d'éléments)</code></p>
<p>D'autres fonctions retournent un vecteur de longueur identique au
vecteur initial :</p>
<p><code>resultat expr { norm(v_1) } (vecteur normé entre 0 et 1)<br>
resultat expr { sort(v_1) } (vecteur trié par ordre croissant)</code></p>
<p>Il existe une autre solution pour sort:</p>
<p><code>v_1 sort (tri par ordre croissant)<br>
v_1 sort -reverse (tri par ordre décroissant)<br>
v_1 sort vecteur2 (tri par ordre croissant de v_1 et
réarrangement du vecteur2 pour que les indices restent
cohérents).</code></p>
Le lecteur peut aussi essayer random ou srandom.
<h2>8. Création (2)</h2>
<p>Le vecteur v_1 créé plus haut n'existait que par
son nom et avait une longueur initiale nulle (si si).</p>
<p>La commande :</p>
<p><code>::blt::vector create vecteur(20)</code></p>
<p>créée un vecteur de 20 éléments
initialisés à la valeur 0, l'indice initial
étant 0 et l'indice final 19 (soit 20 valeurs).</p>
<p>Si on veut créer un vecteur dont l'index initial est 1
(0 par défaut) et de longueur 20 on écrit :</p>
<p><code>::blt::vector create vecteur(1:20)</code></p>
<p>Plusieurs modes d'affectation de valeurs sont disponibles :</p>
<p><code>set v_1(:3) 12 (le premier élément ayant pour
indice 1, les éléments de rang 1 à
3 valent 12)<br>
set v_1(4:5) 2 (les éléments de rang 4 à 5 valent
2) <br>
v_1 index 2 0.5 (le second élément vaut maintenant 0.5) <br>
set i 6<br>
set v_1($i) 10 (le sixième élément vaut 10) <br>
set v_1{7:2*$i) 20 (les éléments de rang 7 à rang
12 valent 20)<br>
set v_1(2*$i+1:) 0.34 (les éléments de rang
supérieur 12 valent 0.34)<br>
set v_1(end) 45 (le dernier élément, le vingtième,
vaut 45)<br>
set v_1(++end) 9 (rajoute un élément de valeur 9 au
vecteur)<br>
v_1 delete 11 15 (supprime le 11ème et le 15ème
élément, la longueur du vecteur diminue)<br>
v_1 length 20 (rajoute des 0 pour que le nombre
d'éléments redevienne égal à 20) <br>
v_1 length 5 (supprime tous les éléments de rang &gt; 5)</code></p>
<p>Il est aussi possible de créer un vecteur avec des valeurs
échelonnées :</p>
<p><code>v_1 seq 5 10 1</code></p>
Ce mode créée automatiquement un vecteur dont le premier <code></code>élément
vaut 5 et le dernier 10 avec un
intervalle de 1.
<p>Il est aussi possible de fusionner des vecteurs :</p>
<p><code>v_1 merge v_2 v_3</code></p>
<h2>9. Et destruction</h2>
<p>Contrairement aux variables locales d'une procédure
Tcl, qui sont détruites à la fin de la
procédure, les vecteurs subsistent ce qui conduit à
encombrer inutilement l'espace mémoire et surtout à
des résultats inattendus si on a recours à des
'append' ou si on utilise le non d'un vecteur existant.<br>
Il est donc prudent de déclarer les vecteurs avec l'option
watchunset :</p>
<p><code>::blt::vector create v_1 vecteur2 -watchunset 1</code></p>
<p>Et à la fin de la procédure de tuer les vecteurs:</p>
<p><code>::blt::vector destroy v_1 vecteur2</code></p>
<p>ou à tout le moins, dans les procédures
itératives, à utiliser la commande :</p>
<p><code>v_1 length 0</code></p>
<p>Ce qui a pour effet de supprimer toutes les valeurs
antérieures : Le vecteur est comme au moment de sa
création.</p>
<h2>10. Quelques exemples pratiques</h2>
<h3>10.1 Obtention du minimum ou du maximum d'une liste</h3>
<p>Les fonctions min et max constituent des solutions
alternatives à des fonctions telles que lmin et lmax.<br>
Il est aussi possible d'obtenir la liste des indices des valeurs
égales au minimum :</p>
<p><code>set indexes [ v_1 search $v_1(min) ]</code></p>
<p>Puis de demander le niveau de cette valeur :</p>
<p><code>set min $v_1([ lindex $indexes 0 ])</code></p>
<h3>10.2 Moyenne dynamique d'une série de mesures (dans
une boucle de rafraîchissement)</h3>
<p><code>vecteur_mesure append $nouvelle_mesure<br>
set moyenne $vecteur_mesure(mean)</code></p>
<h3>10.3 Vérification qu'une liste ne comporte que des
valeurs numériques</h3>
<p>Un vecteur n'admet que des valeurs numériques, autrement
il y erreur.</p>
<p><code>set liste_a_analyser [ list 1 2 3 blabla ]<br>
v_1 set $liste_a_analyser</code></p>
<p>Retourne :</p>
<p><code>invalid bareword "blabla" .....</code></p>
<p>On peut mettre à profit cette erreur pour détecter
l'absence d'erreur sans avoir à analyser chaque
élément :</p>
<p><code>if ![ catch { v_1 set $liste_a_analyser } ErrInfo ] {<br>
&nbsp;&nbsp;&nbsp;#-- c'est bien une liste de valeurs numériques<br>
&nbsp;&nbsp;&nbsp;todo ...<br>
} else {<br>
&nbsp;&nbsp;&nbsp;#-- ce n'est une liste de valeurs numériques<br>
}</code></p>
<h3>10.4 Vérification qu'une série de nombres ne
comporte pas de trou</h3>
<p>La somme des termes d'une suite arithmétique est
donnée par la formule
Somme=Nombre_de_termes*(Premier_terme+Dernier_terme)/2.<br>
On pourra donc écrire :</p>
<p><code>v_1 set $liste_de_valeurs<br>
v_1 sort<br>
if { $v_1(sum) == [ expr { [ v_1 length ]*($v_1(0)+$v_1(end))/2 } ] }
{<br>
&nbsp;&nbsp;&nbsp;#-- c'est une série sans trou<br>
&nbsp;&nbsp;&nbsp;todo<br>
}</code></p>
<h3>10.5 Filtrage et repérage de valeurs en dehors d'un
intervalle</h3>
<p><code>set seuil_bas 20<br>
set seuil_haut 50<br>
v_1 expr { v_1 &lt; $seuil_bas || v_1 &gt; $seuil_haut }</code></p>
<p>Toutes les valeurs sont remplacées par des 0 ou des 1
selon que la valeur est dans l'intervalle ou en dehors.<br>
Pour connaître les positions des éléments en
dehors :</p>
<p><code>set indexes [ v_1 search 1 ]</code></p>
<h3>10.6 Calcul des points d'une courbe paramétrique</h3>
<p>Pour calculer 100 points d'une courbe y=a+bx+c*x², on
créée deux vecteurs :</p>
<p><code>set a 1.2<br>
set b 3.5 <br>
set c -1.56<br>
::blt::vector create x y -watchunset 1<br>
x seq 1 100 1<br>
y expr { $a+$b*x+$c*x^2}</code></p>
<p>Et pour afficher le résultat :</p>
<p><code>::plotxy::plot $x(:) $y(:)</code></p>
<h3>10.7 Passage par nom au lieu de valeur</h3>
<p>Pour indiquer à une procédure les valeurs à
traiter,
il suffit de lui donner le nom du vecteur à traiter au
lieu de lui passer la liste des valeurs :</p>
<p><code>proc todo { nom_du_vecteur } {<br>
&nbsp;&nbsp;&nbsp;$nom_du_vecteur expr { log($nom_du_vecteur^3) }<br>
}<br>
todo v_1</code></p>
<p>Les valeurs de v_1 sont modifiées sans qu'il soit
nécessaire de retourner la liste des valeurs.</p>
<p>Une autre application concerne ::blt::graph. Pour créer une
courbe, on écrit :</p>
<p><code>$w element create courbe -xdata -x $liste_des abscisses -ydata
$liste_des ordonnées</code></p>
<p>Avec les vecteurs il suffit d'écrire :</p>
<p><code>$w element create courbe -xdata vecteur_abscisses -ydata
vecteur_ordonnees</code></p>
<p>La modification du contenu des vecteurs modifie automatiquement
le graphique.</p>
<h3>10.8 Interpolation</h3>
<p>Admettons l'existence d'un vecteur n'ayant que deux valeurs
ayant pour abscisses 150 et 151 (pixels).</p>
<p><code>v_1 set [ list 102 98 ]<br>
v_1 offset 150</code></p>
<p>Pour déterminer l'abscisse intermédiaire ayant pour
valeur 100 (le cas est simple = 150.5) :</p>
<p><code>v_1 populate z 9 (création d'un vecteur 'z'
comportant 11 éléments et donc 10 intervalles)<br>
z offset [ expr { [ v_1 offset ]*10 } ] (l'indice de début de z
vaut 10 fois l'indice soit 1500)<br>
set index [ expr { [ z search 99.9 100.1 ]/10 } ] (la
réponse est divisée par 10 et vaut 150.5)</code></p>
<h3>10.9 Calcul matriciel</h3>
<p>Dans le calcul matriciel gsl_mfitmultilin on recourt à
un vecteur w de pondération des valeurs.<br>
Comment obtenir ce vecteur en sachant qu'il doit avoir le
même nombre d'éléments que le vecteur des
mesures :</p>
<p><code>::blt::vector create w([vecteur_mesures length])</code></p>
<p>Le vecteur est créé mais tous ses
éléments valent 0.</p>
<p><code>w expr { w == 0 }</code></p>
<p>Maintenant il sont tous égaux à 1 !<br>
On aurait aussi pu écrire :</p>
<p><code>set w(:) 1</code></p>
</body></html>