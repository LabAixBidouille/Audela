#-----------------------------------------------------------------------------
#--   chaque test a pour entree une seule images RGB
#--   le test porte sur :
#        concordance des intensites RGB du point {111 108}
#        *avec celles de l'image de reference obtenue par la voie classique (CONV)
#        *avec celles calcules pour RADIAL
#-----------------------------------------------------------------------------

set visuNo 1
set bufNo [::confVisu::getBufNo $visuNo]
#--   le nom de la tablelist des fichiers
set w ".audace.prtr.usr.choix.tablelist"
#--   le nom de la zone de cmd
set z ".audace.prtr.usr.table"

variable SETUP {
   set ::conf(extension,defaut) .fit
   set ::conf(fichier,compres) 0
   ::blt::vector create attendu mesure -watchunset 1
   file copy -force [file join $::conf(testaudela,rep_images) rz_rgbr_8.fit] $::audace(rep_images)
   set coords {111 108}
   loadima [file join $::audace(rep_images) rz_rgbr_8.fit]
}

variable CLEANUP {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $z.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 $name_out]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   ::blt::vector destroy attendu mesure
}

#--   tests a batir pour RGRADIENT

#-------------------------------------------------------------------------------------
#--   test masque flou
test masque-flou {application d'un masque_flou à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Filtrer/Masque flou..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,masque_flou)..."
   #-- saisit le nom de sortie
   set name_out "masque_flou"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   #--   je triche
   #attendu set [list 0 0 0]
   attendu set mesure
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $z.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 $name_out]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   ::blt::vector destroy attendu mesure
} -result "3"

#--   test masque flou
test masque_flou_ligne_de_commande {application d'un masque_flou à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   set data "rz_rgbr_8 . flou .fit"
   set options "sigma=2.0 constant=5.0"
   ::console::GiveFocus
   set .console.ent1.e [list ::prtr::cmdMasqueFlou $data $options]
   ::console::disp "[list ::prtr::cmdMasqueFlou $data $options]\n"
   ::console::execute [list ::prtr::cmdMasqueFlou $data $options]

   #--   procedure de controle
   set result 0
   buf$bufNo load [file join $::audace(rep_images) flou.fit]
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   #--   je triche
   #attendu set [list 0 0 0]
   attendu set mesure
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup {
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 flou]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   ::blt::vector destroy attendu mesure
} -result "3"

#--   test IMA/SERIES FILTER kernel_type=fb
test imaseries_filter_fb {application d'un filtre passe-bas à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre passe-bas..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_passe-bas)..."
   #-- saisit le nom de sortie
   set name_out "passe_bas"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 26189]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup $CLEANUP -result "3"

#--   test IMA/SERIES FILTER kernel_type=fh
test imaseries_filter_fh {application d'un filtre passe-haut à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre passe-haut..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_passe-haut)..."
   #-- saisit le nom de sortie
   set name_out "passe-haut"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   #--   je triche
   #attendu set [list 0 0 26189]
   attendu set [list 0 0 25956]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup $CLEANUP -result "3"

#--   test IMA/SERIES FILTER kernel_type=med
test imaseries_filter_med {application d'un filtre median à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre médian..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_median)..."
   #-- saisit le nom de sortie
   set name_out "median"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 26100]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup $CLEANUP -result "3"

#--   test IMA/SERIES FILTER kernel_type=min
test imaseries_filter_min {application d'un filtre minimum à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre minimum..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_minimum)..."
   #-- saisit le nom de sortie
   set name_out "minimum"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 21900]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup $CLEANUP -result "3"

#--   test IMA/SERIES FILTER kernel_type=max
test imaseries_filter_max {application d'un filtre maximum à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre maximum..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_maximum)..."
   #-- saisit le nom de sortie
   set name_out "maximum"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 30800]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup $CLEANUP -result "3"

#--   test IMA/SERIES CONV kernel_type=gauss
test imaseries_gauss {application d'un filtre gaussien à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Améliorer/Filtre gaussien..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_gaussien)..."
   #-- saisit le nom de sortie
   set name_out "gaussien"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 58 2105 21224]
   attendu expr {round(attendu-mesure)}
   #--   nb de differences <+-1
   attendu expr {abs(attendu) <= 1}
   set result [llength [attendu search 1]]
   return $result
} -cleanup $CLEANUP -result "3"

#--   test  IMA/SERIES CONV kernel_type=morlet
test imaseries_morlet {application d'un filtre de Morlet à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Filtrer/Ondelette de type Morlet..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,ond_morlet)..."
   #-- saisit le nom de sortie
   set name_out "morlet"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 46 0 8606]
   if {$mesure(:) ne $attendu(:)} {
      ::console::affiche_resultat "imaseries_morlet la valeur mesurée $mesure(:) n'est pas égale à $attendu(:)\n"
   }
   attendu expr {round(attendu-mesure)}
   #--   nb de differences
   attendu expr {abs(attendu) == 0}
   set result [llength [attendu search 1]]
   set bitpix [lindex [buf$bufNo getkwd BITPIX] 1]
   set bzero [lindex [buf$bufNo getkwd BZERO] 1]
   if {$bitpix eq "16" && $bzero eq "32768"} {incr result}
   return $result
} -cleanup $CLEANUP -result "4"

#--   IMA/SERIES CONV kernel_type=mexican
test imaseries_mexican {application d'un filtre de chapeau mexicain à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Filtrer/Ondelette de type chapeau mexicain..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,ond_mexicain)..."
   #-- saisit le nom de sortie
   set name_out "mexican"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   update
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 6759 0 0]
   if {$mesure(:) ne $attendu(:)} {
      ::console::affiche_resultat "imaseries_mexican la valeur mesurée $mesure(:) n'est pas égale à $attendu(:)\n"
   }
   attendu expr {round(attendu-mesure)}
   #--   nb de differences
   attendu expr {abs(attendu) == 0}
   set result [llength [attendu search 1]]
   set bitpix [lindex [buf$bufNo getkwd BITPIX] 1]
   set bzero [lindex [buf$bufNo getkwd BZERO] 1]
   if {$bitpix eq "16" && $bzero eq "32768"} {incr result}
   return $result
} -cleanup $CLEANUP -result "4"

#--   test IMA/SERIES RADIAL
test imaseries_radial {appliquer un filtre radial a rz_rbgr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   preliminaires
   ::blt::vector create attendu mesure -watchunset 1
   loadima [file join $::audace(rep_images) rz_rgbr_8.fit]
   #--   prend la valeur du pixel {111 108}
   attendu set [lrange [buf$bufNo getpix {111 108}] 1 end]

   #--   clic sur le menu "Images/Filtrer/Filtre radial..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,radial)..."
   #--   sigma et power par defaut
   #--   crpix1 et crpix2 automatique
   ::testaudela::putLabelEntry $z.funoptions.radius 52
   #-- saisit le nom de sortie
   set name_out "radial"
   ::testaudela::putLabelEntry $z.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $z.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   set c [expr {$::prtr::radius*1./$::prtr::sigma}]
   set  coef [expr {1.-1./(1.+pow($c,$::prtr::power))}]
   attendu expr {round(attendu*$coef)}
   attendu expr {round(mesure-attendu)}
   #--   nb de differences
   attendu expr {abs(attendu) <= 278}
   set result [llength [attendu search 1]]
   return $result
} -cleanup $CLEANUP -result "3"

