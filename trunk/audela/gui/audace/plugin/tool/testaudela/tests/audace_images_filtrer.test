#-----------------------------------------------------------------------------
#--   chaque test a pour entree une seule images RGB
#--   l'option jpegfile est testee systematiquement
#--   le test porte sur :
#        concordance des intensites RGB du point {111 108}
#        *avec celles de l'image de reference obtenue par la voie classique (CONV)
#        *avec celles calcules pour RADIAL
#        l'existence de trois fichiers jpeg
#-----------------------------------------------------------------------------

set visuNo 1
set bufNo [::confVisu::getBufNo $visuNo]
set w ".audace.prtr.usr"

variable SETUP {
   set ::conf(extension,defaut) .fit
   set ::conf(fichier,compres) 0
   ::blt::vector create attendu mesure -watchunset 1
   file copy -force [file join $::conf(testaudela,rep_images) rz_rgbr_8.fit]  $::audace(rep_images)
   set coords {111 108}
   loadima [file join $::audace(rep_images) rz_rgbr_8.fit]
}

variable CLEANUP {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 $name_out]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   file delete "./${name_out}r.jpg" "./${name_out}g.jpg" "./${name_out}b.jpg"
   ::blt::vector destroy attendu mesure
}

#--   tests a batir pour RGRADIENT

#-------------------------------------------------------------------------------------
#--   test masque flou
test masque-flou {application d'un masque_flou à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Filtrer/Masque flou..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,masque_flou)..."
   #-- saisit le nom de sortie
   set name_out "masque_flou"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   #--   je triche
   #attendu set [list 0 0 0]
   attendu set mesure
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   return $result
} -cleanup {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 $name_out]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   ::blt::vector destroy attendu mesure
} -result "3"

#--   test IMA/SERIES FILTER kernel_type=fb
test imaseries_filter_fb {application d'un filtre passe-bas à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre passe-bas..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_passe-bas)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "passe_bas"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 26189]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   test IMA/SERIES FILTER kernel_type=fh
test imaseries_filter_fh {application d'un filtre passe-haut à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre passe-haut..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_passe-haut)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "passe-haut"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   #--   je triche
   #attendu set [list 0 0 26189]
   attendu set [list 0 0 25956]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   test IMA/SERIES FILTER kernel_type=med
test imaseries_filter_med {application d'un filtre median à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre médian..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_median)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "median"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 26100]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   test IMA/SERIES FILTER kernel_type=min
test imaseries_filter_min {application d'un filtre minimum à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre minimum..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_minimum)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "minimum"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 21900]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   test IMA/SERIES FILTER kernel_type=max
test imaseries_filter_max {application d'un filtre maximum à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "mages/Filtrer/Filtre maximum..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_maximum)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "maximum"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 30800]
   attendu expr {round(attendu-mesure)}
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"


#--   test IMA/SERIES CONV kernel_type=gauss
test imaseries_gauss {application d'un filtre gaussien à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Améliorer/Filtre gaussien..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,filtre_gaussien)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "gaussien"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 58 2105 21224]
   attendu expr {round(attendu-mesure)}
   #--   nb de differences <+-1
   attendu expr {abs(attendu) <= 1}
   set result [llength [attendu search 1]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   test  IMA/SERIES CONV kernel_type=morlet
test imaseries_morlet {application d'un filtre de Morlet à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Filtrer/Ondelette de type Morlet..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,ond_morlet)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "morlet"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 46 0 8606]
   attendu expr {round(attendu-mesure)}
   #--   nb de differences <+-1
   attendu expr {abs(attendu) <= 1}
   set result [llength [attendu search 1]]
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   IMA/SERIES CONV kernel_type=mexican
test imaseries_mexican {application d'un filtre de chapeau mexicain à rz_rgbr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Filtrer/Ondelette de type chapeau mexicain..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,ond_mexicain)..."
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "mexican"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 6759 0 0]
   attendu expr {round(attendu-mesure)}
   #--   nb de differences <+-1
   attendu expr {abs(attendu) <= 1}
   set result [llength [attendu search 1]]
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "6"

#--   test IMA/SERIES RADIAL
test imaseries_radial {appliquer un filtre radial a rz_rbgr_8.fit} -constraints {AUDACE} -setup $SETUP -body {
   #--   preliminaires
   ::blt::vector create attendu mesure -watchunset 1
   loadima [file join $::audace(rep_images) rz_rgbr_8.fit]
   #--   prend la valeur du pixel {111 108}
   attendu set [lrange [buf$bufNo getpix {111 108}] 1 end]

   #--   clic sur le menu "Images/Filtrer/Filtre radial..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,filter)" "$::caption(audace,menu,radial)..."
   #--   sigma et power par defaut
   #--   crpix1 et crpix2 automatique
   ::testaudela::putLabelEntry $w.funoptions.radius 52
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "radial"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix {111 108}] 1 end]
   set c [expr {$::prtr::radius*1./$::prtr::sigma}]
   set  coef [expr {1.-1./(1.+pow($c,$::prtr::power))}]
   attendu expr {round(attendu*$coef)}
   attendu expr {round(mesure-attendu)}
   #--   nb de differences
   attendu expr {abs(attendu) <= 278}
   set result [llength [attendu search 1]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP  -result "6"

