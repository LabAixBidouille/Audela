set visuNo 1
set bufNo [::confVisu::getBufNo $visuNo]
set w ".audace.prtr.usr"

variable SETUP {
   set ::conf(extension,defaut) .fit
   set ::conf(fichier,compres) 0
   ::blt::vector create attendu mesure temp -watchunset 1
   foreach file {rz_rgbr_8 rz_rgbr_15} {
      file copy -force [file join $::conf(testaudela,rep_images) $file.fit] $::audace(rep_images)
   }
   loadima [file join $::audace(rep_images) rz_rgbr_15.fit]
   set coords [list 110 100]
   attendu set [lrange [buf$bufNo getpix $coords] 1 end]
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
}

variable CLEANUP {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 rz_rgbr_15 ${name_out}1 ${name_out}2]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   file delete "./${name_out}1r.jpg" "./${name_out}1g.jpg" "./${name_out}1b.jpg"
   file delete "./${name_out}2r.jpg" "./${name_out}2g.jpg" "./${name_out}2b.jpg"
   ::blt::vector destroy attendu mesure temp
}

#-----------------------------------------------------------------------------
#--   chaque test ADD SUB DIV PROD a pour entree deux images RGB a traiter
#--   avec une troisième image venant de testaudela (sans recopie)
#--   l'option jpegfile est testee systematiquement
#--   le test porte sur :
#        l'existence de six fichiers jpeg
#        la concordance entre les valeurs au point {1 1} et les valeurs calculees
#-----------------------------------------------------------------------------

variable SETUP2 {
   ::blt::vector create attendu mesure temp -watchunset 1
   foreach file {rz_rgbr_8 rz_rgbr_15 rz_rgbr_30} {
      file copy -force [file join $::conf(testaudela,rep_images) $file.fit] $::audace(rep_images)
   }
   loadima [file join $::audace(rep_images) rz_rgbr_15.fit]
   set coords [list 110 100]
   attendu set [lrange [buf$bufNo getpix $coords] 1 end]
   loadima [file join $::audace(rep_images) rz_rgbr_30.fit]
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   #--   efface rz_rgbr_30.fit apres mesure
   file delete rz_rgbr_30.fit
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
}

#--   IMA/SERIES ADD
test imaseries_add {additionner rz_rgbr_8 et rz_rgbr_15 avec rz_rgbr_30} -constraints {AUDACE} -setup $SETUP2 -body {
   #--   clic sur le menu "Images/Modifier/Additionner une image..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,addition)..."
   #-- selectionne les deux images a traiter
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #-- saisit le nom du fichier a ajouter
   ::testaudela::putLabelEntry $w.funoptions.file "[file join $::conf(testaudela,rep_images) rz_rgbr_30.fit]"
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #-- saisit l'offset
   set offset "500"
   ::testaudela::putLabelEntry $w.ttoptions.offset $offset
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #--   saisit nullpixel
   set nullpixel "0"
   #::testaudela::putLabelEntry $w.ttoptions.nullpixel $nullpixel
   #-- saisit le nom de sortie
   set name_out "ajout"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   attendu expr {attendu+mesure}
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   attendu expr {attendu+$offset}
   temp expr {attendu < $nullpixel}
   set indexes [temp search 1]
   foreach index $indexes {
      set attendu($index) $nullpixel
   }
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats nuls
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "9"

#--   IMA/SERIES SUB
test imaseries_sub {soustraire rz_rgbr_30 de rz_rgbr_8 et de rz_rgbr_15}  -constraints {AUDACE} -setup $SETUP2 -body {
   #--   clic sur le menu "Images/Modifier/Soustraire une image..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,soust)..."
   #-- selectionne les deux images a traiter
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #-- saisit le nom du fichier a soustraire
   ::testaudela::putLabelEntry $w.funoptions.file "[file join $::conf(testaudela,rep_images) rz_rgbr_30.fit]"
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   saisit l'offset
   set offset "-100"
   ::testaudela::putLabelEntry $w.ttoptions.offset $offset
   #--   saisit bitpix
   set bitpix "-32"
   set prtr::bitpix "$bitpix"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "soustraction"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   attendu expr {attendu-mesure}
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   attendu expr {attendu+$offset}
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats nuls
   set result [llength [attendu search 0]]
   if {[lindex [buf$bufNo getkwd BITPIX] 1] eq $bitpix} {incr result}
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "10"

#--   IMA/SERIES DIV
test imaseries_div {division de rz_rgbr_8 et rz_rgbr_15 par rgb_30} -constraints {AUDACE} -setup $SETUP2 -body {
   #--   clic sur le menu "Images/Modifier/Diviser par une image..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,division)..."
   #-- selectionne les deux images a traiter
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #-- saisit le nom du fichier diviseur
   ::testaudela::putLabelEntry $w.funoptions.file "[file join $::conf(testaudela,rep_images) rz_rgbr_30.fit]"
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   saisit la constante multiplicative
   set constante "5"
   ::testaudela::putLabelEntry $w.ttoptions.constant $constante
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "division"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   attendu expr {attendu/mesure}
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   attendu expr {attendu*$constante}
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats concordants
   attendu expr {abs(attendu) <= 1}
   set result [llength [attendu search 1]]
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "9"

#--   IMA/SERIES PROD
test imaseries_prod {produit de rz_rgbr_8 et rz_rgbr_15 par rgb_30} -constraints {AUDACE} -setup {
   ::blt::vector create attendu mesure temp -watchunset 1
   foreach file {rz_rgbr_8 rz_rgbr_15 rz_rgbr_30} {
      file copy -force [file join $::conf(testaudela,rep_images) $file.fit] $::audace(rep_images)
   }
   loadima [file join $::audace(rep_images) rz_rgbr_15.fit]
   attendu set [lrange [buf$bufNo getpix $coords] 1 end]
   loadima [file join $::audace(rep_images) rz_rgbr_30.fit]
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   set constante "10000"
   attendu expr {attendu*mesure/$constante}
   file delete rz_rgbr_30.fit
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
} -body {
   #--   clic sur le menu "Images/Modifier/Multiplier par une image ..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,multipli)..."
   #-- selectionne les deux images a traiter
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #-- saisit le nom du fichier multiplicateur
   ::testaudela::putLabelEntry $w.funoptions.file "[file join $::conf(testaudela,rep_images) rz_rgbr_30.fit]"
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   saisit la constante multiplicative
   ::testaudela::putLabelEntry $w.ttoptions.constant $constante
   #--   saisit bitpix
   set bitpix "-64"
   ::testaudela::clicCombobox $w.ttoptions.combo.bitpix $bitpix
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "produit"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats nuls
   set result [llength [attendu search 0]]
   if {[lindex [buf$bufNo getkwd BITPIX] 1] eq "$bitpix"} {incr result}
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "10"

#-----------------------------------------------------------------------------
#--   chaque test OFFSET MULT LOG  a pour entree deux images RGB a traiter
#--   l'option jpegfile est testee systematiquement
#--   le test porte sur :
#        l'existence de six fichiers jpeg
#        la concordance entre les valeurs au point {110 100} et les valeurs calculees
#-----------------------------------------------------------------------------
#--   IMA/SERIES OFFSET
test imaseries_offset {ajouter une constante a rz_rgbr_8 rz_rgbr_15} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Modifier/Ajouter une constante..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,offset)..."
   #--   selectionne rz_rgbr_8 rz_rgbr_15
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #-- saisit l'offset
   set offset 1000
   ::testaudela::putLabelEntry $w.funoptions.offset $offset
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "offset"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   attendu expr {attendu+$offset}
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats nuls
   set result [llength [attendu search 0]]
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "9"

#--   IMA/SERIES MULT
test imaseries_mult {multiplier rz_rgbr_8 rz_rgbr_15 par constante} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Modifier/Ajouter une constante..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,mult_cte)..."
   #--   selectionne rz_rgbr_8 rz_rgbr_15
   foreach img {rz_rgbr_8 rz_rgbr_15} {
     set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #-- saisit la constante (valeur entiere pour eviter les pb d'arrondi)
   set constante "0.5"
   ::testaudela::putLabelEntry $w.funoptions.constant $constante
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   saisit bitpix
   set bitpix "32"
   set prtr::bitpix $bitpix
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "mult"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   attendu expr {attendu*$constante}
   temp expr {attendu < $nullpixel}
   set indexes [temp search 1]
   foreach index $indexes {
      set attendu($index) $nullpixel
   }
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   attendu expr {attendu <-1 || attendu > 1}
   #--   compte le nombre de resultats nuls
   set result [llength [attendu search 0]]
   if {[lindex [buf$bufNo getkwd BITPIX] 1] eq "$bitpix"} {incr result}
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   #--   saisit bitpix
   buf$bufNo bitpix short
   return $result
} -cleanup $CLEANUP -result "10"

#--   IMA/SERIES LOG
test imaseries_log {appliquer logarithme a rz_rgbr_8 rz_rgbr_15} -constraints {AUDACE} -setup $SETUP -body {
   #--   clic sur le menu "Images/Modifier/Logarithme..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,log)..."
   #--   selectionne rz_rgbr_8 rz_rgbr_15
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #--   saisit la constante
   set coef 20
   ::testaudela::putLabelEntry $w.funoptions.coef $coef
   #--   saisit l'offset_log
   set offsetlog 10
   ::testaudela::putLabelEntry $w.funoptions.offsetlog $offsetlog
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   saisit bitpix
   set bitpix "16"
   set prtr::bitpix $bitpix
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "log"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   charge le resultat obtenu
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   attendu expr {log10(attendu-$offsetlog)*$coef}
   temp expr {attendu < $nullpixel}
   set indexes [temp search 1]
   foreach index $indexes {
      set attendu($index) $nullpixel
   }
   #--   calcule le ratio
   attendu expr {round(mesure/attendu)}
   #--   compte le nombre de resultats nuls (bizarre bizarre)
   set result [llength [attendu search 363]]
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "9"

#--   IMA/SERIES NORMGAIN
test imaseries_normgain {normaliser le gain de rz_rgbr_8 rz_rgbr_15} -constraints {AUDACE} -setup {
   ::blt::vector create attendu mesure moyenne temp -watchunset 1
   foreach file {rz_rgbr_8 rz_rgbr_15} {
      file copy -force [file join $::conf(testaudela,rep_images) $file.fit] $::audace(rep_images)
   }
   #--   decompose rz_rgbr_15 en plans couleurs
   set nom_sans_extension [file join $::audace(rep_images) rz_rgbr_15]
   ::conv2::Do_rgb2r+g+b $nom_sans_extension.fit $nom_sans_extension
   foreach color {r g b} {
      loadima [file join $::audace(rep_images) rz_rgbr_15$color.fit]
      buf$bufNo stat
      moyenne append [ lindex [buf$bufNo getkwd MEAN] 1]
   }
   loadima [file join $::audace(rep_images) rz_rgbr_15.fit]
   attendu set [lrange [buf$bufNo getpix $coords] 1 end]
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
} -body {
   #--   clic sur le menu "Images/Modifier/Normaliser l'éclairement..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,ngain)..."
  #--   selectionne rz_rgbr_8 rz_rgbr_15
   foreach img {rz_rgbr_8 rz_rgbr_15} {
      set k [lsearch [$w.choix getcolumns 1] $img]
      ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   }
   #--   saisit la valeur de normalisation du gain
   set normgain_value "5000"
   ::testaudela::putLabelEntry $w.funoptions.normgain_value $normgain_value
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "norm"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   #--   calcule le resultat attendu
   attendu expr {attendu*$normgain_value/moyenne}
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats nuls
   attendu expr {abs(attendu) <= 1}
   set result [llength [attendu search 1]]
   foreach file [list ${name_out}1r.jpg ${name_out}1g.jpg ${name_out}1b.jpg \
      ${name_out}2r.jpg ${name_out}2g.jpg ${name_out}2b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup $CLEANUP -result "9"

#-----------------------------------------------------------------------------
#--   chaque test NORMOFFSET a pour entree une images RGB
#--   l'option jpegfile est testee systematiquement
#--   le test porte sur :
#        l'existence de trois fichiers jpeg
#        la concordance entre les valeurs au point {110 100} et
#        les valeurs obtenues dans une image de reference
#-----------------------------------------------------------------------------
#--   IMA/SERIES NORMOFFSET
test imaseries_normoffset {normaliser le fond du ciel de rz_rgbr_8} -constraints {AUDACE} -setup {
   ::blt::vector create attendu mesure -watchunset 1
   file copy -force [file join $::conf(testaudela,rep_images) rz_rgbr_8.fit] $::audace(rep_images)
} -body {
   #--   clic sur le menu "Images/Modifier/Normaliser le fond du ciel..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,noffset)..."
   #--   selectionne rz_rgbr_8
   set k [lsearch [$w.choix getcolumns 1] rz_rgbr_8]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   saisit la valeur de normalisation
   set normoffset_value "100"
   ::testaudela::putLabelEntry $w.funoptions.normoffset_value $normoffset_value
   #--   selectionne l'option "Options"
   ::testaudela::clicCheckButton $w.ttoptions.che "1"
   #--   selectionne l'option "jpegfile"
   ::testaudela::clicCheckButton $w.ttoptions.jpegfile "1"
   #-- saisit le nom de sortie
   set name_out "noffset"
   ::testaudela::putLabelEntry $w.sortie.out "$name_out"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   mesure set [lrange [buf$bufNo getpix $coords] 1 end]
   #--   valeurs mesurees sur une image obtenue par la voie classique
   attendu set [list 0 0 28737]
   #--   calcule la difference
   attendu expr {round(attendu-mesure)}
   #--   compte le nombre de resultats concordants
   attendu expr {abs(attendu) <=1}
   set result [llength [attendu search 1]]
   foreach file [list ${name_out}r.jpg ${name_out}g.jpg ${name_out}b.jpg] {
      if {[file exists $file]} {incr result}
   }
   return $result
} -cleanup {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 noffset_rgbr_8 noffset]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   file delete "./${name_out}r.jpg" "./${name_out}g.jpg" "./${name_out}b.jpg"
   ::blt::vector destroy attendu mesure
} -result "6"

#-----------------------------------------------------------------------------
#--   chaque test clip_min_clip_max a pour entree une images RGB
#--   le test porte sur :
#        la concordance entre les valeurs aux points {110 100} et {227 108} et
#        les valeurs calculees
#-----------------------------------------------------------------------------
#--   clip_min_clip_max
#     concordance des intensites R G B constatees avec celles calculees
test ecreter_les_extremes {ecreter rz_rgbr_8} -constraints {AUDACE} -setup {
   ::blt::vector create attendu1 attendu2 mesure1 mesure2 -watchunset 1
   file copy -force [file join $::conf(testaudela,rep_images) rz_rgbr_8.fit] $::audace(rep_images)
   loadima [file join $::audace(rep_images) rz_rgbr_8.fit]
   set coord1 [list 110 100]
   set coord2 [list 227 108]
   attendu1 set [lrange [buf$bufNo getpix $coord1] 1 end]
   attendu2 set [lrange [buf$bufNo getpix $coord2] 1 end]
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
} -body {
   #--   clic sur le menu "Images/Modifier/Ecrêter les extrêmes..."
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,arithm)" "$::caption(audace,menu,clip)..."
   #--   selectionne rz_rgbr_8
   set k [lsearch [$w.choix getcolumns 1] rz_rgbr_8]
  ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   saisit la valeur du minimum
   set mini "350"
   ::testaudela::putLabelEntry $w.funoptions.mini $mini
   #--   saisit la valeur du maximum
   set maxi "3000"
   ::testaudela::putLabelEntry $w.funoptions.maxi $maxi
   #-- saisit le nom de sortie
   set name_out "clip"
   ::testaudela::putLabelEntry $w.sortie.out $name_out
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   mesure1 set [lrange [buf$bufNo getpix $coord1] 1 end]
   mesure2 set [lrange [buf$bufNo getpix $coord2] 1 end]
   for {set i 0} {$i < 3} {incr i} {
      if {$attendu1($i) <= $mini} {set attendu1($i) $mini}
      if {$attendu2($i) <= $mini} {set attendu2($i) $mini}
      if {$attendu1($i) >= $maxi} {set attendu1($i) $maxi}
      if {$attendu2($i) >= $maxi} {set attendu2($i) $maxi}
   }
   #--   calcule la difference
   attendu1 expr {round(attendu1-mesure1)}
   #--   compte le nombre de resultats nuls
   incr result [llength [attendu1 search 0]]
   #--   calcule la difference
   attendu2 expr {round(attendu2-mesure2)}
   #--   compte le nombre de resultats nuls
   incr result [llength [attendu2 search 0]]
   return $result
} -cleanup {
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   #---  efface l'image
   ::confVisu::deleteImage $visuNo
   set liste [list rz_rgbr_8 clip]
   ttscript2 "IMA/SERIES . \"$liste\" * * .fit . . . . DELETE"
   ::blt::vector destroy attendu1 attendu2 mesure1 mesure2
} -result "6"

