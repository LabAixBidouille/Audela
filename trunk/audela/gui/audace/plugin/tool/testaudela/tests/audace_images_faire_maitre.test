set visuNo 1
set bufNo [::confVisu::getBufNo $visuNo]
set w ".audace.prtr.usr"
#--   memorise le format, l'extension, audace(rep_images)
set parInitial [list $::conf(extension,defaut) $::conf(fichier,compres) $::audace(rep_images)]

#--   tous les tests sont effectues sur des fichiers compresses pour gagner de la place
#--   le chebutton de compression est coché
#--   les offset, dark, flat et images brutes sont dans des repertoires separes
#--   les images produites sont stockees dans un fichier test_result

#-------------------------------------------------------------------------------
#--   Nature du test audace_pretrait_init :
#     -memorisation des réglages extension et compression
#     -création des répertoires
#     -transfert des images de test
#     -defintion des coordonnes de la mesure
test audace_pretrait_init {initialisation} -constraints {AUDACE} -setup {
   #--   configure l'extension et la compression
   set ::conf(extension,defaut) ".fit"
   set ::conf(fichier,compres) 1

   #--   fixe le point de mesure
   set coords [list 10 20]

   #--   creation des repertoires et transfert des images
   foreach rep [list offset dark flat] {
      #--   cree les repertoires test_offset, test_dark, test_flat dans rep_images
      set dir [file join $::audace(rep_images) test_$rep]
      file mkdir $dir
      for {set i 1} {$i <=3} {incr i} {
         set fileName "rz_${rep}$i.fit.gz"
         file copy -force [file join $::conf(testaudela,rep_images) $fileName] $dir
      }

      #--   initialise les vecteurs
      ::blt::vector create vector$rep -watchunset 1
      foreach file [list rz_${rep}1 rz_${rep}2 rz_${rep}3] {
         loadima [file join $dir $file.fit.gz]
         vector$rep append [lrange [buf$bufNo getpix $coords] 1 end]
      }
   }
   ::blt::vector create mediane -watchunset 1
   #--   cree le repertoire test_brut
   set dir [file join [lindex $parInitial end] test_brut]
   file mkdir $dir

   #--   recopie l'image rz_cfa_rgbr_8.fit.gz dans $::audace(rep_images)
   file copy -force [file join $::conf(testaudela,rep_images) rz_cfa_rgbr_8.fit.gz] $dir

   #--   cree le repertoire test_result
   set dirOut [file join [lindex $parInitial end] test_result]
   file mkdir $dirOut
}

#-------------------------------------------------------------------------------
test audace_pretrait_offset {faire un offset} -constraints {AUDACE} -setup {} -body {
   #--   selectionne le repertoire des offset
   set ::audace(rep_images) [file join [lindex $parInitial end] test_offset]
   #--- clic sur le menu faire un offset
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,maitre)" "$::caption(audace,menu,faire_offset)..."
   #--   selectionne rz_offset1
   set k [lsearch [$w.choix getcolumns 1] "rz_offset1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   saisit le nom de sortie
   set nom_offset [file join $dirOut offset]
   ::testaudela::putLabelEntry $w.sortie.out $nom_offset
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   mediane expr {median(vectoroffset)}
   set attenduOffset $mediane(0)
   #--   calcule la difference
   set difference [expr {$attenduOffset-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "offset OK\n\n"
      incr result
   }
   return $result
} -cleanup {
   #---  supprime le repertoire
   file delete -force [file join [lindex $parInitial end] test_offset]
   #--   vide la visu
   ::confVisu::clear $visuNo
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   ::blt::vector destroy vectoroffset
} -result "1"

#-------------------------------------------------------------------------------
test audace_pretrait_dark {faire un dark sans et avec offset} -constraints {AUDACE} -setup {} -body {
   #--   selectionne le repertoire des dark
   set ::audace(rep_images) [file join [lindex $parInitial end] test_dark]
   set ::conf(fichier,compres) 1
   #--- clic sur le menu faire un dark
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,maitre)" "$::caption(audace,menu,faire_dark)..."
   #--   test sans offset----------------------------------------
   #--   selectionne rz_dark1
   set k [lsearch [$w.choix getcolumns 1] "rz_dark1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   saisit le nom de sortie
   set nom_dark [file join $dirOut dark]
   ::testaudela::putLabelEntry $w.sortie.out $nom_dark
   #--   decoche la compression
   ::testaudela::clicCheckButton $w.affiche.compress "0"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle sur le dark sans offset
   set result 0
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   mediane expr {median(vectordark)}
   set attenduDark $mediane(0)
   #--   calcule la difference
   set difference [expr {$attenduDark-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "dark sans offset OK\n\n"
      incr result
   }
   #--   supprime l'image non compressee
   file delete -force $nom_dark.fit

   #--   test avec offset----------------------------------------
   #--- vide la visu
   ::confVisu::clear $visuNo
   #--   reselectionne dark
   set k [lsearch [$w.choix getcolumns 1] "rz_dark1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   saisit le nom de l'offset
   set nom_bias [file join $dirOut offset.fit.gz]
   ::testaudela::putLabelEntry $w.funoptions.bias $nom_bias
   #--   saisit le nom de sortie
   set nom_dark [file join $dirOut dark]
   ::testaudela::putLabelEntry $w.sortie.out $nom_dark
   #--   coche la compression
   ::testaudela::clicCheckButton $w.affiche.compress "1"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle avec offset
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   mediane expr {median(vectordark-$attenduOffset)}
   set attenduDark $mediane(0)
   #--   calcule la difference
   set difference [expr {$attenduDark -$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "dark avec offset OK\n\n"
      incr result
   }
   return $result
} -cleanup {
   #---  supprime le repertoire
   file delete -force [file join [lindex $parInitial end] test_dark]
   #--   vide la visu
   ::confVisu::clear $visuNo
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   ::blt::vector destroy vectordark
} -result "2"

#-------------------------------------------------------------------------------
test audace_pretrait_flat {faire un flat sans/avec offset sans/avec dark} -constraints {AUDACE} -setup {} -body {
   #--- clic sur le menu faire un PLU
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,maitre)" "$::caption(audace,menu,faire_flat_field)..."
   set ::conf(fichier,compres) 1
   #--   selectionne le repertoire des dark
   set ::audace(rep_images) [file join [lindex $parInitial end] test_flat]

   #--   test sans offset ni dark----------------------------------------
   #--   selectionne rz_flat1
   set k [lsearch [$w.choix getcolumns 1] "rz_flat1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   saisit le nom de sortie
   set nom_flat [file join $dirOut flat]
   ::testaudela::putLabelEntry $w.sortie.out $nom_flat
   #--   decoche la compression
   ::testaudela::clicCheckButton $w.affiche.compress "0"
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   mediane expr {median(vectorflat)}
   set attenduFlat $mediane(0)
   #--   calcule la difference
   set difference [expr {$attenduFlat-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "flat sans offset ni dark OK\n\n"
      incr result
   }

   #--   test avec offset sans dark----------------------------------------
   #--- vide la visu
   ::confVisu::clear $visuNo
   #--   reselectionne flat1
   set k [lsearch [$w.choix getcolumns 1] "rz_flat1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   saisit le nom de l'offset
   ::testaudela::putLabelEntry $w.funoptions.bias $nom_offset.fit.gz
   #--   saisit la valeur de normoffset_value
   ::testaudela::putLabelEntry $w.funoptions.normoffset_value "0"
   #--   saisit le nom de sortie
   ::testaudela::putLabelEntry $w.sortie.out $nom_flat
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   set attenduFlat 0
   #--   calcule la difference
   set difference [expr {$attenduFlat-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "flat avec offset sans dark OK\n\n"
      incr result
   }

   #--   test sans offset avec dark----------------------------------------
   #--- vide la visu
   ::confVisu::clear $visuNo
   #--   reselectionne flat1
   set k [lsearch [$w.choix getcolumns 1] "rz_flat1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   vide le nom de l'offset
   ::testaudela::putLabelEntry $w.funoptions.bias ""
   #--   saisit le nom du dark
   set nom_dark [file join $dirOut dark]
   ::testaudela::putLabelEntry $w.funoptions.dark $nom_dark.fit.gz
   #--   saisit le nom de sortie
   ::testaudela::putLabelEntry $w.sortie.out $nom_flat
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   set attenduFlat "25.0"
   #--   calcule la difference
   set difference [expr {$attenduFlat-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "flat sans offset avec dark OK\n\n"
      incr result
   }

   #--   supprime l'image cree
   file delete -force $nom_flat.fit

   #--   test avec offset et dark----------------------------------------
   #--- vide la visu
   ::confVisu::clear $visuNo
   #--   reselectionne flat1
   set k [lsearch [$w.choix getcolumns 1] "rz_flat1"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   selectionne l'option "Tout sélectionner"
   ::testaudela::clicCheckButton $w.all.select "1"
   #--   saisit le nom de l'offset
   ::testaudela::putLabelEntry $w.funoptions.bias $nom_offset.fit.gz
   #--   coche la compression
   ::testaudela::clicCheckButton $w.affiche.compress "1"
   #--   saisit le nom de sortie
   ::testaudela::putLabelEntry $w.sortie.out $nom_flat
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   set attenduFlat "75.0"
   set difference [expr {$attenduFlat-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "flat avec offset et dark OK\n\n"
      incr result
   }
   return $result
} -cleanup {
   #---  supprime le repertoire
   file delete -force [file join [lindex $parInitial end] test_flat]
   #--   vide la visu
   ::confVisu::clear $visuNo
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   ::blt::vector destroy mediane vectorflat
} -result "4"

#-------------------------------------------------------------------------------
test audace_pretrait_pretraitee {faire une image avec/sans optimisation du noir} -constraints {AUDACE} -setup {} -body {
   set ::conf(fichier,compres) 1
   #--   selectionne le repertoire des images brutes
   set ::audace(rep_images) [file join [lindex $parInitial end] test_brut]
   buf$bufNo load [file join [lindex $parInitial end] test_brut rz_cfa_rgbr_8.fit.gz]
   set brut [lrange [buf$bufNo getpix $coords] 1 end]
   #--- clic sur le menu faire une image calibree
   ::testaudela::clicMenu $visuNo "$::caption(audace,menu,images)" "$::caption(audace,menu,pretraitee)"
   #--   avec optimisation du noir
   #--   selectionne rz_cfa_rgbr_8
   set k [lsearch [$w.choix getcolumns 1] "rz_cfa_rgbr_8"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
   #--   saisit le nom de l'offset
   ::testaudela::putLabelEntry $w.funoptions.bias $nom_offset.fit.gz
   #--   saisit le nom de du dark
   ::testaudela::putLabelEntry $w.funoptions.dark $nom_dark.fit.gz
   #--   selectionne l'option "opt_black"
   ::testaudela::clicCheckButton $w.funoptions.opt_black "1"
   #--   saisit le nom du flat
   set nom_flat [file join $dirOut flat]
   ::testaudela::putLabelEntry $w.funoptions.flat $nom_flat.fit.gz
   #--   attente pour que la constante soit mise a jour
   ::testaudela::putLabelEntry $w.funoptions.constant 5000
   #--   decoche la compression
   ::testaudela::clicCheckButton $w.affiche.compress "0"
   #--   saisit le nom de sortie
   set nom_cal [file join $dirOut pretraitee]
   ::testaudela::putLabelEntry $w.sortie.out $nom_cal
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   set result 0
   #--   valeur obtenue par un traitement pas à pas
   set attendu "33267"
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   #--   calcule la difference
   set difference [expr {$attendu-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "prétraitement avec optimisation du noir OK\n\n"
      incr result
   }
   #--   supprime l'image cree
   file delete -force $nom_cal.fit
   #--   sans optimisation du noir

   #--   selectionne rz_cfa_rgbr_8
   set k [lsearch [$w.choix getcolumns 1] "rz_cfa_rgbr_8"]
   ::testaudela::clicCheckButton [$w.choix windowpath $k,0] 1
  #--   deselectionne l'option "opt_black"
   ::testaudela::clicCheckButton $w.funoptions.opt_black "0"
   #--   coche la compression
   ::testaudela::clicCheckButton $w.affiche.compress "1"
   ::testaudela::putLabelEntry $w.funoptions.constant 1000
   #--   saisit le nom de sortie
   ::testaudela::putLabelEntry $w.sortie.out $nom_cal
   #--   clic sur le bouton Appliquer
   ::testaudela::clicButton $w.cmd.appliquer

   #--   procedure de controle
   #--   valeur obtenue par un traitement pas à pas
   set attendu 8000
   #--   cherche la valeur obtenue
   set mesure [lrange [buf$bufNo getpix $coords] 1 end]
   #--   calcule la difference
   set difference [expr {$attendu-$mesure}]
   if {$difference eq "0.0"} {
      ::console::affiche_resultat "prétraitement sans optimisation du noir OK\n\n"
      incr result
   }
   return $result
} -cleanup {
   #--   retablit les parametres initiaux
   lassign $parInitial ::conf(extension,defaut) ::conf(fichier,compres) ::audace(rep_images)
   #--   vide la visu
   ::confVisu::clear $visuNo
   #--   clic sur le bouton Fermer
   ::testaudela::clicButton $w.cmd.fermer
   #---  supprime le repertoire
   file delete -force [file join [lindex $parInitial end] test_brut]
   #--- supprime le repertoire des resultats
   file delete -force $dirOut
} -result "2"

