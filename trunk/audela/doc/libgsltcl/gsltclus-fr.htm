<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>



<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Librairie GSL : Manuel de l'utilisateur</title></head><body>
<p class="date">Date de mise à jour : 21 août 2013</p>
<h1>LibGSLTcl </h1>
<h1>Librairie d'extension Tcl pour le calcul scientifique </h1>
<h1> 1. Introduction</h1>
<p>La librairie libgsltcl ajoute des fonctions de calculs scientifique
à un interpréteur Tcl. Cette librairie utilise la Gnu Scientific
Library :</p>
<p><a href="http://sources.redhat.com/gsl/">http://sources.redhat.com/gsl/</a></p>
<p>Le principe général de libgsltcl est de transformer des listes Tcl
en vecteurs C qui sont soumis au calcul par les fonctions C de GSL. En
retour, libgsltcl, fourni le résultat sous forme d'une liste à
l'interpréteur Tcl. Par exemple, pour calculer la transformée de
Fourier du vecteur de valeurs 1; 2; 5; 7; 3; 1; -7; -4; -1; 0; on
écrira :</p>
<code>set vec {1 2 5 7 3 1 -7 -4 -1 0}</code> <br />
<code>gsl_fft $vec</code>
<p>En retour, la fonction renvoie deux listes qui correspondent aux
composantes réelles et imaginaires du résultat de la transformée de
Fourier.</p>
<p>Les vecteurs sont de type "liste Tcl" (ListVector). Les matrices
sont définies comme des "listes de listes Tcl" (ListMatrix). Par
exemple, la matrice :</p>
<code> [ 2 6 7 ]</code> <br />
<code>a = [ 1 2 3 ]</code> <br />
<code> [ 1 9 8 ]</code>
<p>sera codée de la façon suivante en Tcl :</p>
<p><code>set a { {2 6 7} {1 2 3} {1 9 8} }</code></p>
<p>On vérifiera que l'élément de la 1ère ligne et 3ième colonne vaut 7 :</p>
<p><code>gsl_mindex $a 1 3</code></p>
<p>Dans toutes les fonctions, l'ordre des indices d'une matrice est toujours de la forme <em>ligne</em> puis <em>colonne</em>.</p>
<h1> 2. Manuel de l'utilisateur</h1>
<h2> 2.1. Manipulation des données</h2>
<h3> <a name="gsl_mlength" id="gsl_mlength" />gsl_mlength ListMatrix</h3>
<p>Retourne une liste de deux éléments dont les valeurs sont les dimensions (nlignes ncolonnes) de la matrice ListMatrix.</p>
<h3> <a name="gsl_mindex" id="gsl_mindex" />gsl_mindex ListMatrix IndexLig IndexCol</h3>
<p>Retourne la valeur de l'élément situé à la position (IndexLig IndexCol) de la matrice ListMatrix.</p>
<h3> <a name="gsl_mreplace" id="gsl_mreplace" />gsl_mreplace ListMatrix IndexLig IndexCol Value</h3>
<p>Remplace la valeur de l'élément situé à la position (IndexLig IndexCol) de la matrice ListMatrix par Value</p>
<h2> 2.2. Algèbre matricielle</h2>
<h3> <a name="gsl_mtranspose" id="gsl_mtranspose" />gsl_mtranspose ListMatrix</h3>
<p>Retourne la matrice résultat de la transposée de la matrice ListMatrix</p>
<h3> <a name="gsl_madd" id="gsl_madd" />gsl_madd ListMatrixA ListMatrixB</h3>
<p>Retourne la matrice résultat de la somme algébrique de ListMatrixA et ListMatrixB</p>
<h3> <a name="gsl_msub" id="gsl_msub" />gsl_msub ListMatrixA ListMatrixB</h3>
<p>Retourne la matrice résultat de la différence algébrique de ListMatrixA et ListMatrixB</p>
<h3> <a name="gsl_mmult" id="gsl_mmult" />gsl_mmult ListMatrixA ListMatrixB</h3>
<p>Retourne la matrice résultat de la multiplication algébrique de ListMatrixA par ListMatrixB</p>
<h3> <a name="gsl_mdet" id="gsl_mdet" />gsl_mdet ListMatrix</h3>
<p>Retourne la valeur du déterminant de la matrice ListMatrix</p>
<h3> <a name="gsl_minv" id="gsl_minv" />gsl_minv ListMatrix</h3>
<p>Retourne la matrice résultat de l'inverse de la matrice ListMatrix</p>
<h3> <a name="gsl_meigsym" id="gsl_meigsym" />gsl_meigsym ListMatrix</h3>
<p>Retourne le vecteur des valeurs propres et la matrice des vecteurs propres de la matrice ListMatrix. Par exemple :</p>
<code>set a { {2 6 7} {1 6 3} {7 3 8} }</code> <br />
<code>gsl_meigsym $a</code>
<p>Retourne:</p>
<p>{13.816095 4.882125 -2.698219} {{0.497108 0.285358 0.819423} {0.365628 -0.925327 0.100428} {0.786892 0.249681 -0.564323}}</p>
<h2> 2.3. Calculs d'algèbre linéaire</h2>
<h3> <a name="gsl_msolvelin" id="gsl_msolvelin" />gsl_msolvelin ListMatrixA ListVectorB</h3>
<p>Cette fonction permet de trouver les valeurs du vecteur inconnu X
définit par B = A*X, où B est un vecteur et A est une matrice. Le
vecteur X comporte p lignes (=p inconnues), et B comporte n lignes (=n
observations). La matrice A est de dimensions n*p.</p>
<h3> <a name="gsl_mfitmultilin" id="gsl_mfitmultilin" />gsl_mfitmultilin ListVectorY ListMatrixX ListVectorW</h3>
<p>Cette fonction permet la résolution d'un système multilinéaire de type y=X*c où :</p>
<p>y est un vecteur de n observations (paramètre ListVectorY)</p>
<p>X est une matrice n*p associée au modèle physique à résoudre (paramètre ListMatrixX)</p>
<p>c est le vecteur des p inconnues à déterminer</p>
<p>La condition n&gt;p permet la détermination du vecteur c par une
méthode d'ajustement aux moindre carrés. Le meilleur ajustement est
recherché en minimisant le chi2 par la formule suivante :</p>
<p>chi2 = (y-X*c)<sup>T</sup>*w*(y-X*c)</p>
<p>où w est une matrice n*n dont les éléments de la diagonale sont
associés aux variances des mesures des n observations. Si l'on ne
souhaite pas pondérer les diverses mesures du vecteur y, alors w sera
une matrice unitaire. Les valeurs des éléments de la diagonale de la
matrice w sont remplies avec les valeurs du vecteur W (paramètre
ListVectorW)</p>
<p>En retour, on a une liste de trois éléments :</p>
<p>1er élément : vecteur des solutions c.</p>
<p>2ème élément : chi2 de l'ajustement.</p>
<p>3ème élément : matrice des covariances.</p>
<p>Exemple : On dispose de n mesures d'un signal (x,y), que l'on souhaite ajuster par une loi parabolique :</p>
<p>y = c(1) + c(2) * x + c(3) *x*x</p>
<p>Le système comporte donc p=3 inconnues à déterminer: c(1), c(2) et c(3). La forme matricielle du système y=X*c, s'écrit :</p>
<code>[ y(1) ] [ 1 x(1) x(1)*x(1) ]</code> <br />
<code>[ y(2) ] [ 1 x(2) x(2)*x(2) ]</code> <br />
<code>... ... [ c(1) ]</code> <br />
<code>[ y(i) ] = [ 1 x(i) x(i)*x(i) ] * [ c(2) ]</code> <br />
<code>... ... [ c(3) ]</code> <br />
<code>[ y(n) ] [ 1 x(n) x(n)*x(n) ]</code>
<p>Application numérique :</p>
<p><code># - definition des mesures</code> <br />
  <code>set x {0 1 2 3 4 5 }</code> <br />
  <code>set y {0.12 0.95 3.78 9.21 15.43 25.83 }</code> <br />
  <code>set w {1 1 1 1 1 1 }</code> <br />
  <code># - calcul de la matrice X</code> <br />
  <code>set n [llength $x]</code> <br />
  <code>set X ""</code> <br />
  <code>for {set i 0} {$i&lt;$n} {incr i} {</code> <br />
  <code> set xi [lindex $x $i]</code> <br />
  <code> set ligne_i 1</code> <br />
  <code> lappend ligne_i $xi</code> <br />
  <code> lappend ligne_i [expr $xi*$xi]</code> <br />
  <code> lappend X $ligne_i</code> <br />
  <code>}</code> <br />
  <code># - calcul de l'ajustement</code> <br />
  <code>set result [gsl_mfitmultilin $y $X $w]</code> <br />
  <code># - extrait le resultat</code> <br />
  <code>set c [lindex $result 0]</code> <br />
  <code>set chi2 [lindex $result 1]</code> <br />
  <code>set covar [lindex $result 2]</code></p>
<p>La variable result vaut :</p>
<p>{0.202500 -0.413893 1.096607} 0.674041 {{0.821429 -0.589286
0.089286} {-0.589286 0.726786 -0.133929} {0.089286 -0.133929 0.026786}}</p>
<p>L'interprétation du résultat est que le meilleur ajustement est
obtenu par la fonction : y = 0.202500 - 0.413893*x + 1.096607*x*x</p>
<h2> 2.4. Transformées de Fourier</h2>
<h3> <a name="gsl_fft" id="gsl_fft" />gsl_fft ListVector ?ListVectorTime?</h3>
<p>Effectue la transformée de Fourier du vecteur ListVector. En retour, on a une liste de deux éléments:</p>
<p>1er élément : vecteur des amplitudes réelles</p>
<p>2ème élément : vecteur des amplitudes imaginaires</p>
<p>Si l'on a effectué le calcul avec le vecteur ListVectorTime
correspondant aux instants de mesure chaque point de ListVector, alors
un troisième élément est retourné par la fonction gsl_fft. C'est le
vecteur de la valeur des fréquences associées à chaque point de la TF.</p>
<p>Exemple: Nous allons générer un vecteur c(k)=sin(k) dont les valeurs
varient sinusoïdalement pour 0&lt;=k&lt;100, puis nous allons
visualiser le module de sa transformée de Fourier :</p>
<code>set n 100</code> <br />
<code>set c ""</code> <br />
<code>set t ""</code> <br />
<code>for {set k 0} {$k&lt;$n} {incr k} {</code> <br />
<code> set value [expr sin($k)]</code> <br />
<code> lappend c $value</code> <br />
<code> lappend t $k</code> <br />
<code>}</code> <br />
<code>set fft [gsl_fft $c $t]</code> <br />
<code>set fftr [lindex $fft 0]</code> <br />
<code>set ffti [lindex $fft 1]</code> <br />
<code>set freq [lindex $fft 2]</code> <br />
<code>set module ""</code> <br />
<code>for {set k 0} {$k&lt;$n} {incr k} {</code> <br />
<code> set x [lindex $fftr $k]</code> <br />
<code> set y [lindex $ffti $k]</code> <br />
<code> set value [expr sqrt($x*$x+$y*$y)]</code> <br />
<code> lappend module $value</code> <br />
<code>}</code> <br />
<code>::plotxy::figure 1</code> <br />
<code>::plotxy::plot $freq $module</code> <br />
<code>::plotxy::xlabel "frequency (Hz)"</code> <br />
<code>::plotxy::ylabel "module intensity"</code> <br />
<code>::plotxy::title "FFT of a sinus function"</code>
<p>Cet exemple affiche le résultat sous la forme d'un graphe grâce aux fonctions du <a href="audplotxy.htm">namespace ::plotxy</a>
disponible dans Aud'ACE. Sur le graphe, on remarquera que la fréquence
de Nyquist est 0.5Hz (= inverse de deux fois la durée totale du signal
temporel). Au delà de 0.5Hz, on assiste à un phénomène d'aliasing.</p>
<h3> <a name="gsl_ifft" id="gsl_ifft" />gsl_ifft ListVectorReal ListVectorImag ?ListVectorFreq?</h3>
<p>Effectue la transformée de Fourier inverse des vecteurs
ListVectorReal (vecteur des amplitudes réelles) et ListVectorImag
(vecteur des amplitudes imaginaires) et retourne un vecteur. Si l'on a
effectué le calcul avec le vecteur ListVectorFreq correspondant aux
fréquences de mesure de chaque point, alors un second élément est
retourné par la fonction gsl_fft. C'est le vecteur de la valeur des
instants associées à chaque point de la TF inverse.<br />
</p>
<h2> 2.5. Calculs autour du chi2<br />
</h2>
<h3>gsl_cdf_chisq_Pinv ProbabilityDensity_P DegreesOfFreedom_nu</h3>

<p>Cette fonction retourne la
valeur limite de chi2 connaissant la densité de probabilité souhaitée (ProbabilityDensity_P) et le nombre de degrés de liberté (DegreesOfFreedom_nu).</p>
Par exemple :<br />
gsl_cdf_chisq_Pinv 0.95 43
<br />
# 59.3035
<p></p>
L'interprétation du chi2 n'est pas triviale. Elle dépend
du nombre de points de mesures N et du nombre de variables
à trouver V. Plus le nombre est petit, mieux c'est. Mais pour
une interprétation quantitative il faut d'abord calculer ddl
le nombre de degrés de liberté. Dans notre cas de modèle de pointage, avec N étoiles
pointées et un modèle à V paramètres, on a :<br />

<br />
ddl = 2*N - V - 1
<br />

<br />
Soit avec 25 étoiles et le modèle {IH ID NP CH ME MA} donc à 6
paramètres, alors on aura ddl= 2*25 - 6 - 1 = 43 degrés de liberté.
<br />

<br />
Pour un niveau de confiance à 95% (p=0.95) on calcule la valeur
limite du chi2 avec :<br />
gsl_cdf_chisq_Pinv 0.95 43<br />

<br />
On obtient la valeur de 59.3035. Il faut alors comparer la valeur
trouvée par le calcul du modèle et 59.3035. Si la valeur trouvée
par le calcul est inférieure à 59.3035 alors cela signifie que le
nombre de paramètres choisis est OK. Si la valeur est supérieure
à 59.3035 alors il faudrait ajouter des paramètres au modèle pour
revenir dans la zone d'acceptabilité.<br />

<br />
Le test du chi2 ne nous apprend rien sur quelle mesure d'étoile
aurait été fausse (mauvais pointage). Le test chi2 est simplement
là pour nous dire que le choix du nombre d'étoiles et des
paramètres du test sont compatibles avec le modèle.<br />

<h3>gsl_cdf_chisq_Q Chi2Critic_x DegreesOfFreedom_nu</h3>



<p>Cette fonction retourne pour une valeur
expérimentale de chi2 et un nombre de degré de liberté nu
donné, la probabilité que le modèle soit
correct.</p>
<p>Par exemple :<br />
gsl_cdf_chisq_Q 25.67 34
<br />
# 0.847126
</p>
Ce qui signifie que le modèle est acceptable à 84.7%
de niveau de confiance. Il faut interpréter cela comme
on le fait avec l'écart type d'une distribution gaussienne :
<br />

<br />
68% = 1 sigma
<br />
95% = 2 sigma
<br />
99.7% = 3 sigma
<h3>gsl_cdf_ugaussian_Qinv&nbsp; Q</h3>




<p>Cette fonction permet de calculer le nombre de sigma.</p>
Par exemple :<br />
set p [gsl_cdf_chisq_Q 25.67 34]
<br />
set Q [expr (1.-$p)/2.]
<br />
set kappa [gsl_cdf_ugaussian_Qinv $Q]
<br />

<br />
&nbsp;&nbsp;&nbsp; =&gt; p = 0.847126 à interpréter comme acceptable à 84.7%
de niveau de confiance.
<br />
&nbsp;&nbsp;&nbsp; =&gt; kappa = 1.4 à interpréter comme 1.4*sigma
<br />

<br />
Un bon modèle doit être meilleur que 3 sigmas.<br />


</body></html>