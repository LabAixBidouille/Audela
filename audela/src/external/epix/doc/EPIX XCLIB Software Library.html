<!DOCTYPE HTML PUBLIC "-//WSC//DTD HTML 3.2 FINAL//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><!--								    -->
<!--	XCLIB Reference Manual	External    22-Oct-2009 	    -->
<!--								    -->
<!--	Copyright (C)  1998-2009  EPIX, Inc.  All rights reserved.  -->
<!--								    -->
<!--								    -->



<title>XCLIB Reference Manual</title>
<style>
    BODY {
        font-family: times,serif;
        color: black;
        font-size: 12pt;
        padding: 0px;
        margin: 60px;
    }
    PRE {
        color: black;
        font-size: 9pt;
    }
    H1 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 20pt;
        background-color: #66CCFF;
        padding-left: 5px;
    }
    H2 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 18pt;
        background-color: #88DDFF;
        padding-left: 10px;
    }
    H3 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 16pt;
        background-color: #AAEEFF;
        padding-left: 15px;
    }
    H4 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 14pt;
        background-color: #BBEEFF;
        padding-left: 20px;
    }
    H5 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 12pt;
        background-color: #CCEEFF;
        padding-left: 25px;
    }
    H6 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 12pt;
        background-color: #DDEEFF;
        padding-left: 30px;
    }
    EM {
        font-family: times,serif;
        color: black;
        font-size: 12pt;
        font-style=italics;
    }
    EM.Ep {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 10pt;
    }
    EM.Ss {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 14pt;
    }
    B.Fg {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 12pt;
    }
    HR {
        border:thin solid #999999;
    }
    TABLE {
        border: 1px solid #999999;
        background-color: #EEEEEE;
    }
    A:link {
        color:#0044FF;
    }
    A:visited {
        color:#0000CC;
    }
    A:focus {
        color:#FF0000;
    }
    A:hover {
        color:#FF0000;
    }
    A:active {
        color:#0000FF;
    }
</style>
</head><body bgcolor="#ffffff">
<br>
<br>
<br>
<br>
<br>
<hr>
<div align="center">
<font face="Helvetica,sans-serif,sansserif" size="+2">
<b>REFERENCE MANUAL</b>
<br>
<br>
<b>XCLIB<sup>tm</sup></b>
<br>
<b>Imaging Board 'C' Library</b>
<br>
<br>
<b>VERSI0N 3.7</b>
<br>
<br>
<b>For use with:</b>
<br>
<b>PIXCI<sup>®</sup> Imaging Boards</b>
<br>
<b></b>
<br>
<b></b>
<br>
<br>
Copyright © 1998-2009 EPIX, Inc.
<hr>
</font>
</div>
<div align="left">
<blockquote>
No part of this document may be reproduced, transmitted, photocopied,
or translated into another language without the written consent of EPIX,&nbsp;Inc.
Information in this document is subject to change without obligation or notice.
EPIX,&nbsp;Inc. makes no warranty of any kind with regard to this document,
including, but not limited to, the implied warranties of
merchantability and fitness for a particular purpose.
EPIX,&nbsp;Inc. assumes no responsibility for any errors that
may appear in this document.
EPIX,&nbsp;Inc. reserves the right to make changes to the specifications
of hardware and software at any time, without obligation or notice.
<br>
<br>
4MIP, SVIP, XCIP, XCAP, 4MEG VIDEO, 1MEG VIDEO, SILICON VIDEO MUX,
QUICK SET VIDEO, 12-7MUX, IMAGE MEMORY EXPANSION,
COC40, and COC402 are trademarks of EPIX,&nbsp;Inc.
<br>
<br>
EPIX, SILICON VIDEO, and PIXCI are registered trademarks of EPIX,&nbsp;Inc.
<br>
<br>
Other brand, product, and company names are trademarks or
registered trademarks of their respective owners.
<br>
<br>
Printing: 08-Mar-2011
</blockquote>
<hr size="3">
<h1>Table of Contents</h1>
<ul type="circle">
<li>
<a href="#1.%20%20Installation,%20Configuration,+and+Usage+%3F+Compile+Time" class="TOC">1.  Installation, Configuration, and Usage &#8212; Compile Time</a>
<ul type="circle">
<li>
<a href="#1.1.%20%20Introduction" class="TOC">1.1.  Introduction</a>
</li><li>
<a href="#1.2.%20%20Library%20Installation" class="TOC">1.2.  Library Installation</a>
</li><li>
<a href="#1.3.%20%20Compiling" class="TOC">1.3.  Compiling</a>
<ul type="circle">
<li>
<a href="#1.3.1.%20%20Stack" class="TOC">1.3.1.  Stack</a>
</li><li>
<a href="#1.3.2.%20%20Heap" class="TOC">1.3.2.  Heap</a>
</li><li>
<a href="#1.3.3.%20%20Memory%20Allocation%20Hooks" class="TOC">1.3.3.  Memory Allocation Hooks</a>
</li></ul>
</li><li>
<a href="#1.4.%20%20Compile%20Time%20Inclusions" class="TOC">1.4.  Compile Time Inclusions</a>
</li><li>
<a href="#1.5.%20%20Common%20Types%20and%20Concepts" class="TOC">1.5.  Common Types and Concepts</a>
<ul type="circle">
<li>
<a href="#1.5.1.%20%20Types" class="TOC">1.5.1.  Types</a>
</li><li>
<a href="#1.5.2.%20%20Modifiers" class="TOC">1.5.2.  Modifiers</a>
</li><li>
<a href="#1.5.3.%20%20Call%20Back%20Types" class="TOC">1.5.3.  Call Back Types</a>
<ul type="circle">
<li>
<a href="#1.5.3.1.%20%20The%20pxabortfunc_t" class="TOC">1.5.3.1.  The pxabortfunc_t</a>
</li></ul>
</li><li>
<a href="#1.5.4.%20%20Usage%20Assumptions" class="TOC">1.5.4.  Usage Assumptions</a>
</li><li>
<a href="#1.5.5.%20%20On%20Frame%20Buffers%20and%20Memory" class="TOC">1.5.5.  On Frame Buffers and Memory</a>
</li><li>
<a href="#1.5.6.%20%20On%20the%20Semantics%20of%20Snap" class="TOC">1.5.6.  On the Semantics of Snap</a>
</li><li>
<a href="#1.5.7.%20%20On%20Imaging%20Boards%20with%20Multiple%20Functional%20Units" class="TOC">1.5.7.  On Imaging Boards with Multiple Functional Units</a>
</li><li>
<a href="#1.5.8.%20%20On%20Multiple%20Imaging%20Boards" class="TOC">1.5.8.  On Multiple Imaging Boards</a>
</li><li>
<a href="#1.5.9.%20%20On%20Multiple%20Identical%20Imaging%20Boards" class="TOC">1.5.9.  On Multiple Identical Imaging Boards</a>
</li><li>
<a href="#1.5.10.%20%20On%20Serial%20Ports" class="TOC">1.5.10.  On Serial Ports</a>
</li><li>
<a href="#1.5.11.%20%20On%20Video%20Format%20Configuration" class="TOC">1.5.11.  On Video Format Configuration</a>
</li><li>
<a href="#1.5.12.%20%20On%20Video%20State%20ID%27s" class="TOC">1.5.12.  On Video State ID's</a>
</li><li>
<a href="#1.5.13.%20%20On%20Error%20Codes" class="TOC">1.5.13.  On Error Codes</a>
</li><li>
<a href="#1.5.14.%20%20On%20Structures%20and%20Signatures" class="TOC">1.5.14.  On Structures and Signatures</a>
</li></ul>
</li><li>
<a href="#1.6.%20%20Common%20Structures" class="TOC">1.6.  Common Structures</a>
<ul type="circle">
<li>
<a href="#1.6.1.%20%20Coordinates,%20Images,%20and%20Image%20Window%20Structures" class="TOC">1.6.1.  Coordinates, Images, and Image Window Structures</a>
</li><li>
<a href="#1.6.2.%20%20Imaging%20Board,%20Driver,%20and%20Video%20Format%20Configuration%20Structures" class="TOC">1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures</a>
</li></ul>
</li></ul>
</li><li>
<a href="#2.++Installation+and+Configuration+%3F+Run+Time" class="TOC">2.  Installation and Configuration &#8212; Run Time</a>
<ul type="circle">
<li>
<a href="#2.1.%20%20Driver%20Configuration%20Parameters" class="TOC">2.1.  Driver Configuration Parameters</a>
</li><li>
<a href="#2.2.%20%20Windows%2095,%2098,%20ME%20Environment" class="TOC">2.2.  Windows 95, 98, ME Environment</a>
</li><li>
<a href="#2.3.%20%20Windows%20NT,%202000,%20XP,%20XP%28x64%29,%20Vista,%20Vista%28x64%29,%207,%207%28x64%29%20Environment" class="TOC">2.3.  Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64) Environment</a>
</li><li>
<a href="#2.4.%20%20Tenberry%20DOS4GW%20DOS%20Extender%20Environment" class="TOC">2.4.  Tenberry DOS4GW DOS Extender Environment</a>
</li><li>
<a href="#2.5.%20%20Linux%2032%20Bit%20&amp;%20Intel%20i386%20Environment" class="TOC">2.5.  Linux 32 Bit &amp; Intel i386 Environment</a>
</li><li>
<a href="#2.6.%20%20Linux%2064%20Bit%20&amp;%20Intel%20x86-64%20Environment" class="TOC">2.6.  Linux 64 Bit &amp; Intel x86-64 Environment</a>
</li></ul>
</li><li>
<a href="#3.%20%20SCF%20Style%20Interface" class="TOC">3.  SCF Style Interface</a>
<ul type="circle">
<li>
<a href="#Buffer%27s%20Capture%20Field%20Count%20%20%20---%20%20%20pxd_buffersFieldCount" class="TOC">Buffer's Capture Field Count   ---   pxd_buffersFieldCount</a>
</li><li>
<a href="#Buffer%27s%20Capture%20General%20Purpose%20Input%20%20%20---%20%20%20pxd_buffersGPIn" class="TOC">Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn</a>
</li><li>
<a href="#Buffer%27s%20Capture%20System%20Time%20%20%20---%20%20%20pxd_buffersSysTicks" class="TOC">Buffer's Capture System Time   ---   pxd_buffersSysTicks</a>
</li><li>
<a href="#Buffer%27s%20Capture%20System%20Time%20%20%20---%20%20%20pxd_buffersSysTicks2" class="TOC">Buffer's Capture System Time   ---   pxd_buffersSysTicks2</a>
</li><li>
<a href="#Last%20Captured%20Buffer:%20Buffer%20Number%20%20%20---%20%20%20pxd_capturedBuffer" class="TOC">Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer</a>
</li><li>
<a href="#Last%20Captured%20Buffer:%20Field%20Count%20%20%20---%20%20%20pxd_capturedFieldCount" class="TOC">Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount</a>
</li><li>
<a href="#Last%20Captured%20Buffer:%20System%20Time%20%20%20---%20%20%20pxd_capturedSysTicks" class="TOC">Last Captured Buffer: System Time   ---   pxd_capturedSysTicks</a>
</li><li>
<a href="#Camera%20Link%20CC%20Output%20Signal:%20Set%20%20%20---%20%20%20pxd_setCameraLinkCCOut" class="TOC">Camera Link CC Output Signal: Set   ---   pxd_setCameraLinkCCOut</a>
</li><li>
<a href="#Camera%20Link%20CC%20Output%20Signal:%20Get%20%20%20---%20%20%20pxd_getCameraLinkCCOut" class="TOC">Camera Link CC Output Signal: Get   ---   pxd_getCameraLinkCCOut</a>
</li><li>
<a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20%20%20---%20%20%20pxd_defineImage" class="TOC">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage</a>
</li><li>
<a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxd_defineImage3" class="TOC">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3</a>
</li><li>
<a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20%20%20---%20%20%20pxd_definePximage" class="TOC">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage</a>
</li><li>
<a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxd_definePximage3" class="TOC">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3</a>
</li><li>
<a href="#Get%20PXIMAGE:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxd_definePximageFree" class="TOC">Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree</a>
</li><li>
<a href="#Get%20PXIMAGE3:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxd_definePximage3Free" class="TOC">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free</a>
</li><li>
<a href="#Video%20Snap%20and%20Wait%20%20%20---%20%20%20pxd_doSnap" class="TOC">Video Snap and Wait   ---   pxd_doSnap</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldCreate" class="TOC">Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldCreate2" class="TOC">Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldClose" class="TOC">Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldCreate" class="TOC">Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldCreate2" class="TOC">Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldClose" class="TOC">Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerCreate" class="TOC">Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerCreate2" class="TOC">Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerClose" class="TOC">Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultCreate" class="TOC">Windows: Register Event upon Fault   ---   pxd_eventFaultCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultCreate2" class="TOC">Windows: Register Event upon Fault   ---   pxd_eventFaultCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultClose" class="TOC">Windows: Unregister Event upon Fault   ---   pxd_eventFaultClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Serial%20%20%20---%20%20%20pxd_eventSerialCreate" class="TOC">Windows: Register Event upon Serial   ---   pxd_eventSerialCreate</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Serial%20%20%20---%20%20%20pxd_eventSerialClose" class="TOC">Windows: Unregister Event upon Serial   ---   pxd_eventSerialClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldCreate" class="TOC">DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldClose" class="TOC">DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldCreate" class="TOC">DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldClose" class="TOC">DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerCreate" class="TOC">DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerClose" class="TOC">DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultCreate" class="TOC">DOS: Register Callback upon Fault   ---   pxd_eventFaultCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultClose" class="TOC">DOS: Unregister Callback upon Fault   ---   pxd_eventFaultClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Serial%20%20%20---%20%20%20pxd_eventSerialCreate" class="TOC">DOS: Register Callback upon Serial   ---   pxd_eventSerialCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Serial%20%20%20---%20%20%20pxd_eventSerialClose" class="TOC">DOS: Unregister Callback upon Serial   ---   pxd_eventSerialClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldCreate" class="TOC">Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Video%20Field%20%20%20---%20%20%20pxd_eventFieldClose" class="TOC">Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldCreate" class="TOC">Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxd_eventCapturedFieldClose" class="TOC">Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerCreate" class="TOC">Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxd_eventGPTriggerClose" class="TOC">Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultCreate" class="TOC">Linux: Register Signal upon Fault   ---   pxd_eventFaultCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Fault%20%20%20---%20%20%20pxd_eventFaultClose" class="TOC">Linux: Unregister Signal upon Fault   ---   pxd_eventFaultClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Serial%20%20%20---%20%20%20pxd_eventSerialCreate" class="TOC">Linux: Register Signal upon Serial   ---   pxd_eventSerialCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Serial%20%20%20---%20%20%20pxd_eventSerialClose" class="TOC">Linux: Unregister Signal upon Serial   ---   pxd_eventSerialClose</a>
</li><li>
<a href="#General%20Purpose%20Input%20Signal:%20Sense%20%20%20---%20%20%20pxd_getGPIn" class="TOC">General Purpose Input Signal: Sense   ---   pxd_getGPIn</a>
</li><li>
<a href="#General%20Purpose%20Input%20Signal:%20Reset%20%20%20---%20%20%20pxd_setGPIn" class="TOC">General Purpose Input Signal: Reset   ---   pxd_setGPIn</a>
</li><li>
<a href="#General%20Purpose%20Output%20Signal:%20Set%20%20%20---%20%20%20pxd_setGPOut" class="TOC">General Purpose Output Signal: Set   ---   pxd_setGPOut</a>
</li><li>
<a href="#General%20Purpose%20Output%20Signal:%20Get%20%20%20---%20%20%20pxd_getGPOut" class="TOC">General Purpose Output Signal: Get   ---   pxd_getGPOut</a>
</li><li>
<a href="#General%20Purpose%20Trigger%20Count:%20Sense%20%20%20---%20%20%20pxd_getGPTrigger" class="TOC">General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger</a>
</li><li>
<a href="#Video%20Snap%20%20%20---%20%20%20pxd_goSnap" class="TOC">Video Snap   ---   pxd_goSnap</a>
</li><li>
<a href="#Video%20Snap%20Pair%20%20%20---%20%20%20pxd_goSnapPair" class="TOC">Video Snap Pair   ---   pxd_goSnapPair</a>
</li><li>
<a href="#Video%20Live%20%20%20---%20%20%20pxd_goLive" class="TOC">Video Live   ---   pxd_goLive</a>
</li><li>
<a href="#Video%20Live%20Pair%20Alternate%20%20%20---%20%20%20pxd_goLivePair" class="TOC">Video Live Pair Alternate   ---   pxd_goLivePair</a>
</li><li>
<a href="#Video%20Live%20Sequence%20%20%20---%20%20%20pxd_goLiveSeq" class="TOC">Video Live Sequence   ---   pxd_goLiveSeq</a>
</li><li>
<a href="#Video%20UnLive%20%20%20---%20%20%20pxd_goUnLive" class="TOC">Video UnLive   ---   pxd_goUnLive</a>
</li><li>
<a href="#Video%20Abort%20%20%20---%20%20%20pxd_goAbortLive" class="TOC">Video Abort   ---   pxd_goAbortLive</a>
</li><li>
<a href="#Video%20Live%20Trigger%20%20%20---%20%20%20pxd_goLiveTrig" class="TOC">Video Live Trigger   ---   pxd_goLiveTrig</a>
</li><li>
<a href="#Video%20Live%20Sequence%20Trigger%20%20%20---%20%20%20pxd_goLiveSeqTrig" class="TOC">Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig</a>
</li><li>
<a href="#Video%20Initiated%20Status%20Check%20%20%20---%20%20%20pxd_goneLive" class="TOC">Video Initiated Status Check   ---   pxd_goneLive</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20%20%20---%20%20%20pxd_imageAspectRatio" class="TOC">Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20%20%20---%20%20%20pxd_imageAspectRatio2" class="TOC">Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio2</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20%20%20---%20%20%20pxd_imageBdim" class="TOC">Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20%20%20---%20%20%20pxd_imageBdims" class="TOC">Get Frame Buffer Image Bit Depth   ---   pxd_imageBdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20%20%20---%20%20%20pxd_imageCdim" class="TOC">Get Frame Buffer Image Color Components   ---   pxd_imageCdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20%20%20---%20%20%20pxd_imageCdims" class="TOC">Get Frame Buffer Image Color Components   ---   pxd_imageCdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20%20%20---%20%20%20pxd_imageIdim" class="TOC">Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20%20%20---%20%20%20pxd_imageIdims" class="TOC">Get Frame Buffer Image Field Dimension   ---   pxd_imageIdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20%20%20---%20%20%20pxd_imageXdim" class="TOC">Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20%20%20---%20%20%20pxd_imageXdims" class="TOC">Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20%20%20---%20%20%20pxd_imageYdim" class="TOC">Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20%20%20---%20%20%20pxd_imageYdims" class="TOC">Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Count%20%20%20---%20%20%20pxd_imageZdim" class="TOC">Get Frame Buffer Image Count   ---   pxd_imageZdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Count%20%20%20---%20%20%20pxd_imageZdims" class="TOC">Get Frame Buffer Image Count   ---   pxd_imageZdims</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Driver%20ID%20%20%20---%20%20%20pxd_infoDriverId" class="TOC">Get Imaging Board Driver ID   ---   pxd_infoDriverId</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Include%20Files%20ID%20%20%20---%20%20%20pxd_infoIncludeId" class="TOC">Get Imaging Board Include Files ID   ---   pxd_infoIncludeId</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Library%20ID%20%20%20---%20%20%20pxd_infoLibraryId" class="TOC">Get Imaging Board Library ID   ---   pxd_infoLibraryId</a>
</li><li>
<a href="#Get%20Imaging%20Board%27s%20Frame%20Buffer%20Size%20%20%20---%20%20%20pxd_infoMemsize" class="TOC">Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize</a>
</li><li>
<a href="#Get%20Imaging%20Board%27s%20Model%20%20%20---%20%20%20pxd_infoModel" class="TOC">Get Imaging Board's Model   ---   pxd_infoModel</a>
</li><li>
<a href="#Get%20Imaging%20Board%27s%20Submodel%20%20%20---%20%20%20pxd_infoSubmodel" class="TOC">Get Imaging Board's Submodel   ---   pxd_infoSubmodel</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Unit%20Count%20%20%20---%20%20%20pxd_infoUnits" class="TOC">Get Imaging Board Unit Count   ---   pxd_infoUnits</a>
</li><li>
<a href="#Load%20Image:%20BMP%20Format%20%20%20---%20%20%20pxd_loadBmp" class="TOC">Load Image: BMP Format   ---   pxd_loadBmp</a>
</li><li>
<a href="#Load%20Image:%20TIFF%20Format%20%20%20---%20%20%20pxd_loadTiff" class="TOC">Load Image: TIFF Format   ---   pxd_loadTiff</a>
</li><li>
<a href="#Save%20Image:%20BMP%20Format%20%20%20---%20%20%20pxd_saveBmp" class="TOC">Save Image: BMP Format   ---   pxd_saveBmp</a>
</li><li>
<a href="#Save%20Image:%20PCX%20Format%20%20%20---%20%20%20pxd_savePcx" class="TOC">Save Image: PCX Format   ---   pxd_savePcx</a>
</li><li>
<a href="#Save%20Image:%20TARGA%20Format%20%20%20---%20%20%20pxd_saveTga" class="TOC">Save Image: TARGA Format   ---   pxd_saveTga</a>
</li><li>
<a href="#Save%20Image:%20TIFF%20Format%20%20%20---%20%20%20pxd_saveTiff" class="TOC">Save Image: TIFF Format   ---   pxd_saveTiff</a>
</li><li>
<a href="#Load%20Frame%20Buffers%20%20%20---%20%20%20pxd_loadRawBuffers" class="TOC">Load Frame Buffers   ---   pxd_loadRawBuffers</a>
</li><li>
<a href="#Save%20Frame%20Buffers%20%20%20---%20%20%20pxd_saveRawBuffers" class="TOC">Save Frame Buffers   ---   pxd_saveRawBuffers</a>
</li><li>
<a href="#Errors:%20Translate%20Error%20Code%20to%20String%20%20%20---%20%20%20pxd_mesgErrorCode" class="TOC">Errors: Translate Error Code to String   ---   pxd_mesgErrorCode</a>
</li><li>
<a href="#Errors:%20Check%20&amp;%20Report%20Faults%20%20%20---%20%20%20pxd_mesgFault" class="TOC">Errors: Check &amp; Report Faults   ---   pxd_mesgFault</a>
</li><li>
<a href="#Errors:%20Check%20&amp;%20Report%20Faults%20%20%20---%20%20%20pxd_mesgFaultText" class="TOC">Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board:+Open+and+Set+Video+Format+Configuration+++---+++pxd_PIXCIopen" class="TOC">PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board:+Close+++---+++pxd_PIXCIclose" class="TOC">PIXCI® Imaging Board: Close   ---   pxd_PIXCIclose</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Char%20%20%20---%20%20%20pxd_readuchar" class="TOC">Read Pixel Values as Unsigned Char   ---   pxd_readuchar</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Short%20%20%20---%20%20%20pxd_readushort" class="TOC">Read Pixel Values as Unsigned Short   ---   pxd_readushort</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Char%20%20%20---%20%20%20pxd_writeuchar" class="TOC">Write Pixel Values as Unsigned Char   ---   pxd_writeuchar</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Short%20%20%20---%20%20%20pxd_writeushort" class="TOC">Write Pixel Values as Unsigned Short   ---   pxd_writeushort</a>
</li><li>
<a href="#Windows:%20Create%20Device%20Independent%20Bitmap%20%28DIB%29%20%20%20---%20%20%20pxd_renderDIBCreate" class="TOC">Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate</a>
</li><li>
<a href="#Windows:%20Release%20Device%20Independent%20Bitmap%20%28DIB%29%20%20%20---%20%20%20pxd_renderDIBFree" class="TOC">Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Init%20%20%20---%20%20%20pxd_renderDirectVideoInit" class="TOC">Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Done%20%20%20---%20%20%20pxd_renderDirectVideoDone" class="TOC">Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Start%20%20%20---%20%20%20pxd_renderDirectVideoLive" class="TOC">Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Stop%20%20%20---%20%20%20pxd_renderDirectVideoUnLive" class="TOC">Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive</a>
</li><li>
<a href="#Windows:%20Display%20Image%20Frame%20Buffer%20On%20Device%20Context%20%20%20---%20%20%20pxd_renderStretchDIBits" class="TOC">Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits</a>
</li><li>
<a href="#Serial%20Port:%20Set%20Configuration%20%20%20---%20%20%20pxd_serialConfigure" class="TOC">Serial Port: Set Configuration   ---   pxd_serialConfigure</a>
</li><li>
<a href="#Serial%20Port:%20Read%20%20%20---%20%20%20pxd_serialRead" class="TOC">Serial Port: Read   ---   pxd_serialRead</a>
</li><li>
<a href="#Serial%20Port:%20Write%20%20%20---%20%20%20pxd_serialWrite" class="TOC">Serial Port: Write   ---   pxd_serialWrite</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Initialize%20%20%20---%20%20%20clSerialInit" class="TOC">Camera Link Serial: Initialize   ---   clSerialInit</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Close%20%20%20---%20%20%20clSerialClose" class="TOC">Camera Link Serial: Close   ---   clSerialClose</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Read%20%20%20---%20%20%20clSerialRead" class="TOC">Camera Link Serial: Read   ---   clSerialRead</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Write%20%20%20---%20%20%20clSerialWrite" class="TOC">Camera Link Serial: Write   ---   clSerialWrite</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Read%20Available%20%20%20---%20%20%20clGetNumBytesAvail" class="TOC">Camera Link Serial: Read Available   ---   clGetNumBytesAvail</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Read%20Flush%20%20%20---%20%20%20clFlushPort" class="TOC">Camera Link Serial: Read Flush   ---   clFlushPort</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Error%20Text%20%20%20---%20%20%20clGetErrorText" class="TOC">Camera Link Serial: Error Text   ---   clGetErrorText</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Ports%20%20%20---%20%20%20clGetNumSerialPorts" class="TOC">Camera Link Serial: Ports   ---   clGetNumSerialPorts</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Ports%20ID%20%20%20---%20%20%20clGetSerialPortIdentifier" class="TOC">Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Manufacturer%20ID%20%20%20---%20%20%20clGetManufacturerInfo" class="TOC">Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Get%20Baud%20Rates%20%20%20---%20%20%20clGetSupportedBaudRates" class="TOC">Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates</a>
</li><li>
<a href="#Camera%20Link%20Serial:%20Set%20Baud%20Rate%20%20%20---%20%20%20clSetBaudRate" class="TOC">Camera Link Serial: Set Baud Rate   ---   clSetBaudRate</a>
</li><li>
<a href="#Set%20EXSYNC%20and%20PRIN%20Counter%20Values%20%20%20---%20%20%20pxd_setExsyncPrin" class="TOC">Set EXSYNC and PRIN Counter Values   ---   pxd_setExsyncPrin</a>
</li><li>
<a href="#Get%20EXSYNC%20Counter%20Value%20%20%20---%20%20%20pxd_getExsync" class="TOC">Get EXSYNC Counter Value   ---   pxd_getExsync</a>
</li><li>
<a href="#Get%20PRIN%20Counter%20Value%20%20%20---%20%20%20pxd_getPrin" class="TOC">Get PRIN Counter Value   ---   pxd_getPrin</a>
</li><li>
<a href="#Set%20EXSYNC%20and%20PRINC%20Mode%20Bits%20%20%20---%20%20%20pxd_setExsyncPrincMode" class="TOC">Set EXSYNC and PRINC Mode Bits   ---   pxd_setExsyncPrincMode</a>
</li><li>
<a href="#Get%20EXSYNC%20Mode%20Bits%20%20%20---%20%20%20pxd_getExsyncMode" class="TOC">Get EXSYNC Mode Bits   ---   pxd_getExsyncMode</a>
</li><li>
<a href="#Get%20PRINC%20Mode%20Bits%20%20%20---%20%20%20pxd_getPrincMode" class="TOC">Get PRINC Mode Bits   ---   pxd_getPrincMode</a>
</li><li>
<a href="#Set%20Video%20Input%20Multiplexer%20%20%20---%20%20%20pxd_setVidMux" class="TOC">Set Video Input Multiplexer   ---   pxd_setVidMux</a>
</li><li>
<a href="#Set%20Video%20Contrast%20and%20Brightness%20%20%20---%20%20%20pxd_setContrastBrightness" class="TOC">Set Video Contrast and Brightness   ---   pxd_setContrastBrightness</a>
</li><li>
<a href="#Set%20Video%20Hue%20and%20Saturation%20%20%20---%20%20%20pxd_setHueSaturation" class="TOC">Set Video Hue and Saturation   ---   pxd_setHueSaturation</a>
</li><li>
<a href="#Get%20Video%20Input%20Multiplexer%20%20%20---%20%20%20pxd_getVidMux" class="TOC">Get Video Input Multiplexer   ---   pxd_getVidMux</a>
</li><li>
<a href="#Get%20Video%20Contrast%20%20%20---%20%20%20pxd_getContrast" class="TOC">Get Video Contrast   ---   pxd_getContrast</a>
</li><li>
<a href="#Get%20Video%20Brightness%20%20%20---%20%20%20pxd_getBrightness" class="TOC">Get Video Brightness   ---   pxd_getBrightness</a>
</li><li>
<a href="#Get%20Video%20Hue%20%20%20---%20%20%20pxd_getHue" class="TOC">Get Video Hue   ---   pxd_getHue</a>
</li><li>
<a href="#Get%20Video%20U%20Saturation%20%20%20---%20%20%20pxd_getUGain" class="TOC">Get Video U Saturation   ---   pxd_getUGain</a>
</li><li>
<a href="#Get%20Video%20V%20Saturation%20%20%20---%20%20%20pxd_getVGain" class="TOC">Get Video V Saturation   ---   pxd_getVGain</a>
</li><li>
<a href="#Set%20Bright%20White%20Balance%20%20%20---%20%20%20pxd_setImageBrightBalance" class="TOC">Set Bright White Balance   ---   pxd_setImageBrightBalance</a>
</li><li>
<a href="#Set%20Dark%20White%20Balance%20%20%20---%20%20%20pxd_setImageDarkBalance" class="TOC">Set Dark White Balance   ---   pxd_setImageDarkBalance</a>
</li><li>
<a href="#Get%20Video%20Field%20Count%20%20%20---%20%20%20pxd_videoFieldCount" class="TOC">Get Video Field Count   ---   pxd_videoFieldCount</a>
</li><li>
<a href="#Get%20Video%20Field%20Characteristic%20%20%20---%20%20%20pxd_videoFieldsPerFrame" class="TOC">Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame</a>
</li><li>
<a href="#Get%20Video%20Field%20Characteristic%20%20%20---%20%20%20pxd_videoFieldsPerFrames" class="TOC">Get Video Field Characteristic   ---   pxd_videoFieldsPerFrames</a>
</li><li>
<a href="#Set%20Video%20Configuration%20as%20per%20Compiled%20Include%20%20%20---%20%20%20pxd_videoFormatAsIncluded" class="TOC">Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gain,%20and%20Offset%20%20%20---%20%20%20pxd_SILICONVIDEO_setExposureGainOffset" class="TOC">Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxd_SILICONVIDEO_setExposureGainOffset</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gains,%20and%20Offsets%20%20%20---%20%20%20pxd_SILICONVIDEO_setExposureColorGainOffsets" class="TOC">Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxd_SILICONVIDEO_setExposureColorGainOffsets</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Exposure%20%20%20---%20%20%20pxd_SILICONVIDEO_setExposure" class="TOC">Set SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_setExposure</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Exposure%20%20%20---%20%20%20pxd_SILICONVIDEO_getExposure" class="TOC">Get SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_getExposure</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Gain%20A%20%20%20---%20%20%20pxd_SILICONVIDEO_getGainA" class="TOC">Get SILICON VIDEO Gain A   ---   pxd_SILICONVIDEO_getGainA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Gain%20B%20%20%20---%20%20%20pxd_SILICONVIDEO_getGainB" class="TOC">Get SILICON VIDEO Gain B   ---   pxd_SILICONVIDEO_getGainB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20A%20%20%20---%20%20%20pxd_SILICONVIDEO_getGainsA" class="TOC">Get SILICON VIDEO Color Gains A   ---   pxd_SILICONVIDEO_getGainsA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20B%20%20%20---%20%20%20pxd_SILICONVIDEO_getGainsB" class="TOC">Get SILICON VIDEO Color Gains B   ---   pxd_SILICONVIDEO_getGainsB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20A%20%20%20---%20%20%20pxd_SILICONVIDEO_getOffsetsA" class="TOC">Get SILICON VIDEO Color Offsets A   ---   pxd_SILICONVIDEO_getOffsetsA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20B%20%20%20---%20%20%20pxd_SILICONVIDEO_getOffsetsB" class="TOC">Get SILICON VIDEO Color Offsets B   ---   pxd_SILICONVIDEO_getOffsetsB</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Resolution%20and%20Timing%20%20%20---%20%20%20pxd_SILICONVIDEO_setResolutionAndTiming" class="TOC">Set SILICON VIDEO Resolution and Timing   ---   pxd_SILICONVIDEO_setResolutionAndTiming</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Subsample%20%20%20---%20%20%20pxd_SILICONVIDEO_getSubsample" class="TOC">Get SILICON VIDEO Subsample   ---   pxd_SILICONVIDEO_getSubsample</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Left%20Edge%20%20%20---%20%20%20pxd_SILICONVIDEO_getAoiLeft" class="TOC">Get SILICON VIDEO Aoi Left Edge   ---   pxd_SILICONVIDEO_getAoiLeft</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Top%20Edge%20%20%20---%20%20%20pxd_SILICONVIDEO_getAoiTop" class="TOC">Get SILICON VIDEO Aoi Top Edge   ---   pxd_SILICONVIDEO_getAoiTop</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Width%20%20%20---%20%20%20pxd_SILICONVIDEO_getAoiTop" class="TOC">Get SILICON VIDEO Aoi Width   ---   pxd_SILICONVIDEO_getAoiTop</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Height%20%20%20---%20%20%20pxd_SILICONVIDEO_getAoiTop" class="TOC">Get SILICON VIDEO Aoi Height   ---   pxd_SILICONVIDEO_getAoiTop</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Scan%20Direction%20%20%20---%20%20%20pxd_SILICONVIDEO_getScanDirection" class="TOC">Get SILICON VIDEO Scan Direction   ---   pxd_SILICONVIDEO_getScanDirection</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Pixel%20Clock%20Frequency%20%20%20---%20%20%20pxd_SILICONVIDEO_getPixelClock" class="TOC">Get SILICON VIDEO Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getPixelClock</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Frame%20Period%20%20%20---%20%20%20pxd_SILICONVIDEO_getFramePeriod" class="TOC">Get SILICON VIDEO Frame Period   ---   pxd_SILICONVIDEO_getFramePeriod</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Video%20And%20Trigger%20Modes%20%20%20---%20%20%20pxd_SILICONVIDEO_setVideoAndTriggerMode" class="TOC">Set SILICON VIDEO Video And Trigger Modes   ---   pxd_SILICONVIDEO_setVideoAndTriggerMode</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Controlled%20Rates%20%20%20---%20%20%20pxd_SILICONVIDEO_setCtrlRates" class="TOC">Set SILICON VIDEO Controlled Rates   ---   pxd_SILICONVIDEO_setCtrlRates</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Video%20Mode%20%20%20---%20%20%20pxd_SILICONVIDEO_getVideoMode" class="TOC">Get SILICON VIDEO Video Mode   ---   pxd_SILICONVIDEO_getVideoMode</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Controlled%20Video%20Mode%20%20%20---%20%20%20pxd_SILICONVIDEO_getCtrlVideoMode" class="TOC">Get SILICON VIDEO Controlled Video Mode   ---   pxd_SILICONVIDEO_getCtrlVideoMode</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Controlled%20Trigger%20Mode%20%20%20---%20%20%20pxd_SILICONVIDEO_getCtrlTriggerMode" class="TOC">Get SILICON VIDEO Controlled Trigger Mode   ---   pxd_SILICONVIDEO_getCtrlTriggerMode</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20AGC%20and%20AEC%20%20%20---%20%20%20pxd_SILICONVIDEO_setAxC" class="TOC">Set SILICON VIDEO AGC and AEC   ---   pxd_SILICONVIDEO_setAxC</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20AGC%20A%20Gain%20%20%20---%20%20%20pxd_SILICONVIDEO_getAgcA" class="TOC">Get SILICON VIDEO AGC A Gain   ---   pxd_SILICONVIDEO_getAgcA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20AGC%20B%20Gain%20%20%20---%20%20%20pxd_SILICONVIDEO_getAgcB" class="TOC">Get SILICON VIDEO AGC B Gain   ---   pxd_SILICONVIDEO_getAgcB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20AEC%20Exposure%20%20%20---%20%20%20pxd_SILICONVIDEO_getAec" class="TOC">Get SILICON VIDEO AEC Exposure   ---   pxd_SILICONVIDEO_getAec</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Exposure%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxExposure" class="TOC">Get SILICON VIDEO Min/Max Exposure   ---   pxd_SILICONVIDEO_getMinMaxExposure</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Frame%20Period%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxFramePeriod" class="TOC">Get SILICON VIDEO Min/Max Frame Period   ---   pxd_SILICONVIDEO_getMinMaxFramePeriod</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Controlled%20Frame%20Rate%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxCtrlFrameRate" class="TOC">Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxd_SILICONVIDEO_getMinMaxCtrlFrameRate</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Pixel%20Clock%20Frequency%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxPixelClock" class="TOC">Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getMinMaxPixelClock</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20A%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxGainA" class="TOC">Get SILICON VIDEO Min/Max Gain A   ---   pxd_SILICONVIDEO_getMinMaxGainA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20B%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxGainB" class="TOC">Get SILICON VIDEO Min/Max Gain B   ---   pxd_SILICONVIDEO_getMinMaxGainB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20A%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxOffsetA" class="TOC">Get SILICON VIDEO Min/Max Offset A   ---   pxd_SILICONVIDEO_getMinMaxOffsetA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20B%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxOffsetB" class="TOC">Get SILICON VIDEO Min/Max Offset B   ---   pxd_SILICONVIDEO_getMinMaxOffsetB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Width%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxAoiWidth" class="TOC">Get SILICON VIDEO Min/Max AOI Width   ---   pxd_SILICONVIDEO_getMinMaxAoiWidth</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Height%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxAoiHeight" class="TOC">Get SILICON VIDEO Min/Max AOI Height   ---   pxd_SILICONVIDEO_getMinMaxAoiHeight</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20A%20Gain%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxAgcA" class="TOC">Get SILICON VIDEO Min/Max AGC A Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20B%20Gain%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxAgcB" class="TOC">Get SILICON VIDEO Min/Max AGC B Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AEC%20Exposure%20%20%20---%20%20%20pxd_SILICONVIDEO_getMinMaxAec" class="TOC">Get SILICON VIDEO Min/Max AEC Exposure   ---   pxd_SILICONVIDEO_getMinMaxAec</a>
</li></ul>
</li><li>
<a href="#4.%20%20SCF+%20Style%20Interface" class="TOC">4.  SCF+ Style Interface</a>
<ul type="circle">
<li>
<a href="#PIXCI%AE+Imaging+Board+Library:+Create+Instance+++---+++pxe_XCLIBinstantiate" class="TOC">PIXCI® Imaging Board Library: Create Instance   ---   pxe_XCLIBinstantiate</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board+Library:+Uncreate+Instance+++---+++pxe_XCLIBuninstantiate" class="TOC">PIXCI® Imaging Board Library: Uncreate Instance   ---   pxe_XCLIBuninstantiate</a>
</li><li>
<a href="#Buffer%27s%20Capture%20Field%20Count%20%20%20---%20%20%20pxe_buffersFieldCount" class="TOC">Buffer's Capture Field Count   ---   pxe_buffersFieldCount</a>
</li><li>
<a href="#Buffer%27s%20Capture%20General%20Purpose%20Input%20%20%20---%20%20%20pxe_buffersGPIn" class="TOC">Buffer's Capture General Purpose Input   ---   pxe_buffersGPIn</a>
</li><li>
<a href="#Buffer%27s%20Capture%20System%20Time%20%20%20---%20%20%20pxe_buffersSysTicks" class="TOC">Buffer's Capture System Time   ---   pxe_buffersSysTicks</a>
</li><li>
<a href="#Buffer%27s%20Capture%20System%20Time%20%20%20---%20%20%20pxe_buffersSysTicks2" class="TOC">Buffer's Capture System Time   ---   pxe_buffersSysTicks2</a>
</li><li>
<a href="#Last%20Captured%20Buffer:%20Buffer%20Number%20%20%20---%20%20%20pxe_capturedBuffer" class="TOC">Last Captured Buffer: Buffer Number   ---   pxe_capturedBuffer</a>
</li><li>
<a href="#Last%20Captured%20Buffer:%20Field%20Count%20%20%20---%20%20%20pxe_capturedFieldCount" class="TOC">Last Captured Buffer: Field Count   ---   pxe_capturedFieldCount</a>
</li><li>
<a href="#Last%20Captured%20Buffer:%20System%20Time%20%20%20---%20%20%20pxe_capturedSysTicks" class="TOC">Last Captured Buffer: System Time   ---   pxe_capturedSysTicks</a>
</li><li>
<a href="#Camera%20Link%20CC%20Output%20Signal:%20Set%20%20%20---%20%20%20pxe_setCameraLinkCCOut" class="TOC">Camera Link CC Output Signal: Set   ---   pxe_setCameraLinkCCOut</a>
</li><li>
<a href="#Camera%20Link%20CC%20Output%20Signal:%20Get%20%20%20---%20%20%20pxe_getCameraLinkCCOut" class="TOC">Camera Link CC Output Signal: Get   ---   pxe_getCameraLinkCCOut</a>
</li><li>
<a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20%20%20---%20%20%20pxe_defineImage" class="TOC">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_defineImage</a>
</li><li>
<a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxe_defineImage3" class="TOC">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_defineImage3</a>
</li><li>
<a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20%20%20---%20%20%20pxe_definePximage" class="TOC">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_definePximage</a>
</li><li>
<a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxe_definePximage3" class="TOC">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_definePximage3</a>
</li><li>
<a href="#Get%20PXIMAGE:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxe_definePximageFree" class="TOC">Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximageFree</a>
</li><li>
<a href="#Get%20PXIMAGE3:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20%20%20---%20%20%20pxe_definePximage3Free" class="TOC">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximage3Free</a>
</li><li>
<a href="#Video%20Snap%20and%20Wait%20%20%20---%20%20%20pxe_doSnap" class="TOC">Video Snap and Wait   ---   pxe_doSnap</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldCreate" class="TOC">Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldCreate2" class="TOC">Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldClose" class="TOC">Windows: Unregister Event upon Video Field   ---   pxe_eventFieldClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldCreate" class="TOC">Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldCreate2" class="TOC">Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldClose" class="TOC">Windows: Unregister Event upon Captured Video Field   ---   pxe_eventCapturedFieldClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerCreate" class="TOC">Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerCreate2" class="TOC">Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerClose" class="TOC">Windows: Unregister Event upon General Purpose Trigger   ---   pxe_eventGPTriggerClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultCreate" class="TOC">Windows: Register Event upon Fault   ---   pxe_eventFaultCreate</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultCreate2" class="TOC">Windows: Register Event upon Fault   ---   pxe_eventFaultCreate2</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultClose" class="TOC">Windows: Unregister Event upon Fault   ---   pxe_eventFaultClose</a>
</li><li>
<a href="#Windows:%20Register%20Event%20upon%20Serial%20%20%20---%20%20%20pxe_eventSerialCreate" class="TOC">Windows: Register Event upon Serial   ---   pxe_eventSerialCreate</a>
</li><li>
<a href="#Windows:%20Unregister%20Event%20upon%20Serial%20%20%20---%20%20%20pxe_eventSerialClose" class="TOC">Windows: Unregister Event upon Serial   ---   pxe_eventSerialClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldCreate" class="TOC">DOS: Register Callback upon Video Field   ---   pxe_eventFieldCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldClose" class="TOC">DOS: Unregister Callback upon Video Field   ---   pxe_eventFieldClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldCreate" class="TOC">DOS: Register Callback upon Captured Video Field   ---   pxe_eventCapturedFieldCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldClose" class="TOC">DOS: Unregister Callback upon Captured Video Field   ---   pxe_eventCapturedFieldClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerCreate" class="TOC">DOS: Register Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerClose" class="TOC">DOS: Unregister Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultCreate" class="TOC">DOS: Register Callback upon Fault   ---   pxe_eventFaultCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultClose" class="TOC">DOS: Unregister Callback upon Fault   ---   pxe_eventFaultClose</a>
</li><li>
<a href="#DOS:%20Register%20Callback%20upon%20Serial%20%20%20---%20%20%20pxe_eventSerialCreate" class="TOC">DOS: Register Callback upon Serial   ---   pxe_eventSerialCreate</a>
</li><li>
<a href="#DOS:%20Unregister%20Callback%20upon%20Serial%20%20%20---%20%20%20pxe_eventSerialClose" class="TOC">DOS: Unregister Callback upon Serial   ---   pxe_eventSerialClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldCreate" class="TOC">Linux: Register Signal upon Video Field   ---   pxe_eventFieldCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Video%20Field%20%20%20---%20%20%20pxe_eventFieldClose" class="TOC">Linux: Unregister Signal upon Video Field   ---   pxe_eventFieldClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldCreate" class="TOC">Linux: Register Signal upon Captured Video Field   ---   pxe_eventCapturedFieldCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Captured%20Video%20Field%20%20%20---%20%20%20pxe_eventCapturedFieldClose" class="TOC">Linux: Unregister Signal upon Captured Video Field   ---   pxe_eventCapturedFieldClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerCreate" class="TOC">Linux: Register Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20General%20Purpose%20Trigger%20%20%20---%20%20%20pxe_eventGPTriggerClose" class="TOC">Linux: Unregister Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultCreate" class="TOC">Linux: Register Signal upon Fault   ---   pxe_eventFaultCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Fault%20%20%20---%20%20%20pxe_eventFaultClose" class="TOC">Linux: Unregister Signal upon Fault   ---   pxe_eventFaultClose</a>
</li><li>
<a href="#Linux:%20Register%20Signal%20upon%20Serial%20%20%20---%20%20%20pxe_eventSerialCreate" class="TOC">Linux: Register Signal upon Serial   ---   pxe_eventSerialCreate</a>
</li><li>
<a href="#Linux:%20Unregister%20Signal%20upon%20Serial%20%20%20---%20%20%20pxe_eventSerialClose" class="TOC">Linux: Unregister Signal upon Serial   ---   pxe_eventSerialClose</a>
</li><li>
<a href="#General%20Purpose%20Input%20Signal:%20Sense%20%20%20---%20%20%20pxe_getGPIn" class="TOC">General Purpose Input Signal: Sense   ---   pxe_getGPIn</a>
</li><li>
<a href="#General%20Purpose%20Input%20Signal:%20Reset%20%20%20---%20%20%20pxe_setGPIn" class="TOC">General Purpose Input Signal: Reset   ---   pxe_setGPIn</a>
</li><li>
<a href="#General%20Purpose%20Output%20Signal:%20Set%20%20%20---%20%20%20pxe_setGPOut" class="TOC">General Purpose Output Signal: Set   ---   pxe_setGPOut</a>
</li><li>
<a href="#General%20Purpose%20Output%20Signal:%20Get%20%20%20---%20%20%20pxe_getGPOut" class="TOC">General Purpose Output Signal: Get   ---   pxe_getGPOut</a>
</li><li>
<a href="#General%20Purpose%20Trigger%20Count:%20Sense%20%20%20---%20%20%20pxe_getGPTrigger" class="TOC">General Purpose Trigger Count: Sense   ---   pxe_getGPTrigger</a>
</li><li>
<a href="#Get%20Video%20Brightness%20%20%20---%20%20%20pxe_getBrightness" class="TOC">Get Video Brightness   ---   pxe_getBrightness</a>
</li><li>
<a href="#Get%20Video%20Contrast%20%20%20---%20%20%20pxe_getContrast" class="TOC">Get Video Contrast   ---   pxe_getContrast</a>
</li><li>
<a href="#Get%20Video%20Hue%20%20%20---%20%20%20pxe_getHue" class="TOC">Get Video Hue   ---   pxe_getHue</a>
</li><li>
<a href="#Get%20Video%20U%20Saturation%20%20%20---%20%20%20pxe_getUGain" class="TOC">Get Video U Saturation   ---   pxe_getUGain</a>
</li><li>
<a href="#Get%20Video%20V%20Saturation%20%20%20---%20%20%20pxe_getVGain" class="TOC">Get Video V Saturation   ---   pxe_getVGain</a>
</li><li>
<a href="#Get%20Video%20Input%20Multiplexer%20%20%20---%20%20%20pxe_getVidMux" class="TOC">Get Video Input Multiplexer   ---   pxe_getVidMux</a>
</li><li>
<a href="#Video%20Snap%20%20%20---%20%20%20pxe_goSnap" class="TOC">Video Snap   ---   pxe_goSnap</a>
</li><li>
<a href="#Video%20Snap%20Pair%20%20%20---%20%20%20pxe_goSnapPair" class="TOC">Video Snap Pair   ---   pxe_goSnapPair</a>
</li><li>
<a href="#Video%20Live%20%20%20---%20%20%20pxe_goLive" class="TOC">Video Live   ---   pxe_goLive</a>
</li><li>
<a href="#Video%20Live%20Pair%20Alternate%20%20%20---%20%20%20pxe_goLivePair" class="TOC">Video Live Pair Alternate   ---   pxe_goLivePair</a>
</li><li>
<a href="#Video%20Live%20Sequence%20%20%20---%20%20%20pxe_goLiveSeq" class="TOC">Video Live Sequence   ---   pxe_goLiveSeq</a>
</li><li>
<a href="#Video%20UnLive%20%20%20---%20%20%20pxe_goUnLive" class="TOC">Video UnLive   ---   pxe_goUnLive</a>
</li><li>
<a href="#Video%20Abort%20%20%20---%20%20%20pxe_goAbortLive" class="TOC">Video Abort   ---   pxe_goAbortLive</a>
</li><li>
<a href="#Video%20Live%20Trigger%20%20%20---%20%20%20pxe_goLiveTrig" class="TOC">Video Live Trigger   ---   pxe_goLiveTrig</a>
</li><li>
<a href="#Video%20Live%20Sequence%20Trigger%20%20%20---%20%20%20pxe_goLiveSeqTrig" class="TOC">Video Live Sequence Trigger   ---   pxe_goLiveSeqTrig</a>
</li><li>
<a href="#Video%20Initiated%20Status%20Check%20%20%20---%20%20%20pxe_goneLive" class="TOC">Video Initiated Status Check   ---   pxe_goneLive</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20%20%20---%20%20%20pxe_imageAspectRatio" class="TOC">Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20%20%20---%20%20%20pxe_imageAspectRatio2" class="TOC">Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio2</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20%20%20---%20%20%20pxe_imageBdim" class="TOC">Get Frame Buffer Image Bit Depth   ---   pxe_imageBdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20%20%20---%20%20%20pxe_imageBdims" class="TOC">Get Frame Buffer Image Bit Depth   ---   pxe_imageBdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20%20%20---%20%20%20pxe_imageCdim" class="TOC">Get Frame Buffer Image Color Components   ---   pxe_imageCdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20%20%20---%20%20%20pxe_imageCdims" class="TOC">Get Frame Buffer Image Color Components   ---   pxe_imageCdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20%20%20---%20%20%20pxe_imageIdim" class="TOC">Get Frame Buffer Image Field Dimension   ---   pxe_imageIdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20%20%20---%20%20%20pxe_imageIdims" class="TOC">Get Frame Buffer Image Field Dimension   ---   pxe_imageIdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20%20%20---%20%20%20pxe_imageXdim" class="TOC">Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20%20%20---%20%20%20pxe_imageXdims" class="TOC">Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20%20%20---%20%20%20pxe_imageYdim" class="TOC">Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20%20%20---%20%20%20pxe_imageYdims" class="TOC">Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdims</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Count%20%20%20---%20%20%20pxe_imageZdim" class="TOC">Get Frame Buffer Image Count   ---   pxe_imageZdim</a>
</li><li>
<a href="#Get%20Frame%20Buffer%20Image%20Count%20%20%20---%20%20%20pxe_imageZdims" class="TOC">Get Frame Buffer Image Count   ---   pxe_imageZdims</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Driver%20ID%20%20%20---%20%20%20pxe_infoDriverId" class="TOC">Get Imaging Board Driver ID   ---   pxe_infoDriverId</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Library%20ID%20%20%20---%20%20%20pxe_infoLibraryId" class="TOC">Get Imaging Board Library ID   ---   pxe_infoLibraryId</a>
</li><li>
<a href="#Get%20Imaging%20Board%27s%20Frame%20Buffer%20Size%20%20%20---%20%20%20pxe_infoMemsize" class="TOC">Get Imaging Board's Frame Buffer Size   ---   pxe_infoMemsize</a>
</li><li>
<a href="#Get%20Imaging%20Board%27s%20Model%20%20%20---%20%20%20pxe_infoModel" class="TOC">Get Imaging Board's Model   ---   pxe_infoModel</a>
</li><li>
<a href="#Get%20Imaging%20Board%27s%20Submodel%20%20%20---%20%20%20pxe_infoSubmodel" class="TOC">Get Imaging Board's Submodel   ---   pxe_infoSubmodel</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Unit%20Count%20%20%20---%20%20%20pxe_infoUnits" class="TOC">Get Imaging Board Unit Count   ---   pxe_infoUnits</a>
</li><li>
<a href="#Load%20Image:%20BMP%20Format%20%20%20---%20%20%20pxe_loadBmp" class="TOC">Load Image: BMP Format   ---   pxe_loadBmp</a>
</li><li>
<a href="#Load%20Image:%20TIFF%20Format%20%20%20---%20%20%20pxe_loadTiff" class="TOC">Load Image: TIFF Format   ---   pxe_loadTiff</a>
</li><li>
<a href="#Save%20Image:%20BMP%20Format%20%20%20---%20%20%20pxe_saveBmp" class="TOC">Save Image: BMP Format   ---   pxe_saveBmp</a>
</li><li>
<a href="#Save%20Image:%20PCX%20Format%20%20%20---%20%20%20pxe_savePcx" class="TOC">Save Image: PCX Format   ---   pxe_savePcx</a>
</li><li>
<a href="#Save%20Image:%20TARGA%20Format%20%20%20---%20%20%20pxe_saveTga" class="TOC">Save Image: TARGA Format   ---   pxe_saveTga</a>
</li><li>
<a href="#Save%20Image:%20TIFF%20Format%20%20%20---%20%20%20pxe_saveTiff" class="TOC">Save Image: TIFF Format   ---   pxe_saveTiff</a>
</li><li>
<a href="#Load%20Frame%20Buffers%20%20%20---%20%20%20pxe_loadRawBuffers" class="TOC">Load Frame Buffers   ---   pxe_loadRawBuffers</a>
</li><li>
<a href="#Save%20Frame%20Buffers%20%20%20---%20%20%20pxe_saveRawBuffers" class="TOC">Save Frame Buffers   ---   pxe_saveRawBuffers</a>
</li><li>
<a href="#Errors:%20Check%20&amp;%20Report%20Faults%20%20%20---%20%20%20pxe_mesgFault" class="TOC">Errors: Check &amp; Report Faults   ---   pxe_mesgFault</a>
</li><li>
<a href="#Errors:%20Check%20&amp;%20Report%20Faults%20%20%20---%20%20%20pxe_mesgFaultText" class="TOC">Errors: Check &amp; Report Faults   ---   pxe_mesgFaultText</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board:+Open+and+Set+Video+Format+Configuration+++---+++pxe_PIXCIopen" class="TOC">PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxe_PIXCIopen</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board:+Close+++---+++pxe_PIXCIclose" class="TOC">PIXCI® Imaging Board: Close   ---   pxe_PIXCIclose</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Char%20%20%20---%20%20%20pxe_readuchar" class="TOC">Read Pixel Values as Unsigned Char   ---   pxe_readuchar</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Short%20%20%20---%20%20%20pxe_readushort" class="TOC">Read Pixel Values as Unsigned Short   ---   pxe_readushort</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Char%20%20%20---%20%20%20pxe_writeuchar" class="TOC">Write Pixel Values as Unsigned Char   ---   pxe_writeuchar</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Short%20%20%20---%20%20%20pxe_writeushort" class="TOC">Write Pixel Values as Unsigned Short   ---   pxe_writeushort</a>
</li><li>
<a href="#Windows:%20Create%20Device%20Independent%20Bitmap%20%28DIB%29%20%20%20---%20%20%20pxe_renderDIBCreate" class="TOC">Windows: Create Device Independent Bitmap (DIB)   ---   pxe_renderDIBCreate</a>
</li><li>
<a href="#Windows:%20Release%20Device%20Independent%20Bitmap%20%28DIB%29%20%20%20---%20%20%20pxe_renderDIBFree" class="TOC">Windows: Release Device Independent Bitmap (DIB)   ---   pxe_renderDIBFree</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Init%20%20%20---%20%20%20pxe_renderDirectVideoInit" class="TOC">Windows: Direct Video Display, Init   ---   pxe_renderDirectVideoInit</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Done%20%20%20---%20%20%20pxe_renderDirectVideoDone" class="TOC">Windows: Direct Video Display, Done   ---   pxe_renderDirectVideoDone</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Start%20%20%20---%20%20%20pxe_renderDirectVideoLive" class="TOC">Windows: Direct Video Display, Start   ---   pxe_renderDirectVideoLive</a>
</li><li>
<a href="#Windows:%20Direct%20Video%20Display,%20Stop%20%20%20---%20%20%20pxe_renderDirectVideoUnLive" class="TOC">Windows: Direct Video Display, Stop   ---   pxe_renderDirectVideoUnLive</a>
</li><li>
<a href="#Windows:%20Display%20Image%20Frame%20Buffer%20On%20Device%20Context%20%20%20---%20%20%20pxe_renderStretchDIBits" class="TOC">Windows: Display Image Frame Buffer On Device Context   ---   pxe_renderStretchDIBits</a>
</li><li>
<a href="#Serial%20Port:%20Set%20Configuration%20%20%20---%20%20%20pxe_serialConfigure" class="TOC">Serial Port: Set Configuration   ---   pxe_serialConfigure</a>
</li><li>
<a href="#Serial%20Port:%20Read%20%20%20---%20%20%20pxe_serialRead" class="TOC">Serial Port: Read   ---   pxe_serialRead</a>
</li><li>
<a href="#Serial%20Port:%20Write%20%20%20---%20%20%20pxe_serialWrite" class="TOC">Serial Port: Write   ---   pxe_serialWrite</a>
</li><li>
<a href="#Set%20EXSYNC%20and%20PRIN%20Counter%20Values%20%20%20---%20%20%20pxe_setExsyncPrin" class="TOC">Set EXSYNC and PRIN Counter Values   ---   pxe_setExsyncPrin</a>
</li><li>
<a href="#Get%20EXSYNC%20Counter%20Value%20%20%20---%20%20%20pxe_getExsync" class="TOC">Get EXSYNC Counter Value   ---   pxe_getExsync</a>
</li><li>
<a href="#Get%20PRIN%20Counter%20Value%20%20%20---%20%20%20pxe_getPrin" class="TOC">Get PRIN Counter Value   ---   pxe_getPrin</a>
</li><li>
<a href="#Set%20EXSYNC%20and%20PRINC%20Mode%20Bits%20%20%20---%20%20%20pxe_setExsyncPrincMode" class="TOC">Set EXSYNC and PRINC Mode Bits   ---   pxe_setExsyncPrincMode</a>
</li><li>
<a href="#Get%20EXSYNC%20Mode%20Bits%20%20%20---%20%20%20pxe_getExsyncMode" class="TOC">Get EXSYNC Mode Bits   ---   pxe_getExsyncMode</a>
</li><li>
<a href="#Get%20PRINC%20Mode%20Bits%20%20%20---%20%20%20pxe_getPrincMode" class="TOC">Get PRINC Mode Bits   ---   pxe_getPrincMode</a>
</li><li>
<a href="#Set%20Video%20Input%20Multiplexer%20%20%20---%20%20%20pxe_setVidMux" class="TOC">Set Video Input Multiplexer   ---   pxe_setVidMux</a>
</li><li>
<a href="#Set%20Video%20Contrast%20and%20Brightness%20%20%20---%20%20%20pxe_setContrastBrightness" class="TOC">Set Video Contrast and Brightness   ---   pxe_setContrastBrightness</a>
</li><li>
<a href="#Set%20Video%20Hue%20and%20Saturation%20%20%20---%20%20%20pxe_setHueSaturation" class="TOC">Set Video Hue and Saturation   ---   pxe_setHueSaturation</a>
</li><li>
<a href="#Set%20Bright%20White%20Balance%20%20%20---%20%20%20pxe_setImageBrightBalance" class="TOC">Set Bright White Balance   ---   pxe_setImageBrightBalance</a>
</li><li>
<a href="#Set%20Dark%20White%20Balance%20%20%20---%20%20%20pxe_setImageDarkBalance" class="TOC">Set Dark White Balance   ---   pxe_setImageDarkBalance</a>
</li><li>
<a href="#Get%20Video%20Field%20Count%20%20%20---%20%20%20pxe_videoFieldCount" class="TOC">Get Video Field Count   ---   pxe_videoFieldCount</a>
</li><li>
<a href="#Get%20Video%20Field%20Characteristic%20%20%20---%20%20%20pxe_videoFieldsPerFrame" class="TOC">Get Video Field Characteristic   ---   pxe_videoFieldsPerFrame</a>
</li><li>
<a href="#Get%20Video%20Field%20Characteristic%20%20%20---%20%20%20pxe_videoFieldsPerFrames" class="TOC">Get Video Field Characteristic   ---   pxe_videoFieldsPerFrames</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gain,%20and%20Offset%20%20%20---%20%20%20pxe_SILICONVIDEO_setExposureGainOffset" class="TOC">Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxe_SILICONVIDEO_setExposureGainOffset</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gains,%20and%20Offsets%20%20%20---%20%20%20pxe_SILICONVIDEO_setExposureColorGainOffsets" class="TOC">Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxe_SILICONVIDEO_setExposureColorGainOffsets</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Exposure%20%20%20---%20%20%20pxe_SILICONVIDEO_setExposure" class="TOC">Set SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_setExposure</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Exposure%20%20%20---%20%20%20pxe_SILICONVIDEO_getExposure" class="TOC">Get SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_getExposure</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Gain%20A%20%20%20---%20%20%20pxe_SILICONVIDEO_getGainA" class="TOC">Get SILICON VIDEO Gain A   ---   pxe_SILICONVIDEO_getGainA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Gain%20B%20%20%20---%20%20%20pxe_SILICONVIDEO_getGainB" class="TOC">Get SILICON VIDEO Gain B   ---   pxe_SILICONVIDEO_getGainB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20A%20%20%20---%20%20%20pxe_SILICONVIDEO_getGainsA" class="TOC">Get SILICON VIDEO Color Gains A   ---   pxe_SILICONVIDEO_getGainsA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20B%20%20%20---%20%20%20pxe_SILICONVIDEO_getGainsB" class="TOC">Get SILICON VIDEO Color Gains B   ---   pxe_SILICONVIDEO_getGainsB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20A%20%20%20---%20%20%20pxe_SILICONVIDEO_getOffsetsA" class="TOC">Get SILICON VIDEO Color Offsets A   ---   pxe_SILICONVIDEO_getOffsetsA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20B%20%20%20---%20%20%20pxe_SILICONVIDEO_getOffsetsB" class="TOC">Get SILICON VIDEO Color Offsets B   ---   pxe_SILICONVIDEO_getOffsetsB</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Resolution%20and%20Timing%20%20%20---%20%20%20pxe_SILICONVIDEO_setResolutionAndTiming" class="TOC">Set SILICON VIDEO Resolution and Timing   ---   pxe_SILICONVIDEO_setResolutionAndTiming</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Subsample%20%20%20---%20%20%20pxe_SILICONVIDEO_getSubsample" class="TOC">Get SILICON VIDEO Subsample   ---   pxe_SILICONVIDEO_getSubsample</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Left%20Edge%20%20%20---%20%20%20pxe_SILICONVIDEO_getAoiLeft" class="TOC">Get SILICON VIDEO Aoi Left Edge   ---   pxe_SILICONVIDEO_getAoiLeft</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Top%20Edge%20%20%20---%20%20%20pxe_SILICONVIDEO_getAoiTop" class="TOC">Get SILICON VIDEO Aoi Top Edge   ---   pxe_SILICONVIDEO_getAoiTop</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Width%20%20%20---%20%20%20pxe_SILICONVIDEO_getAoiTop" class="TOC">Get SILICON VIDEO Aoi Width   ---   pxe_SILICONVIDEO_getAoiTop</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Aoi%20Height%20%20%20---%20%20%20pxe_SILICONVIDEO_getAoiTop" class="TOC">Get SILICON VIDEO Aoi Height   ---   pxe_SILICONVIDEO_getAoiTop</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Scan%20Direction%20%20%20---%20%20%20pxe_SILICONVIDEO_getScanDirection" class="TOC">Get SILICON VIDEO Scan Direction   ---   pxe_SILICONVIDEO_getScanDirection</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Pixel%20Clock%20Frequency%20%20%20---%20%20%20pxe_SILICONVIDEO_getPixelClock" class="TOC">Get SILICON VIDEO Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getPixelClock</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Frame%20Period%20%20%20---%20%20%20pxe_SILICONVIDEO_getFramePeriod" class="TOC">Get SILICON VIDEO Frame Period   ---   pxe_SILICONVIDEO_getFramePeriod</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Video%20And%20Trigger%20Modes%20%20%20---%20%20%20pxe_SILICONVIDEO_setVideoAndTriggerMode" class="TOC">Set SILICON VIDEO Video And Trigger Modes   ---   pxe_SILICONVIDEO_setVideoAndTriggerMode</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20Controlled%20Rates%20%20%20---%20%20%20pxe_SILICONVIDEO_setCtrlRates" class="TOC">Set SILICON VIDEO Controlled Rates   ---   pxe_SILICONVIDEO_setCtrlRates</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Video%20Mode%20%20%20---%20%20%20pxe_SILICONVIDEO_getVideoMode" class="TOC">Get SILICON VIDEO Video Mode   ---   pxe_SILICONVIDEO_getVideoMode</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Controlled%20Video%20Mode%20%20%20---%20%20%20pxe_SILICONVIDEO_getCtrlVideoMode" class="TOC">Get SILICON VIDEO Controlled Video Mode   ---   pxe_SILICONVIDEO_getCtrlVideoMode</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Controlled%20Trigger%20Mode%20%20%20---%20%20%20pxe_SILICONVIDEO_getCtrlTriggerMode" class="TOC">Get SILICON VIDEO Controlled Trigger Mode   ---   pxe_SILICONVIDEO_getCtrlTriggerMode</a>
</li><li>
<a href="#Set%20SILICON%20VIDEO%20AGC%20and%20AEC%20%20%20---%20%20%20pxe_SILICONVIDEO_setAxC" class="TOC">Set SILICON VIDEO AGC and AEC   ---   pxe_SILICONVIDEO_setAxC</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20AGC%20A%20Gain%20%20%20---%20%20%20pxe_SILICONVIDEO_getAgcA" class="TOC">Get SILICON VIDEO AGC A Gain   ---   pxe_SILICONVIDEO_getAgcA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20AGC%20B%20Gain%20%20%20---%20%20%20pxe_SILICONVIDEO_getAgcB" class="TOC">Get SILICON VIDEO AGC B Gain   ---   pxe_SILICONVIDEO_getAgcB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20AEC%20Exposure%20%20%20---%20%20%20pxe_SILICONVIDEO_getAec" class="TOC">Get SILICON VIDEO AEC Exposure   ---   pxe_SILICONVIDEO_getAec</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Exposure%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxExposure" class="TOC">Get SILICON VIDEO Min/Max Exposure   ---   pxe_SILICONVIDEO_getMinMaxExposure</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Frame%20Period%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxFramePeriod" class="TOC">Get SILICON VIDEO Min/Max Frame Period   ---   pxe_SILICONVIDEO_getMinMaxFramePeriod</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Controlled%20Frame%20Rate%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxCtrlFrameRate" class="TOC">Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxe_SILICONVIDEO_getMinMaxCtrlFrameRate</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Pixel%20Clock%20Frequency%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxPixelClock" class="TOC">Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getMinMaxPixelClock</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20A%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxGainA" class="TOC">Get SILICON VIDEO Min/Max Gain A   ---   pxe_SILICONVIDEO_getMinMaxGainA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20B%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxGainB" class="TOC">Get SILICON VIDEO Min/Max Gain B   ---   pxe_SILICONVIDEO_getMinMaxGainB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20A%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxOffsetA" class="TOC">Get SILICON VIDEO Min/Max Offset A   ---   pxe_SILICONVIDEO_getMinMaxOffsetA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20B%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxOffsetB" class="TOC">Get SILICON VIDEO Min/Max Offset B   ---   pxe_SILICONVIDEO_getMinMaxOffsetB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Width%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxAoiWidth" class="TOC">Get SILICON VIDEO Min/Max AOI Width   ---   pxe_SILICONVIDEO_getMinMaxAoiWidth</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Height%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxAoiHeight" class="TOC">Get SILICON VIDEO Min/Max AOI Height   ---   pxe_SILICONVIDEO_getMinMaxAoiHeight</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20A%20Gain%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxAgcA" class="TOC">Get SILICON VIDEO Min/Max AGC A Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcA</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20B%20Gain%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxAgcB" class="TOC">Get SILICON VIDEO Min/Max AGC B Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcB</a>
</li><li>
<a href="#Get%20SILICON%20VIDEO%20Min/Max%20AEC%20Exposure%20%20%20---%20%20%20pxe_SILICONVIDEO_getMinMaxAec" class="TOC">Get SILICON VIDEO Min/Max AEC Exposure   ---   pxe_SILICONVIDEO_getMinMaxAec</a>
</li></ul>
</li><li>
<a href="#5.%20%20Structured%20Style%20Interface%20-%20Open,%20Close,%20Information,%20and%20Fault%20Services" class="TOC">5.  Structured Style Interface - Open, Close, Information, and Fault Services</a>
<ul type="circle">
<li>
<a href="#Get%20Imaging%20Board%20Include%20Files%20ID%20%20%20---%20%20%20xclib_libincid" class="TOC">Get Imaging Board Include Files ID   ---   xclib_libincid</a>
</li><li>
<a href="#Get%20Imaging%20Board%20Library%20ID%20%20%20---%20%20%20xclib_liblibid" class="TOC">Get Imaging Board Library ID   ---   xclib_liblibid</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board:+Structured+Open+++---+++xclib_open" class="TOC">PIXCI® Imaging Board: Structured Open   ---   xclib_open</a>
</li><li>
<a href="#PIXCI%AE+Imaging+Board:+Structured+Close+++---+++xclib_close" class="TOC">PIXCI® Imaging Board: Structured Close   ---   xclib_close</a>
</li><li>
<a href="#Get%20Imaging%20Board%20and%20Driver%20Information%20%20%20---%20%20%20::pxdev.getDevInfo" class="TOC">Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo</a>
</li><li>
<a href="#Get%20Extended%20Imaging%20Board%20and%20Driver%20Information%20%20%20---%20%20%20::xcdev.getDevInfo" class="TOC">Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo</a>
</li><li>
<a href="#Obtain%20Last%20Logged%20Fault%20%20%20---%20%20%20::pxdev.getFault" class="TOC">Obtain Last Logged Fault   ---   ::pxdev.getFault</a>
</li><li>
<a href="#Get%20Driver%20Parameters%20%20%20---%20%20%20::xcdev.getDevParms" class="TOC">Get Driver Parameters   ---   ::xcdev.getDevParms</a>
</li><li>
<a href="#Set%20Driver%20Parameters%20%20%20---%20%20%20::xcdev.setDevParms" class="TOC">Set Driver Parameters   ---   ::xcdev.setDevParms</a>
</li></ul>
</li><li>
<a href="#6.%20%20Structured%20Style%20Interface%20-%20Video%20Format%20Configuration%20Services" class="TOC">6.  Structured Style Interface - Video Format Configuration Services</a>
<ul type="circle">
<li>
<a href="#Allocate%20Copy%20of%20Video%20State%20%20%20---%20%20%20::pxlib.allocStateCopy" class="TOC">Allocate Copy of Video State   ---   ::pxlib.allocStateCopy</a>
</li><li>
<a href="#Free%20Copy%20of%20Video%20State%20%20%20---%20%20%20::pxlib.freeStateCopy" class="TOC">Free Copy of Video State   ---   ::pxlib.freeStateCopy</a>
</li><li>
<a href="#Compare%20Pair%20of%20Video%20State%20Copies%20%20%20---%20%20%20::pxlib.compareStateCopy" class="TOC">Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy</a>
</li><li>
<a href="#Define%20Video%20State%20%20%20---%20%20%20::pxlib.defineState" class="TOC">Define Video State   ---   ::pxlib.defineState</a>
</li><li>
<a href="#Delete%20Video%20State%20%20%20---%20%20%20::pxlib.deleteState" class="TOC">Delete Video State   ---   ::pxlib.deleteState</a>
</li><li>
<a href="#Get%20Video%20State%20%20%20---%20%20%20::pxlib.getState" class="TOC">Get Video State   ---   ::pxlib.getState</a>
</li><li>
<a href="#Export%20Copy%20of%20Video%20State%20%20%20---%20%20%20::pxlib.exportStateCopy" class="TOC">Export Copy of Video State   ---   ::pxlib.exportStateCopy</a>
</li><li>
<a href="#Import%20Copy%20of%20Video%20State%20%20%20---%20%20%20::pxlib.importStateCopy" class="TOC">Import Copy of Video State   ---   ::pxlib.importStateCopy</a>
</li><li>
<a href="#Fixup%20Video%20State%20%20%20---%20%20%20::xclib.fixxStateCopy" class="TOC">Fixup Video State   ---   ::xclib.fixxStateCopy</a>
</li><li>
<a href="#Fill%20Video%20State%20%20%20---%20%20%20::xclib.fillStateCopy" class="TOC">Fill Video State   ---   ::xclib.fillStateCopy</a>
</li><li>
<a href="#Sign%20Video%20State%20%20%20---%20%20%20::xclib.signStateCopy" class="TOC">Sign Video State   ---   ::xclib.signStateCopy</a>
</li><li>
<a href="#Set%20Default%20Configuration%20Copy%20of%20Video%20State%20%20%20---%20%20%20::pxlib.initStateCopy" class="TOC">Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy</a>
</li><li>
<a href="#Declare%20Instance%20of%20Video%20Format%20Configuration%20Structures%20%20%20---%20%20%20xclib_DeclareVidStateStructs" class="TOC">Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs</a>
</li><li>
<a href="#Initialize%20Instance%20of%20Video%20Format%20Configuration%20Structures%20%20%20---%20%20%20xclib_InitVidStateStructs" class="TOC">Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs</a>
</li></ul>
</li><li>
<a href="#7.%20%20Structured%20Style%20Interface%20-%20Memory%20Access%20Services" class="TOC">7.  Structured Style Interface - Memory Access Services</a>
<ul type="circle">
<li>
<a href="#Obtain%20Pointer%20into%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxdev.getImap" class="TOC">Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap</a>
</li><li>
<a href="#Free%20Pointer%20into%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxdev.freeImap" class="TOC">Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap</a>
</li><li>
<a href="#Obtain%20pximage%20Access%20into%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxlib.initPximage" class="TOC">Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage</a>
</li><li>
<a href="#Obtain%20pximage3%20Access%20into%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxlib.initPximage3" class="TOC">Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3</a>
</li><li>
<a href="#Obtain%20Filtered%20pximage%20Access%20into%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxlib.initFilteredPximage" class="TOC">Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage</a>
</li><li>
<a href="#Obtain%20Filtered%20pximage3%20Access%20into%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxlib.initFilteredPximage3" class="TOC">Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3</a>
</li><li>
<a href="#Read/Write%20Imaging%20Board%20Memory%20%20%20---%20%20%20::pxdev.io" class="TOC">Read/Write Imaging Board Memory   ---   ::pxdev.io</a>
</li><li>
<a href="#Read/Write%20Imaging%20Board%20Memory,%20Sparsely%20%20%20---%20%20%20::pxdev.iosparse" class="TOC">Read/Write Imaging Board Memory, Sparsely   ---   ::pxdev.iosparse</a>
</li></ul>
</li><li>
<a href="#8.%20%20Structured%20Style%20Interface%20-%20Video%20Services" class="TOC">8.  Structured Style Interface - Video Services</a>
<ul type="circle">
<li>
<a href="#Get%20Live/Snap%20Status%20%20%20---%20%20%20::xcdev.getLiveStatus" class="TOC">Get Live/Snap Status   ---   ::xcdev.getLiveStatus</a>
</li><li>
<a href="#Get%20Current%20Video%20Status%20%20%20---%20%20%20::pxdev.getVidStatus" class="TOC">Get Current Video Status   ---   ::pxdev.getVidStatus</a>
</li><li>
<a href="#Get%20Extended%20Video%20Status%20%20%20---%20%20%20::xcdev.getVidStatus" class="TOC">Get Extended Video Status   ---   ::xcdev.getVidStatus</a>
</li><li>
<a href="#Get%20Current%20Video%20Status%20Value%20%20%20---%20%20%20::pxdev.getVidStatusValue" class="TOC">Get Current Video Status Value   ---   ::pxdev.getVidStatusValue</a>
</li><li>
<a href="#Get%20Current%20Buffer%20Status%20%20%20---%20%20%20::pxlib.goingBufStatus" class="TOC">Get Current Buffer Status   ---   ::pxlib.goingBufStatus</a>
</li><li>
<a href="#Initiate%20Snap%20into%20Frame%20Buffer%20%20%20---%20%20%20::xcdev.setSnapBuf" class="TOC">Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf</a>
</li><li>
<a href="#Initiate%20Snap%20Pair%20into%20Frame%20Buffers%20%20%20---%20%20%20::xcdev.setSnapPairBuf" class="TOC">Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf</a>
</li><li>
<a href="#Initiate%20Continuous%20Capture%20into%20Frame%20Buffer%20%20%20---%20%20%20::xcdev.setLiveBuf" class="TOC">Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf</a>
</li><li>
<a href="#Initiate%20Continuous%20Alternate%20Capture%20into%20Frame%20Buffers%20%20%20---%20%20%20::xcdev.setLivePairBuf" class="TOC">Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf</a>
</li><li>
<a href="#Initiate%20Continuous%20Capture%20into%20Memory%20Space%20%20%20---%20%20%20::setLivePhys" class="TOC">Initiate Continuous Capture into Memory Space   ---   ::setLivePhys</a>
</li><li>
<a href="#Initiate%20Sequence%20Capture%20into%20Frame%20Buffers%20%20%20---%20%20%20::setLiveSeqBuf" class="TOC">Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf</a>
</li><li>
<a href="#Initiate%20Triggered%20Capture%20into%20Frame%20Buffer%20%20%20---%20%20%20::setLiveTrigBuf" class="TOC">Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf</a>
</li><li>
<a href="#Terminate%20Live/Snap%20into%20Frame%20Buffer%20%20%20---%20%20%20::xcdev.setUnLive" class="TOC">Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive</a>
</li><li>
<a href="#Abort%20Live/Snap%20into%20Frame%20Buffer%20%20%20---%20%20%20::xcdev.setAbortLive" class="TOC">Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive</a>
</li><li>
<a href="#Set%20Camera%20Configuration%20%20%20---%20%20%20::xcdev.setCameraConfig" class="TOC">Set Camera Configuration   ---   ::xcdev.setCameraConfig</a>
</li><li>
<a href="#Set%20Video%20Configuration%20%20%20---%20%20%20::xcdev.setVideoConfig" class="TOC">Set Video Configuration   ---   ::xcdev.setVideoConfig</a>
</li><li>
<a href="#Adjust%20Video%20Configuration%20%20%20---%20%20%20::xcdev.setVideoAdjust" class="TOC">Adjust Video Configuration   ---   ::xcdev.setVideoAdjust</a>
</li></ul>
</li><li>
<a href="#9.%20%20Structured%20Style%20Interface%20-%20Miscellaneous%20Services" class="TOC">9.  Structured Style Interface - Miscellaneous Services</a>
<ul type="circle">
<li>
<a href="#General%20Purpose%20Input%20Signal:%20Sense%20%20%20---%20%20%20::xcdev.getGpin" class="TOC">General Purpose Input Signal: Sense   ---   ::xcdev.getGpin</a>
</li><li>
<a href="#General%20Purpose%20Input%20Signal:%20Reset%20%20%20---%20%20%20::xcdev.setGpin" class="TOC">General Purpose Input Signal: Reset   ---   ::xcdev.setGpin</a>
</li><li>
<a href="#General%20Purpose%20Output%20Signal:%20Set%20%20%20---%20%20%20::xcdev.setGpout" class="TOC">General Purpose Output Signal: Set   ---   ::xcdev.setGpout</a>
</li><li>
<a href="#General%20Purpose%20Output%20Signal:%20Get%20%20%20---%20%20%20::xcdev.getGpout" class="TOC">General Purpose Output Signal: Get   ---   ::xcdev.getGpout</a>
</li><li>
<a href="#Device%20Control%20%20%20---%20%20%20::pxdev.ioctl" class="TOC">Device Control   ---   ::pxdev.ioctl</a>
</li></ul>
</li><li>
<a href="#10.%20%20Structured%20Style%20Interface%20-%20Auxiliary%20Services" class="TOC">10.  Structured Style Interface - Auxiliary Services</a>
<ul type="circle">
<li>
<a href="#Load%20Frame%20Buffers%20as%20Stream%20%20%20---%20%20%20::pxaux.bufferLoadStream" class="TOC">Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream</a>
</li><li>
<a href="#Save%20Frame%20Buffers%20as%20Stream%20%20%20---%20%20%20::pxaux.bufferSaveStream" class="TOC">Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream</a>
</li><li>
<a href="#Errors:%20Translate%20Error%20Code%20to%20String%20%20%20---%20%20%20::pxaux.errorCodeString" class="TOC">Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString</a>
</li><li>
<a href="#Errors:%20Check%20&amp;%20Report%20Faults%20%20%20---%20%20%20::pxaux.faultMessageBox" class="TOC">Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox</a>
</li><li>
<a href="#Errors:%20Check%20&amp;%20Report%20Faults%20%20%20---%20%20%20::pxaux.faultPrintf" class="TOC">Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf</a>
</li><li>
<a href="#Load%20Image:%20BMP%20Format%20%20%20---%20%20%20::pxaux.imageLoadBmp" class="TOC">Load Image: BMP Format   ---   ::pxaux.imageLoadBmp</a>
</li><li>
<a href="#Load%20Image:%20TIFF%20Format%20%20%20---%20%20%20::pxaux.imageLoadTiff" class="TOC">Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff</a>
</li><li>
<a href="#Save%20Image:%20BMP%20Format%20%20%20---%20%20%20::pxaux.imageSaveBmp" class="TOC">Save Image: BMP Format   ---   ::pxaux.imageSaveBmp</a>
</li><li>
<a href="#Save%20Image:%20PCX%20Format%20%20%20---%20%20%20::pxaux.imageSavePcx" class="TOC">Save Image: PCX Format   ---   ::pxaux.imageSavePcx</a>
</li><li>
<a href="#Save%20Image:%20TARGA%20Format%20%20%20---%20%20%20::pxaux.imageSaveTga" class="TOC">Save Image: TARGA Format   ---   ::pxaux.imageSaveTga</a>
</li><li>
<a href="#Save%20Image:%20TIFF%20Format%20%20%20---%20%20%20::pxaux.imageSaveTiff" class="TOC">Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Char%20%20%20---%20%20%20::pxaux.imageReadUChar" class="TOC">Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Short%20%20%20---%20%20%20::pxaux.imageReadUShort" class="TOC">Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort</a>
</li><li>
<a href="#Read%20Pixel%20Values%20as%20Unsigned%20Int%20%20%20---%20%20%20::pxaux.imageReadUInt" class="TOC">Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Char%20%20%20---%20%20%20::pxaux.imageWriteUChar" class="TOC">Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Short%20%20%20---%20%20%20::pxaux.imageWriteUShort" class="TOC">Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort</a>
</li><li>
<a href="#Write%20Pixel%20Values%20as%20Unsigned%20Int%20%20%20---%20%20%20::pxaux.imageWriteUInt" class="TOC">Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt</a>
</li><li>
<a href="#Windows:%20Make%20Device%20Independent%20Bitmap%20%20%20---%20%20%20::pxaux.makeDIB" class="TOC">Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB</a>
</li><li>
<a href="#Windows:%20Free%20Device%20Independent%20Bitmap%20%20%20---%20%20%20::pxaux.freeDIB" class="TOC">Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB</a>
</li><li>
<a href="#Windows:%20Display%20Image%20Frame%20Buffer%20On%20Device%20Context%20%20%20---%20%20%20::pxaux.StretchDIBits" class="TOC">Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits</a>
</li></ul>
</li><li>
<a href="#11.%20%20Structured%20Style%20Interface%20-%20Camera%20Services" class="TOC">11.  Structured Style Interface - Camera Services</a>
<ul type="circle">
<li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+2112+++---+++PXCam_SILICONVIDEO2112" class="TOC">Camera Control: SILICON VIDEO® 2112   ---   PXCam_SILICONVIDEO2112</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+1310+++---+++PXCam_SILICONVIDEO1310" class="TOC">Camera Control: SILICON VIDEO® 1310   ---   PXCam_SILICONVIDEO1310</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+1281+++---+++PXCam_SILICONVIDEO1281" class="TOC">Camera Control: SILICON VIDEO® 1281   ---   PXCam_SILICONVIDEO1281</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+9M001+++---+++PXCam_SILICONVIDEO9M001" class="TOC">Camera Control: SILICON VIDEO® 9M001   ---   PXCam_SILICONVIDEO9M001</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+9T001+++---+++PXCam_SILICONVIDEO9M001" class="TOC">Camera Control: SILICON VIDEO® 9T001   ---   PXCam_SILICONVIDEO9M001</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+5M10/5C10+++---+++PXCam_SILICONVIDEO9M001" class="TOC">Camera Control: SILICON VIDEO® 5M10/5C10   ---   PXCam_SILICONVIDEO9M001</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+9C10+++---+++PXCam_SILICONVIDEO9M001" class="TOC">Camera Control: SILICON VIDEO® 9C10   ---   PXCam_SILICONVIDEO9M001</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+642+++---+++PXCam_SILICONVIDEO642" class="TOC">Camera Control: SILICON VIDEO® 642   ---   PXCam_SILICONVIDEO642</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+643+++---+++PXCam_SILICONVIDEO643" class="TOC">Camera Control: SILICON VIDEO® 643   ---   PXCam_SILICONVIDEO643</a>
</li><li>
<a href="#Camera%20Control:+SILICON+VIDEO%AE+WGA+++---+++PXCam_SILICONVIDEO032" class="TOC">Camera Control: SILICON VIDEO® WGA   ---   PXCam_SILICONVIDEO032</a>
</li></ul>
</li><li>
<a href="#12.%20%20Device%20Independent%20Image%20Access%20Interface" class="TOC">12.  Device Independent Image Access Interface</a>
<ul type="circle">
<li>
<a href="#PXIMAGE:%20Image%20and%20Pixel%20Specifications%20%20%20---%20%20%20Struct%20pximage" class="TOC">PXIMAGE: Image and Pixel Specifications   ---   Struct pximage</a>
</li><li>
<a href="#PXIMAGE:%20Set%20&amp;%20Get%20Area%20of%20Interest%20Window%20%20%20---%20%20%20pximage::xwind" class="TOC">PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind</a>
</li><li>
<a href="#PXIMAGE:%20Get%20Advice,%20Errors,%20Info%20&amp;%20Options%20%20%20---%20%20%20pximage::aeiou" class="TOC">PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou</a>
</li><li>
<a href="#PXIMAGE:%20Set%20to%20Access%20Sequential%20Pixels%20%20%20---%20%20%20pximage::ioset" class="TOC">PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset</a>
</li><li>
<a href="#PXIMAGE:%20Read%20Sequential%20Pixels%20%20%20---%20%20%20pximage::ioread" class="TOC">PXIMAGE: Read Sequential Pixels   ---   pximage::ioread</a>
</li><li>
<a href="#PXIMAGE:%20Write%20Sequential%20Pixels%20%20%20---%20%20%20pximage::iorite" class="TOC">PXIMAGE: Write Sequential Pixels   ---   pximage::iorite</a>
</li><li>
<a href="#PXIMAGE:%20Wait%20for%20Sequential%20Access%20Completion%20%20%20---%20%20%20pximage::iowait" class="TOC">PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait</a>
</li><li>
<a href="#PXIMAGE:%20Obtain%20Sequential%20Access%20Pixel%20Count%20%20%20---%20%20%20pximage::iolen" class="TOC">PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen</a>
</li><li>
<a href="#PXIMAGE:%20Set%20to%20Access%20Non-Sequential%20Pixels%20%20%20---%20%20%20pximage::bxts" class="TOC">PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts</a>
</li><li>
<a href="#PXIMAGE:%20Prepare%20for%20Non-Sequential%20Pixel%20Access%20%20%20---%20%20%20pximage::bxtp" class="TOC">PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp</a>
</li><li>
<a href="#PXIMAGE:%20Access%20Non-Sequential%20Pixels%20%20%20---%20%20%20pximage::bxta" class="TOC">PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta</a>
</li><li>
<a href="#PXIMAGE:%20Wait%20for%20Non-Sequential%20Access%20Completion%20%20%20---%20%20%20pximage::bxtw" class="TOC">PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw</a>
</li><li>
<a href="#PXIMAGE:%20Set%20to%20Obtain%20Pointer%20to%20Pixels%20%20%20---%20%20%20pximage::imapset" class="TOC">PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset</a>
</li><li>
<a href="#PXIMAGE:%20Obtain%20Pointer%20to%20Pixels%20%20%20---%20%20%20pximage::imap" class="TOC">PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap</a>
</li><li>
<a href="#PXIMAGE:%20Release%20Pointer%20to%20Pixels%20%20%20---%20%20%20pximage::imapr" class="TOC">PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr</a>
</li></ul>
</li><li>
<a href="#13.%20%20Deprecated%20Functions" class="TOC">13.  Deprecated Functions</a>
</li><li>
<a href="#14.%20%20Application%20Notes" class="TOC">14.  Application Notes</a>
<ul type="circle">
<li>
<a href="#14.1.%20%20Conversion%20of%20Application%20Programs%20from%20XCOBJ" class="TOC">14.1.  Conversion of Application Programs from XCOBJ</a>
</li><li>
<a href="#14.2.++Using+a+Serial+%28RS-232%29+Configurable+Camera+with+the+PIXCI%AE+CL1,%20CL2,%20CL3SD,%20D,%20D24,%20D32,%20D2X,%20D3X,%20E1,%20E1DB,%20E4,%20E4DB,%20EB1,%20EB1-PoCL,%20EC1,%20ECB1,%20ECB1-34,%20ECB2,%20EL1,%20EL1DB,%20ELS2,%20SI,%20SI1,%20SI2,+or+SI4" class="TOC">14.2.
Using a Serial (RS-232) Configurable Camera with the PIXCI® CL1, CL2,
CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1,
ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, or SI4</a>
<ul type="circle">
<li>
<a href="#14.2.1.%20%20Initialization%20of%20RS-232%20or%20Camera%20Link%20Serial%20Configured%20Cameras" class="TOC">14.2.1.  Initialization of RS-232 or Camera Link Serial Configured Cameras</a>
</li><li>
<a href="#14.2.2.%20%20Initialization%20of%20Camera%20Link%20Serial,%20I%3CSUP%3E%3CSMALL%3E2%3C/SMALL%3E%3C/SUP%3EC,%20or%20SPI%20Configured%20Cameras" class="TOC">14.2.2.  Initialization of Camera Link Serial, I<sup><small>2</small></sup>C, or SPI Configured Cameras</a>
</li><li>
<a href="#14.2.3.%20%20Adjustments%20to%20RS-232%20or%20Camera%20Link%20Serial%20Configured%20Cameras" class="TOC">14.2.3.  Adjustments to RS-232 or Camera Link Serial Configured Cameras</a>
</li><li>
<a href="#14.2.4.%20%20Adjustments%20to%20I%3CSUP%3E%3CSMALL%3E2%3C/SMALL%3E%3C/SUP%3EC%20or%20SPI%20Configured%20Cameras" class="TOC">14.2.4.  Adjustments to I<sup><small>2</small></sup>C or SPI Configured Cameras</a>
</li></ul>
</li><li>
<a href="#14.3.%20%20Using%20a%20Video%20Format%20Configuration%20Exported%20by%20XCAP" class="TOC">14.3.  Using a Video Format Configuration Exported by XCAP</a>
</li><li>
<a href="#14.4.%20%20Capture%20Directly%20into%20Memory%20Space%20of%20Other%20Devices" class="TOC">14.4.  Capture Directly into Memory Space of Other Devices</a>
<ul type="circle">
<li>
<a href="#14.4.1.++PIXCI%AE+SV4,%20SV5,%20SV5A,%20SV5B,%20SV5L,+SV7+and+DirectDraw" class="TOC">14.4.1.  PIXCI® SV4, SV5, SV5A, SV5B, SV5L, SV7 and DirectDraw</a>
</li><li>
<a href="#14.4.2.++PIXCI%AE+and+StreamStor" class="TOC">14.4.2.  PIXCI® and StreamStor</a>
</li></ul>
</li><li>
<a href="#14.5.++Adjusting+White+Balance+of+a+Bayer+Output+Camera+with+the+PIXCI%AE+Imaging+Board" class="TOC">14.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI® Imaging Board</a>
</li><li>
<a href="#14.6.++Processing+Images+from+a+Bayer+Output+Camera+with+the+PIXCI%AE+CL,%20D,%20E,+or+SI+Series" class="TOC">14.6.  Processing Images from a Bayer Output Camera with the PIXCI® CL, D, E, or SI Series</a>
</li></ul>
</li><li>
<a href="#15.%20%20Release%20Notes" class="TOC">15.  Release Notes</a>
</li><li>
<a href="#16.%20%20Distribution%20Contents" class="TOC">16.  Distribution Contents</a>
</li><li>
<a href="#Footnotes" class="TOC">17.  Footnotes</a>
</li><li>
<a href="#Index" class="TOC">Index</a>
</li></ul>
<!-- BODY BODY BODY -->
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Installation, Configuration, and Usage &#8212; Compile Time" class="Ch"></a>
<a name="1.  Installation, Configuration, and Usage &#8212; Compile Time"></a>
</p><h1>1.  Installation, Configuration, and Usage &#8212; Compile Time</h1>
<br>
<p>&nbsp;
<a name="Introduction" class="Ch"></a>
<a name="1.1.  Introduction"></a>
</p><h2>1.1.  Introduction</h2>
<p>
This manual describes the XCLIB and XCLIB-Lite ``C'' Library
for use with the EPIX®
PIXCI®
A, CL1, CL2, CL3SD,
D, D24, D32, D2X, D3X,
E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB,
SI, SI1, SI2, SI4, SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, SV7
imaging boards.
The library supports all current and previous versions of the
PIXCI®
imaging boards,
allowing convenient control and access to the features
of single imaging boards, or multiple imaging boards,
or one or more imaging boards with multiple functional units.<a href="#Footnote%201" class="Ff"><sup>[1]</sup></a>
</p><p>
This common manual discusses all PIXCI® imaging boards,
clearly identifying the common features and the distinguishing features
as seen through the XCLIB and XCLIB-Lite ``C'' Library.
An imaging board specific introduction to using XCLIB and XCLIB-Lite
can be found in the
''Getting Started with XCLIB''
chapter of the imaging board's specific manual,
such as the
<cite class="Ec">PIXCI® SV5 User's Manual</cite>,
<cite class="Ec">PIXCI® D2X User's Manual</cite>,
<cite class="Ec">PIXCI® CL1 User's Manual</cite>,
etc.
</p><p>
A comprehensive example Windows program named
<code class="Em">xclibex2.cpp</code>
is included with the library,
and demonstrates many of the library's functions.
In particular, it demonstrates a variety of techniques
for capturing and displaying video
on the graphics display (S/VGA), including the display of nondestructive overlays,
and the use of events to receive notification of captured images.
The example also demonstrates access to numeric pixel data.
</p><p>
An example DOS and Windows command line program named
<code class="Em">xclibex1.c</code>
is included with the library,
and demonstrates capturing images,
access to numeric pixel data,
and saving images in standard formats.
Under DOS, and in conjunction with the
<cite class="Ec">PXIPL Image Processing Library</cite>
the examples also demonstrates displaying
video on the graphics display (S/VGA).
</p><p>
An example Visual Basic program named
<code class="Em">xclibex3.txt</code>,
an example VB.NET program named
<code class="Em">xclibex6.txt</code>,
and an example C#.NET program named
<code class="Em">xclibex7.txt</code>
are included with the library, demonstrating
the fundamental library functions.
</p><p>
An example Windows program named
<code class="Em">xclibex4.cpp</code>
is included with the library,
and demonstrates capture of image sequences
at video rate and subsequent display on the graphics display (S/VGA).
An example Windows program named
<code class="Em">xclibex5.cpp</code>
is included with the library,
and demonstrates simultaneous operation of two imaging boards
at different resolutions.
An example Windows program named
<code class="Em">xclibexp.cpp</code>
is included with the library,
and demonstrates live display of processed video images.
</p><p>
An example Windows program named
<code class="Em">xclibexd.cpp</code>
is included with the library for use with the
SILICON VIDEO® 1281M, 1281C,
1310, 1310C,
2112, 2112C,
5C10, 5M10
642M, 642C, 643M, 643C,
9C10,
9M001, 9M001C, and 9T001C cameras,
and demonstrates camera specific controls as well as
capturing and displaying video
on the graphics display (S/VGA).
An example VB.NET program named
<code class="Em">xclibexd.txt</code>
provides a similar example.
</p><p>
An example Linux command line program named
<code class="Em">xclibel1.c</code>
is included with the library,
and demonstrates capturing images,
access to numeric pixel data,
and saving images in standard formats.
</p><p>
An example Linux GUI program named
<code class="Em">xclibel3.c</code>
is included with the library,
and demonstrates capturing images,
and displaying video
on the graphics display (S/VGA), using the Gnome Desktop.
</p><p>
These example programs can be compiled and executed to gain familiarity
with the library,
as well as the source code of each read in conjunction with this manual.
Instructions on setting options and compilation are contained within each
program.
</p><p>
A word about conventions used in this manual.
Highlighted phrases such as
<a href="#Introduction" class="Er">Introduction</a>
are a reference to a section of this manual.
Highlighted phrases such as
<cite class="Ec">FUNDAMENTALS OF DIGITAL IMAGE PROCESSING</cite>
are a reference to this manual or another publication.
Highlighted phrases such as
<code class="Em">file.xyz</code>
are a reference to a file.
Highlighted phrases such as
<em class="Ep">threshold</em>
typically refer to a function's parameters.
Older HTML browsers may not show these variations in a distinguished manner.
Unless explicitly differentiated otherwise, references to XCLIB include XCLIB-Lite.
</p><p>
This manual groups the library functions according
to expected patterns of use, or common effect.
The
<a href="#Index" class="Er">Index</a>
provides an alphabetically sorted
listing of function names.
<br>
</p><p>&nbsp;
<a name="Library Installation" class="Ch"></a>
<a name="1.2.  Library Installation"></a>
</p><h2>1.2.  Library Installation</h2>
<p>
While XCLIB is easy to install,
like most manufacturer's of PC software we recommend as a precaution
that a hard disk backup be performed
before installing XCLIB.
</p><p>
To install XCLIB on a PC with hard disk:
</p><ol type="1">
<p>
</p><li>
If XCLIB is provided on CD:
<ol type="i">
<p>
</p><li>
If your PC is set to allow automatic execution
of loaded CDs, the CD's interactive index program
will be executed automatically.
Otherwise, execute the index program, from a command prompt,
or via the Windows
''Start'',
''Run'':
<blockquote>
<pre>    &gt; Z:SETUP       (replace Z with drive letter for your CD)
</pre>
</blockquote>
<p>
</p></li><li>
Select
''Setup PIXCI(R) Imaging Software''
and one of:
<blockquote>
<pre>    XCLIB-Lite 'C' Library for Win 95/98/ME
    XCLIB-Lite 'C' Library for Win NT/2000/XP/Vista/7
    XCLIB 'C' Library for Win 95/98/ME
    XCLIB 'C' Library for Win NT/2000/XP/Vista/7
    XCLIB 'C' Library for Win XP(x64)/Vista(x64)/7(x64)
    XCLIB 'C' Library for DOS+Watcom+Tenberry
    XCLIB+PXIPL `C' Library for Win 95/98/ME
    XCLIB+PXIPL `C' Library for Win NT/2000/XP/Vista/7
    XCLIB+PXIPL `C' Library for Win XP(x64)/Vista(x64)/7(x64)
or
    XCLIB+PXIPL `C' Library for DOS+Watcom+Tenberry
</pre>
</blockquote>
as appropriate.
Click
''OK''.
<p>
</p></li><li>
Follow the installation program's directions, such as to
select an installation directory.
</li></ol>
<p>
</p></li><li>
If XCLIB is provided via the internet:
<ol type="i">
<p>
</p><li>
As directed by your customer service representative,
download a specified
<code class="Em">&nbsp;.EXE</code>
file from the EPIX, Inc. ftp site.
<p>
</p></li><li>
Execute the downloaded program, from a command prompt,
or via the Windows
''Start'',
''Run'':
<blockquote>
<pre>    &gt; MY.EXE
</pre>
</blockquote>
<p>
</p></li><li>
Follow the installation program's directions, such as to
select an installation directory.
<p>
</p></li><li>
Delete the downloaded
<code class="Em">&nbsp;.EXE</code>
file from your PC's hard drive.
</li></ol>
</li></ol>
After installation, any files in the chosen directory named
<code class="Em">*.TXT</code>
etc. contain distribution listings, corrections, or additions
to this manual, or other up-to-date information.
<p>
The example
<code class="Em">xclibex1.c</code>,
<code class="Em">xclibex2.cpp</code>,
<code class="Em">xclibex3.txt</code>,
<code class="Em">xclibex6.txt</code>,
<code class="Em">xclibex7.txt</code>,
<code class="Em">xclibex4.cpp</code>,
<code class="Em">xclibex5.cpp</code>,
<code class="Em">xclibel1.c</code>,
or
<code class="Em">xclibel3.c</code>
program, or your application program,
can now be compiled and run.
<br>
</p><p>&nbsp;
<a name="Compiling" class="Ch"></a>
<a name="1.3.  Compiling"></a>
</p><h2>1.3.  Compiling</h2>
<p>
The library is compatible with
the following compilers, versions, memory models, and environments:
<a name="Libraries NX0" class="NX"></a>
<a name="Compilation NX1" class="NX"></a>
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="center">
            
</td>
<td colspan="1" align="center">
     
</td>
<td colspan="1" align="center">
            
</td>
<td colspan="1" align="center">
                   
</td>
<td colspan="1" align="center">
Execution  
</td>
<td colspan="1" align="center">
Run Time
</td>
</tr>
<tr>
<td colspan="1" align="center">
Compiler    
</td>
<td colspan="1" align="center">
Model
</td>
<td colspan="1" align="center">
Library Name
</td>
<td colspan="1" align="center">
Compiled w. Options
</td>
<td colspan="1" align="center">
Environment
</td>
<td colspan="1" align="center">
Modules
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="3"></td></tr>
<tr>
<td colspan="2" align="left">
Any 32 bit Microsoft 
</td>
<td colspan="1" align="left">
<code>XCLIBW95.LIB</code>
</td>
<td colspan="1" align="left">
<code>-GB -MT -LD</code>
</td>
<td colspan="1" align="left">
Windows 95
</td>
<td colspan="1" align="left">
<code>XCLIBW95.DLL</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
Compatible Compiler  
</td>
<td colspan="1" align="left">
      or                    
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows 98
</td>
<td colspan="1" align="left">
<code>EPIXXCW5.VXD</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
<code>XCLYBW95.LIB</code>
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows ME
</td>
<td colspan="1" align="left">
<code>EPIXXCW5.INF</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
          
</td>
<td colspan="1" align="left">
<code>EPIXXC.SYS (optional)</code>
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
Any 32 bit Microsoft 
</td>
<td colspan="1" align="left">
<code>XCLIBWNT.LIB</code>
</td>
<td colspan="1" align="left">
<code>-GB -MT -LD</code>
</td>
<td colspan="1" align="left">
Windows NT  
</td>
<td colspan="1" align="left">
<code>XCLIBWNT.DLL</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
Compatible Compiler  
</td>
<td colspan="1" align="left">
      or                    
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
            
</td>
<td colspan="1" align="left">
<code>EPIXXCWT.SYS</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
<code>XCLYBWNT.LIB</code>
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
            
</td>
<td colspan="1" align="left">
<code>EPIXXCWT.INF</code>
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
Any 32 bit Microsoft 
</td>
<td colspan="1" align="left">
<code>XCLIBWNT.LIB</code>
</td>
<td colspan="1" align="left">
<code>-GB -MT -LD</code>
</td>
<td colspan="1" align="left">
Windows 2000       
</td>
<td colspan="1" align="left">
<code>XCLIBWNT.DLL</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
Compatible Compiler  
</td>
<td colspan="1" align="left">
      or                    
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows XP         
</td>
<td colspan="1" align="left">
<code>EPIXXCW2.SYS</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
<code>XCLYBWNT.LIB</code>
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows Vista      
</td>
<td colspan="1" align="left">
<code>EPIXXCW2.INF</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows 7          
</td>
<td colspan="1" align="left">
<code>EPIXXCW2.CAT</code>
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
Any 32 bit Microsoft 
</td>
<td colspan="1" align="left">
<code>XCLIBWNT.LIB</code>
</td>
<td colspan="1" align="left">
<code>-GB -MT -LD</code>
</td>
<td colspan="1" align="left">
Windows XP(x64)    
</td>
<td colspan="1" align="left">
<code>XCLIBWNT.DLL</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
Compatible Compiler  
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows Vista(x64) 
</td>
<td colspan="1" align="left">
<code>EPIXXCW6.SYS</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows 7(x64)     
</td>
<td colspan="1" align="left">
<code>EPIXXCW6.INF</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
                   
</td>
<td colspan="1" align="left">
<code>EPIXXCW6.CAT</code>
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
Any 64 bit Microsoft 
</td>
<td colspan="1" align="left">
<code>XCLIBW64.LIB</code>
</td>
<td colspan="1" align="left">
<code>-GB -MT -LD</code>
</td>
<td colspan="1" align="left">
Windows XP(x64)    
</td>
<td colspan="1" align="left">
<code>XCLIBW64.DLL</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
Compatible Compiler  
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows Vista(x64) 
</td>
<td colspan="1" align="left">
<code>EPIXXCW6.SYS</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
Windows 7(x64)     
</td>
<td colspan="1" align="left">
<code>EPIXXCW6.INF</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
                     
</td>
<td colspan="1" align="left">
                            
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
                   
</td>
<td colspan="1" align="left">
<code>EPIXXCW6.CAT</code>
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
GNU V3 or V4       
</td>
<td colspan="1" align="left">
<code>xclib_i386.a</code> 
</td>
<td colspan="1" align="left">
                     
</td>
<td colspan="1" align="left">
Linux 2.4 kernels 
</td>
<td colspan="1" align="left">
<code>pixci_i386.o</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
32 bit             
</td>
<td colspan="1" align="left">
                             
</td>
<td colspan="1" align="left">
                     
</td>
<td colspan="1" align="left">
                  
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
GNU V3 or V4       
</td>
<td colspan="1" align="left">
<code>xclib_i386_pic.a</code> 
</td>
<td colspan="1" align="left">
 <code>-fPIC</code> 
</td>
<td colspan="1" align="left">
Linux 2.4 kernels 
</td>
<td colspan="1" align="left">
<code>pixci_i386.o</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
32 bit             
</td>
<td colspan="1" align="left">
                             
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
                  
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
GNU V3 or V4       
</td>
<td colspan="1" align="left">
<code>xclib_i386.a</code> 
</td>
<td colspan="1" align="left">
                     
</td>
<td colspan="1" align="left">
Linux 2.6 kernels  
</td>
<td colspan="1" align="left">
<code>pixci_i386.ko</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
32 bit             
</td>
<td colspan="1" align="left">
                             
</td>
<td colspan="1" align="left">
                     
</td>
<td colspan="1" align="left">
                   
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
GNU V3 or V4       
</td>
<td colspan="1" align="left">
<code>xclib_i386_pic.a</code> 
</td>
<td colspan="1" align="left">
 <code>-fPIC</code> 
</td>
<td colspan="1" align="left">
Linux 2.6 kernels  
</td>
<td colspan="1" align="left">
<code>pixci_i386.ko</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
32 bit             
</td>
<td colspan="1" align="left">
                             
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
                   
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
GNU V3 or V4       
</td>
<td colspan="1" align="left">
<code>xclib_x86_64.a</code> 
</td>
<td colspan="1" align="left">
                   
</td>
<td colspan="1" align="left">
Linux 2.6 kernels  
</td>
<td colspan="1" align="left">
<code>pixci_x86_64.ko</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
64 bit             
</td>
<td colspan="1" align="left">
                               
</td>
<td colspan="1" align="left">
                   
</td>
<td colspan="1" align="left">
                   
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="2" align="left">
GNU V3 or V4       
</td>
<td colspan="1" align="left">
<code>xclib_x86_64_pic.a</code> 
</td>
<td colspan="1" align="left">
 <code>-fPIC</code> 
</td>
<td colspan="1" align="left">
Linux 2.6 kernels  
</td>
<td colspan="1" align="left">
<code>pixci_x86_64.ko</code>
</td>
</tr>
<tr>
<td colspan="2" align="left">
64 bit             
</td>
<td colspan="1" align="left">
                               
</td>
<td colspan="1" align="left">
                         
</td>
<td colspan="1" align="left">
                   
</td>
</tr>
<tr><td colspan="6"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
</td>
<td colspan="1" align="left">
f, 32 bit
</td>
<td colspan="1" align="left">
<code>XCLBW0DF.LIB</code>
</td>
<td colspan="1" align="left">
<code>-4r -mf -w3 -ox</code>
</td>
<td colspan="1" align="left">
DOS4GW      
</td>
<td colspan="1" align="left">
none
</td>
</tr>
<tr>
<td colspan="1" align="left">
</td>
<td colspan="1" align="left">
         
</td>
<td colspan="1" align="left">
                               
</td>
<td colspan="1" align="left">
                             
</td>
<td colspan="1" align="left">
Professional
</td>
</tr>
<tr>
<td colspan="1" align="left">
</td>
</tr>
<tr>
<td colspan="1" align="left">
Watcom C/C++ V11.0   
</td>
<td colspan="1" align="left">
f, 32 bit
</td>
<td colspan="1" align="left">
<code>XCLBW1DF.LIB</code>
</td>
<td colspan="1" align="left">
<code>-4r -mf -w3 -ox</code>
</td>
<td colspan="1" align="left">
DOS4GW      
</td>
<td colspan="1" align="left">
none
</td>
</tr>
<tr>
<td colspan="1" align="left">
                     
</td>
<td colspan="1" align="left">
         
</td>
<td colspan="1" align="left">
                               
</td>
<td colspan="1" align="left">
                             
</td>
<td colspan="1" align="left">
Professional
</td>
</tr>
</tbody></table>
</pre>
</div>
<br>
For Linux, the XCAP application includes a driver recompilation kit,
allowing compiling an additional XCLIB driver so as to exactly match the current kernel.
The Compiled w. Options column shows the significant
options used for creation of each library.
The exact options shown are neither necessary,
nor necessarily desirable, when compiling an application program.
<br>
<a name="Stack" class="Ch"></a>
<a name="1.3.1.  Stack"></a>
<h3>1.3.1.  Stack</h3>
<p>
The available stack space required by the
base XCLIB ``C'' Library is
4096 bytes
plus 8 times the memory space required for an image's line or column.
If the optional
<cite class="Ec">PXIPL Image Processing Library</cite>
is used, the additional stack space required is
4096 bytes
plus 4 times the memory space required for an image's line or column.
The application program may require significant amounts of additional stack space.
Under some operating systems, additional stack space may
have to be declared during compilation
or linkage to accommodate the total requirement.
</p><p>
<br>
<b class="Hv">Note.</b>
<a name="Stack Overflow NX2" class="NX"></a>
For efficiency, the XCLIB library
is compiled without explicit stack checks (probes).
Invoking a library function with insufficient available stack
space will produce strange and catastrophic results.
<br>
<a name="Heap" class="Ch"></a>
<a name="1.3.2.  Heap"></a>
</p><h3>1.3.2.  Heap</h3>
<p>
The XCLIB ``C'' Library does not require any large
<cite class="Ec">malloc</cite>'ed
storage, other than the host memory allocated for image frame buffers.
In addition, smaller amounts of host memory (approximately 64 or 128 bytes
per frame buffer) are used for per-buffer status information
such as time stamps.
</p><p>
The PIXCI®&nbsp;CL3SD and SI2 use on-board memory instead of host memory
for image frame buffers.
Host memory (approximately 1 MByte) is needed as a DMA buffer
and for per-buffer status information such as time stamps.
</p><p>
With the PIXCI®&nbsp;CL1, CL2, CL3SD, D, D24, D32, D2X, D3X,
E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, SI, SI1, SI2, or SI4 imaging board,
when used with a color camera where XCLIB provides
white balancing,
approximately 8*2<sup><small>BitsPerPixel</small></sup> bytes of
<cite class="Ec">malloc</cite>'ed
storage is required for each video state.
</p><p>
Several small amounts of storage, of a few hundred bytes each, are
<cite class="Ec">malloc</cite>'ed
for storage of video state and internal structures.
<br>
<a name="Memory Allocation Hooks" class="Ch"></a>
<a name="1.3.3.  Memory Allocation Hooks"></a>
</p><h3>1.3.3.  Memory Allocation Hooks</h3>
<p>
The XCLIB invokes the ``C'' library function
<cite class="Ec">malloc</cite>
to obtain memory for temporary use.
The application programmer may modify
the memory allocation used by XCLIB.
This substitution is not available when XCLIB is embedded in a
Windows DLL.
</p><p>
Most memory allocated and freed by XCLIB,
except memory allocated for image frame buffers,
and most memory allocated and freed by the
<cite class="Ec">PXIPL Image Processing Library</cite>,
if used,
is actually obtained and released by invoking internal functions
<cite class="Ec">pxmalloc</cite>,
<cite class="Ec">pxfree</cite>,
<cite class="Ec">pxrealloc</cite>,
<cite class="Ec">pxmallocf16</cite>,
and
<cite class="Ec">pxfreef16</cite>
which are defined in module PXMALLOC.OBJ as:<a href="#Footnote%202" class="Ff"><sup>[2]</sup></a>
</p><blockquote>
<pre>/* 16/32 bit environments */
void *     _cfunfcc pxmalloc(uint len)          { if(!len)return(NULL);
                                                  return(malloc(len));   }
void       _cfunfcc pxfree(void*buf)            { free(buf);             }
void *     _cfunfcc pxrealloc(void*p, uint len) { if(!p&amp;&amp;!len)return(NULL);
                                                  return(realloc(p,len));}
<br>
/* 16 bit environments */
void _far* _cfunfcc pxmallocf16(uint len)       { if(!len)return(NULL);
                                                  return(_fmalloc(len)); }
void       _cfunfcc pxfreef16(void _far*buf)    { _ffree(buf);           }
<br>
/* 32 bit environments */
void *     _cfunfcc pxmallocf16(uint len)       { if(!len)return(NULL);
                                                  return(malloc(len));   }
void       _cfunfcc pxfreef16(void*buf)         { free(buf);             }
</pre>
</blockquote>
The application program may provide alternate functions with the
same name and semantics,
to be selected by the linker in preference to the above definitions.
<br>
<p>&nbsp;
<a name="Compile Time Inclusions" class="Ch"></a>
<a name="1.4.  Compile Time Inclusions"></a>
</p><h2>1.4.  Compile Time Inclusions</h2>
<a name="Inclusions NX3" class="NX"></a>
<p>
The
<code class="Em">xcliball.h</code>
file
directly or indirectly contains all prototype function declarations
and definitions of constants and declaration of structures
needed for XCLIB.
Proper use of library functions requires inclusion of
<code class="Em">xcliball.h</code>
by using the statement:
</p><blockquote>
<pre>#include "xcliball.h"
</pre>
</blockquote>
at the start of each source file of the application program
that uses XCLIB functions.
<p>
If using
<code class="Em">xcliball.h</code>
within a C++ program, then:
</p><blockquote>
<pre>extern "C" {
#include "xcliball.h"
}
</pre>
</blockquote>
should be used.<a href="#Footnote%203" class="Ff"><sup>[3]</sup></a>
<p>
If using
<code class="Em">xcliball.h</code>
in a Windows environment, a
</p><blockquote>
<pre>#include &lt;windows.h&gt;
</pre>
</blockquote>
must (not necessarily immediately) precede
<blockquote>
<pre>#include "xcliball.h"
</pre>
</blockquote>
<p>
Several examples shown in this manual utilize the ``C'' construct
''NULL''
to represent
''(void&nbsp;*)&nbsp;0''.
Application programs which use NULL must include the appropriate ``C''
include file, such as
<code class="Em">stdio.h</code>
or
<code class="Em">stdlib.h</code>.
<br>
</p><p>&nbsp;
<a name="Common Types and Concepts" class="Ch"></a>
<a name="1.5.  Common Types and Concepts"></a>
</p><h2>1.5.  Common Types and Concepts</h2>
<p>
Common concepts, data types, and modifiers are discussed below,
rather than repeatedly discussed with each function.
These concepts and data types are applicable
to the SCF Style Interface,
the SCF+ Style Interface,
and the Structured Style Interface.
<br>
<a name="Types" class="Ch"></a>
<a name="1.5.1.  Types"></a>
</p><h3>1.5.1.  Types</h3>
<p>
The following data types
are automatically provided via inclusion of
<code class="Em">xcliball.h</code>;
the programmer need not
''define''
or
''typedef''
these symbols.
</p><p>
Types defined by ``C'':
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
Symbol      
</td>
<td colspan="1" align="left">
 ``C'' Definition   
</td>
<td colspan="1" align="left">
 Use
</td>
</tr>
<tr>
<td colspan="1" align="left">
size_t      
</td>
<td colspan="1" align="left">
 typically unsigned int 
</td>
<td colspan="1" align="left">
 size of memory objects
</td>
</tr>
<tr>
<td colspan="1" align="left">
            
</td>
<td colspan="1" align="left">
 or unsigned long       
</td>
<td colspan="1" align="left">
 (i.e. malloc())
</td>
</tr>
</tbody></table>
</pre>
</div>
<a name="size_t NX4" class="NX"></a>
<a name="Type size_t NX5" class="NX"></a>
<p>
Extended data types:
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
Symbol       
</td>
<td colspan="1" align="left">
 ``C'' Definition 
</td>
<td colspan="1" align="left">
 Use
</td>
</tr>
<tr>
<td colspan="1" align="left">
uchar        
</td>
<td colspan="1" align="left">
 unsigned char    
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
ushort       
</td>
<td colspan="1" align="left">
 unsigned short   
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
uint         
</td>
<td colspan="1" align="left">
 unsigned int     
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
ulong        
</td>
<td colspan="1" align="left">
 unsigned long    
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
schar        
</td>
<td colspan="1" align="left">
 signed char      
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
sshort       
</td>
<td colspan="1" align="left">
 signed short     
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
sint         
</td>
<td colspan="1" align="left">
 signed int       
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
slong        
</td>
<td colspan="1" align="left">
 signed long      
</td>
<td colspan="1" align="left">
 general
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxcoord_t  
</td>
<td colspan="1" align="left">
 int              
</td>
<td colspan="1" align="left">
 x, y, z image coordinates
</td>
</tr>
<tr>
<td colspan="1" align="left">
pximcnt_t  
</td>
<td colspan="1" align="left">
 unsigned int     
</td>
<td colspan="1" align="left">
 image data transfer size
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxim1size_t
</td>
<td colspan="1" align="left">
 unsigned int     
</td>
<td colspan="1" align="left">
 image line size
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxim2size_t
</td>
<td colspan="1" align="left">
 unsigned long    
</td>
<td colspan="1" align="left">
 image size
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxim3size_t
</td>
<td colspan="1" align="left">
 unsigned long    
</td>
<td colspan="1" align="left">
 image sequence size
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxbuffer_t 
</td>
<td colspan="1" align="left">
 long             
</td>
<td colspan="1" align="left">
 image buffer number/index
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvbtime_t 
</td>
<td colspan="1" align="left">
 unsigned long    
</td>
<td colspan="1" align="left">
 video field counts/time
</td>
</tr>
<tr>
<td colspan="1" align="left">
pximaplen_t
</td>
<td colspan="1" align="left">
 unsigned long    
</td>
<td colspan="1" align="left">
 length of 'imap' mapping
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxapiadrs_t
</td>
<td colspan="1" align="left">
 unsigned long    
</td>
<td colspan="1" align="left">
 frame buffer memory address and length
</td>
</tr>
<tr>
<td colspan="1" align="left">
_farimap   
</td>
<td colspan="1" align="left">
 _far or blank  
</td>
<td colspan="1" align="left">
 farness of an 'imap' pointer
</td>
</tr>
</tbody></table>
</pre>
</div>
<a name="uchar NX6" class="NX"></a>
<a name="uint NX7" class="NX"></a>
<a name="ushort NX8" class="NX"></a>
<a name="ulong NX9" class="NX"></a>
<a name="schar NX10" class="NX"></a>
<a name="sint NX11" class="NX"></a>
<a name="sshort NX12" class="NX"></a>
<a name="slong NX13" class="NX"></a>
<a name="pxcoord_t NX14" class="NX"></a>
<a name="pximcnt_t NX15" class="NX"></a>
<a name="pxim1size_t NX16" class="NX"></a>
<a name="pxim2size_t NX17" class="NX"></a>
<a name="pxim3size_t NX18" class="NX"></a>
<a name="pxbuffer_t NX19" class="NX"></a>
<a name="pxvbtime_t NX20" class="NX"></a>
<a name="_farimap NX21" class="NX"></a>
<a name="uchar" class="Tr"></a>
<a name="uint" class="Tr"></a>
<a name="ushort" class="Tr"></a>
<a name="ulong" class="Tr"></a>
<a name="schar" class="Tr"></a>
<a name="sint" class="Tr"></a>
<a name="sshort" class="Tr"></a>
<a name="slong" class="Tr"></a>
<a name="pxcoord_t" class="Tr"></a>
<a name="pximcnt_t" class="Tr"></a>
<a name="pxim1size_t" class="Tr"></a>
<a name="pxim2size_t" class="Tr"></a>
<a name="pxim3size_t" class="Tr"></a>
<a name="pxbuffer_t" class="Tr"></a>
<a name="pxvbtime_t" class="Tr"></a>
<a name="pximaplen_t" class="Tr"></a>
<a name="pxapiadrs_t" class="Tr"></a>
<a name="_farimap" class="Tr"></a>
<a name="Type uchar NX22" class="NX"></a>
<a name="Type uint NX23" class="NX"></a>
<a name="Type ushort NX24" class="NX"></a>
<a name="Type ulong NX25" class="NX"></a>
<a name="Type schar NX26" class="NX"></a>
<a name="Type sint NX27" class="NX"></a>
<a name="Type sshort NX28" class="NX"></a>
<a name="Type slong NX29" class="NX"></a>
<a name="Type pxcoord_t NX30" class="NX"></a>
<a name="Type pximcnt_t NX31" class="NX"></a>
<a name="Type pxim1size_t NX32" class="NX"></a>
<a name="Type pxim2size_t NX33" class="NX"></a>
<a name="Type pxim3size_t NX34" class="NX"></a>
<a name="Type pxbuffer_t NX35" class="NX"></a>
<a name="Type pxvbtime_t NX36" class="NX"></a>
<a name="Type pximaplen_t NX37" class="NX"></a>
<a name="Type pxapiadrs_t NX38" class="NX"></a>
<a name="Type _farimap NX39" class="NX"></a>
<br>
<a name="Modifiers" class="Ch"></a>
<a name="1.5.2.  Modifiers"></a>
<h3>1.5.2.  Modifiers</h3>
The following function calling convention modifiers
are automatically provided via inclusion of
<code class="Em">xcliball.h</code>;
the programmer need not
''define''
or
''typedef''
these symbols:
<div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
Symbol          
</td>
<td colspan="1" align="left">
 Typical Definition
</td>
</tr>
<tr>
<td colspan="1" align="left">
_cfunfcc      
</td>
<td colspan="1" align="left">
 _fastcall or _pascal or _stdcall
</td>
</tr>
<tr>
<td colspan="1" align="left">
_cfunvcc      
</td>
<td colspan="1" align="left">
 _cdecl or blank
</td>
</tr>
<tr>
<td colspan="1" align="left">
_cfunacc      
</td>
<td colspan="1" align="left">
 _cdecl or blank
</td>
</tr>
</tbody></table>
</pre>
</div>
<a name="_cfunfcc NX40" class="NX"></a>
<a name="_cfunvcc NX41" class="NX"></a>
<a name="_cfunacc NX42" class="NX"></a>
<a name="_cfunfcc" class="Tr"></a>
<a name="_cfunvcc" class="Tr"></a>
<a name="_cfunacc" class="Tr"></a>
<a name="Type _cfunfcc NX43" class="NX"></a>
<a name="Type _cfunvcc NX44" class="NX"></a>
<a name="Type _cfunacc NX45" class="NX"></a>
These modifiers vary in different environments,
accommodating different conventions under DOS, Windows,
and various compilers.
Function prototypes apply modifiers automatically, thus
the programmer need not normally be aware of their existence,
nor are the modifiers normally shown in documentation.
The exception to the programmer's need of awareness, and shown
in the documentation,
are modifiers for functions that are
''called back''
from library functions.
<br>
<a name="Call Back Types" class="Ch"></a>
<a name="1.5.3.  Call Back Types"></a>
<h3>1.5.3.  Call Back Types</h3>
The following call back function calling convention modifiers
are automatically provided via inclusion of
<code class="Em">xcliball.h</code>;
the programmer need not
''define''
or
''typedef''
these symbols:
<div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
Symbol          
</td>
<td colspan="1" align="left">
 Use
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxabortfunc_t 
</td>
<td colspan="1" align="left">
 premature termination callback predicate function
</td>
</tr>
</tbody></table>
</pre>
</div>
<a name="pxabortfunc_t NX46" class="NX"></a>
<a name="pxabortfunc_t" class="Tr"></a>
<a name="Type pxabortfunc_t NX47" class="NX"></a>
<p>
<a name="The pxabortfunc_t" class="Ch"></a>
<a name="1.5.3.1.  The pxabortfunc_t"></a>
</p><h4>1.5.3.1.  The pxabortfunc_t</h4>
Some services, such as the
<a href="#::bufferSaveStream" class="Er">::bufferSaveStream</a>
and
<a href="#::bufferLoadStream" class="Er">::bufferLoadStream</a>
accept an
<em class="Ep">abortp</em>
parameter of type
<em class="Ep">pxabortfunc_t</em>,
which is declared in
<code class="Em">xcliball.h</code>
as:
<blockquote>
<pre>typedef int (_cfunfcc pxabortfunc_t)(void*,int,int);
</pre>
</blockquote>
If
<em class="Ep">abortp</em>&#8800;NULL,
the service will periodically invoke:
<blockquote>
<pre>(*abortp)(abortp, ipos, npos);
</pre>
</blockquote>
and prematurely terminate if the return value is nonzero,
echoing the same return value.
Use of termination values less than 0 is required, and use of the
particular value PXERBREAK, is suggested.
<p>
The values passed as
<em class="Ep">done</em>
and
<em class="Ep">total</em>
indicate the approximate progress of the service.
If
<em class="Ep">total</em>&gt;0,
then the service, or one phase of the service, is approximately
<em class="Ep">done</em>*100./<em class="Ep">total</em>
percent complete.
If
<em class="Ep">total</em>=0
and
<em class="Ep">done</em>=0,
that invocation of
<em class="Ep">*abortp</em>
is not updating the progress information,
or the service does not provide progress information.
</p><p>
If
<em class="Ep">total</em>&lt;0,
then the processing is being done in phases,
with each phase independently reporting progress from 0 to 100%;
the number of phases is
-<em class="Ep">total</em>,
of which the current phase is
<em class="Ep">done</em>,
where
1&lt;=<em class="Ep">done</em>&lt;=-<em class="Ep">total</em>.
The processing time required may differ among the phases.
</p><p>
If
<em class="Ep">total</em>=0
and
<em class="Ep">done</em>&#8800;0,
then the value
<em class="Ep">done</em>
should be added to an internal
''disable''
counter whose
initial value is 0.
While the disable counter is less than 0,
interpretation of invocations with
<em class="Ep">total</em>&gt;0
(percent completion)
or
<em class="Ep">total</em>&lt;0
(operation phase)
should be ignored.
</p><p>
The
<em class="Ep">total</em>
and
<em class="Ep">done</em>
values are intended solely for optionally
advising an interactive user of computational progress,
and have accuracy suitable only for such use.
<br>
<a name="Usage Assumptions" class="Ch"></a>
<a name="1.5.4.  Usage Assumptions"></a>
</p><h3>1.5.4.  Usage Assumptions</h3>
<p>
Except where noted otherwise, the library functions expect that the
library is currently open for use.
The most notable excepttions are, of course,
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>
or
<a href="#xclib_open" class="Er">xclib_open</a>
which open the library,
and
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>
or
<a href="#pxe_XCLIBuninstantiate" class="Er">pxe_XCLIBuninstantiate</a>
to (un)instantiate instances of the library.
The
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>,
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>,
and/or
<a href="#pxd_mesgErrorCode" class="Er">pxd_mesgErrorCode</a>
can be used if the open failed,
to obtain additional information on the cause of failure.
<br>
<a name="On Frame Buffers and Memory" class="Ch"></a>
<a name="1.5.5.  On Frame Buffers and Memory"></a>
</p><h3>1.5.5.  On Frame Buffers and Memory</h3>
<p>
For PIXCI®&nbsp;A, CL1, CL2, D, D24, D32, D2X, D3X,
E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, SI, SI1, SI4,
SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, or SV7 imaging boards
which do not have on-board frame buffer memory,
the XCLIB architecture
uses a fixed amount of frame buffer memory.
Under Windows 95, 98, ME, NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64),
the frame buffer memory is allocated when Windows boots;
the total size is fixed until the next reboot.
Under DOS+Tenberry, the frame buffer
memory is allocated when the XCLIB is opened;
the total size is fixed until XCLIB is re-opened.
Under Linux, the frame buffer
memory is allocated when Linux boots;
the total size is fixed until the next reboot.
</p><p>
For all PIXCI®&nbsp;imaging boards,
the frame buffer memory is partitioned into image
frame buffers, based upon the number of PIXCI(rg
imaging boards in use and the video format configuration
and resolution for each imaging board.
The frame buffer memory is re-partitioned
whenever the number of PIXCI(rg imaging boards in use changes,
or the video format configuration changes.
</p><p>
An XCLIB function such as:
</p><blockquote>
<pre>    pxd_goLive(..., 1);
</pre>
</blockquote>
which commands live capture of all fields or frames
into image frame buffer 1,
does not produce a
''history''
of all fields or frames captured, nor use any memory
other than image frame buffer 1;
each newly captured field or frame overlays the data
of the previously captured field or frame.
Similarly,
<blockquote>
<pre>    pxd_doSnap(..., 1, ...);
    pxd_doSnap(..., 1, ...);
</pre>
</blockquote>
snaps two fields or frames into image frame buffer 1;
the latter overlaying the former.
<p>
The image frame buffers for each imaging board
are numbered consecutively starting with 1.
Thus when using multiple imaging boards, the XCLIB function
</p><blockquote>
<pre>    pxd_goLive(0x03, 1);
</pre>
</blockquote>
which commands both imaging boards one and two to begin
capturing into buffer number 1,
does not cause conflict or overwriting of image data;
each board has its own, unique, buffer number 1.
Similarly, when accessing pixel data or saving the contents
of the frame buffer to a file,
the appropriate functions require a buffer number
as well as a qualifying imaging board number (i.e.
''unit'').
<p>
Video capture is always into one of these image frame buffers,
and never to an
<cite class="Ec">malloc</cite>'ed
buffer provided by the application program.
The XCLIB library provides functions to read/write all or portions
of a frame buffer to a program's array or
<cite class="Ec">malloc</cite>'ed
buffer.
The XCLIB library also provides the application program
with a pointer into the actual image frame buffer.<a href="#Footnote%204" class="Ff"><sup>[4]</sup></a>
</p><p>
Since the total number of image frame buffers
cannot be increased arbitrarily (for a given number
of image boards and a fixed video format resolution),
a live sequence capture with:
</p><blockquote>
<pre>    pxd_LiveSeq(...)
</pre>
</blockquote>
is limited to the number of image frame buffers.
However, nothing precludes the application from
executing a continuous live sequence capture
using the image frame buffers in a circular fashion,
and copying the contents of a newly captured
image frame buffer elsewhere (such as
<cite class="Ec">malloc</cite>'ed
memory, or to disk)
before the live sequence capture
''returns''
and re-uses that buffer.
<br>
<a name="On the Semantics of Snap" class="Ch"></a>
<a name="1.5.6.  On the Semantics of Snap"></a>
<h3>1.5.6.  On the Semantics of Snap</h3>
<p>
Functions to snap a video field or frame,
such as
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
capture the next field or frame following its invocation;
that is, the function
''arms''
the PIXCI® imaging board to capture the next field or frame
into a frame buffer.
This is in contrast to having the imaging board consume
resources continuously capturing every field or frame,
and having a hypothetical snap function retrieve the last
field or frame captured.
This hypothetical behavior
<u class="U">can</u>
be obtained in XCLIB using
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>
or similar functions,
but it isn't the behavior of the snap functions.
<br>
<a name="On Imaging Boards with Multiple Functional Units" class="Ch"></a>
<a name="1.5.7.  On Imaging Boards with Multiple Functional Units"></a>
</p><h3>1.5.7.  On Imaging Boards with Multiple Functional Units</h3>
<p>
<a name="Functional Units NX48" class="NX"></a>
The PIXCI®&nbsp;E1DB, ECB2, EL1DB, and E4DB imaging boards contain multiple, independent
functional units within a single physical board
and replaces two PIXCI®&nbsp;E1, ECB1, EL1, or E4 imaging boards, respectively.
The PIXCI®&nbsp;ELS2 imaging board contains multiple, independent
functional units within a single physical board
and provides features similar to two PIXCI®&nbsp;SI imaging boards.
The PIXCI®&nbsp;SI2, and SI4 imaging boards contain multiple, independent
functional units within a single physical board
and replaces two or four PIXCI®&nbsp;SI imaging boards, respectively.
The PIXCI®&nbsp;SV7 imaging board contains multiple, independent
functional units within a single physical board
and provides features similar to two PIXCI®&nbsp;SV5B imaging boards.
The XCLIB Library presents the two halves or four quarters of the
PIXCI®&nbsp;E1DB, E4DB, ECB2, EL1DB, ELS2, SI2, SI4, SV7 imaging board
as two or four PIXCI®&nbsp;E1, E4, ECB1, EL1, SI, SI, SI, SV5B imaging boards,
accessed and controlled via a
<em class="Ep">unitmap</em>
parameter as described below.
Each half or quarter of the PIXCI®&nbsp;E1DB, E4DB, ECB2, EL1DB, ELS2,
SI2, SI4, SV7 imaging board may be opened and used independently.
Within software documentation,
''imaging board''
is synonomous with
''functional units''
unless explicitly stated otherwise.
<br>
<a name="On Multiple Imaging Boards" class="Ch"></a>
<a name="1.5.8.  On Multiple Imaging Boards"></a>
</p><h3>1.5.8.  On Multiple Imaging Boards</h3>
<p>
Each open instance of the library allows
operation of one or more identical imaging boards;
the imaging boards may have
independent video format and resolution.
Relevant XCLIB functions allow simultaneous control
of multiple boards via the
<em class="Ep">unitmap</em>
parameter.<a href="#Footnote%205" class="Ff"><sup>[5]</sup></a>
</p><p>
Multiple instances of the
library may be opened for mutually exclusive subsets
of imaging boards.
Different open instances are independent;
they do not share Video State ID's or
Video Format Configuration's.
A single invocation of a XCLIB function
can't control multiple imaging boards across multiple open
instances of the library.
</p><p>
Only one instance of the library may be opened
via the SCF Style Interface.
<br>
<a name="On Multiple Identical Imaging Boards" class="Ch"></a>
<a name="1.5.9.  On Multiple Identical Imaging Boards"></a>
</p><h3>1.5.9.  On Multiple Identical Imaging Boards</h3>
<p>
A single open instance of
XCLIB supports the operation of multiple identical
PIXCI(rg imaging boards, typically referred to as
''units''.
Each relevant XCLIB function provides a
<em class="Ep">unitmap</em>
parameter to select which boards, or boards,
an invocation of that function is to affect.
The
<em class="Ep">unitmap</em>
is a bit-map;
the
<em class="Ep">i'th</em>
bit has value 1 to select the
<em class="Ep">i</em>'th
imaging board.
</p><p>
Some functions allow operation on multiple
imaging boards with a single invocation;
they describe
<em class="Ep">unitmap</em>
with the phrasing
''on each of the multiple boards selected by ...''.
</p><p>
Some functions only allow operation on a single imaging board
with a single invocation;
they describe
<em class="Ep">unitmap</em>
with the phrasing
''the single imaging board selected by ...''.
Should the
<em class="Ep">unitmap</em>
have more than one bit set to 1, the imaging board corresponding
to the rightmost 1 bit is selected for use.
<br>
<a name="On Serial Ports" class="Ch"></a>
<a name="1.5.10.  On Serial Ports"></a>
</p><h3>1.5.10.  On Serial Ports</h3>
<p>
PIXCI® imaging cards for use with Camera Link camera
include a serial port (i.e. similar to asynchronous RS-232)
for configuring cameras through the Camera Link cable.
</p><p>
Under Windows, in compliance with the Camera Link standard,
the
<code class="Em">clserEPX.dll</code>,
available separately,
provides the standard Camera Link Serial API
with
<a href="#clSerialInit" class="Er">clSerialInit</a>
and related functions
for sending and receiving serial data.
The
<code class="Em">clserEPX.dll</code>
is most often used by application programs that need an imaging-board
independent method to access Camera Link serial ports, such as
a camera manufacturer's configuration application.
The
<code class="Em">clserEPX.dll</code>
supports all standard Camera Link baud rates.
</p><p>
Under Linux with 2.6 and later kernels, the
</p><blockquote>
<pre>    /dev/ttyPIXCI0
    /dev/ttyPIXCI1
    ..
</pre>
</blockquote>
nodes offer
''tty''
style access to the serial port for functional unit 0,
functional unit 1, etc.
All Camera Link standard baud rates are supported.
The
''tty''
style access is most often used by
application programs that need an imaging-board
independent method to access Camera Link serial ports, such as
a camera manufacturer's configuration application.
<p>
For convenience of application programs, XCLIB also, directly,
includes the
<a href="#clSerialInit" class="Er">clSerialInit</a>
and related functions
for sending and receiving serial data.
These
functions support all standard Camera Link baud rates.
These functions are also available under Linux.
</p><p>
XCLIB also has alternative functions,
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>,
<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>,
and
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>
for sending and receiving serial data.
These may be simpler to use than the
<a href="#clSerialInit" class="Er">clSerialInit</a>
and related functions,
and, for some PIXCI® imaging cards,
these support additional, non-standard, baud rates.
</p><p>
For application programs already using XCLIB for video capture,
use of the integrated
<a href="#clSerialInit" class="Er">clSerialInit</a>
functions or the
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>
functions is more efficient than invoking
<a href="#clSerialInit" class="Er">clSerialInit</a>
in the separate
<code class="Em">clserEPX.dll</code>
DLL,
or accessing
the /dev/ttyPIXCI0, /dev/ttyPIXCI1, etc. nodes.
Also, under
Windows 95, 98, and ME
XCLIB cannot share access to the
PIXCI® imaging board(s) with
<code class="Em">clserEPX.dll</code>
requiring use of the integrated functions.
Under Linux with 2.4 kernels, which doesn't support /dev/ttyPIXCI0, etc. nodes,
use of the integrated functions is similarly necessary.
<br>
<a name="On Video Format Configuration" class="Ch"></a>
<a name="1.5.11.  On Video Format Configuration"></a>
</p><h3>1.5.11.  On Video Format Configuration</h3>
<p>
<a name="Video Format Configuration NX49" class="NX"></a>
The Video Format Configuration
is a group of dozens of parameters
that defines the video format
(i.e. whether NTSC, RS-170, PAL, or CCIR
for applicable imaging boards,
or camera manufacturer and model for other
imaging boards),
the resolution (i.e. capturing more or fewer pixels
per line or column),
and other settings related to the imaging board's hardware.
</p><p>
The XCLIB provides a suitable default Video Format Configuration
for each PIXCI(rg imaging board, model, and submodel.
The library of defaults is compiled into XCLIB and cannot
be changed in the field.
</p><p>
For PIXCI(rg imaging boards supporting multiple standard formats
such as NTSC, RS-170, PAL, or CCIR,
a standard format can be selected by name
as the second parameter to
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
or
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or as the fourth parameter to
<a href="#xclib_open" class="Er">xclib_open</a>.
</p><p>
The easiest and suggested method of creating an
alternate Video Format Configuration is to use
<cite class="Ec">XCAP</cite>.
XCAP uses an identical and compatible<a href="#Footnote%206" class="Ff"><sup>[6]</sup></a>
Video Format Configuration,
although XCAP uses the term
''Video Setup''.
In XCAP, use:
</p><blockquote>
<pre>    PIXCI®
    PIXCI® Video Setup
    .. adjust video configuration followed by OK ..
    PIXCI®
    PIXCI® Export Video Setup
</pre>
</blockquote>
After running XCAP, specify the path name of the saved video setup file
as the third parameter to
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
or
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or as the fifth parameter to
<a href="#xclib_open" class="Er">xclib_open</a>.
<p>
The contents of the saved video setup file
is readable and editable text;
the
<code class="Em">pxlibvs.h</code>
and
<code class="Em">xclibvs.h</code>
files describe the various fields.
Using the
Structured Style Interface,<a href="#Footnote%207" class="Ff"><sup>[7]</sup></a>
the structures composing the
Video Format Configuration,
as described in
<code class="Em">pxlibvs.h</code>
and
<code class="Em">xclibvs.h</code>,
can be manipulated directly.
</p><p>
Alternately, using the SCF Style Interface
a video setup file can be
''loaded''
without re-opening XCLIB by using<a href="#Footnote%208" class="Ff"><sup>[8]</sup></a>
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>.
To use SCF style or SCF+ style functions with multiple imaging boards at different
formats and resolutions, a
saved video setup file, created with XCAP configured with
</p><blockquote>
<pre>    PIXCI®
    PIXCI® Open/Close
    Multiple Devices
    Use Individual Formats &amp; Controls
    OK
</pre>
</blockquote>
must be specified as the third parameter to
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
or
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>.
<p>
The XCLIB does not implicitly use a video format name or saved video setup file;
neither the Windows registry,
Windows'
<code class="Em">SYSTEM.INI</code>
file,
nor Windows' or Linux' environment variables
(i.e. via
''SET''
commands)
are implicitly used by XCLIB to select a video format name
or a video setup file.
The application program is free to create its own convention,
such as using the C/C++ library's
<cite class="Ec">RegQueryValueEx()</cite>,
<cite class="Ec">GetPrivateProfileString()</cite>,
or
<cite class="Ec">getenv()</cite>,
for run time selection of the video format name or video setup file.
<br>
<a name="On Video State ID's" class="Ch"></a>
<a name="1.5.12.  On Video State ID's"></a>
</p><h3>1.5.12.  On Video State ID's</h3>
<p>
<a name="Video State ID NX50" class="NX"></a>
For efficiency, XCLIB maintains
copies of Video Format Configurations
and associates a unique
''video state id''
integer, greater than zero, with each.
Thereafter, the video state id may be used
to refer to the Video Format Configuration.
In XCLIB, the process of association is termed
''defining a video state''.
<br>
<a name="On Error Codes" class="Ch"></a>
<a name="1.5.13.  On Error Codes"></a>
</p><h3>1.5.13.  On Error Codes</h3>
<p>
Library functions return a common set of return codes,
indicating success or failure.
These codes are defined via inclusion of
<code class="Em">xcliball.h</code>
with mnemonic names beginning with
''PXER''.
All error return codes are negative values.
Specific error conditions can be differentiated by
reading the definitions of these codes in
<code class="Em">pxerrno.h</code>,
or by use of the
<a href="#pxd_mesgErrorCode" class="Er">pxd_mesgErrorCode</a>
function.
<br>
<a name="On Structures and Signatures" class="Ch"></a>
<a name="1.5.14.  On Structures and Signatures"></a>
</p><h3>1.5.14.  On Structures and Signatures</h3>
<p>
Various structures which might change between versions
of XCLIB utilize a
''signature'',
so that an application compiled with an older
version of XCLIB can't declare an older, smaller, structure
and have it accepted by a newer library expecting a newer, larger, structure.
Structures that are changed typically define the added fields
so that a zero value maintains the previous structure's effect.
</p><p>
Applications should initialize
''new''
instances of structures by zeroing
the entire structure to 0,
and setting the
<em class="Ep">ddch.len</em>
and
<em class="Ep">ddch.cnt</em>
to the size of the structure,
and to a signature constant,
respectively.
<a name="ddch.len NX51" class="NX"></a>
<a name="ddch.cnt NX52" class="NX"></a>
<a name="ddch.len" class="Tr"></a>
<a name="ddch.cnt" class="Tr"></a>
For example,
</p><blockquote>
<pre>    struct pxdevfault fault_structure;
<br>
    memset(&amp;fault_structure, 0, sizeof(fault_structure));
    fault_structure.ddch.len = sizeof(fault_structure);
    fault_structure.ddch.mos = PXMOS_DEVFAULT;
</pre>
</blockquote>
initializes the
<a href="#pxdevfault" class="Er">pxdevfault</a>
structure.
<br>
<p>&nbsp;
<a name="Common Structures" class="Ch"></a>
<a name="1.6.  Common Structures"></a>
</p><h2>1.6.  Common Structures</h2>
<p>
Common structures are discussed below,
rather than repeatedly discussed with each function.
These concepts and data types are applicable
to the Structured Style Interface, and are not needed for
the SCF Style Interface or the SCF+ Style Interface.
Declaration of all structures
are automatically provided via inclusion of
<code class="Em">xcliball.h</code>.
</p><p>
Most structures have an abbreviated name
<cite class="Ec">typedef</cite>'ed.
These follow the convention of the structure's name
followed by
''_s''.
For example, either of:
</p><blockquote>
<pre>    struct  pxy     a_pair_of_xy_coordinates;
            pxy_s   another_pair_of_xy_coordinates;
</pre>
</blockquote>
may be used.
<br>
<a name="Coordinates, Images, and Image Window Structures" class="Ch"></a>
<a name="1.6.1.  Coordinates, Images, and Image Window Structures"></a>
<h3>1.6.1.  Coordinates, Images, and Image Window Structures</h3>
<p>
The
<em class="Ep">pxy</em>
struct provides a pair of x, y coordinates defining a point in two dimensions:
<a name="Struct pxy NX53" class="NX"></a>
<a name="pxy, struct NX54" class="NX"></a>
<a name="pxy_s NX55" class="NX"></a>
<a name="pxypoint_s NX56" class="NX"></a>
<a name="pxy" class="Tr"></a>
<a name="pxy_s" class="Tr"></a>
<a name="pxypoint_s" class="Tr"></a>
</p><blockquote>
<pre>struct pxy {
    pxcoord_t   x;
    pxcoord_t   y;
};
typedef struct pxy pxy_s;
typedef struct pxy pxypoint_s;
</pre>
</blockquote>
The
<em class="Ep">pxyz</em>
struct provides a triplet of x, y, z coordinates
defining a point in three dimensions:
<a name="Struct pxyz NX57" class="NX"></a>
<a name="pxyz, struct NX58" class="NX"></a>
<a name="pxyz_s NX59" class="NX"></a>
<a name="pxypointz_s NX60" class="NX"></a>
<a name="pxyz" class="Tr"></a>
<a name="pxyz_s" class="Tr"></a>
<a name="pxyzpoint_s" class="Tr"></a>
<blockquote>
<pre>struct pxyz {
    pxcoord_t   x;
    pxcoord_t   y;
    pxcoord_t   z;
};
typedef struct pxyz pxyz_s;
typedef struct pxyz pxyzpoint_s;
</pre>
</blockquote>
<p>
The
<em class="Ep">pxywindow</em>
struct provides a pair of x, y coordinates defining a rectangle in two dimensions:
<a name="Struct pxywindow NX61" class="NX"></a>
<a name="pxywindow, struct NX62" class="NX"></a>
<a name="pxywindow_s NX63" class="NX"></a>
<a name="pxywindow_s" class="Tr"></a>
<a name="pxywindow" class="Tr"></a>
</p><blockquote>
<pre>struct pxywindow {
    struct  pxy nw;   // north west corner inclusive
    struct  pxy se;   // south east corner, usually exclusive
};
typedef struct pxywindow pxywindow_s;
</pre>
</blockquote>
The
<em class="Ep">pxyzwindow</em>
struct provides a pair of x, y, z coordinates defining a rectangle in three dimensions:
<a name="Struct pxyzwindow NX64" class="NX"></a>
<a name="pxyzwindow, struct NX65" class="NX"></a>
<a name="pxyzwindow_s NX66" class="NX"></a>
<a name="pxyzwindow" class="Tr"></a>
<a name="pxyzwindow_s" class="Tr"></a>
<blockquote>
<pre>struct pxyzwindow {
    struct  pxyz nw;  // north west corner inclusive
    struct  pxyz se;  // south east corner, usually exclusive
};
typedef struct pxywindow pxyzwindow_s;
</pre>
</blockquote>
<p>
The
<em class="Ep">pximage</em>
struct is used as an object<a href="#Footnote%209" class="Ff"><sup>[9]</sup></a> defining:
(a)&nbsp;An image,
(b)&nbsp;The dimensions of the image,
(c)&nbsp;A rectangular area of interest,
(d)&nbsp;The means of accessing the image,
(e)&nbsp;Other parameters for internal use.
The
<em class="Ep">pximage</em>
must be initialized<a href="#Footnote%2010" class="Ff"><sup>[10]</sup></a>
using a provided function, such as
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>
or
<a href="#::initPximage" class="Er">::initPximage</a>.
</p><p>
The following abstract of the
<em class="Ep">pximage</em>
shows some of the fields
of interest to the application programmer.
<a name="Struct pximage NX67" class="NX"></a>
<a name="pximage, struct NX68" class="NX"></a>
<a name="pximage_s NX69" class="NX"></a>
<a name="pximage" class="Tr"></a>
<a name="pximage_s" class="Tr"></a>
</p><blockquote>
<pre>struct pximage {
    struct  pxywindow imdim; // nw.x = nw.y = 0. se.x &amp; se.y is dimension of image
    struct  pxywindow wind;  // subwindow within imdim
        ...         ...
};
typedef struct pximage pximage_s;
</pre>
</blockquote>
The
<em class="Ep">pximage</em>.<em class="Ep">imdim</em>
provides the image's dimensions.
The
<em class="Ep">pximage</em>.<em class="Ep">wind</em>
defines an area of interest within the image; the
<em class="Ep">pximage</em>.<em class="Ep">wind</em>
may be directly altered by the application programmer.
<p>
Similarly, the
<em class="Ep">pximage3</em>
defines a sequence of images
(or depending on point of view, a three-dimensional image),
and means of access.
The following abstract of the
<em class="Ep">pximage3</em>
shows some of the fields
of interest to the application programmer.
<a name="Struct pximage3 NX70" class="NX"></a>
<a name="pximage3, struct NX71" class="NX"></a>
<a name="pximage3_s NX72" class="NX"></a>
<a name="pximage3" class="Tr"></a>
<a name="pximage3_s" class="Tr"></a>
</p><blockquote>
<pre>struct pximage3 {
    struct  pxyzwindow imdim; // nw.x = nw.y = nw.z = 0. se.x, se.y &amp; se.z is dimension of image
    struct  pxyzwindow wind;  // subwindow within imdim
        ...         ...
};
typedef struct pximage3 pximage3_s;
</pre>
</blockquote>
<br>
<a name="Imaging Board, Driver, and Video Format Configuration Structures" class="Ch"></a>
<a name="1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures"></a>
<h3>1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures</h3>
<p>
The structures used for access to and control of the
imaging board(s), driver, and Video Format Configuration
are listed.
Each structure is declared and described in the specified file.
<a name="Struct pxddch NX73" class="NX"></a>
<a name="Struct pxvidstate NX74" class="NX"></a>
<a name="Struct pxvidformat NX75" class="NX"></a>
<a name="Struct pxvidimage NX76" class="NX"></a>
<a name="Struct pxviddim NX77" class="NX"></a>
<a name="Struct pxvidres NX78" class="NX"></a>
<a name="Struct pxvidphys NX79" class="NX"></a>
<a name="Struct pxvidmode NX80" class="NX"></a>
<a name="Struct pxvidopt NX81" class="NX"></a>
<a name="Struct pxvidmem NX82" class="NX"></a>
<a name="Struct pxcamcntl NX83" class="NX"></a>
<a name="Struct xcsv2format NX84" class="NX"></a>
<a name="Struct xcsv2mode NX85" class="NX"></a>
<a name="Struct xcdxxformat NX86" class="NX"></a>
<a name="Struct pxdevinfo NX87" class="NX"></a>
<a name="Struct xcdevinfo NX88" class="NX"></a>
<a name="Struct xcdevparms NX89" class="NX"></a>
<a name="Struct pxtimestamp NX90" class="NX"></a>
<a name="Struct pxvidstatus NX91" class="NX"></a>
<a name="Struct xcvidstatus NX92" class="NX"></a>
<a name="Struct pxdevfault NX93" class="NX"></a>
<a name="Struct pximagebuf NX94" class="NX"></a>
<a name="Struct pximage3buf NX95" class="NX"></a>
<a name="Struct pxtrigspec NX96" class="NX"></a>
<a name="Struct xclibs NX97" class="NX"></a>
<a name="Struct pxdevservice NX98" class="NX"></a>
<a name="Struct pxauxservice NX99" class="NX"></a>
<a name="Struct xcdevservice NX100" class="NX"></a>
<a name="Struct xclibservice NX101" class="NX"></a>
<a name="Struct pxbufstatus NX102" class="NX"></a>
<a name="Struct pxbufstatusfile NX103" class="NX"></a>
<a name="pxddch, struct NX104" class="NX"></a>
<a name="pxvidstate, struct NX105" class="NX"></a>
<a name="pxvidformat, struct NX106" class="NX"></a>
<a name="pxvidimage, struct NX107" class="NX"></a>
<a name="pxviddim, struct NX108" class="NX"></a>
<a name="pxvidres, struct NX109" class="NX"></a>
<a name="pxvidphys, struct NX110" class="NX"></a>
<a name="pxvidmode, struct NX111" class="NX"></a>
<a name="pxvidopt, struct NX112" class="NX"></a>
<a name="pxvidmem, struct NX113" class="NX"></a>
<a name="pxcamcntl, struct NX114" class="NX"></a>
<a name="xcsv2format, struct NX115" class="NX"></a>
<a name="xcsv2mode, struct NX116" class="NX"></a>
<a name="xcdxxformat, struct NX117" class="NX"></a>
<a name="pxdevinfo, struct NX118" class="NX"></a>
<a name="xcdevinfo, struct NX119" class="NX"></a>
<a name="xcdevparms, struct NX120" class="NX"></a>
<a name="pxtimestamp, struct NX121" class="NX"></a>
<a name="pxvidstatus, struct NX122" class="NX"></a>
<a name="xcvidstatus, struct NX123" class="NX"></a>
<a name="pxdevfault, struct NX124" class="NX"></a>
<a name="pximagebuf, struct NX125" class="NX"></a>
<a name="pximage3buf, struct NX126" class="NX"></a>
<a name="pxtrigspec, struct NX127" class="NX"></a>
<a name="xclibs, struct NX128" class="NX"></a>
<a name="pxdevservice, struct NX129" class="NX"></a>
<a name="pxauxservice, struct NX130" class="NX"></a>
<a name="xcdevservice, struct NX131" class="NX"></a>
<a name="xclibservice, struct NX132" class="NX"></a>
<a name="pxbufstatus, struct NX133" class="NX"></a>
<a name="pxbufstatusfile, struct NX134" class="NX"></a>
<a name="pxddch_s NX135" class="NX"></a>
<a name="pxvidstate_s NX136" class="NX"></a>
<a name="pxvidformat_s NX137" class="NX"></a>
<a name="pxvidimage_s NX138" class="NX"></a>
<a name="pxviddim_s NX139" class="NX"></a>
<a name="pxvidres_s NX140" class="NX"></a>
<a name="pxvidphys_s NX141" class="NX"></a>
<a name="pxvidmode_s NX142" class="NX"></a>
<a name="pxvidopt_s NX143" class="NX"></a>
<a name="pxvidmem_s NX144" class="NX"></a>
<a name="pxcamcntl_s NX145" class="NX"></a>
<a name="xcsv2format_s NX146" class="NX"></a>
<a name="xcsv2mode_s NX147" class="NX"></a>
<a name="xcdxxformat_s NX148" class="NX"></a>
<a name="pxdevinfo_s NX149" class="NX"></a>
<a name="xcdevinfo_s NX150" class="NX"></a>
<a name="xcdevparms_s NX151" class="NX"></a>
<a name="pxtimestamp_s NX152" class="NX"></a>
<a name="pxvidstatus_s NX153" class="NX"></a>
<a name="xcvidstatus_s NX154" class="NX"></a>
<a name="pxdevfault_s NX155" class="NX"></a>
<a name="pximagebuf_s NX156" class="NX"></a>
<a name="pximage3buf_s NX157" class="NX"></a>
<a name="pxtrigspec_s NX158" class="NX"></a>
<a name="xclibs_s NX159" class="NX"></a>
<a name="pxdevservice_s NX160" class="NX"></a>
<a name="pxauxservice_s NX161" class="NX"></a>
<a name="xcdevservice_s NX162" class="NX"></a>
<a name="xclibservice_s NX163" class="NX"></a>
<a name="pxbufstatus_s NX164" class="NX"></a>
<a name="pxbufstatusfile_s NX165" class="NX"></a>
<a name="pxddch" class="Tr"></a>
<a name="pxvidstate" class="Tr"></a>
<a name="pxvidformat" class="Tr"></a>
<a name="pxvidimage" class="Tr"></a>
<a name="pxviddim" class="Tr"></a>
<a name="pxvidres" class="Tr"></a>
<a name="pxvidphys" class="Tr"></a>
<a name="pxvidmode" class="Tr"></a>
<a name="pxvidopt" class="Tr"></a>
<a name="pxvidmem" class="Tr"></a>
<a name="pxcamcntl" class="Tr"></a>
<a name="xcsv2format" class="Tr"></a>
<a name="xcsv2mode" class="Tr"></a>
<a name="xcdxxformat" class="Tr"></a>
<a name="pxdevinfo" class="Tr"></a>
<a name="xcdevinfo" class="Tr"></a>
<a name="xcdevparms" class="Tr"></a>
<a name="pxtimestamp" class="Tr"></a>
<a name="pxvidstatus" class="Tr"></a>
<a name="xcvidstatus" class="Tr"></a>
<a name="pxdevfault" class="Tr"></a>
<a name="pximagebuf" class="Tr"></a>
<a name="pximage3buf" class="Tr"></a>
<a name="pxtrigspec" class="Tr"></a>
<a name="xclibs" class="Tr"></a>
<a name="pxdevservice" class="Tr"></a>
<a name="pxauxservice" class="Tr"></a>
<a name="xcdevservice" class="Tr"></a>
<a name="xclibservice" class="Tr"></a>
<a name="pxbufstatus" class="Tr"></a>
<a name="pxbufstatusfile" class="Tr"></a>
<a name="pxddch_s" class="Tr"></a>
<a name="pxvidstate_s" class="Tr"></a>
<a name="pxvidformat_s" class="Tr"></a>
<a name="pxvidimage_s" class="Tr"></a>
<a name="pxviddim_s" class="Tr"></a>
<a name="pxvidres_s" class="Tr"></a>
<a name="pxvidphys_s" class="Tr"></a>
<a name="pxvidmode_s" class="Tr"></a>
<a name="pxvidopt_s" class="Tr"></a>
<a name="pxvidmem_s" class="Tr"></a>
<a name="pxcamcntl_s" class="Tr"></a>
<a name="xcsv2format_s" class="Tr"></a>
<a name="xcsv2mode_s" class="Tr"></a>
<a name="xcdxxformat_s" class="Tr"></a>
<a name="pxdevinfo_s" class="Tr"></a>
<a name="xcdevinfo_s" class="Tr"></a>
<a name="xcdevparms_s" class="Tr"></a>
<a name="pxtimestamp_s" class="Tr"></a>
<a name="pxvidstatus_s" class="Tr"></a>
<a name="xcvidstatus_s" class="Tr"></a>
<a name="pxdevfault_s" class="Tr"></a>
<a name="pximagebuf_s" class="Tr"></a>
<a name="pximage3buf_s" class="Tr"></a>
<a name="pxtrigspec_s" class="Tr"></a>
<a name="xclibs_s" class="Tr"></a>
<a name="pxdevservice_s" class="Tr"></a>
<a name="pxauxservice_s" class="Tr"></a>
<a name="xcdevservice_s" class="Tr"></a>
<a name="xclibservice_s" class="Tr"></a>
<a name="pxbufstatus_s" class="Tr"></a>
<a name="pxbufstatusfile_s" class="Tr"></a>
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
Structure   
</td>
<td colspan="1" align="left">
                             
</td>
</tr>
<tr>
<td colspan="1" align="left">
Name        
</td>
<td colspan="1" align="left">
 Use                         
</td>
<td colspan="1" align="left">
 File
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxddch      
</td>
<td colspan="1" align="left">
 Version signatures          
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr><td colspan="3"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
pxvidstate  
</td>
<td colspan="1" align="left">
 Video Format Configuration  
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidformat 
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidimage  
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxviddim    
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidres    
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidphys   
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidmode   
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidopt    
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidmem    
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxcamcntl   
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 pxlibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcsv2format 
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 xclibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcsv2mode   
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 xclibvs.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcdxxformat 
</td>
<td colspan="1" align="left">
 ..  substructure            
</td>
<td colspan="1" align="left">
 xclibvs.h
</td>
</tr>
<tr><td colspan="3"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
pxbufstatus     
</td>
<td colspan="1" align="left">
 Buffer status                     
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxbufstatusfile 
</td>
<td colspan="1" align="left">
 Buffer status for external file   
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxdevinfo       
</td>
<td colspan="1" align="left">
 Driver and board info             
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxdevfault      
</td>
<td colspan="1" align="left">
 Logged fault                      
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pximagebuf      
</td>
<td colspan="1" align="left">
 Non-frame image buffer            
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pximage3buf     
</td>
<td colspan="1" align="left">
 Non-frame image buffers           
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxtimestamp     
</td>
<td colspan="1" align="left">
 Time stamp                        
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxtrigspec      
</td>
<td colspan="1" align="left">
 Trigger specification             
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxvidstatus     
</td>
<td colspan="1" align="left">
 Video and capture status          
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcdevinfo       
</td>
<td colspan="1" align="left">
 Extended driver and board info    
</td>
<td colspan="1" align="left">
 xclibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcdevparms      
</td>
<td colspan="1" align="left">
 Driver configuration              
</td>
<td colspan="1" align="left">
 xclibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcvidstatus     
</td>
<td colspan="1" align="left">
 Extended video and capture status 
</td>
<td colspan="1" align="left">
 xclibsv.h
</td>
</tr>
<tr><td colspan="3"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
xclibs      
</td>
<td colspan="1" align="left">
 Access to XCLIB services    
</td>
<td colspan="1" align="left">
 xclibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxauxservice
</td>
<td colspan="1" align="left">
 .. substructure             
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
pxdevservice
</td>
<td colspan="1" align="left">
 .. substructure             
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xcdevservice
</td>
<td colspan="1" align="left">
 .. substructure             
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
<tr>
<td colspan="1" align="left">
xclibservice
</td>
<td colspan="1" align="left">
 .. substructure             
</td>
<td colspan="1" align="left">
 pxlibsv.h
</td>
</tr>
</tbody></table>
</pre>
</div>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Installation and Configuration &#8212; Run Time" class="Ch"></a>
<a name="2.  Installation and Configuration &#8212; Run Time"></a>
</p><h1>2.  Installation and Configuration &#8212; Run Time</h1>
<p>
The following installation instructions are oriented
to the application program developer, following
installation of the library files, as described above.
Application programs intended for distribution to third parties
must be provided with the appropriate run time support modules
and suitable installation instructions.
The entire XCLIB distribution is not required for
third parties using application programs,
and is normally
<u class="U">not</u>
licensed for distribution to third parties.
<br>
</p><p>&nbsp;
<a name="Driver Configuration Parameters" class="Ch"></a>
<a name="2.1.  Driver Configuration Parameters"></a>
</p><h2>2.1.  Driver Configuration Parameters</h2>
<a name="Driver Configuration Parameter" class="Tr"></a>
<p>
Configuration parameters can be
specified in a Driver Configuration Parameter string which is passed to
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or
<a href="#xclib_open" class="Er">xclib_open</a>;
or, depending upon the run time environment (see below),
specified in an alternate manner.
</p><p>
<a name="Driver Configuration Parameters NX166" class="NX"></a>
The Driver Configuration Parameter string may contain any of the
following parameters, separated by spaces, in any order.
Each parameter's flag is followed by a number,
whose value is interpreted as hexadecimal if preceded by
''0x''
or
''0X'',
octal if preceded by
''0o''
or
''0O'',
binary if preceded by
''0b''
or
''0B'',
and is otherwise interpreted as decimal.
</p><dl>
<br><dt>-BH <i>n</i></dt><dd>
If &#8800;0,
the amount of memory space, in kByte, directly below the
4 GByte address which overlaps other hardware resources
such as BIOS, memory mapped I/O, PCI configuration space, etc.
and is unavailable to either the operating system or for use as frame buffers.<a href="#Footnote%2011" class="Ff"><sup>[11]</sup></a>
The usable frame buffer memory is therefore reduced by the
amount by which the -IA address up to the -IA address plus -IM size
overlap the 4 GByte address minus -BH size up to the 4 GByte address.
Only used with forceful image frame buffer allocation, under
Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64), Linux 32 Bit, and Linux 64 Bit.
Default: 0.
<br></dd><dt>-DM <i>n</i></dt><dd>
A bit map selecting which of the PIXCI® imaging boards
present should be used.
The
<em class="Ep">i'th</em>
bit of the bit-map selects the
<em class="Ep">i</em>'th
board found, sequentially, on the PCI bus.
The relationship between bit
<em class="Ep">i</em>
and the order of motherboard slots is
motherboard, BIOS, and OS dependent and can not be specified
or queried via XCLIB.
<p>
For example, 0x01 selects the first board, 0x04 selects
the third board, and 0b1001 selects the first and fourth board.
</p><p>
For the PIXCI®&nbsp;E1DB, E4DB, ECB2, EL1DB, ELS2, SI2, and SV7 imaging boards which contain two multiple, independent
functional units within a single physical board,
and for the PIXCI®&nbsp;SI4 imaging boards which contain four multiple, independent
functional units within a single physical board:
Under
Windows 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64), Linux 32 Bit and Linux 64 Bit,
each functional unit is handled as an independent imaging board
and may be opened and closed independently.
Under other operating systems, the first functional unit (i.e. half or quarter)
must be opened before latter functional units of the same physical board.
A bit map of
0b1101 selects the first half of the first physical PIXCI®&nbsp;E1DB, E4DB, ECB2, EL1DB, ELS2, SI2, or SV7
imaging board and both halves of the second physical PIXCI®&nbsp;E1DB, E4DB, ECB2, EL1DB, ELS2, SI2, or SV7;
0b11111001 selects the first and fourth quarter of the first physical PIXCI®&nbsp;SI4
imaging board and all quarters of the second physical PIXCI®&nbsp;SI4.
</p><p>
After the library is open, the customary
<em class="Ep">unitmap</em>
function parameter selects one or more of the
<u class="U">opened</u>
boards, not
potentially opened boards.
Thus, while
<em class="Ep">-DM 0x0A</em>
selects opening of the second and fourth
PIXCI® imaging boards, valid values of the
<em class="Ep">unitmap</em>
would be 0x01 to select the first actually open (second potentially opened),
0x02 to select the second actually open (fourth potentially opened),
or 0x03 to select the first and second actually open (second and fourth potentially opened)
imaging board(s).
Default: 0x01, except under a Windows Plug &amp; Play O.S. where the default is a bitmap of all functional units
of the first physical board.
<br></p></dd><dt>-IA <i>n</i></dt><dd>
If &#8800;0,
the physical address of memory, in kByte, at which image
frame buffers are assumed to start.
Only used with forceful image frame buffer allocation, under
Windows 95, 98, ME, NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64), Linux 32 Bit, and Linux 64 Bit.
Default: 0.
<br></dd><dt>-IM <i>n</i></dt><dd>
Requested size, in kByte, to be reserved for the entire
image frame buffer memory.
Default:
32768&nbsp;kByte under Windows NT, 2000, XP, Vista, and 7,
32768&nbsp;kByte under Windows XP(x64), Vista(x64), 7(x64) and Linux 64 Bit,
4096&nbsp;kByte for others.
<p>
For the PIXCI® CL3SD and SI2 which has on-board frame buffer memory,
memory reserved by this parameter is needed for DMA buffers
(approximately 1 MByte).
Memory reserved by this parameter is also, optionally, used
for support of recording frame buffer capture status,
i.e. support for
<a href="#pxd_buffersFieldCount" class="Er">pxd_buffersFieldCount</a>,
<a href="#pxe_buffersFieldCount" class="Er">pxe_buffersFieldCount</a>,
<a href="#pxd_buffersSysTicks" class="Er">pxd_buffersSysTicks</a>,
<a href="#pxe_buffersSysTicks" class="Er">pxe_buffersSysTicks</a>,
<a href="#pxd_buffersGPIn" class="Er">pxd_buffersGPIn</a>,
<a href="#pxe_buffersGPIn" class="Er">pxe_buffersGPIn</a>,
and
<a href="#::goingBufStatus" class="Er">::goingBufStatus</a>
functions,
as specified by the
''-MU''
parameter.
Currently, 64 bytes are needed for each frame buffer's capture status.
Default: 4096&nbsp;kByte.
<br></p></dd><dt>-I2C <i>n</i></dt><dd>
Bit rate of the I<sup><small>2</small></sup>C or other two wire serial bus used within
some PIXCI® imaging boards.
Specifies an upper bound for the bit rate; actual bit rate
is dependent on PC characteristics and is typically slower.
Value of 0 selects predefined, board-dependent, default values.
<p>
Particularly useful for use with SILICON VIDEO®
1281(C),
1310(C),
2112(C),
5C10, 5M10,
642(C),
643(C),
9C10,
9M001(C), and 9T001 cameras;
these SILICON VIDEO® camera heads use a I<sup><small>2</small></sup>C or similar two wire serial bus
to control camera head features.
</p><p>
Does
<u class="U">not</u>
affect the serial baud rate of Camera Link compatible imaging boards.
</p><p>
Default: 0.
<br></p></dd><dt>-LX <i>n</i></dt><dd>
If bit 0x20 is set, a high resolution kernel timer
(''do_gettimeofday'')
is used
for time stamping video events instead of
''jiffies''
and
''HZ'';
however, the high resolution timer incurs additional overhead.
Only used with Linux 32 Bit and Linux 64 Bit.
<p>
If bit 0x80 is set with non forceful memory allocation,
frame buffer memory below 4&nbsp;GByte is requested;
this allows use of 32 bit PCI cards on 64 bit systems with more than
4 GByte of memory.
Option is quietly ignored for kernels
that don't support the necessary feature(s).
</p><p>
Other bits to be described.
Default: 0.
<br></p></dd><dt>-MB <i>n</i></dt><dd>
If &#8800;0,
the image frame buffer memory, of size
specified by
''-IM'',
is split into partitions of this size, in kByte.
Depending on operating system and
''-IA''
parameters, this may imply that each partition is
individually allocated, so that a larger,
total amount of memory can be allocated.
Or that the contiguous memory
is treated as individual partitions for the sake
of the operating system and processor's virtual memory
management, which could not otherwise
''map''
the entire frame buffer memory at once.
In either case,
(a)&nbsp;A single frame buffer can't
extend across partitions,
(b)&nbsp;The partition size should be
a multiple of the frame buffer size so as to maximize the
number of buffers and minimize wasted space, and
(c)&nbsp;A maximum of 256 partitions is supported.
Default: 0.
<br></dd><dt>-MH <i>n</i></dt><dd>
If &#8800;0,
the amount of lower memory, in kByte, to pass over
before allocating the requested
image frame buffer memory.
This may be necessary for use with some graphics display (S/VGA) or
network interface cards which,
a)&nbsp;May be allocating memory later than the PIXCI(rg driver,
and b)&nbsp;May require memory with lower addresses.
Only used with non-forceful image frame buffer allocation,
under
Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64).
Default:
0 kByte under Windows NT, 2000, XP, Vista, and 7; 512 kByte under Windows XP(x64), Vista(x64), and 7(x64).
<br></dd><dt>-MO <i>n</i></dt><dd>
To be described.
Default: 0.
<br></dd><dt>-MU <i>n</i></dt><dd>
If bit 0x01 is not set, the frame buffer memory is not mapped
directly into the application's address space.
If bit 0x02 is set, the frame buffer memory is not
permanently mapped into the driver's address space.
These options minimize use of the operating systems memory management
resources, but may increase overhead in accessing frame buffer memory.
These options are typically required when using very large
amounts of frame buffer memory
(typically,
more than 1 or 2 GByte under under Windows NT, 2000, XP, and XP(x64)
or more than a few hundred MByte under Windows 95/98/ME),
but are not currently supported for all Video Format Configurations.
<p>
If bit 0x04 is not set, the frame buffer memory is
not cleared after allocation, minimizing delay, particularly
when using several GBytes of frame buffer memory.
</p><p>
If bit 0x08 is not set, a portion of frame buffer memory is
reserved for recording each frame buffer's capture status,
such as time stamping the capture.
If bit 0x08 is set, memory is allocated dynamically from the
operating system for recording each frame buffer's capture status.
The amount of space reserved, or the amount of space allocated,
is proportional to the number of frame buffers.
The dynamic memory allocation option is not available under
Windows 95, 98, or ME.
</p><p>
Default: 0x01.
<br></p></dd><dt>-PO <i>n</i></dt><dd>
If &#8800;0, the polling period, in µseconds, for
driver features that are not driven by an interrupt.
Ignored under Tenberry DOS4GW DOS extender.
Default: 5000 µseconds.
<br></dd><dt>-QP <i>n</i></dt><dd>
The XCLIB normally installs a bimodal interrupt handler
so that XCLIB interrupts are handled in both real and protected modes.
The Tenberry DOS4GW DOS extender included with Watcom C/C++ does not have all of the
features (DPMI services) required by XCLIB, the Tenberry DOS4GW Professional
DOS extender must be used.
Alternately,
if &#8800;0, an assigned auxiliary interrupt
number (not IRQ number!)
within Tenberry's range of auto pass-up interrupts: 0x08 to 0x2E.
Only used with the Tenberry DOS4GW DOS extender.
Default: 0.
<br></dd><dt>-QS <i>n</i></dt><dd>
If &#8800;0, allow sharing the imaging boards' assigned hardware interrupt
with other devices.
Ignored under Tenberry DOS4GW DOS extender and Linux.
Default: 1.
<br></dd><dt>-QU <i>n</i></dt><dd>If &#8800;0, utilize the imaging boards'
hardware interrupts.
For PIXCI® A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, SI4, SV4, SV5, SV5A, SV5B, SV5L, and SV7 imaging boards,
the interrupt may be disabled if the polling period (-PO)
is small relative to a field's period.
For PIXCI® SV2 and SV3, disabling the interrupt
will adversely affect all capture modes other than snap.
For PIXCI® D, D24, D32, the interrupt may be disabled
only if the interrupt is not shared.
For all PIXCI® imaging boards operated under Tenberry DOS4GW DOS
extender,
use of hardware interrupts is required.
Disabling use of interrupts is intended primarily for diagnosing
interrupt conflicts, and is not recommended.
Default: 1.
<br></dd><dt>-SM <i>n</i></dt><dd>
Total amount of memory, in kByte, on the computer system.
This parameter and value is currently ignored by the PIXCI® driver, but used
by XCAP's Driver Assistant in conjunction with -IM and -IA
to note the
''context''
under which the -IM and -IA values were set.
<p>
Default: 0.
<br></p></dd><dt>-XM <i>n</i></dt><dd>
If &#8800;0, reserve the proportionate share of image frame buffer
memory for imaging boards not opened by the first application,
for use with other imaging boards opened later.
If 0, all image frame buffer memory is shared
amongst the imaging boards opened by the first application.
Affects PIXCI® imaging boards other than CL3SD and SI2,
which have on-board frame buffer memory.
Default: 1.
<br></dd><dt>-SV5 <i>n</i></dt><dd>
Setting bit 0x02 enables compatibility with 430FX PCI controllers.
Setting bit 0x04 enables compatibility with VIA/SIS PCI controllers.
Only used with PIXCI® SV5, SV5A, SV5B, SV5L.
Default: 0.
<br></dd><dt>-WT <i>n</i></dt><dd>
If bits 0x05 are set to 0x01 or to 0x05,
alternate methods of Windows NT resource allocation are used,
avoiding problems seen on some motherboards where the same resources
are assigned to multiple imaging boards.
Only used with Windows NT.
<p>
If bit 0x20 is set, a high resolution kernel timer is used
for time stamping video events.
Windows documentation states that use of this timer incurs
additional overhead.
Only used with
Window NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64).
</p><p>
If bit 0x80 is set, frame buffer memory below 4&nbsp;GByte is requested;
this allows use of 32 bit PCI cards on 64 bit systems with more than
4 GByte of memory.
</p><p>
Other bits to be described.
Default: 0x20.
<br></p></dd><dt>-XU <i>n</i></dt><dd>
If &#8800;0, allow other applications
to share use of imaging boards previously
opened for use by the first application.
Not supported under Windows 95, 98, ME: Default: 0.
Supported under Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64): Default: 1.
Supported under Linux: Default: 0:
Not supported under Tenberry DOS4GW DOS: Default: 0.
</dd></dl>
<br>
<p>&nbsp;
<a name="Windows 95, 98, ME Environment" class="Ch"></a>
<a name="2.2.  Windows 95, 98, ME Environment"></a>
</p><h2>2.2.  Windows 95, 98, ME Environment</h2>
<p>
The EPIXXCW5.VXD driver, the
XCLIBW95.DLL, and the PXIPLW95.DLL
if the
<cite class="Ec">PXIPL Image Processing Library</cite>
is used,
must be installed in order to
operate any application program using XCLIB.
</p><p>
Typically, XCAP is used to install the driver, specify
frame buffer memory allocation, specify other
Driver Configuration Parameters, and verify proper operation;
these settings are then available to the XCLIB program.
The options in XCAP's:
</p><blockquote>
<pre>    PIXCI
    PIXCI Open/Close
    Advanced
</pre>
</blockquote>
directly correspond to the Driver Configuration Parameters.
Alternately, the details of manual
installation of the
EPIXXCW5.VXD driver
and specification of frame buffer memory allocation,
are described in the
<cite class="Ec">XCAP Reference Manual</cite>
and also the
<cite class="Ec">PIXCI® User's Manual</cite>.
<p>
Driver Configuration Parameters
may be specified in the Windows'
<code class="Em">SYSTEM.INI</code>
file:
</p><blockquote>
<pre>[EPIX_XC]
PIXCI=&lt;DriverConfigurationParameters&gt;
</pre>
</blockquote>
Windows must be rebooted for the new specification to take effect.
<p>
The
''-IA'',
''-IM'',
''-MH'',
and
''-MB''
parameters are effective only when specified in
<code class="Em">SYSTEM.INI</code>,
and can't be specified with
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or
<a href="#xclib_open" class="Er">xclib_open</a>.
</p><p>
The
XCLIBW95.DLL, and the PXIPLW95.DLL
if the
<cite class="Ec">PXIPL Image Processing Library</cite>
is used,
must be available in order to
operate any application program using XCLIB, such as by placing the
DLL(s) in the same directory as the application program,
or by placing the DLL(s) in the Windows directory.
</p><p>
Frame buffer memory is allocated once during Windows initialization;
the contents of frame buffer memory is retained as the driver is closed and opened,
but lost if Windows is restarted.
<br>
</p><p>&nbsp;
<a name="Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64) Environment" class="Ch"></a>
<a name="2.3.  Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64) Environment"></a>
</p><h2>2.3.  Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, 7(x64) Environment</h2>
<p>
The EPIXXCWT.SYS driver for Windows NT, or the
EPIXXCW2.SYS driver for Windows&nbsp;2000, XP, Vista, and 7,
or the EPIXXCW6.SYS driver for Windows&nbsp;XP(x64), Vista(x64), and 7(x64);
the
XCLIBWNT.DLL, and the PXIPLWNT.DLL
if the
<cite class="Ec">PXIPL Image Processing Library</cite>
is used,
must be installed in order to
operate any application program using XCLIB.
</p><p>
Typically, XCAP is used to install the driver, specify
frame buffer memory allocation, specify other
Driver Configuration Parameters, and verify proper operation;
these settings are then available to the XCLIB program.
The options in XCAP's:
</p><blockquote>
<pre>    PIXCI
    PIXCI Open/Close
    Advanced
</pre>
</blockquote>
directly correspond to the Driver Configuration Parameters.
Alternately, the details of manual
installation of the
EPIXXCWT.SYS, EPIXXCW2.SYS, EPIXXCW6.SYS driver
and specification of frame buffer memory allocation,
are described in the
<cite class="Ec">XCAP Reference Manual</cite>
and also the
<cite class="Ec">PIXCI® User's Manual</cite>.
<p>
Driver Configuration Parameters
may be specified in the Windows&nbsp;NT
registry:
</p><pre>    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EPIXXCWT
    PIXCI   =  &lt;DriverConfigurationParameters&gt;
</pre>
or the Windows&nbsp;2000, XP, Vista, and 7 registry:
<pre>    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EPIXXCW2
    PIXCI   =  &lt;DriverConfigurationParameters&gt;
</pre>
or the Windows&nbsp;XP(x64), Vista(x64), and 7(x64) registry:
<pre>    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EPIXXCW6
    PIXCI   =  &lt;DriverConfigurationParameters&gt;
</pre>
Within the registry entry, the
''Value''
named
''PIXCI''
must be of type string
(i.e.
''REG_SZ'').
Windows must be rebooted for the new specification to take effect.
<p>
The
''-IA'',
''-IM'',
''-MH'',
''-MB'',
and
''-BH''
parameters are effective only when specified in the Windows registry,
and can't be specified with
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or
<a href="#xclib_open" class="Er">xclib_open</a>.
</p><p>
The
XCLIBWNT.DLL, and the PXIPLWNT.DLL
if the
<cite class="Ec">PXIPL Image Processing Library</cite>
is used,
must be available in order to
operate any application program using XCLIB, such as by placing the
DLL(s) in the same directory as the application program,
or by placing the DLL(s) in the Windows directory.
</p><p>
Frame buffer memory is allocated once during Windows initialization;
the contents of frame buffer memory is retained as the driver is closed and opened,
but lost if Windows is restarted.
<br>
</p><p>&nbsp;
<a name="Tenberry DOS4GW DOS Extender Environment" class="Ch"></a>
<a name="2.4.  Tenberry DOS4GW DOS Extender Environment"></a>
</p><h2>2.4.  Tenberry DOS4GW DOS Extender Environment</h2>
<p>
No run time module is needed for execution of
application programs in the Watcom/DOS4GW environment.
</p><p>
<a name="EMM386 NX167" class="NX"></a>
It is suggested that
EMM386.SYS be removed from C:\CONFIG.SYS and
<u class="U">not</u>
be used with XCLIB, as it significantly slows hardware interrupts.
Also, according to the manufacturer of DOS4GW,
some versions of EMM386.SYS have bugs that affect the operation of DOS4GW.
</p><p>
Frame buffer memory is allocated
when
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or
<a href="#xclib_open" class="Er">xclib_open</a>
is invoked;
the contents of frame buffer memory is lost
when XCLIB is closed.
<br>
</p><p>&nbsp;
<a name="Linux 32 Bit &amp; Intel i386 Environment" class="Ch"></a>
<a name="2.5.  Linux 32 Bit &amp; Intel i386 Environment"></a>
</p><h2>2.5.  Linux 32 Bit &amp; Intel i386 Environment</h2>
<p>
The
''pixci_i386.o''
(for 2.4 kernels)
or
''pixci_i386.ko''
(for 2.6 kernels)
loadable driver must be installed by
<cite class="Ec">insmod</cite>
in order to operate any application program using XCLIB.
</p><p>
Driver Configuration Parameters
may be specified as an option to
<cite class="Ec">insmod</cite>,
by assignation to module parameter
''PIXCIPARM'',
such as:
</p><pre>    insmod -o pixci [ -force ] pixci_i386.o  [ PIXCIPARM=&lt;driver_config_parameters&gt; ]
</pre>
or
<pre>    insmod pixci_i386.ko [ PIXCIPARM=&lt;driver_config_parameters&gt; ]
</pre>
Some versions of
<cite class="Ec">insmod</cite>
under 2.6 kernels object to quoted spaces in the Driver Configuration Parameters;
an underscore (i.e.
''_'')
may be used instead of a space.
<p>
The
''-IA'',
''-IM'',
''-BH'',
and
''-MB''
parameters are effective only when specified with
<cite class="Ec">insmod</cite>,
and can't be specified with
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or
<a href="#xclib_open" class="Er">xclib_open</a>.
</p><p>
Frame buffer memory is allocated
when the
''pixci_i386.o''
or
''pixci_i386.ko''
is loaded;
the contents of frame buffer memory is lost
when
''pixci_i386.o''
or
''pixci_i386.ko''
is unloaded.
<br>
</p><p>&nbsp;
<a name="Linux 64 Bit &amp; Intel x86-64 Environment" class="Ch"></a>
<a name="2.6.  Linux 64 Bit &amp; Intel x86-64 Environment"></a>
</p><h2>2.6.  Linux 64 Bit &amp; Intel x86-64 Environment</h2>
<p>
The
''pixci_x86_64.ko''
(for 2.6 kernels)
loadable driver must be installed by
<cite class="Ec">insmod</cite>
in order to operate any application program using XCLIB.
</p><p>
Driver Configuration Parameters
may be specified as an option to
<cite class="Ec">insmod</cite>,
by assignation to module parameter
''PIXCIPARM'',
such as:
</p><pre>    insmod pixci_x86_64.ko [ PIXCIPARM=&lt;driver_config_parameters&gt; ]
</pre>
Some versions of
<cite class="Ec">insmod</cite>
under 2.6 kernels object to quoted spaces in the Driver Configuration Parameters;
an underscore (i.e.
''_'')
may be used instead of a space.
<p>
The
''-IA'',
''-IM'',
''-BH'',
and
''-MB''
parameters are effective only when specified with
<cite class="Ec">insmod</cite>,
and can't be specified with
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>,
<a href="#pxe_PIXCIopen" class="Er">pxe_PIXCIopen</a>,
or
<a href="#xclib_open" class="Er">xclib_open</a>.
</p><p>
Frame buffer memory is allocated
when the
''pixci_x86_64.ko''
is loaded;
the contents of frame buffer memory is lost
when
''pixci_x86_64.ko''
is unloaded.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="SCF Style Interface" class="Ch"></a>
<a name="3.  SCF Style Interface"></a>
</p><h1>3.  SCF Style Interface</h1>
<p>
The so-called
Simple ``C'' Function
Style Interface provides sufficient services
for most common applications using a single imaging board,
or using multiple, identical, imaging boards,
or using one or more identical imaging boards
each with multiple functional units.
</p><p>
The SCF style interface differs from the non-SCF functions
in several regards.
First, the SCF functions do not (explicitly) use structures
and minimize the use of pointers.
These functions can be easily used by casual ``C'' programmers,
and invoked from languages other than ``C'',
such as Visual Basic, VB.NET,
Borland Delphi, LabView, Matlab, or any other
Windows programming environment that allows
calling an arbitrary function in an arbitrary DLL.
In contrast, the non-SCF functions provide a
''structured''
and
''object oriented''
interface, providing an alternate API for advanced C/C++ programmers.
</p><p>
Second, the SCF functions do not allow low level changes
to the video format configuration.
Rather, the video format configuration is
either chosen from the predefined selections,
or loaded from a video format file,<a href="#Footnote%2012" class="Ff"><sup>[12]</sup></a>
previously saved by the XCAP application.
In contrast, the non-SCF functions provide full access to all of the
dozens of parameters with which the video format configuration
can be customized.
</p><p>
Third, while the SCF functions support multiple imaging boards,
or imaging boards with multiple functional units,
the boards or units must be identical.
In contrast, the non-SCF functions
support multiple identical imaging boards and functional units with
independent video format and resolution,
or by opening multiple instances of the library
the non-SCF functions support access to multiple, non-identical,
imaging boards.<a href="#Footnote%2013" class="Ff"><sup>[13]</sup></a>
</p><p>
Fourth, the SCF functions share common names
with libraries for other families of EPIX, Inc. imaging boards.
This allows easier porting of application programs
from one board family to another, but complicates
using boards from both families within the same program.
In contrast, the non-SCF functions do not share common
names with libraries for other families of EPIX, Inc. imaging boards,
requiring additional editing of source code when
porting the application program.
</p><p>
The SCF functions are not intended to be used in conjunction
with non-SCF functions; though upon advice of EPIX, Inc, Technical Support,
the
<a href="#pxd_xclibEscape" class="Er">pxd_xclibEscape</a>
and
<a href="#pxd_xclibEscaped" class="Er">pxd_xclibEscaped</a>
functions
can be used in special circumstances.<a href="#Footnote%2014" class="Ff"><sup>[14]</sup></a>
</p><p>
The source for many of the SCF function
''wrappers''
for programmers
wishing to understand their manner of implementation
in terms of the non-SCF functions,
is available from EPIX, Inc. Technical Support.
</p><hr size="1">
<a name="pxd_buffersFieldCount NX168" class="NX"></a>
<a name="pxd_buffersFieldCount" class="Sf"></a>
<a name="Buffer's Capture Field Count NX169" class="NX"></a>
<a name="Buffer's Capture Field Count   ---   pxd_buffersFieldCount" class="Sf"></a>
<a name="Buffer's Capture Field Count   ---   pxd_buffersFieldCount"></a>
<h6 class="Sf">Buffer's Capture Field Count   ---   pxd_buffersFieldCount</h6>
<a name="pxd_buffersGPIn NX170" class="NX"></a>
<a name="pxd_buffersGPIn" class="Sg"></a>
<a name="Buffer's Capture General Purpose Input NX171" class="NX"></a>
<a name="Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn" class="Sg"></a>
<a name="Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn"></a>
<h6 class="Sg">Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn</h6>
<a name="pxd_buffersSysTicks NX172" class="NX"></a>
<a name="pxd_buffersSysTicks" class="Sg"></a>
<a name="Buffer's Capture System Time NX173" class="NX"></a>
<a name="Buffer's Capture System Time   ---   pxd_buffersSysTicks" class="Sg"></a>
<a name="Buffer's Capture System Time   ---   pxd_buffersSysTicks"></a>
<h6 class="Sg">Buffer's Capture System Time   ---   pxd_buffersSysTicks</h6>
<a name="pxd_buffersSysTicks2 NX174" class="NX"></a>
<a name="pxd_buffersSysTicks2" class="Sg"></a>
<a name="Buffer's Capture System Time NX175" class="NX"></a>
<a name="Buffer's Capture System Time   ---   pxd_buffersSysTicks2" class="Sg"></a>
<a name="Buffer's Capture System Time   ---   pxd_buffersSysTicks2"></a>
<h6 class="Sg">Buffer's Capture System Time   ---   pxd_buffersSysTicks2</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>pxvbtime_t pxd_buffersFieldCount(unitmap, buffer);
int        pxd_buffersGPIn(unitmap, buffer);
uint32     pxd_buffersSysTicks(unitmap, buffer);
int        pxd_buffersSysTicks2(unitmap, buffer, ticks);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
uint32              ticks[2];       // System time
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Information about the specified, captured, frame buffer is returned.
</p><p>
The
<em class="Ep">pxd_buffersFieldCount</em>
returns the video field count when the specified frame buffer
was captured,
on the single unit specified by
<em class="Ep">unitmap</em>.
The field count is initialized to 0
when
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
is invoked,
and (typically, but dependent upon imaging board)
counts all video fields, whether captured or not.
</p><p>
The
<a href="#pxd_buffersGPIn" class="Er">pxd_buffersGPIn</a>
returns the value(s)
of the general purpose
input signals, if any, when the specified frame buffer
was captured.
The return value is in the same imaging board dependent format
as for
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>.
For the PIXCI®&nbsp;SV2 and SV3 imaging boards, the
<a href="#pxd_buffersGPIn" class="Er">pxd_buffersGPIn</a>
is not available and always returns 0.
</p><p>
The
<a href="#pxd_buffersSysTicks" class="Er">pxd_buffersSysTicks</a>
returns the low 32 bits of the system time
when the specified frame buffer was captured,<a href="#Footnote%2015" class="Ff"><sup>[15]</sup></a>
on the single unit specified by
<em class="Ep">unitmap</em>.
The
<a href="#pxd_buffersSysTicks2" class="Er">pxd_buffersSysTicks2</a>
''returns''
the low and high 32 bits of the system time in
<em class="Ep">ticks</em>[0]
and
<em class="Ep">ticks</em>[1],
respectively,
when the specified frame buffer was captured,<a href="#Footnote%2015" class="Ff"><sup>[15]</sup></a>
on the single unit specified by
<em class="Ep">unitmap</em>.
Under Windows 95, 98, and ME,
the system time is in 1 millisecond units
with a resolution of approximately 50 milliseconds
(i.e.
<cite class="Ec">Get_Last_Updated_System_Time</cite>).
Under Windows NT,
the system time is in 100 nanosecond units
with a resolution of approximately 10 milliseconds
(i.e.
<cite class="Ec">KeQuerySystemTime</cite>).
Under Windows 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64)
the system time is in 100 nanosecond units
with resolution dependent upon the host computer
(i.e.
<cite class="Ec">KeQueryInterruptTime</cite>).
Under Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64)
if the high resolution timer option (see
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>)
is used, the units are dependent upon Windows and the host computer.
Under DOS+Tenberry,
the system time is in 54.94 millisecond (i.e. 1/18.2&nbsp;Hz)
units with the same resolution.
Under Linux, the system time units
are dependent on the Linux version and host computer
(i.e. the reciprocal of Linux's
''HZ'');
for common 2.4 and 2.6 kernels on a PC, the system time is in 10 millisecond units
with the same resolution.
Under Linux,
if the high resolution timer option (see
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>)
is used, the units are 1 microsecond,
with resolution dependent on the host computer.
</p><p>
The return values of the
<a href="#pxd_buffersFieldCount" class="Er">pxd_buffersFieldCount</a>
<a href="#pxd_buffersGPIn" class="Er">pxd_buffersGPIn</a>
<a href="#pxd_buffersSysTicks" class="Er">pxd_buffersSysTicks</a>
functions, and the
''returned''
contents of
<em class="Ep">ticks</em>for
<a href="#pxd_buffersSysTicks2" class="Er">pxd_buffersSysTicks2</a>,
is undefined
if the specified frame buffer has not yet been captured,
or if the Video Format Configuration
has been changed thereby causing frame buffer memory to be reorganized.
</p><p>
Capture status information may not stored for each frame buffer,
depending on frame buffer memory configuration
such as use of forceful memory allocation and/or the
''-MU''
<a href="#Device%20Configuration%20Parameters" class="Er">Device Configuration Parameters</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
The
<a href="#pxd_buffersFieldCount" class="Er">pxd_buffersFieldCount</a>
<a href="#pxd_buffersGPIn" class="Er">pxd_buffersGPIn</a>
<a href="#pxd_buffersSysTicks" class="Er">pxd_buffersSysTicks</a>
return 0 if
the library is not open or the feature is not available.
The
<a href="#pxd_buffersSysTicks2" class="Er">pxd_buffersSysTicks2</a>
returns:
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
See
<a href="#pxd_capturedFieldCount" class="Er">pxd_capturedFieldCount</a>,
<a href="#pxd_capturedSysTicks" class="Er">pxd_capturedSysTicks</a>,
and
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>
which provide similar information
if invoked in a timely manner,
and are
supported for all PIXCI® imaging boards and
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>.
</p><hr size="1">
<a name="pxd_capturedBuffer NX176" class="NX"></a>
<a name="pxd_capturedBuffer" class="Sf"></a>
<a name="Last Captured Buffer: Buffer Number NX177" class="NX"></a>
<a name="Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer" class="Sf"></a>
<a name="Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer"></a>
<h6 class="Sf">Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer</h6>
<a name="pxd_capturedFieldCount NX178" class="NX"></a>
<a name="pxd_capturedFieldCount" class="Sg"></a>
<a name="Last Captured Buffer: Field Count NX179" class="NX"></a>
<a name="Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount" class="Sg"></a>
<a name="Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount"></a>
<h6 class="Sg">Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount</h6>
<a name="pxd_capturedSysTicks NX180" class="NX"></a>
<a name="pxd_capturedSysTicks" class="Sg"></a>
<a name="Last Captured Buffer: System Time NX181" class="NX"></a>
<a name="Last Captured Buffer: System Time   ---   pxd_capturedSysTicks" class="Sg"></a>
<a name="Last Captured Buffer: System Time   ---   pxd_capturedSysTicks"></a>
<h6 class="Sg">Last Captured Buffer: System Time   ---   pxd_capturedSysTicks</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>pxbuffer_t pxd_capturedBuffer(unitmap);
pxvbtime_t pxd_capturedFieldCount(unitmap);
uint32     pxd_capturedSysTicks(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Information about the last captured frame buffer is returned.
</p><p>
The
<a href="#pxd_capturedBuffer" class="Er">pxd_capturedBuffer</a>
returns the buffer number into which the last frame was captured,
on the single unit specified by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#pxd_capturedFieldCount" class="Er">pxd_capturedFieldCount</a>
returns the video field count when the last frame
was captured,
on the single unit specified by
<em class="Ep">unitmap</em>.
The field count is initialized to 0
when
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
is invoked,
and (typically, but dependent upon imaging board)
counts all video fields, whether captured or not.
</p><p>
The
<a href="#pxd_capturedSysTicks" class="Er">pxd_capturedSysTicks</a>
returns the low 32 bits of the system time
when the last frame was captured,<a href="#Footnote%2016" class="Ff"><sup>[16]</sup></a>
on the single unit specified by
<em class="Ep">unitmap</em>.
Under Windows 95, 98, and ME,
the system time is in 1 millisecond units
with a resolution of approximately 50 milliseconds
(i.e.
<cite class="Ec">Get_Last_Updated_System_Time</cite>).
Under Windows NT,
the system time is in 100 nanosecond units
with a resolution of approximately 10 milliseconds
(i.e.
<cite class="Ec">KeQuerySystemTime</cite>).
Under Windows 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64)
the system time is in 100 nanosecond units
with resolution dependent upon the host computer
(i.e.
<cite class="Ec">KeQueryInterruptTime</cite>).
Under Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64)
if the high resolution timer option (see
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>)
is used, the units are dependent upon Windows and the host computer
(i.e.
<cite class="Ec">KeQueryPerformanceCounter</cite>).
Under DOS+Tenberry,
the system time is in 54.94 millisecond (i.e. 1/18.2&nbsp;Hz)
units with the same resolution.
Under Linux, the system time units
are dependent on the Linux version and host computer;
for common 2.4 and 2.6 kernels on a PC, the system time is in 10 millisecond units
with the same resolution
(i.e.
<cite class="Ec">jiffies</cite>
and
<cite class="Ec">HZ</cite>).
Under Linux,
if the high resolution timer option (see
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>)
is used, the units are 1 microsecond,
with resolution dependent on the host computer
(i.e.
<cite class="Ec">gettimeofday</cite>).
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
All functions return 0 if
the library is not open for use or no
frame has even been captured since the library was
opened.
<br>
<br>
<br>
<em class="Ss">See Also</em>
</p><p>
See
<a href="#pxd_buffersFieldCount" class="Er">pxd_buffersFieldCount</a>
and
<a href="#pxd_buffersSysTicks" class="Er">pxd_buffersSysTicks</a>
which provides similar information
saved on a per buffer basis, rather
than having to be retrieved before another
video frame is captured.
</p><hr size="1">
<a name="pxd_setCameraLinkCCOut NX182" class="NX"></a>
<a name="pxd_setCameraLinkCCOut" class="Sf"></a>
<a name="Camera Link CC Output Signal: Set NX183" class="NX"></a>
<a name="Camera Link CC Output Signal: Set   ---   pxd_setCameraLinkCCOut" class="Sf"></a>
<a name="Camera Link CC Output Signal: Set   ---   pxd_setCameraLinkCCOut"></a>
<h6 class="Sf">Camera Link CC Output Signal: Set   ---   pxd_setCameraLinkCCOut</h6>
<a name="pxd_getCameraLinkCCOut NX184" class="NX"></a>
<a name="pxd_getCameraLinkCCOut" class="Sg"></a>
<a name="Camera Link CC Output Signal: Get NX185" class="NX"></a>
<a name="Camera Link CC Output Signal: Get   ---   pxd_getCameraLinkCCOut" class="Sg"></a>
<a name="Camera Link CC Output Signal: Get   ---   pxd_getCameraLinkCCOut"></a>
<h6 class="Sg">Camera Link CC Output Signal: Get   ---   pxd_getCameraLinkCCOut</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  pxd_setCameraLinkCCOut(unitmap, setoutdata);
int  pxd_getCameraLinkCCOut(unitmap, getoutdata);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 data;           // Binary value(s) to set, bit value 0x1 for CC1,
                                    // bit value 0x2 for CC2, etc.
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>
sets the current value of the Camera Link CC output signals to
<em class="Ep">setoutdata</em>,
for those CC lines which are not otherwise in use
for video control, as specified in the video format.
Both for historical reasons and to be conservative,
video formats typically reserve all of the CC lines to
be used for video control so as to avoid accidental interference
with video.
Changes via
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>
take effect immediately; changes are not synchronized to
horizontal or vertical video timing.
</p><p>
The
<a href="#pxd_getCameraLinkCCOut" class="Er">pxd_getCameraLinkCCOut</a>
gets the current value of the Camera Link CC output signals
returning a value in the same format as the
<em class="Ep">setoutdata</em>
parameter of
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>.
For CC lines which remain under video control,
the return'ed bits of
<a href="#pxd_getCameraLinkCCOut" class="Er">pxd_getCameraLinkCCOut</a>
are undefined.
The
<em class="Ep">getoutdata</em>
is ignored.
</p><p>
For
<a href="#pxd_getCameraLinkCCOut" class="Er">pxd_getCameraLinkCCOut</a>
the
<em class="Ep">unitmap</em>
specifies the single unit for which the Camera Link CC output signals
are sensed.
For
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>
the
<em class="Ep">unitmap</em>
specifies the multiple units for which the Camera Link CC output signals
are set.
</p><p>
The
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>
and
<a href="#pxd_getCameraLinkCCOut" class="Er">pxd_getCameraLinkCCOut</a>
are not available for use with the PIXCI® CL1 and CL3SD imaging boards,
nor for PIXCI® imaging boards which do not support Camera Link.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_getCameraLinkCCOut" class="Er">pxd_getCameraLinkCCOut</a>
return values as described above, and may also return:
</p><dl>
<br><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<p>
The
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>
returns:
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_defineImage NX186" class="NX"></a>
<a name="pxd_defineImage" class="Sf"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer NX187" class="NX"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage" class="Sf"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage"></a>
<h6 class="Sf">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage</h6>
<a name="pxd_defineImage3 NX188" class="NX"></a>
<a name="pxd_defineImage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers NX189" class="NX"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3"></a>
<h6 class="Sg">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3</h6>
<a name="pxd_definePximage NX190" class="NX"></a>
<a name="pxd_definePximage" class="Sg"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer NX191" class="NX"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage" class="Sg"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage"></a>
<h6 class="Sg">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage</h6>
<a name="pxd_definePximage3 NX192" class="NX"></a>
<a name="pxd_definePximage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers NX193" class="NX"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3"></a>
<h6 class="Sg">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3</h6>
<a name="pxd_definePximageFree NX194" class="NX"></a>
<a name="pxd_definePximageFree" class="Sg"></a>
<a name="Get PXIMAGE: Release Access to Imaging Board Frame Buffers NX195" class="NX"></a>
<a name="Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree" class="Sg"></a>
<a name="Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree"></a>
<h6 class="Sg">Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree</h6>
<a name="pxd_definePximage3Free NX196" class="NX"></a>
<a name="pxd_definePximage3Free" class="Sg"></a>
<a name="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers NX197" class="NX"></a>
<a name="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free" class="Sg"></a>
<a name="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free"></a>
<h6 class="Sg">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>struct pximage  * pxd_defineImage (unitmap, framebuf, ulx, uly, lrx, lry, colorspace);
struct pximage3 * pxd_defineImage3(unitmap, startbuf, endbuf, ulx, uly, lrx, lry, colorspace);
<br>
struct pximage  * pxd_definePximage (unitmap, framebuf, ulx, uly, lrx, lry, colorspace);
struct pximage3 * pxd_definePximage3(unitmap, startbuf, endbuf, ulx, uly, lrx, lry, colorspace);
void              pxd_definePximageFree(image);
void              pxd_definePximage3Free(image3)
<br>
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
char                *colorspace;    // Name of requested color representation
<br>
pxbuffer_t          startbuf;       // First image frame buffer
pxbuffer_t          endbuf;         // Last image frame buffer
<br>
struct pximage      image;          // Image access to be released
struct pximage3     image3;         // Image access to be released
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
A reference to an image frame buffer and an area of interest within the image
frame buffer, or a reference to a sequence of image frame buffers
and an area of interest within each image frame buffer,
is constructed and returned.
</p><p>
These functions are useful for constructing a reference
which specifies
an image frame buffer and an area of interest
for use with other library functions,
in particular functions in the
<cite class="Ec">PXIPL Image Processing Library</cite>,
which expect a
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*'',
to specify image access,
and where the programmer prefers to avoid the (explicit)
use of structures and pointers.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit to be accessed.
For
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>,
the
<em class="Ep">framebuf</em>,
where
1&lt;=<em class="Ep">framebuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
specifies the image frame buffer to be accessed.
For
<a href="#pxd_defineImage3" class="Er">pxd_defineImage3</a>,
the
<em class="Ep">startbuf</em>
and
<em class="Ep">endbuf</em>,
where
<em class="Ep">startbuf</em>&lt;=<em class="Ep">endbuf,</em>
1&lt;=<em class="Ep">startbuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
and
1&lt;=<em class="Ep">endbuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
specify the first and last, inclusively, image frame buffer
to be accessed.
The
<em class="Ep">ulx</em>
and
<em class="Ep">uly</em>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>())
or the extreme bottom vertical coordinate
(i.e.
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>()),
respectively.
</p><p>
The
<em class="Ep">colorspace</em>
specifies the color space and color component(s)
in which the image frame buffer(s) are to be accessed.
Valid choices are:
</p><blockquote>
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
colorspace  
</td>
<td colspan="1" align="left">
 Number of Components 
</td>
<td colspan="1" align="left">
 Color Representation
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Default"   
</td>
<td colspan="1" align="left">
 ? 
</td>
<td colspan="1" align="left">
 Image frame buffer's default representation,
</td>
</tr>
<tr>
<td colspan="1" align="left">
            
</td>
<td colspan="1" align="left">
   
</td>
<td colspan="1" align="left">
 typically Grey, RGB, BGR, or YCrCb.
</td>
</tr>
<tr>
<td colspan="1" align="left">
<br>
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Display"   
</td>
<td colspan="1" align="left">
 ? 
</td>
<td colspan="1" align="left">
 Optimum representation for display purposes,
</td>
</tr>
<tr>
<td colspan="1" align="left">
            
</td>
<td colspan="1" align="left">
   
</td>
<td colspan="1" align="left">
 typically Grey, RGB, BGR, RGBx, or BGRx.
</td>
</tr>
<tr>
<td colspan="1" align="left">
<br>
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RGB"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Red, Green, Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofRGB"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofRGB"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofRGB"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BGR"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Blue, Green, Red (RGB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofBGR"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofBGR"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofBGR"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BSH"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Brightness, Saturation, Hue (HSB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofBSH"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Brightness
</td>
</tr>
<tr>
<td colspan="1" align="left">
"SofBSH"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Saturation
</td>
</tr>
<tr>
<td colspan="1" align="left">
"HofBSH"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Hue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RGBx"      
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Red, Green, Blue, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofRGBx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofRGBx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofRGBx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BGRx"      
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Blue, Green, Red, Pad (RGB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofBGRx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofBGRx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofBGRx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Grey"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GREY"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale (alternate spelling for "Grey")
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Gray"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale (alternate spelling for "Grey")
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GRAY"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale (alternate spelling for "Grey")
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YCrCb"     
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YofYCrCb"  
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Intensity
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofYCrCb"  
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofYCrCb"  
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YCrCbX"    
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YofYCrCbX" 
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Intensity
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofYCrCbX" 
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofYCrCbX" 
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Bayer"     
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Raw Bayer Pattern Values
</td>
</tr>
<tr>
<td colspan="1" align="left">
"CbYCrY"    
</td>
<td colspan="1" align="left">
 2 
</td>
<td colspan="1" align="left">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"CMY"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Cyan, Magenta, Yellow
</td>
</tr>
<tr>
<td colspan="1" align="left">
"CofCMY"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Cyan
</td>
</tr>
<tr>
<td colspan="1" align="left">
"MofCMY"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Magenta
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YofCMY"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Yellow
</td>
</tr>
</tbody></table>
</pre>
</blockquote>
<p>
The
''BGRx''
selection, when read into a
''uchar''
buffer on Intel machines with little-endian architecture
(i.e. least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, results in pixels that are compatible with Windows' RGB() data type.
</p><p>
The
''Bayer''
selection is available only in conjunction with cameras
that actually output raw Bayer pattern values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
</p><p>
The
''CbYCrY''
selection is available only in conjunction with imaging boards
that actually capture CbYCrY (UYVY) values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x), BGR(x), or YCrCb.
</p><p>
The
''Display''
selection chooses an optimum color representation
for use with
<cite class="Ec">pxio8_GDIDisplay</cite>
and similar display functions
(in the
<cite class="Ec">PXIPL Image Processing Library</cite>),
and is dependent upon the camera, video
format configuration, and current graphics display system (S/VGA card).
</p><p>
For ease of use, the
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>
and
<a href="#pxd_defineImage3" class="Er">pxd_defineImage3</a>
return
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
that need
<u class="U">not</u>
(and must not)
be
<cite class="Ec">free</cite>'ed<cite class="Ec">.</cite>
Instead,
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>
and
<a href="#pxd_defineImage3" class="Er">pxd_defineImage3</a>
provide references to a limited number
of statically
allocated structures.
The limit is sufficient to support the convenient use of
any library function in the manner shown
in the example below; invoking
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>
or
<a href="#pxd_defineImage3" class="Er">pxd_defineImage3</a>
as
''in-line''
functions.
The returned
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
should
<u class="U">not</u>
be assigned to a pointer variable and used repeatedly.
</p><p>
In contrast, the
<a href="#pxd_definePximage" class="Er">pxd_definePximage</a>
and
<a href="#pxd_definePximage3" class="Er">pxd_definePximage3</a>
return a
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
that after use
<u class="U">must</u>
be released via
<a href="#pxd_definePximageFree" class="Er">pxd_definePximageFree</a>
or
<a href="#pxd_definePximage3Free" class="Er">pxd_definePximage3Free</a>,
respectively.
The
<a href="#pxd_definePximage" class="Er">pxd_definePximage</a>
and
<a href="#pxd_definePximage3" class="Er">pxd_definePximage3</a>
alternatives are appropriate
when accessing the library from a multi-threaded
environment, or when the programmer
chooses to assign the return values to a
pointer variable for repeated use.
The
<a href="#pxd_definePximage" class="Er">pxd_definePximage</a>
and
<a href="#pxd_definePximage3" class="Er">pxd_definePximage3</a>
creates a copy of the image access structures in
<cite class="Ec">malloc</cite>'ed
memory, but does not copy the image contents;
each use of the returned
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
access the current contents of the frame buffer.
</p><p>
The XCLIB-Lite does not support this feature.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><p>
Returns NULL if the library is not open for use,
if XCLIB-Lite is being used,
if the
<em class="Ep">colorspace</em>
or other parameter is invalid,
or for
<a href="#pxd_definePximage" class="Er">pxd_definePximage</a>
and
<a href="#pxd_definePximage3" class="Er">pxd_definePximage3</a>
if memory could not be
<cite class="Ec">malloc</cite>'ed.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
Consider the typical image processing library function
<cite class="Ec">pxip8_pixand</cite>,
which should be invoked as:
</p><blockquote>
<pre>int pxip8_pixand(abortp, sip, dip, mask);
pxabortfunc_t   **abortp;   // premature termination function, or NULL
struct  pximage *sip;       // source
struct  pximage *dip;       // destination
int     mask;               // and mask
</pre>
</blockquote>
The following invokes this library function,
operating on the upper left quadrant of image frame buffer 1
and placing the result in the lower right
quadrant of image frame buffer 2,
without explicitly using structures or pointers.
<blockquote>
<pre>int xdim, ydim;
<br>
xdim = pxd_imageXdim();
ydim = pxd_imageYdim();
pxip8_pixand(NULL,                  // no abort
             pxd_defineImage(1, 1, 0,      0,      xdim/2, ydim/2, "Default"),
             pxd_defineImage(1, 2, xdim/2, ydim/2, xdim,   ydim,   "Default"),
             0xC0 );                // chosen mask value
</pre>
</blockquote>
<p>
Consider the typical image processing library function
<cite class="Ec">pxio8_tifwriteseq</cite>,
which saves a sequence of images.
It may be invoked as:
</p><blockquote>
<pre>pxio8_tifwriteseq(NULL,
                  pxd_defineImage3(1, 1, pxd_imageZdim(), 0, 0, -1, -1, "Default"),
                  NULL, "test.tif", 8, 0, 0, NULL);
</pre>
</blockquote>
to save the entire AOI of all image frame buffers.
<hr size="1">
<a name="pxd_doSnap NX198" class="NX"></a>
<a name="pxd_doSnap" class="Sf"></a>
<a name="Video Snap and Wait NX199" class="NX"></a>
<a name="Video Snap and Wait   ---   pxd_doSnap" class="Sf"></a>
<a name="Video Snap and Wait   ---   pxd_doSnap"></a>
<h6 class="Sf">Video Snap and Wait   ---   pxd_doSnap</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_doSnap(unitmap, buffer, timeout);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
ulong               timeout;        // Snap timeout, in milliseconds
int
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>
initiates capture of a single image into the
<em class="Ep">buffer</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>,
and waits for capture to be complete
before returning.
</p><p>
The
<em class="Ep">timeout</em>
specifies a period of time after which the
snap should be aborted and  the function return
without having completed acquisition of a frame buffer.
If
<em class="Ep">timeout</em>=0,
a default timeout, as appropriate for the current video format
configuration, is used;
if
<em class="Ep">unitmap</em>
selects multiple imaging boards and
the multiple boards are being operated with different video format
configurations,
the default timeout used is the maximum of the
defaults for each of the selected imaging boards.
</p><p>For the PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB,
E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2,
SI, SI1, SI2, and SI4 imaging board
configured for triggered
capture, the
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>
''arms''
the imaging board to capture the next externally triggered
frame, or both
''arms''
and initiates a software triggered frame,
according to the Video Format Configuration.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture.
<br></dd><dt>PXERTIMEOUT</dt><dd>
The operation was aborted
due to timeout.
<br></dd><dt>PXERDEVFAULT</dt><dd>
Capture was not completed properly,
the
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
may provide additional information.
<br></dd><dt>PXER*</dt><dd>
Other error codes as appropriate.
</dd></dl>
7.\"
<hr size="1">
<a name="pxd_eventFieldCreate NX200" class="NX"></a>
<a name="pxd_eventFieldCreate" class="Sf"></a>
<a name="Windows: Register Event upon Video Field NX201" class="NX"></a>
<a name="Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate" class="Sf"></a>
<a name="Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate"></a>
<h6 class="Sf">Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate</h6>
<a name="pxd_eventFieldCreate2 NX202" class="NX"></a>
<a name="pxd_eventFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Video Field NX203" class="NX"></a>
<a name="Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate2"></a>
<h6 class="Sg">Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate2</h6>
<a name="pxd_eventFieldClose NX204" class="NX"></a>
<a name="pxd_eventFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Video Field NX205" class="NX"></a>
<a name="Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose</h6>
<a name="pxd_eventCapturedFieldCreate NX206" class="NX"></a>
<a name="pxd_eventCapturedFieldCreate" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field NX207" class="NX"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"></a>
<h6 class="Sg">Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</h6>
<a name="pxd_eventCapturedFieldCreate2 NX208" class="NX"></a>
<a name="pxd_eventCapturedFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field NX209" class="NX"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate2"></a>
<h6 class="Sg">Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate2</h6>
<a name="pxd_eventCapturedFieldClose NX210" class="NX"></a>
<a name="pxd_eventCapturedFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Captured Video Field NX211" class="NX"></a>
<a name="Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose</h6>
<a name="pxd_eventGPTriggerCreate NX212" class="NX"></a>
<a name="pxd_eventGPTriggerCreate" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger NX213" class="NX"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"></a>
<h6 class="Sg">Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</h6>
<a name="pxd_eventGPTriggerCreate2 NX214" class="NX"></a>
<a name="pxd_eventGPTriggerCreate2" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger NX215" class="NX"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate2" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate2"></a>
<h6 class="Sg">Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate2</h6>
<a name="pxd_eventGPTriggerClose NX216" class="NX"></a>
<a name="pxd_eventGPTriggerClose" class="Sg"></a>
<a name="Windows: Unregister Event upon General Purpose Trigger NX217" class="NX"></a>
<a name="Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose" class="Sg"></a>
<a name="Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"></a>
<h6 class="Sg">Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</h6>
<a name="pxd_eventFaultCreate NX218" class="NX"></a>
<a name="pxd_eventFaultCreate" class="Sg"></a>
<a name="Windows: Register Event upon Fault NX219" class="NX"></a>
<a name="Windows: Register Event upon Fault   ---   pxd_eventFaultCreate" class="Sg"></a>
<a name="Windows: Register Event upon Fault   ---   pxd_eventFaultCreate"></a>
<h6 class="Sg">Windows: Register Event upon Fault   ---   pxd_eventFaultCreate</h6>
<a name="pxd_eventFaultCreate2 NX220" class="NX"></a>
<a name="pxd_eventFaultCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Fault NX221" class="NX"></a>
<a name="Windows: Register Event upon Fault   ---   pxd_eventFaultCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Fault   ---   pxd_eventFaultCreate2"></a>
<h6 class="Sg">Windows: Register Event upon Fault   ---   pxd_eventFaultCreate2</h6>
<a name="pxd_eventFaultClose NX222" class="NX"></a>
<a name="pxd_eventFaultClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Fault NX223" class="NX"></a>
<a name="Windows: Unregister Event upon Fault   ---   pxd_eventFaultClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Fault   ---   pxd_eventFaultClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Fault   ---   pxd_eventFaultClose</h6>
<a name="pxd_eventSerialCreate NX224" class="NX"></a>
<a name="pxd_eventSerialCreate" class="Sg"></a>
<a name="Windows: Register Event upon Serial NX225" class="NX"></a>
<a name="Windows: Register Event upon Serial   ---   pxd_eventSerialCreate" class="Sg"></a>
<a name="Windows: Register Event upon Serial   ---   pxd_eventSerialCreate"></a>
<h6 class="Sg">Windows: Register Event upon Serial   ---   pxd_eventSerialCreate</h6>
<a name="pxd_eventSerialClose NX226" class="NX"></a>
<a name="pxd_eventSerialClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Serial NX227" class="NX"></a>
<a name="Windows: Unregister Event upon Serial   ---   pxd_eventSerialClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Serial   ---   pxd_eventSerialClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Serial   ---   pxd_eventSerialClose</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>HANDLE pxd_eventFieldCreate(unitmap);
HANDLE pxd_eventFieldCreate2(unitmap, type);
void   pxd_eventFieldClose(unitmap, hEvent);
HANDLE pxd_eventCapturedFieldCreate(unitmap);
HANDLE pxd_eventCapturedFieldCreate2(unitmap, type);
void   pxd_eventCapturedFieldClose(unitmap, hEvent);
HANDLE pxd_eventGPTriggerCreate(unitmap, gpwhich, rsvd);
HANDLE pxd_eventGPTriggerCreate2(unitmap, gpwhich, rsvd, type);
void   pxd_eventGPTriggerClose(unitmap, gpwhich, rsvd, hEvent);
HANDLE pxd_eventFaultCreate(unitmap, rsvd);
HANDLE pxd_eventFaultCreate2(unitmap, rsvd, type);
void   pxd_eventFaultClose(unitmap, rsvd, hEvent);
HANDLE pxd_eventSerialCreate(unitmap, serwhich, rsvd, type);
void   pxd_eventSerialClose(unitmap, serwhich, rsvd, hEvent);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
HANDLE              hEvent;         // HANDLE returned by previous create
int                 gpwhich;        // Which of N triggers to use, N &gt;= 0
int                 rsvd;           // Reserved, should be 0
int                 type;           // 's': synchronization style event
                                    // 'n': notification style event
int                 serwhich;       // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="Windows NX228" class="NX"></a>
The
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>
and
<a href="#pxd_eventFieldCreate2" class="Er">pxd_eventFieldCreate2</a>
returns a handle to a Windows event which is signaled
once per video field, whether captured or not,
on the single unit specified by
<em class="Ep">unitmap</em>.
For PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L:
The event is signaled at (approximately) the start of vertical drive.
For PIXCI®&nbsp;SV7:
The event is signaled at (approximately) the middle of vertical drive.
For PIXCI®&nbsp;A, CL1, CL2, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB,
EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1,
SI2, and SI4:
The event is signaled at (approximately) the end of vertical drive.
For PIXCI®&nbsp;CL3SD:
The event is signaled at vertical drive, which is so short as to
make end vs. start distinctions irrelevant.
</p><p>
The
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>
and
<a href="#pxd_eventCapturedFieldCreate2" class="Er">pxd_eventCapturedFieldCreate2</a>
returns a HANDLE to a Windows event which is signaled
once per captured video field,
on the single unit specified by
<em class="Ep">unitmap</em>.
The event is signaled at (approximately) after the last pixel captured
within the field.
</p><p>
The
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>
and
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>
returns a HANDLE to a Windows event which is signaled
once per trigger initiated by the
general purpose trigger signal(s), if any,
on the single unit specified by
<em class="Ep">unitmap</em>.
The
<em class="Ep">gpwhich</em>
specifies which of several trigger(s) is to be sensed.
</p><p>
The
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
and
<a href="#pxd_eventFaultCreate2" class="Er">pxd_eventFaultCreate2</a>
returns a HANDLE to a Windows event which is signaled
once per fault,
on the single unit specified by
<em class="Ep">unitmap</em>.
These are the faults retrieved by
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
or
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>.
</p><p>
The
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
returns a HANDLE to a Windows event which is signaled
once per serial activity
on the single unit specified by
<em class="Ep">unitmap</em>
on
PIXCI® CL1, CL2, CL3SD, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, and EL1DB imaging boards.
The serial port must be configured via
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>
or
<a href="#clSerialInit" class="Er">clSerialInit</a>.
The event is signalled upon
character received,
character transmitted, character receive overrun, and receive framing errors.
</p><p>
Under Windows NT, 2000, XP, Vista, and 7
the
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
and
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
create synchronization style events.
The
<a href="#pxd_eventFieldCreate2" class="Er">pxd_eventFieldCreate2</a>,
<a href="#pxd_eventCapturedFieldCreate2" class="Er">pxd_eventCapturedFieldCreate2</a>,
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>,
<a href="#pxd_eventFaultCreate2" class="Er">pxd_eventFaultCreate2</a>,
and
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
create a Windows synchronization style event
if
<em class="Ep">type</em>='s',
and create a Windows notification style event if
<em class="Ep">type</em>='n'.
Under Windows 95, 98, and ME there is only one event type
and the
<em class="Ep">type</em>
parameter is ignored.
</p><p>
The Windows HANDLE returned by
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventFieldCreate2" class="Er">pxd_eventFieldCreate2</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate2" class="Er">pxd_eventCapturedFieldCreate2</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>,
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>,
<a href="#pxd_eventFaultCreate2" class="Er">pxd_eventFaultCreate2</a>,
or
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
can be used with
<cite class="Ec">WaitForSingleObject</cite>
or any other appropriate Windows' API function, such as:
</p><blockquote>
<pre>    HANDLE  hEvent = pxd_eventFieldCreate(0x1);
    for (;;) {
        WaitForSingleObject(hEvent, INFINITE);
        // do something upon signal
    }
</pre>
</blockquote>
If using multiple threads in conjunction with
<cite class="Ec">WaitForSingleObject</cite>
or similar functions, note that entry into XCLIB functions
must synchronized by the application
to prevent overlapping entry by multiple threads.
<p>
The
<a href="#pxd_eventFieldClose" class="Er">pxd_eventFieldClose</a>,
<a href="#pxd_eventCapturedFieldClose" class="Er">pxd_eventCapturedFieldClose</a>,
<a href="#pxd_eventGPTriggerClose" class="Er">pxd_eventGPTriggerClose</a>,
<a href="#pxd_eventFaultClose" class="Er">pxd_eventFaultClose</a>,
or
<a href="#pxd_eventSerialClose" class="Er">pxd_eventSerialClose</a>
terminates the event previously created with
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventFieldCreate2" class="Er">pxd_eventFieldCreate2</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate2" class="Er">pxd_eventCapturedFieldCreate2</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>,
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>,
<a href="#pxd_eventFaultCreate2" class="Er">pxd_eventFaultCreate2</a>,
or
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
respectively.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventFieldCreate2" class="Er">pxd_eventFieldCreate2</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate2" class="Er">pxd_eventCapturedFieldCreate2</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>,
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>,
<a href="#pxd_eventFaultCreate2" class="Er">pxd_eventFaultCreate2</a>,
and
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
return a Windows' HANDLE, or NULL
if error.
<br>
<br>
<br>
<em class="Ss">See Also</em>
</p><p>
The
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>,
and
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
provide signals or counts, respectively,
upon the same general purpose trigger signal.
See
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
for additional discussion on the availability and use
of general purpose trigger signal(s).
</p><p>
See Windows MSDN documentation for the distinction
between synchronization versus notification style
events and the advantages of each.
</p><hr size="1">
<a name="pxd_eventFieldCreate NX229" class="NX"></a>
<a name="pxd_eventFieldCreate" class="Sf"></a>
<a name="DOS: Register Callback upon Video Field NX230" class="NX"></a>
<a name="DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate" class="Sf"></a>
<a name="DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate"></a>
<h6 class="Sf">DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate</h6>
<a name="pxd_eventFieldClose NX231" class="NX"></a>
<a name="pxd_eventFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Video Field NX232" class="NX"></a>
<a name="DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose</h6>
<a name="pxd_eventCapturedFieldCreate NX233" class="NX"></a>
<a name="pxd_eventCapturedFieldCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Captured Video Field NX234" class="NX"></a>
<a name="DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</h6>
<a name="pxd_eventCapturedFieldClose NX235" class="NX"></a>
<a name="pxd_eventCapturedFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Captured Video Field NX236" class="NX"></a>
<a name="DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose</h6>
<a name="pxd_eventGPTriggerCreate NX237" class="NX"></a>
<a name="pxd_eventGPTriggerCreate" class="Sg"></a>
<a name="DOS: Register Callback upon General Purpose Trigger NX238" class="NX"></a>
<a name="DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate" class="Sg"></a>
<a name="DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"></a>
<h6 class="Sg">DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</h6>
<a name="pxd_eventGPTriggerClose NX239" class="NX"></a>
<a name="pxd_eventGPTriggerClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon General Purpose Trigger NX240" class="NX"></a>
<a name="DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</h6>
<a name="pxd_eventFaultCreate NX241" class="NX"></a>
<a name="pxd_eventFaultCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Fault NX242" class="NX"></a>
<a name="DOS: Register Callback upon Fault   ---   pxd_eventFaultCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Fault   ---   pxd_eventFaultCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Fault   ---   pxd_eventFaultCreate</h6>
<a name="pxd_eventFaultClose NX243" class="NX"></a>
<a name="pxd_eventFaultClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Fault NX244" class="NX"></a>
<a name="DOS: Unregister Callback upon Fault   ---   pxd_eventFaultClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Fault   ---   pxd_eventFaultClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Fault   ---   pxd_eventFaultClose</h6>
<a name="pxd_eventSerialCreate NX245" class="NX"></a>
<a name="pxd_eventSerialCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Serial NX246" class="NX"></a>
<a name="DOS: Register Callback upon Serial   ---   pxd_eventSerialCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Serial   ---   pxd_eventSerialCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Serial   ---   pxd_eventSerialCreate</h6>
<a name="pxd_eventSerialClose NX247" class="NX"></a>
<a name="pxd_eventSerialClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Serial NX248" class="NX"></a>
<a name="DOS: Unregister Callback upon Serial   ---   pxd_eventSerialClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Serial   ---   pxd_eventSerialClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Serial   ---   pxd_eventSerialClose</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_eventFieldCreate(unitmap, irqfunc, statep);
int pxd_eventFieldClose(unitmap, irqfunc);
int pxd_eventCapturedFieldCreate(unitmap, irqfunc, statep);
int pxd_eventCapturedFieldClose(unitmap, irqfunc);
int pxd_eventGPTriggerCreate(unitmap, gpwhich, rsvd, irqfunc, statep);
int pxd_eventGPTriggerClose(unitmap, gpwhich, rsvd, irqfunc);
int pxd_eventFaultCreate(unitmap, rsvd, irqfunc, statep);
int pxd_eventFaultClose(unitmap, rsvd, irqfunc);
int pxd_eventSerialCreate(unitmap, serwhich, rsvd, irqfunc, statep);
int pxd_eventSerialClose(unitmap, serwhich, rsvd, irqfunc);
<br>
typedef int (_cfunfcc pxasyncfunc_t)(void*,int,int);
                                    // _cfunfcc is a predefined function modifier
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxasyncfunc_t       irqfunc         // Callback function
void                *statep;        // Argument to call back function
int                 gpwhich;        // Which of N triggers to use, &gt;= 0
int                 rsvd;           // Reserved, should be 0
int                 serwhich;       // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="DOS NX249" class="NX"></a>
The
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>
registers a callback function to be invoked
once per video field, whether captured or not,
on the single unit specified by
<em class="Ep">unitmap</em>.
For PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L:
The function is invoked at (approximately) the start of vertical drive.
For PIXCI®&nbsp;SV7:
The function is invoked at (approximately) the middle of vertical
drive.
For PIXCI®&nbsp;A, CL1, CL2, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB,
EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1,
SI2, and SI4:
The function is invoked at (approximately) the end of vertical drive.
For PIXCI®&nbsp;CL3SD:
The function is invoked at vertical drive, which is so short as to
make end vs. start distinctions irrelevant.
</p><p>
The
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>
registers a callback function to be invoked
once per captured video field,
on the single unit specified by
<em class="Ep">unitmap</em>.
The function is invoked at (approximately) after the last pixel captured
within the field.
</p><p>
The
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>
registers a callback function to be invoked
once per trigger initiated by the
general purpose trigger signal(s), if any,
on the single unit specified by
<em class="Ep">unitmap</em>.
The
<em class="Ep">gpwhich</em>
specifies which of several trigger(s) is to be sensed.
</p><p>
The
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
registers a callback function to be invoked
once per fault,
on the single unit specified by
<em class="Ep">unitmap</em>.
These are the faults retrieved by
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
or
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>.
</p><p>
The
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
registers a callback function to be invoked
once per serial activity,
on the single unit specified by
<em class="Ep">unitmap</em>
on
PIXCI® CL1, CL2, CL3SD, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, and EL1DB imaging boards.
The serial port must be configured via
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>
or
<a href="#clSerialInit" class="Er">clSerialInit</a>.
The event is signalled upon
character received,
character transmitted, character receive overrun, and receive framing errors.
</p><p>
The
<em class="Ep">irqfunc</em>
specifies the callback function to be invoked, such as:
</p><pre>    int _cfunfcc my_irq_callback(void *statep, int unitmap, int reserved)
    {
    }
</pre>
where
<em class="Ep">statep</em>
is the value previously passed to
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>,
or
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>,
where
<em class="Ep">unitmap</em>
specifies the unit upon which the event occurred,
and where
<em class="Ep">reserved</em>
is currently unused and 0.
<p>
As any other interrupt handler, the
<em class="Ep">irqfunc</em>
must operate under severe constraints.
It, and all functions it invokes,
must not be pageable (i.e under VM),
must be compiled to avoid stack checks (probes),
must not use excessive stack or time,
must not use most DOS or BIOS
functions (including
<cite class="Ec">printf</cite>).
The
<em class="Ep">irqfunc</em>
should not be declared with the compiler's
''_interrupt''
or
''__interrupt''
adjective.
</p><p>
The
<a href="#pxd_eventFieldClose" class="Er">pxd_eventFieldClose</a>,
<a href="#pxd_eventCapturedFieldClose" class="Er">pxd_eventCapturedFieldClose</a>,
<a href="#pxd_eventGPTriggerClose" class="Er">pxd_eventGPTriggerClose</a>,
<a href="#pxd_eventFaultClose" class="Er">pxd_eventFaultClose</a>,
or
<a href="#pxd_eventSerialClose" class="Er">pxd_eventSerialClose</a>
unregisters the callback function previously registered with
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>,
or
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>,
respectively.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
The
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>
and
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
provide callbacks or counts, respectively,
upon the same general purpose trigger signal.
See
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
for additional discussion on the availability and use
of general purpose trigger signal(s).
</p><hr size="1">
<a name="pxd_eventFieldCreate NX250" class="NX"></a>
<a name="pxd_eventFieldCreate" class="Sf"></a>
<a name="Linux: Register Signal upon Video Field NX251" class="NX"></a>
<a name="Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate" class="Sf"></a>
<a name="Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate"></a>
<h6 class="Sf">Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate</h6>
<a name="pxd_eventFieldClose NX252" class="NX"></a>
<a name="pxd_eventFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Video Field NX253" class="NX"></a>
<a name="Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose</h6>
<a name="pxd_eventCapturedFieldCreate NX254" class="NX"></a>
<a name="pxd_eventCapturedFieldCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Captured Video Field NX255" class="NX"></a>
<a name="Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</h6>
<a name="pxd_eventCapturedFieldClose NX256" class="NX"></a>
<a name="pxd_eventCapturedFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Captured Video Field NX257" class="NX"></a>
<a name="Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose</h6>
<a name="pxd_eventGPTriggerCreate NX258" class="NX"></a>
<a name="pxd_eventGPTriggerCreate" class="Sg"></a>
<a name="Linux: Register Signal upon General Purpose Trigger NX259" class="NX"></a>
<a name="Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate" class="Sg"></a>
<a name="Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"></a>
<h6 class="Sg">Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</h6>
<a name="pxd_eventGPTriggerClose NX260" class="NX"></a>
<a name="pxd_eventGPTriggerClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon General Purpose Trigger NX261" class="NX"></a>
<a name="Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</h6>
<a name="pxd_eventFaultCreate NX262" class="NX"></a>
<a name="pxd_eventFaultCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Fault NX263" class="NX"></a>
<a name="Linux: Register Signal upon Fault   ---   pxd_eventFaultCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Fault   ---   pxd_eventFaultCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Fault   ---   pxd_eventFaultCreate</h6>
<a name="pxd_eventFaultClose NX264" class="NX"></a>
<a name="pxd_eventFaultClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Fault NX265" class="NX"></a>
<a name="Linux: Unregister Signal upon Fault   ---   pxd_eventFaultClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Fault   ---   pxd_eventFaultClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Fault   ---   pxd_eventFaultClose</h6>
<a name="pxd_eventSerialCreate NX266" class="NX"></a>
<a name="pxd_eventSerialCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Serial NX267" class="NX"></a>
<a name="Linux: Register Signal upon Serial   ---   pxd_eventSerialCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Serial   ---   pxd_eventSerialCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Serial   ---   pxd_eventSerialCreate</h6>
<a name="pxd_eventSerialClose NX268" class="NX"></a>
<a name="pxd_eventSerialClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Serial NX269" class="NX"></a>
<a name="Linux: Unregister Signal upon Serial   ---   pxd_eventSerialClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Serial   ---   pxd_eventSerialClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Serial   ---   pxd_eventSerialClose</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_eventFieldCreate(unitmap, signum, rsvd2);
int pxd_eventFieldClose(unitmap, signum);
int pxd_eventCapturedFieldCreate(unitmap, signum, rsvd2);
int pxd_eventCapturedFieldClose(unitmap, signum);
int pxd_eventGPTriggerCreate(unitmap, gpwhich, rsvd, signum, rsvd2);
int pxd_eventGPTriggerClose(unitmap, gpwhich, rsvd, signum);
int pxd_eventFaultCreate(unitmap, rsvd, signum, rsvd2);
int pxd_eventFaultClose(unitmap, rsvd, signum);
int pxd_eventSerialCreate(unitmap, serwhich, rsvd, signum, rsvd2);
int pxd_eventSerialClose(unitmap, serwhich, rsvd, signum);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 signum;         // Signal number
int                 gpwhich;        // Which of N triggers to use, &gt;= 0
int                 rsvd;           // Reserved, should be 0
void                *rsvd2;         // Reserved, should be NULL
int                 serwhich;       // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="Linux NX270" class="NX"></a>
The
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>
registers a signal number to be signaled
once per video field, whether captured or not,
on the single unit specified by
<em class="Ep">unitmap</em>.
For PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L:
The signal is issued at (approximately) the start of vertical drive.
For PIXCI®&nbsp;SV7:
The signal is issued at (approximately) the middle of vertical drive.
For PIXCI®&nbsp;A, CL1, CL2, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB,
EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1,
SI2, and SI4:
The signal is issued at (approximately) the end of vertical drive.
For PIXCI®&nbsp;CL3SD:
The signal is issued at vertical drive, which is so short as to
make end vs. start distinctions irrelevant.
</p><p>
The
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>
registers a signal number to be signaled
once per captured video field,
on the single unit specified by
<em class="Ep">unitmap</em>.
The function is invoked at (approximately) after the last pixel captured
within the field.
</p><p>
The
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>
registers a signal number to be signaled
once per trigger initiated by the
general purpose trigger signal(s), if any,
on the single unit specified by
<em class="Ep">unitmap</em>.
The
<em class="Ep">gpwhich</em>
specifies which of several trigger(s) is to be sensed.
</p><p>
The
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
registers a signal number to be signaled
once per fault,
on the single unit specified by
<em class="Ep">unitmap</em>.
These are the faults retrieved by
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
or
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>.
</p><p>
The
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
registers a signal number to be signaled
once per serial activity,
on the single unit specified by
<em class="Ep">unitmap</em>
on
PIXCI® CL1, CL2, CL3SD, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, and EL1DB imaging boards.
The serial port must be configured via
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>
or
<a href="#clSerialInit" class="Er">clSerialInit</a>.
The event is signalled upon
character received,
character transmitted, character receive overrun, and receive framing errors.
</p><p>
The
<em class="Ep">signum</em>
specifies the Linux signal number to be used,
such as SIGUSR1.
(see Linux's
<code class="Em">signal.h</code>).
Handling the signal, such as with
<cite class="Ec">signal()</cite>
or
<cite class="Ec">sigaction()</cite>
is the caller's responsibility.
</p><p>
If the caller's signal handling function is to call
XCLIB functions, note that
entry into XCLIB functions
must be synchronized by the application
to prevent overlapping entry by multiple threads.
</p><p>
The
<a href="#pxd_eventFieldClose" class="Er">pxd_eventFieldClose</a>,
<a href="#pxd_eventCapturedFieldClose" class="Er">pxd_eventCapturedFieldClose</a>,
<a href="#pxd_eventGPTriggerClose" class="Er">pxd_eventGPTriggerClose</a>,
<a href="#pxd_eventFaultClose" class="Er">pxd_eventFaultClose</a>,
or
<a href="#pxd_eventSerialClose" class="Er">pxd_eventSerialClose</a>
unregisters the signaling previously registered with
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>,
or
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>,
respectively.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
The
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>
and
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
provide signals or counts, respectively,
upon the same general purpose trigger signal.
See
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
for additional discussion on the availability and use
of general purpose trigger signal(s).
</p><hr size="1">
<a name="pxd_getGPIn NX271" class="NX"></a>
<a name="pxd_getGPIn" class="Sf"></a>
<a name="General Purpose Input Signal: Sense NX272" class="NX"></a>
<a name="General Purpose Input Signal: Sense   ---   pxd_getGPIn" class="Sf"></a>
<a name="General Purpose Input Signal: Sense   ---   pxd_getGPIn"></a>
<h6 class="Sf">General Purpose Input Signal: Sense   ---   pxd_getGPIn</h6>
<a name="pxd_setGPIn NX273" class="NX"></a>
<a name="pxd_setGPIn" class="Sg"></a>
<a name="General Purpose Input Signal: Reset NX274" class="NX"></a>
<a name="General Purpose Input Signal: Reset   ---   pxd_setGPIn" class="Sg"></a>
<a name="General Purpose Input Signal: Reset   ---   pxd_setGPIn"></a>
<h6 class="Sg">General Purpose Input Signal: Reset   ---   pxd_setGPIn</h6>
<a name="pxd_setGPOut NX275" class="NX"></a>
<a name="pxd_setGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Set NX276" class="NX"></a>
<a name="General Purpose Output Signal: Set   ---   pxd_setGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Set   ---   pxd_setGPOut"></a>
<h6 class="Sg">General Purpose Output Signal: Set   ---   pxd_setGPOut</h6>
<a name="pxd_getGPOut NX277" class="NX"></a>
<a name="pxd_getGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Get NX278" class="NX"></a>
<a name="General Purpose Output Signal: Get   ---   pxd_getGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Get   ---   pxd_getGPOut"></a>
<h6 class="Sg">General Purpose Output Signal: Get   ---   pxd_getGPOut</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  pxd_getGPIn(unitmap, getindata);
int  pxd_setGPIn(unitmap, setindata);
int  pxd_setGPOut(unitmap, setoutdata);
int  pxd_getGPOut(unitmap, getoutdata);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 data;           // Binary value(s) to set or reset
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The general purpose input and output
signals are sensed, set, or reset.
</p><p>
The
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>
obtains the current value of the general purpose
input signals, if any.
The
<em class="Ep">getindata</em>
is ignored.
</p><p>
The
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
resets the current value of the general purpose
input signals, if any, as per
<em class="Ep">setindata</em>,
for imaging boards where the
general purpose inputs are latched rather than level sensitive.
</p><p>
The
<a href="#pxd_setGPOut" class="Er">pxd_setGPOut</a>
sets the current value of the general purpose
output signals, if any, to
<em class="Ep">setoutdata</em>.
</p><p>
The
<a href="#pxd_getGPOut" class="Er">pxd_getGPOut</a>
gets the current value of the general purpose
output signals, if any,
returning a value in the same format as
the
<em class="Ep">setoutdata</em>
parameter of
<a href="#pxd_setGPOut" class="Er">pxd_setGPOut</a>.
The
<em class="Ep">getoutdata</em>
is ignored.
</p><p>
For
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>
and
<a href="#pxd_getGPOut" class="Er">pxd_getGPOut</a>,
the
<em class="Ep">unitmap</em>
specifies the single unit for which the general
purpose input signals are sensed or the current value of
the general purpose output signals are obtained.
For
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
and
<a href="#pxd_setGPOut" class="Er">pxd_setGPOut</a>,
the
<em class="Ep">unitmap</em>
specifies the multiple units for which the general
purpose input signals are reset or the general purpose
output signals are set.
</p><p>
For the PIXCI®&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
The boards' four general purpose output signals, XD4, XD5, XD6, and XD7,
are set to the bits 0x01, 0x02, 0x04, and 0x08 of
<em class="Ep">setoutdata</em>,
respectively.
The boards' four general purpose input signals, XD0, XD1, XD2, and XD3,
are sensed in bits
0x01, 0x02, 0x04, and 0x08,
respectively,
of the returned value of
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>.
The general purpose inputs are level sensitive,
the
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;SV5B imaging boards:
The board does not provide purpose input or output signals.
</p><p>
For the PIXCI®&nbsp;SV5L imaging board:
The boards' general purpose output signal, XD4,
is set to bit 0x01 of
<em class="Ep">setoutdata</em>.
The boards' general purpose input signal, XD0,
are sensed in bit
0x01
of the returned value of
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>.
The general purpose inputs are level sensitive,
the
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;D, D24, and D32 imaging boards:
The availability of general purpose inputs and outputs
depends upon the board model, revision level, and video format configuration.
The boards may have a single general purpose latched input signal,
sensed as bit 0x01 of the returned value of
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>,
and reset as bit 0x01
of the
<em class="Ep">setindata</em>
of
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>.
The boards may have a single general purpose latched output signal,
set to bit 0x01 of
<em class="Ep">setoutdata</em>.
</p><p>
For the PIXCI®&nbsp;CL2, CL3SD, D2X, D3X, E1, E4, EB1, EB1-PoCL, EC1, EL1, SI, and SI1 imaging boards
and for each functional unit of the PIXCI®&nbsp;E1DB, E4DB, EL1DB, ELS2, SI2, SI4, and SV7 imaging boards:
The two general purpose output signals
are set to bits 0x01 and 0x02 of
<em class="Ep">setoutdata</em>.
The two general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>.
The general purpose inputs are level sensitive,
the
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;ECB1, EL1, and SI imaging board:
The one general purpose output signal
is set to bit 0x01 of
<em class="Ep">setoutdata</em>.
The one general purpose input signal
is sensed in bit
0x01
of the returned value of
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>.
The general purpose inputs are level sensitive,
the
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;ECB1-34 and ECB2 imaging boards:
The board does not provide purpose input or output signals.
</p><p>
For the PIXCI®&nbsp;CL1 imaging boards:
The board's one (revision 1 boards) or two (revision 2 and later boards)
general purpose output signals
are set to bits 0x01 and 0x02 of
<em class="Ep">setoutdata</em>.
The board's one (revision 1 boards) or two (revision 2 and later boards)
general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>.
The general purpose inputs are level sensitive,
the
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
has no effect.
</p><p>Note:
The general purpose input(s) and output(s)
are those
''auxiliary''
features available on some imaging boards
where, at the hardware level, the signal has no direct effect
on video capture.
The general purpose input(s) and output(s)
are not related to, and not needed for,
camera specific, hardware supported, typically asynchronous exposure,
triggering features available on some cameras when used with
the PIXCI®&nbsp;CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, or SI4
imaging board.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>
and
<a href="#pxd_getGPOut" class="Er">pxd_getGPOut</a>
return values as described above, and may also return:
</p><dl>
<br><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<p>
The
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>
and
<a href="#pxd_setGPOut" class="Er">pxd_setGPOut</a>
return:
</p><dl>
<br><dt>0</dt><dd>
Function performed,
however this returned value is not proof that the
imaging board supports the general purpose input(s) and
output(s).
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_getGPTrigger NX279" class="NX"></a>
<a name="pxd_getGPTrigger" class="Sf"></a>
<a name="General Purpose Trigger Count: Sense NX280" class="NX"></a>
<a name="General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger" class="Sf"></a>
<a name="General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger"></a>
<h6 class="Sf">General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  pxd_getGPTrigger(unitmap, which);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 which;          // Which of N triggers to sense, &gt;= 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
obtains the current count of the number of triggers
initiated by the general purpose
trigger signal(s), if any.
The
<em class="Ep">unitmap</em>
specifies the single unit for which the general
purpose trigger count is obtained.
The
<em class="Ep">which</em>
specifies which of several trigger(s) is to be sensed.
</p><p>
For the PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L imaging boards:
There are no general purpose trigger signals.
</p><p>For the PIXCI®&nbsp;CL1, CL2, CL3SD, D, D24, D32, D2X, D32, E1,
E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB,
ELS2, SI, SI1, SI2, SI4, and SV7 imaging boards:
The availability of general purpose triggers, and whether
they are sensitive to rising edges or falling edges
depends upon the board model, revision level, and video format
configuration.
</p><p>Note:
The general purpose trigger(s)
are those
''auxiliary''
features available on some imaging boards
where, at the hardware level, the signal has no direct effect
on video capture.
Use of this function to obtain the general purpose
trigger count is not needed
when the PIXCI®&nbsp;CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB,
E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2,
SI, SI1, SI2, or SI4
and attached camera are in a hardware supported, camera specific,
typically asynchronous exposure,
trigger mode.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above, and may also return:
</p><dl>
<br><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_goSnap NX281" class="NX"></a>
<a name="pxd_goSnap" class="Sf"></a>
<a name="Video Snap NX282" class="NX"></a>
<a name="Video Snap   ---   pxd_goSnap" class="Sf"></a>
<a name="Video Snap   ---   pxd_goSnap"></a>
<h6 class="Sf">Video Snap   ---   pxd_goSnap</h6>
<a name="pxd_goSnapPair NX283" class="NX"></a>
<a name="pxd_goSnapPair" class="Sg"></a>
<a name="Video Snap Pair NX284" class="NX"></a>
<a name="Video Snap Pair   ---   pxd_goSnapPair" class="Sg"></a>
<a name="Video Snap Pair   ---   pxd_goSnapPair"></a>
<h6 class="Sg">Video Snap Pair   ---   pxd_goSnapPair</h6>
<a name="pxd_goLive NX285" class="NX"></a>
<a name="pxd_goLive" class="Sg"></a>
<a name="Video Live NX286" class="NX"></a>
<a name="Video Live   ---   pxd_goLive" class="Sg"></a>
<a name="Video Live   ---   pxd_goLive"></a>
<h6 class="Sg">Video Live   ---   pxd_goLive</h6>
<a name="pxd_goLivePair NX287" class="NX"></a>
<a name="pxd_goLivePair" class="Sg"></a>
<a name="Video Live Pair Alternate NX288" class="NX"></a>
<a name="Video Live Pair Alternate   ---   pxd_goLivePair" class="Sg"></a>
<a name="Video Live Pair Alternate   ---   pxd_goLivePair"></a>
<h6 class="Sg">Video Live Pair Alternate   ---   pxd_goLivePair</h6>
<a name="pxd_goLiveSeq NX289" class="NX"></a>
<a name="pxd_goLiveSeq" class="Sg"></a>
<a name="Video Live Sequence NX290" class="NX"></a>
<a name="Video Live Sequence   ---   pxd_goLiveSeq" class="Sg"></a>
<a name="Video Live Sequence   ---   pxd_goLiveSeq"></a>
<h6 class="Sg">Video Live Sequence   ---   pxd_goLiveSeq</h6>
<a name="pxd_goUnLive NX291" class="NX"></a>
<a name="pxd_goUnLive" class="Sg"></a>
<a name="Video UnLive NX292" class="NX"></a>
<a name="Video UnLive   ---   pxd_goUnLive" class="Sg"></a>
<a name="Video UnLive   ---   pxd_goUnLive"></a>
<h6 class="Sg">Video UnLive   ---   pxd_goUnLive</h6>
<a name="pxd_goAbortLive NX293" class="NX"></a>
<a name="pxd_goAbortLive" class="Sg"></a>
<a name="Video Abort NX294" class="NX"></a>
<a name="Video Abort   ---   pxd_goAbortLive" class="Sg"></a>
<a name="Video Abort   ---   pxd_goAbortLive"></a>
<h6 class="Sg">Video Abort   ---   pxd_goAbortLive</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_goSnap(unitmap, buffer);
int pxd_goSnapPair(unitmap, buffer1, buffer2);
int pxd_goLive(unitmap, buffer);
int pxd_goLivePair(unitmap, buffer, buffer2);
int pxd_goLiveSeq(unitmap, startbuf, endbuf, incbuf, numbuf, videoperiod);
int pxd_goUnLive(unitmap);
int pxd_goAbortLive(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
pxbuffer_t          buffer2;        // Second image frame buffer
pxbuffer_t          startbuf;       // Starting image frame buffer
pxbuffer_t          endbuf;         // Ending image frame buffer
pxbuffer_t          incbuf;         // Image frame buffer number increment
pxbuffer_t          numbuf;         // Number of captured images
int                 videoperiod;    // Period between captured images
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>
initiates capture of a single image into the
<em class="Ep">buffer</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#pxd_goLive" class="Er">pxd_goLive</a>
initiates continuous capture of images into the
<em class="Ep">buffer</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>
initiates continuous capture into
<a href="#buffer" class="Er">buffer</a>
and
<a href="#buffer2" class="Er">buffer2</a>,
alternately
(i.e.
''ping-pong''),
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>
initiates sequence capture of images into
<em class="Ep">startbuf</em>
through
<em class="Ep">endbuf</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
The sequence capture starts into
<em class="Ep">startbuf</em>
and continues into frame buffers
<em class="Ep">startbuf</em>+<em class="Ep">incbuf</em>*1,
<em class="Ep">startbuf</em>+<em class="Ep">incbuf</em>*2,
etc., wrapping around from the
<em class="Ep">endbuf</em>
back to the
<em class="Ep">startbuf</em>.
Typically
<em class="Ep">incbuf</em>=1
for use of consecutive ascending frame buffers.
The
<em class="Ep">numbuf</em>
specifies the number image frame buffers
to be captured.
Typically,
<em class="Ep">numbuf</em>
is
endbuf<em class="Ep">-</em>startbuf<em class="Ep">+1</em>
for simple sequence capture, or 0
for continuous (i.e.
''circular'')
sequence capture.
The
<em class="Ep">videoperiod</em>
specifies the time interval, in video fields or frames,
between captured image frame buffers.
Typically,
<em class="Ep">videoperiod</em>=1
for video rate capture.
For non-interlaced video formats, the
<em class="Ep">videoperiod</em>
is in fields.
For interlaced video formats, the
<em class="Ep">videoperiod</em>
is in units of frames,
unless,
a)&nbsp;Each image frame buffer is configured to
contain only one field, and
b)&nbsp;Video
''switching''
is configured to take place after the
''next'',
rather than after an
''odd''
or an
''even''
field.
</p><p>
The
<a href="#pxd_goSnapPair" class="Er">pxd_goSnapPair</a>
initiates capture of a single image into the
<em class="Ep">buffer1</em>
and initiates capture of the following image into the
<em class="Ep">buffer2</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>;
it is intended for use only with cameras with a so-called
''Triggered Dual Exposure''
mode.
</p><p>
The
<a href="#pxd_goUnLive" class="Er">pxd_goUnLive</a>
terminates a previously initiated
<a href="#pxd_goLive" class="Er">pxd_goLive</a>,
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>,
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>,
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>,
or
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
after the current field or frame,
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#pxd_goAbortLive" class="Er">pxd_goAbortLive</a>
terminates a previously initiated
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
<a href="#pxd_goLive" class="Er">pxd_goLive</a>,
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>,
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>,
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>,
or
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>,
immediately, even if in the middle
of a field, line, or pixel,
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
</p><p>
Except for
<a href="#pxd_goAbortLive" class="Er">pxd_goAbortLive</a>,
these functions return
''immediately''
without waiting for the beginning or conclusion
of their stated effect.<a href="#Footnote%2017" class="Ff"><sup>[17]</sup></a>
The
<a href="#pxd_goAbortLive" class="Er">pxd_goAbortLive</a>
both has effect and returns
''immediately''.
</p><p>For PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, and SI4 configured for triggered
capture, the
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>
''arms''
the imaging board to capture the next externally triggered
frame, or both
''arms''
and initiates a software triggered frame,
according to the Video Format Configuration.
</p><p>
For PIXCI® CL3SD, the
<a href="#pxd_goAbortLive" class="Er">pxd_goAbortLive</a>
currently behaves the same as
<a href="#pxd_goUnLive" class="Er">pxd_goUnLive</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture
(for
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
<a href="#pxd_goLive" class="Er">pxd_goLive</a>,
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>,
or
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>).
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
See
<a href="#pxd_capturedBuffer" class="Er">pxd_capturedBuffer</a>,
<a href="#pxd_capturedSysTicks" class="Er">pxd_capturedSysTicks</a>,
and
<a href="#pxd_capturedFieldCount" class="Er">pxd_capturedFieldCount</a>
to determine when an image frame buffer has been captured,
and thereby whether the above functions have completed their
complete capture
(such as for
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>)
or have completed the next step of their captured
(such as for
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>
or
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>).
</p><p>
See
<a href="#pxd_goneLive" class="Er">pxd_goneLive</a>
to determine whether any video capture is in progress.
</p><p>
See
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>
for an alternative to
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>
that also waits for completion.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
This example illustrates a typical
video rate analysis task, analyzing
one captured video frame while the next
video frame is being captured into
a different frame buffer.
</p><blockquote>
<pre>    pxbuffer_t  lastbuf = 0;
    //
    // Initiate live, alternate, capture
    // in frame buffers 1 and 2.
    //
    pxd_goLivePair(1, 1, 2);
    //
    for (;;) {
        //
        // If a new buffer was not yet captured, wait.
        //
        if (pxd_capturedBuffer(1) == lastbuf) {
            Sleep(5);   // optional
            continue;
        }
        lastbuf = pxd_capturedBuffer(1);
        //
        // Call user-defined processing
        // on one buffer, while video
        // is being captured into the
        // alternate buffer.
        //
        user_process(lastbuf);
    }
</pre>
</blockquote>
<hr size="1">
<a name="pxd_goLiveTrig NX295" class="NX"></a>
<a name="pxd_goLiveTrig" class="Sf"></a>
<a name="Video Live Trigger NX296" class="NX"></a>
<a name="Video Live Trigger   ---   pxd_goLiveTrig" class="Sf"></a>
<a name="Video Live Trigger   ---   pxd_goLiveTrig"></a>
<h6 class="Sf">Video Live Trigger   ---   pxd_goLiveTrig</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_goLiveTrig(unitmap, buffer, gpin10mask,gpout20value,gpout20mask,gpout20when,
                                    gpin30wait,gpin30mask,gpout40value,gpout40mask,
                                    option50,field50,gpout50value,gpout50mask,delay60,
                                    gpout60value,gpout60mask,delay70,field70,capture70,
                                    gpin80mask,gpout80value,gpout80mask);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
<br>
                                    // Phase 1: initial reset of g.p.in:
uint                gpin10mask;     // g.p.in bit mask (for latching g.p.in)
<br>
                                    // Phase 2: initial set of g.p.out
uint                gpout20value;   // g.p.out bit values
uint                gpout20mask;    // g.p.out bit mask
uint                gpout20when;    // 0: async to VB, 1: sync to VB
<br>
                                    // Phase 3: wait for g.p.in change:
uint                gpin30wait;     // 0: no wait
                                    // 1: wait for change as sampled at VB
                                    // 3: wait for rising edge as sampled at VB
                                    // 5: wait for falling edge as sampled at VB
uint                gpin30mask;     // bit mask
<br>
                                    // Phase 4: notify g.p.in change:
uint                gpout40value;   // g.p.out bit values
uint                gpout40mask;    // g.p.out bit mask
<br>
                                    // Phase 5 &amp; 6: optional trig control:
uint                option50;       // 0: ignore, 1: do
uint                field50;        //    at next PXFIELD_NXT/ODD/EVN field
uint                gpout50value;   //    .. g.p.out bit values
uint                gpout50mask;    //    .. g.p.out bit mask
uint                delay60;        //    wait N fields
uint                gpout60value;   //    .. g.p.out bit values
uint                gpout60mask;    //    .. g.p.out bit mask
<br>
                                    // Phase 7: delay and capture:
uint                delay70;        // wait N fields
uint                field70;        // at next PXFIELD_NXT/ODD/EVN field
uint                capture70;      // 0: capture
<br>
                                    // Phase 8: notify capture:
uint                gpin80mask;     // reset g.p.in bits (for latching bits)
uint                gpout80value;   // g.p.out bit values
uint                gpout80mask;    // g.p.out bit mask
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>
initiates triggered capture of a single image into the
<em class="Ep">buffer</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>,
using the
General Purpose Input/Output signals
to sense external events, and control
external devices as described by the
<em class="Ep">gpin10mask</em>
through
<em class="Ep">gpout80mask</em>
parameters.
</p><p>
The
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>is not intended,
and not needed
for PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB,
EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1,
SI2, and SI4 imaging boards
where the PIXCI® combined with the camera hardware
provides dedicated triggering, typically asynchronous exposure, and
''single-shot''
capabilities.
The
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>
is intended for cameras producing continuous
(free-run)
video, and where the imaging board's
General Purpose Input signals
initiation or termination of sequence capture without involvement
of any special feature of the camera.
</p><p>
The
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>
implements continuous capture of multiple fields or frames
(i.e. effectively a
<a href="#pxd_goLive" class="Er">pxd_goLive</a>)
into the same
<em class="Ep">buffer</em>
which at the appropriate time is terminated
(i.e. effectively a
<a href="#pxd_goUnLive" class="Er">pxd_goUnLive</a>)
leaving the last captured field or frame.
</p><p>
The
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>
is not available for PIXCI® SV2 and SV3
imaging boards.
For PIXCI® D, D24, and D32 imaging boards,
the actual non-zero value of
<em class="Ep">gpin30wait</em>
is immaterial; the imaging board's hardware determines
the edge sensitivity of the General Purpose Input.
See
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>
and
<a href="#pxd_getGPOut" class="Er">pxd_getGPOut</a>
for discussion of how many General Purpose Inputs and Outputs
are available on various imaging boards.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_goLiveSeqTrig NX297" class="NX"></a>
<a name="pxd_goLiveSeqTrig" class="Sf"></a>
<a name="Video Live Sequence Trigger NX298" class="NX"></a>
<a name="Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig" class="Sf"></a>
<a name="Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig"></a>
<h6 class="Sf">Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_goLiveSeqTrig(int unitmap, startbuf, endbuf, incbuf, numbuf, videoperiod,
                      rsvd1,rsvd2,trig20wait,trig20slct,trig20delay,rsvd3,rsvd4,
                      rsvd5,rsvd6,rsvd7,rsvd8,rsvd9,trig40wait,trig40slct,
                      trig40delay,rsvd10,rsvd11,rsvd12,rsvd13,rsvd14,rsvd15);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          startbuf;       // Starting image frame buffer
pxbuffer_t          endbuf;         // Ending image frame buffer
pxbuffer_t          incbuf;         // Image frame buffer number increment
pxbuffer_t          numbuf;         // Number of captured images
int                 videoperiod;    // Period between captured images
<br>
uint                trig20wait;     // Trigger start of sequence upon:
                                    //    bits 0x001, 0x002, ... : a g.p. input
                                    //    bits 0x100, 0x200, ... : a g.p. trigger
uint                trig20slct;     // 1: wait for change as sampled at VB
                                    // 3: wait for rising edge as sampled at VB
                                    // 5: wait for falling edge as sampled at VB
pxvbtime_t          trig20delay;    // Delay effect by .. fields.
<br>
uint                trig40wait;     // Trigger end of sequence upon:
                                    //    bits 0x001, 0x002, ... : a g.p. input
                                    //    bits 0x100, 0x200, ... : a g.p. trigger
uint                trig40slct;     // 1: wait for change as sampled at VB
                                    // 3: wait for rising edge as sampled at VB
                                    // 5: wait for falling edge as sampled at VB
pxvbtime_t          trig40delay;    // Delay effect by .. fields.
<br>
int                 rsvd1;          // Reserved, should be 0.
                     ...
int                 rsvd15;         // Reserved, should be 0.
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
initiates sequence capture of images into
<em class="Ep">startbuf</em>
through
<em class="Ep">endbuf</em>,
on each of the multiple units specified by
<em class="Ep">unitmap</em>.
The
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
is a variation of
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>;
the
<em class="Ep">startbuf</em>,
<em class="Ep">endbuf</em>,
<em class="Ep">incbuf</em>,
<em class="Ep">numbuf</em>,
and
<em class="Ep">videoperiod</em>
parameters have the same effect as the
corresponding parameter for
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>.
</p><p>
Unlike
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>,
the
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
allows initiating or allows terminating
(but currently not both), the sequence capture
in response to a General Purpose Input,
or a General Purpose Trigger.
</p><p>
While waiting for an initiating input or trigger,
the
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
implements continuous capture of multiple fields or frames
(i.e. effectively a
<a href="#pxd_goLive" class="Er">pxd_goLive</a>)
into the
<em class="Ep">startbuf</em>.
</p><p>
If
<em class="Ep">trig20wait</em>&#8800;0,
the sequence capture starts
in response to a General Purpose Input,
or a General Purpose Trigger.
Bit 0x01 of
<em class="Ep">trig20wait</em>
selects the first General Purpose Input,
bit 0x02 of
<em class="Ep">trig20wait</em>
selects the second General Purpose Input
(if any), etc.
Bit 0x0100 of
<em class="Ep">trig20wait</em>
selects the first General Purpose Trigger,
bit 0x0200 of
<em class="Ep">trig20wait</em>
selects the second General Purpose Trigger
(if any), etc.
Only one bit of
<em class="Ep">trig20wait</em>
should be set.
For General Purpose Inputs, the
<em class="Ep">trig20slct</em>
selects which transition is to be used.
The effect on the start of sequence capture is delayed by
<em class="Ep">trig20delay</em>
fields.
</p><p>
If
<em class="Ep">trig40wait</em>&#8800;0,
the sequence capture terminates
in response to a General Purpose Input,
or a General Purpose Trigger.
Bit 0x01 of
<em class="Ep">trig40wait</em>
selects the first General Purpose Input,
bit 0x02 of
<em class="Ep">trig40wait</em>
selects the second General Purpose Input
(if any), etc.
Bit 0x0100 of
<em class="Ep">trig40wait</em>
selects the first General Purpose Trigger,
bit 0x0200 of
<em class="Ep">trig40wait</em>
selects the second General Purpose Trigger
(if any), etc.
Only one bit of
<em class="Ep">trig40wait</em>
should be set.
For General Purpose Inputs, the
<em class="Ep">trig40slct</em>
selects which transition is to be used.
The effect on the termination of sequence capture is delayed by
<em class="Ep">trig40delay</em>
fields.
</p><p>
The
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>is not
intended, and not needed
for PIXCI® CL1, CL2, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1,
EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, and
SI4 imaging boards
where the PIXCI® combined with the camera hardware
provides dedicated triggering, typically asynchronous exposure, and
''single-shot''
capabilities.
The
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
is intended for cameras producing continuous
(free-run)
video, and where the imaging board's
General Purpose Input or General Purpose Trigger signals
are used to sense external events and implement an
initiation or termination of sequence capture without involvement
of any special feature of the camera.
</p><p>
The
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>is
currently available only for PIXCI® CL1, CL2, CL3SD, D2X, D3X, E1,
E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB,
ELS2, SI, SI1, SI2, and SI4
imaging boards for use with non-interlaced cameras.<a href="#Footnote%2018" class="Ff"><sup>[18]</sup></a>
See
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>
and
<a href="#pxd_getGPTrigger" class="Er">pxd_getGPTrigger</a>
for discussion of how many General Purpose Inputs and
General Purpose Triggers
are available on various imaging boards.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_goneLive NX299" class="NX"></a>
<a name="pxd_goneLive" class="Sf"></a>
<a name="Video Initiated Status Check NX300" class="NX"></a>
<a name="Video Initiated Status Check   ---   pxd_goneLive" class="Sf"></a>
<a name="Video Initiated Status Check   ---   pxd_goneLive"></a>
<h6 class="Sf">Video Initiated Status Check   ---   pxd_goneLive</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_goneLive(unitmap, rsvd);
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_goneLive" class="Er">pxd_goneLive</a>
returns 0 if video capture
via
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>,
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
<a href="#pxd_goLive" class="Er">pxd_goLive</a>,
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>,
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>,
<a href="#pxd_goLiveTrig" class="Er">pxd_goLiveTrig</a>,
or
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
on any of the multiple units specified by
<em class="Ep">unitmap</em>
is not currently in effect.
Otherwise, a non-zero value is returned.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="1">
<a name="pxd_imageAspectRatio NX301" class="NX"></a>
<a name="pxd_imageAspectRatio" class="Sf"></a>
<a name="Get Frame Buffer Image Aspect Ratio NX302" class="NX"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio" class="Sf"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio"></a>
<h6 class="Sf">Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio</h6>
<a name="pxd_imageAspectRatio2 NX303" class="NX"></a>
<a name="pxd_imageAspectRatio2" class="Sg"></a>
<a name="Get Frame Buffer Image Aspect Ratio NX304" class="NX"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio2" class="Sg"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio2"></a>
<h6 class="Sg">Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio2</h6>
<a name="pxd_imageBdim NX305" class="NX"></a>
<a name="pxd_imageBdim" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth NX306" class="NX"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim"></a>
<h6 class="Sg">Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim</h6>
<a name="pxd_imageBdims NX307" class="NX"></a>
<a name="pxd_imageBdims" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth NX308" class="NX"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxd_imageBdims" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxd_imageBdims"></a>
<h6 class="Sg">Get Frame Buffer Image Bit Depth   ---   pxd_imageBdims</h6>
<a name="pxd_imageCdim NX309" class="NX"></a>
<a name="pxd_imageCdim" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components NX310" class="NX"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxd_imageCdim" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxd_imageCdim"></a>
<h6 class="Sg">Get Frame Buffer Image Color Components   ---   pxd_imageCdim</h6>
<a name="pxd_imageCdims NX311" class="NX"></a>
<a name="pxd_imageCdims" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components NX312" class="NX"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxd_imageCdims" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxd_imageCdims"></a>
<h6 class="Sg">Get Frame Buffer Image Color Components   ---   pxd_imageCdims</h6>
<a name="pxd_imageIdim NX313" class="NX"></a>
<a name="pxd_imageIdim" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension NX314" class="NX"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim"></a>
<h6 class="Sg">Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim</h6>
<a name="pxd_imageIdims NX315" class="NX"></a>
<a name="pxd_imageIdims" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension NX316" class="NX"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxd_imageIdims" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxd_imageIdims"></a>
<h6 class="Sg">Get Frame Buffer Image Field Dimension   ---   pxd_imageIdims</h6>
<a name="pxd_imageXdim NX317" class="NX"></a>
<a name="pxd_imageXdim" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension NX318" class="NX"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim"></a>
<h6 class="Sg">Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim</h6>
<a name="pxd_imageXdims NX319" class="NX"></a>
<a name="pxd_imageXdims" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension NX320" class="NX"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdims" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdims"></a>
<h6 class="Sg">Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdims</h6>
<a name="pxd_imageYdim NX321" class="NX"></a>
<a name="pxd_imageYdim" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension NX322" class="NX"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim"></a>
<h6 class="Sg">Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim</h6>
<a name="pxd_imageYdims NX323" class="NX"></a>
<a name="pxd_imageYdims" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension NX324" class="NX"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdims" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdims"></a>
<h6 class="Sg">Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdims</h6>
<a name="pxd_imageZdim NX325" class="NX"></a>
<a name="pxd_imageZdim" class="Sg"></a>
<a name="Get Frame Buffer Image Count NX326" class="NX"></a>
<a name="Get Frame Buffer Image Count   ---   pxd_imageZdim" class="Sg"></a>
<a name="Get Frame Buffer Image Count   ---   pxd_imageZdim"></a>
<h6 class="Sg">Get Frame Buffer Image Count   ---   pxd_imageZdim</h6>
<a name="pxd_imageZdims NX327" class="NX"></a>
<a name="pxd_imageZdims" class="Sg"></a>
<a name="Get Frame Buffer Image Count NX328" class="NX"></a>
<a name="Get Frame Buffer Image Count   ---   pxd_imageZdims" class="Sg"></a>
<a name="Get Frame Buffer Image Count   ---   pxd_imageZdims"></a>
<h6 class="Sg">Get Frame Buffer Image Count   ---   pxd_imageZdims</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>double pxd_imageAspectRatio();
int    pxd_imageBdim();
int    pxd_imageCdim();
int    pxd_imageIdim();
int    pxd_imageXdim()
int    pxd_imageYdim();
int    pxd_imageZdim();
double pxd_imageAspectRatios(unitmap);
int    pxd_imageBdims(unitmap);
int    pxd_imageCdims(unitmap);
int    pxd_imageIdims(unitmap);
int    pxd_imageXdims(unitmap)
int    pxd_imageYdims(unitmap);
int    pxd_imageZdims(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The dimensions or other characteristics
of the image frame buffer(s) are returned.
</p><p>
The
<a href="#pxd_imageAspectRatio" class="Er">pxd_imageAspectRatio</a>
returns the aspect ratio of a single pixel of the image;
defined as the pixel's height divided by the pixel's width.
For some cameras and/or imaging boards,
the aspect ratio may not be known - a value
of 0 is returned.
</p><p>
The
<a href="#pxd_imageBdim" class="Er">pxd_imageBdim</a>
returns the number of significant bits in
each color component of a pixel,
or in the single monochrome component of a pixel.
For example, for a high quality so-called
''10 bit per pixel color camera''
which produces 30 bits of RGB for each pixel,
the
<a href="#pxd_imageBdim" class="Er">pxd_imageBdim</a>
returns 10.<a href="#Footnote%2019" class="Ff"><sup>[19]</sup></a>
</p><p>
The
<a href="#pxd_imageCdim" class="Er">pxd_imageCdim</a>
returns the number of component values per pixel,
often referred to as
''pixies'',
typically one for monochrome imagery or three for color imagery.
The value returned
is the number of
component colors in the
natural or common
interpretation of the image,
and not necessarily the number of components output by the
camera or imaging board.
For example, three is returned, representing the common
RGB interpretation, for each of:
a)&nbsp;An imaging board which
stores YUYV or YCrCb&nbsp;4:2:2 as two components per pixel,
b)&nbsp;An imaging board which
stores Bayer pattern color as one component per pixel,
c)&nbsp;An imaging board which
stores RGB+Pad as 4 components per pixel.
</p><p>
The
<a href="#pxd_imageIdim" class="Er">pxd_imageIdim</a>
returns the number of video fields
in am image frame buffer.
The value is one for non-interlaced video formats.
For interlaced video formats the value may be
two if each frame buffer provides storage for both fields,
or one if each frame buffer provides storage for a single field.<a href="#Footnote%2020" class="Ff"><sup>[20]</sup></a>
</p><p>
The
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>
returns the number of pixels in a horizontal line.
</p><p>
The
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>
returns the number of pixels in a vertical column.<a href="#Footnote%2021" class="Ff"><sup>[21]</sup></a>
</p><p>
The
<a href="#pxd_imageZdim" class="Er">pxd_imageZdim</a>
returns the number of image frame buffers.
If multiple imaging boards are in use,
the
<a href="#pxd_imageZdim" class="Er">pxd_imageZdim</a>
returns the number of image frame buffers
assigned to each imaging board.
</p><p>
If multiple imaging boards are in use
and operated at different resolutions,
the analogous
<a href="#pxd_imageAspectRatios" class="Er">pxd_imageAspectRatios</a>,
<a href="#pxd_imageBdims" class="Er">pxd_imageBdims</a>,
<a href="#pxd_imageCdims" class="Er">pxd_imageCdims</a>,
<a href="#pxd_imageIdims" class="Er">pxd_imageIdims</a>,
<a href="#pxd_imageXdims" class="Er">pxd_imageXdims</a>,
<a href="#pxd_imageYdims" class="Er">pxd_imageYdims</a>,
and
<a href="#pxd_imageZdims" class="Er">pxd_imageZdims</a>
functions allow obtaining characteristics
relating to the single selected unit; the
<a href="#pxd_imageAspectRatio" class="Er">pxd_imageAspectRatio</a>,
<a href="#pxd_imageBdim" class="Er">pxd_imageBdim</a>,
<a href="#pxd_imageCdim" class="Er">pxd_imageCdim</a>,
<a href="#pxd_imageIdim" class="Er">pxd_imageIdim</a>,
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>,
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>,
and
<a href="#pxd_imageZdim" class="Er">pxd_imageZdim</a>
each provide characteristics for
<em class="Ep">unitmap</em>=1.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><p>
If the library is not open for use,
the
<a href="#pxd_imageAspectRatio" class="Er">pxd_imageAspectRatio</a>
and
<a href="#pxd_imageAspectRatio2" class="Er">pxd_imageAspectRatio2</a>
returns 0,
the other functions return PXERNOTOPEN.
</p><hr size="1">
<a name="pxd_infoDriverId NX329" class="NX"></a>
<a name="pxd_infoDriverId" class="Sf"></a>
<a name="Get Imaging Board Driver ID NX330" class="NX"></a>
<a name="Get Imaging Board Driver ID   ---   pxd_infoDriverId" class="Sf"></a>
<a name="Get Imaging Board Driver ID   ---   pxd_infoDriverId"></a>
<h6 class="Sf">Get Imaging Board Driver ID   ---   pxd_infoDriverId</h6>
<a name="pxd_infoIncludeId NX331" class="NX"></a>
<a name="pxd_infoIncludeId" class="Sg"></a>
<a name="Get Imaging Board Include Files ID NX332" class="NX"></a>
<a name="Get Imaging Board Include Files ID   ---   pxd_infoIncludeId" class="Sg"></a>
<a name="Get Imaging Board Include Files ID   ---   pxd_infoIncludeId"></a>
<h6 class="Sg">Get Imaging Board Include Files ID   ---   pxd_infoIncludeId</h6>
<a name="pxd_infoLibraryId NX333" class="NX"></a>
<a name="pxd_infoLibraryId" class="Sg"></a>
<a name="Get Imaging Board Library ID NX334" class="NX"></a>
<a name="Get Imaging Board Library ID   ---   pxd_infoLibraryId" class="Sg"></a>
<a name="Get Imaging Board Library ID   ---   pxd_infoLibraryId"></a>
<h6 class="Sg">Get Imaging Board Library ID   ---   pxd_infoLibraryId</h6>
<a name="pxd_infoMemsize NX335" class="NX"></a>
<a name="pxd_infoMemsize" class="Sg"></a>
<a name="Get Imaging Board's Frame Buffer Size NX336" class="NX"></a>
<a name="Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize" class="Sg"></a>
<a name="Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize"></a>
<h6 class="Sg">Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize</h6>
<a name="pxd_infoModel NX337" class="NX"></a>
<a name="pxd_infoModel" class="Sg"></a>
<a name="Get Imaging Board's Model NX338" class="NX"></a>
<a name="Get Imaging Board's Model   ---   pxd_infoModel" class="Sg"></a>
<a name="Get Imaging Board's Model   ---   pxd_infoModel"></a>
<h6 class="Sg">Get Imaging Board's Model   ---   pxd_infoModel</h6>
<a name="pxd_infoSubmodel NX339" class="NX"></a>
<a name="pxd_infoSubmodel" class="Sg"></a>
<a name="Get Imaging Board's Submodel NX340" class="NX"></a>
<a name="Get Imaging Board's Submodel   ---   pxd_infoSubmodel" class="Sg"></a>
<a name="Get Imaging Board's Submodel   ---   pxd_infoSubmodel"></a>
<h6 class="Sg">Get Imaging Board's Submodel   ---   pxd_infoSubmodel</h6>
<a name="pxd_infoUnits NX341" class="NX"></a>
<a name="pxd_infoUnits" class="Sg"></a>
<a name="Get Imaging Board Unit Count NX342" class="NX"></a>
<a name="Get Imaging Board Unit Count   ---   pxd_infoUnits" class="Sg"></a>
<a name="Get Imaging Board Unit Count   ---   pxd_infoUnits"></a>
<h6 class="Sg">Get Imaging Board Unit Count   ---   pxd_infoUnits</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>char*  pxd_infoDriverId();
char*  pxd_infoIncludeId();
char*  pxd_infoLibraryId();
ulong  pxd_infoMemsize(unitmap);    // Under 32 bit Windows &amp; Linux
uint64 pxd_infoMemsize(unitmap);    // Under 64 bit Windows &amp; Linux
int    pxd_infoModel(unitmap);
int    pxd_infoSubmodel(unitmap);
int    pxd_infoUnits();
<br>
int             unitmap;            // Unit selection bit map (1 for single unit)
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Identification or other characteristics
of the library, driver, and imaging board(s)
are returned.
</p><p>
The
<a href="#pxd_infoDriverId" class="Er">pxd_infoDriverId</a>
returns the identification string of the current
imaging board driver.
</p><p>
The
<a href="#pxd_infoIncludeId" class="Er">pxd_infoIncludeId</a>
''returns''
the identification string of the current
include (i.e. the
''.h'')
files.
As
<a href="#pxd_infoIncludeId" class="Er">pxd_infoIncludeId</a>
is intended to provide the
the identification string of the current
include files, it can't be an actual pre-compiled function.
However, it can be used as if it were, such as:
</p><blockquote>
<pre>    printf("%s", pxd_infoIncludeId());
</pre>
</blockquote>
or
<blockquote>
<pre>    if (strcmp(pxd_infoIncludeId(), pxd_infoLibraryId))
        printf("Probable DLL mismatch\n");
</pre>
</blockquote>
<p>
The
<a href="#pxd_infoLibraryId" class="Er">pxd_infoLibraryId</a>
returns the identification string of the current
imaging board library.
</p><p>
The
<a href="#pxd_infoMemsize" class="Er">pxd_infoMemsize</a>
returns the size in bytes of the frame buffer memory
associated with the single selected
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#pxd_infoModel" class="Er">pxd_infoModel</a>
returns the model designation associated with the
single selected
<em class="Ep">unitmap</em>.
Current values are:
</p><blockquote>
<pre>    PIXCI_A         // the PIXCI® A Imaging Board
    PIXCI_CL1       // the PIXCI® CL1 Imaging Board
    PIXCI_CL2       // the PIXCI® CL2 Imaging Board
    PIXCI_CL3SD     // the PIXCI® CL3SD Imaging Board
    PIXCI_D         // the PIXCI® D, D24, D32 Imaging Board
    PIXCI_D24       // the PIXCI® D24 Imaging Board
    PIXCI_D32       // the PIXCI® D32 Imaging Board
    PIXCI_D2X       // the PIXCI® D2X Imaging Board
    PIXCI_D3X       // the PIXCI® D3X Imaging Board
    PIXCI_E1        // the PIXCI® E1 Imaging Board
    PIXCI_E1DB      // the PIXCI® E1DB Imaging Board
    PIXCI_E4        // the PIXCI® E4 Imaging Board
    PIXCI_E4DB      // the PIXCI® E4DB Imaging Board
    PIXCI_EB1       // the PIXCI® EB1 Imaging Board
    PIXCI_EB1POCL   // the PIXCI® EB1-PoCL Imaging Board
    PIXCI_EC1       // the PIXCI® EC1 Imaging Board
    PIXCI_ECB1      // the PIXCI® ECB1 Imaging Board
    PIXCI_ECB134    // the PIXCI® ECB1-34 Imaging Board
    PIXCI_ECB2      // the PIXCI® ECB2 Imaging Board
    PIXCI_EL1       // the PIXCI® EL1 Imaging Board
    PIXCI_EL1DB     // the PIXCI® EL1DB Imaging Board
    PIXCI_ELS2      // the PIXCI® ELS2 Imaging Board
    PIXCI_SI        // the PIXCI® SI Imaging Board
    PIXCI_SI2       // the PIXCI® SI2 Imaging Board
    PIXCI_SI4       // the PIXCI® SI4 Imaging Board
    PIXCI_SI1       // the PIXCI® SI1 Imaging Board
    PIXCI_SV2       // the PIXCI® SV2 Imaging Board
    PIXCI_SV3       // the PIXCI® SV3 Imaging Board
    PIXCI_SV4       // the PIXCI® SV4 Imaging Board
    PIXCI_SV5       // the PIXCI® SV5, SV5A, SV5B, SV5L Imaging Board
    PIXCI_SV7       // the PIXCI® SV7 Imaging Board
</pre>
</blockquote>
where these are constants defined by inclusion of
<code class="Em">xcliball.h</code>.
Note that PIXCI®&nbsp;D24, and D32 imaging boards
may be identified as a PIXCI®&nbsp;D imaging board.
<p>
The
<a href="#pxd_infoSubmodel" class="Er">pxd_infoSubmodel</a>
returns the submodel designation associated with the
single selected
<em class="Ep">unitmap</em>.
For PIXCI® SV2, SV3, SV4, SV5, and SV7 imaging boards the value is 0.
For PIXCI® SV5A imaging boards the value is the predefined
constant PIXCI_SV5_SV5A.
For PIXCI® SV5B imaging boards the value is the predefined
constant PIXCI_SV5_SV5B.
For PIXCI® SV5L imaging boards the value is the predefined
constant PIXCI_SV5_SV5L.
For PIXCI® A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, and SI4 imaging boards
that are customized for specific cameras, the value
is a code indicating the specific camera.
</p><p>
The
<a href="#pxd_infoUnits" class="Er">pxd_infoUnits</a>
returns the number of imaging boards
(i.e.
''units'')
that the library has open and available for use.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above
</p><p>
If the library is not open for use,
the
<a href="#pxd_infoLibraryId" class="Er">pxd_infoLibraryId</a>
and
<a href="#pxd_infoDriverId" class="Er">pxd_infoDriverId</a>
return NULL,
the other functions return 0.
</p><hr size="1">
<a name="pxd_loadBmp NX343" class="NX"></a>
<a name="pxd_loadBmp" class="Sf"></a>
<a name="Load Image: BMP Format NX344" class="NX"></a>
<a name="Load Image: BMP Format   ---   pxd_loadBmp" class="Sf"></a>
<a name="Load Image: BMP Format   ---   pxd_loadBmp"></a>
<h6 class="Sf">Load Image: BMP Format   ---   pxd_loadBmp</h6>
<a name="pxd_loadTiff NX345" class="NX"></a>
<a name="pxd_loadTiff" class="Sg"></a>
<a name="Load Image: TIFF Format NX346" class="NX"></a>
<a name="Load Image: TIFF Format   ---   pxd_loadTiff" class="Sg"></a>
<a name="Load Image: TIFF Format   ---   pxd_loadTiff"></a>
<h6 class="Sg">Load Image: TIFF Format   ---   pxd_loadTiff</h6>
<a name="pxd_saveBmp NX347" class="NX"></a>
<a name="pxd_saveBmp" class="Sg"></a>
<a name="Save Image: BMP Format NX348" class="NX"></a>
<a name="Save Image: BMP Format   ---   pxd_saveBmp" class="Sg"></a>
<a name="Save Image: BMP Format   ---   pxd_saveBmp"></a>
<h6 class="Sg">Save Image: BMP Format   ---   pxd_saveBmp</h6>
<a name="pxd_savePcx NX349" class="NX"></a>
<a name="pxd_savePcx" class="Sg"></a>
<a name="Save Image: PCX Format NX350" class="NX"></a>
<a name="Save Image: PCX Format   ---   pxd_savePcx" class="Sg"></a>
<a name="Save Image: PCX Format   ---   pxd_savePcx"></a>
<h6 class="Sg">Save Image: PCX Format   ---   pxd_savePcx</h6>
<a name="pxd_saveTga NX351" class="NX"></a>
<a name="pxd_saveTga" class="Sg"></a>
<a name="Save Image: TARGA Format NX352" class="NX"></a>
<a name="Save Image: TARGA Format   ---   pxd_saveTga" class="Sg"></a>
<a name="Save Image: TARGA Format   ---   pxd_saveTga"></a>
<h6 class="Sg">Save Image: TARGA Format   ---   pxd_saveTga</h6>
<a name="pxd_saveTiff NX353" class="NX"></a>
<a name="pxd_saveTiff" class="Sg"></a>
<a name="Save Image: TIFF Format NX354" class="NX"></a>
<a name="Save Image: TIFF Format   ---   pxd_saveTiff" class="Sg"></a>
<a name="Save Image: TIFF Format   ---   pxd_saveTiff"></a>
<h6 class="Sg">Save Image: TIFF Format   ---   pxd_saveTiff</h6>
<br>
<a name="TIFF Format NX355" class="NX"></a>
<a name="BMP Format NX356" class="NX"></a>
<a name="TARGA Format NX357" class="NX"></a>
<a name="PCX Format NX358" class="NX"></a>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_loadBmp (unitmap, pathname, framebuf, ulx, uly, lrx, lry, loadmode, options);
int pxd_loadTiff(unitmap, pathname, framebuf, ulx, uly, lrx, lry, loadmode, options);
int pxd_saveBmp (unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
int pxd_savePcx (unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
int pxd_saveTga (unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
int pxd_saveTiff(unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
char                *pathname;      // File path name to load from, or save to
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
int                 loadmode;       // Resize: 'b': Bilinear, 'n': Nearest neighbor
                                    // Color Space: 0x100: convert, 0: no convert
int                 savemode;       // Reserved, should be 0
int                 options;        // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
An image frame buffer, or an area of interest within the frame buffer,
is loaded from, or saved to, a file named
<em class="Ep">pathname</em>.
For
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>
and
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>
the image is loaded or saved in
the Windows Device Independent Bitmap File format
(i.e.
''.bmp''
or
''.dib'').
For
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>
and
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>
the image is loaded or saved in
the Tagged Image File Format (TIFF)
(i.e.
''.tif'').
For
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>
the image is saved in
the
''PCX''
graphics file format
(i.e.
''.pcx'').
For
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>
the image is saved in
the
''Targa''
file format
(i.e.
''.tga'').
</p><p>
The
<em class="Ep">pathname</em>
may include a directory path,<a href="#Footnote%2022" class="Ff"><sup>[22]</sup></a>
and may include a file suffix
(i.e.
''.bmp'',
''.tif'',
''.tga'',
or
''.pcx'')
as desired; these functions
do not require, or force, any specific suffix.
For
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>,
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>,
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>,
and
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>
any existing file
<em class="Ep">pathname</em>
is deleted and a new file
<em class="Ep">pathname</em>
created.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which, or to which,
an image is to saved or loaded.
The
<em class="Ep">framebuf</em>,
1&lt;=<em class="Ep">framebuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
specifies the image frame buffer from which, or to which,
an image is to be saved or loaded.
The
<em class="Ep">ulx</em>
and
<em class="Ep">uly</em>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>())
or the extreme bottom vertical coordinate
(i.e.
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>()),
respectively.
</p><p>
For
<a href="#pxd_bmpLoad" class="Er">pxd_bmpLoad</a>
and
<a href="#pxd_tiffLoad" class="Er">pxd_tiffLoad</a>:
The loaded image is resized, as necessary, to fit
the specified frame buffer and area of interest.
If
<em class="Ep">loadmode</em>='b',
the image is resized by bilinear interpolation,
which is suitable for continuous tone images.
If
<em class="Ep">loadmode</em>='n',
the image is resized by nearest neighbor interpolation,
which is particularly suitable for graphics or false colored images,
as it avoids the generation of pixel values, via interpolation, which may
not exist in the original image.
If
<em class="Ep">loadmode</em>&amp;0x100
the loaded image's pixels are converted to the
specified frame buffer's color space.
Pixel values are converted to be most significant bit aligned;
for example a TIFF file with 1 bit per pixel loaded into an image
frame buffer with 8 bit pixels
yields pixel values of 0 and 128.
</p><p>
For
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>:
Color image frame buffers are saved as 24 bit RGB pixels
without compression.
Monochrome image frame buffers are saved
as 8 bit pixels with a monochrome, identity, palette
without compression.
</p><p>
For
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>:
Color image frame buffers are saved as RGB pixels without compression,
monochrome image frame buffers are saved as monochrome pixels without compression,
each with the same number of bits per pixel as the image frame buffer.
</p><p>
For
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>:
Color image frame buffers are saved as 24 bit RGB pixels.
Monochrome image frame buffers are saved
as 8 bit pixels without a palette.
</p><p>
For
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>:
Color image frame buffers are saved as 24 bit RGB pixels.
Monochrome image frame buffers are saved
as 8 bit pixels without a palette.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Image frame buffer loaded or saved.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERNOMODE</dt><dd>
File format uses unsupported options
(for
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>
and
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>).
<br></dd><dt>PXERFILEFORM</dt><dd>
Invalid file format
(for
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>
and
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>).
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
<br></dd><dt>PXERDOSIO</dt><dd>
Operating system I/O error while reading or writing file.
<br></dd><dt>PXERNEWFILE</dt><dd>
Can't create
<em class="Ep">pathname</em>
(for
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>,
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>,
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>,
and
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>).
<br></dd><dt>PXERNOFILE</dt><dd>
Can't find
<em class="Ep">pathname</em>
(for
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>
and
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>).
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">Example</em>
<p>
The entire AOI of all image frame buffers are
saved to a sequence of TIFF formatted files.
</p><blockquote>
<pre>int     framebuf;
char    name[20];
<br>
for (framebuf = 1; framebuf &lt;= pxd_imageZdim(); framebuf++) {
    sprintf(name, "abc%.5d.tif", framebuf);
    pxd_saveTiff(1, name, framebuf, 0, 0, -1, -1, 0, 0);
}
</pre>
</blockquote>
<hr size="1">
<a name="pxd_loadRawBuffers NX359" class="NX"></a>
<a name="pxd_loadRawBuffers" class="Sf"></a>
<a name="Load Frame Buffers NX360" class="NX"></a>
<a name="Load Frame Buffers   ---   pxd_loadRawBuffers" class="Sf"></a>
<a name="Load Frame Buffers   ---   pxd_loadRawBuffers"></a>
<h6 class="Sf">Load Frame Buffers   ---   pxd_loadRawBuffers</h6>
<a name="pxd_saveRawBuffers NX361" class="NX"></a>
<a name="pxd_saveRawBuffers" class="Sg"></a>
<a name="Save Frame Buffers NX362" class="NX"></a>
<a name="Save Frame Buffers   ---   pxd_saveRawBuffers" class="Sg"></a>
<a name="Save Frame Buffers   ---   pxd_saveRawBuffers"></a>
<h6 class="Sg">Save Frame Buffers   ---   pxd_saveRawBuffers</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_loadRawBuffers(unitmap, pathname, startbuf, endbuf, filehandle, fileoffset, alignment, options);
int pxd_saveRawBuffers(unitmap, pathname, startbuf, endbuf, filehandle, fileoffset, alignment, options);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
char                *pathname;      // File path name to load from, or save to
pxbuffer_t          startbuf;       // Starting image frame buffer
pxbuffer_t          endbuf;         // Ending image frame buffer, inclusive
void                *filehandle;    // Existing file handle to be read or written, or NULL
pxbuffer_t          fileoffset;     // Offset into file, in units of image frame buffers
uint32              alignsector;    // Pad image frame buffer size to multiple of ...
int                 options;        // Options, should be 0, except as described below
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
A sequence of one or more consecutive image frame buffers
is saved to, for
<a href="#saveRawBuffers" class="Er">saveRawBuffers</a>,
or loaded from, for
<a href="#loadRawBuffers" class="Er">loadRawBuffers</a>,
a file.
</p><p>
If
<em class="Ep">pathname</em>&#8800;NULL,
the image frame buffers are saved to, or loaded from, the
<em class="Ep">pathname</em>;
for
<a href="#saveRawBuffers" class="Er">saveRawBuffers</a>
an already existing
is not deleted and recreated, but partially or fully overwritten
allowable replacement of one or more images within an existing file.<a href="#Footnote%2023" class="Ff"><sup>[23]</sup></a>
Alternately, a
<em class="Ep">filehandle</em>&#8800;NULL,
to a file previously opened by the application may be supplied.
Under Windows the
<em class="Ep">filehandle</em>
is expected to be a
<cite class="Ec">HANDLE</cite>
provided by
<cite class="Ec">CreateFile</cite>.
Under Linux the
<em class="Ep">filehandle</em>
is expected to be a
''file descriptor''
provided by
<cite class="Ec">_open</cite>.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which, or to which,
image frame buffers are to be saved or loaded.
The
<em class="Ep">startbuf</em>
and
<em class="Ep">endbuf</em>,
<em class="Ep">startbuf</em>&lt;=<em class="Ep">endbuf</em>,
specify the first and last image frame buffers, inclusive,
to be saved or loaded.
The entire image frame buffer is loaded or saved.
</p><p>
Each image frame buffer is saved to, or loaded from,
the file sequentially starting at position
<em class="Ep">fileoffset</em>,
where
<em class="Ep">fileoffset</em>
is interpreted in units
of the size of an image frame buffer.
For example,
<em class="Ep">fileoffset</em>=0
starts at the beginning of the file,
while
<em class="Ep">fileoffset</em>=1
starts with the second image frame buffer in the file.
If
<em class="Ep">alignsector</em>&#8800;0,
the size of each saved image frame buffer, and thus the starting position
relative to the beginning of the file, is padded to a multiple
of
<em class="Ep">alignsector</em>
bytes; typically so that each saved image frame buffer can
be aligned on a multiple of the file system's sector size,
or the operating system's virtual page size.
</p><p>
If
<em class="Ep">options</em>&amp;1,
then additional capture status information is prepended to each image frame buffer
as saved, or the capture status information is set as each image frame buffer is loaded.
The information saved or loaded includes date and time of capture, and value of
general purpose input signals at time of capture.
Currently, this additional information adds 64 bytes per image frame buffer saved or loaded;
all discussion above regarding the frame buffer size
in the context of
<em class="Ep">fileoffset</em>
and
<em class="Ep">alignsector</em>
should be interpreted as the frame buffer size plus 64 bytes.
Depending on frame buffer memory configuration,
the capture status information may not be available,
or a frame buffer being saved may never have been captured;
when saving, the applicable fields of the
capture status
are set to 0 values.
</p><p>
The image frame buffers are saved or loaded
with a file format which is an exact copy, byte for byte, of
the imaging board's frame buffer memory.
The file format is intended for efficient saving and loading
of image frame buffers; the actual format will vary
with different imaging boards, or different video formats
with a single imaging board.
Use of these functions, and the file format created,
is contraindicated for export to other
(i.e. non-EPIX® imaging software) applications.
Use is also contraindicated for archival storage,
as reloading an image requires the presence of the same
imaging board set to the same video format.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERNOFILE</dt><dd>
File doesn't exist (for
<a href="#loadRawBuffers" class="Er">loadRawBuffers</a>).
<br></dd><dt>PXERNEWFILE</dt><dd>
File can't be created (for
<a href="#saveRawBuffers" class="Er">saveRawBuffers</a>).
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_mesgErrorCode NX363" class="NX"></a>
<a name="pxd_mesgErrorCode" class="Sf"></a>
<a name="Errors: Translate Error Code to String NX364" class="NX"></a>
<a name="Errors: Translate Error Code to String   ---   pxd_mesgErrorCode" class="Sf"></a>
<a name="Errors: Translate Error Code to String   ---   pxd_mesgErrorCode"></a>
<h6 class="Sf">Errors: Translate Error Code to String   ---   pxd_mesgErrorCode</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>char* pxd_mesgErrorCode(errorcode);
int                 errorcode;          // Error return code
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Any of the
''PXER...''
error codes returned by various library functions,
given as the
<em class="Ep">errorcode</em>
parameter, is translated and returned as a suitable, concise, NULL terminated
error message string.
A NULL value is returned if
<em class="Ep">errorcode</em>
is not a recognized
''PXER...''
code.
</p><p>
The
''PXER...''
codes are defined in
<code class="Em">pxerrno.h</code>,
included via
<code class="Em">xcliball.h</code>.
Programs should never assume specific values of these error codes,
but may assume that all error codes are negative
and that 0 and positive values
are reserved for nonerror conditions.
Thus, if an arbitrary
''library_function''
is described to return
''PXER...''
codes, the assumptions utilized in:
</p><blockquote>
<pre>int i;
if ((i = library_function(...)) &lt; 0) {
   printf("error %s\n", pxd_mesgErrorCode(i));
   return;
}
</pre>
</blockquote>
or in:
<blockquote>
<pre>char *cp;
if ((cp = pxd_mesgErrorCode(library_function(...)))) {
   printf("error %s\n", cp);
   return;
}
</pre>
</blockquote>
are valid.
<p>
The
<a href="#pxd_mesgErrorCode" class="Er">pxd_mesgErrorCode</a>
may be invoked even if the library is
not open for use.
</p><p>
The
<a href="#pxd_mesgErrorCode" class="Er">pxd_mesgErrorCode</a>
is functionally identical to the
<cite class="Ec">pxerrnomesg</cite>
mentioned in the
<cite class="Ec">PXIPL Image Processing Library Reference Manual</cite>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
A char&nbsp;* to an error message, or NULL.
</p><hr size="1">
<a name="pxd_mesgFault NX365" class="NX"></a>
<a name="pxd_mesgFault" class="Sf"></a>
<a name="Errors: Check &amp; Report Faults NX366" class="NX"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxd_mesgFault" class="Sf"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxd_mesgFault"></a>
<h6 class="Sf">Errors: Check &amp; Report Faults   ---   pxd_mesgFault</h6>
<a name="pxd_mesgFaultText NX367" class="NX"></a>
<a name="pxd_mesgFaultText" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults NX368" class="NX"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText"></a>
<h6 class="Sg">Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_mesgFault(unitmap);
int pxd_mesgFaultText(unitmap, buf, bufsize);
int                 unitmap;        // Unit selection bit map (1 for single unit)
char                *buf;           // 'Returned' fault text
size_t              bufsize;        // Size of *buf
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
checks whether a fault has occurred since the last check,
and if so displays a description of the fault.
The
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>
checks whether a fault has occurred since the last check,
and if so
''returns''
a description of the fault in
''buf''.
The
<em class="Ep">unitmap</em>
specifies the single unit for which faults
are checked and displayed.
</p><p>
Under Windows, the
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
displays the description of the fault in a Windows MessageBox.
Under other environments, the
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
displays the description of the fault to
''stderr''.
</p><p>
Alternately, the
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>
returns into
<em class="Ep">buf</em>,
which is assumed to be of size
<em class="Ep">bufsize</em>,
essentially the same description as would be displayed by
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
but without the
''boilerplate''
such as:
</p><blockquote>
<pre>    "Configuration Error or Fault"
        ...
        ...
    "Check Configuration!"
    "See `Installation' and `In Case of Trouble' in ..."
</pre>
</blockquote>
The
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>'s
return code does not indicate whether the
<em class="Ep">buf</em>
was too small; if after calling
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>
<blockquote>
<pre>    strlen(buf)==bufsize
</pre>
</blockquote>
then the
<em class="Ep">buf</em>
was too small and the remainder of the fault's
description was lost.
A
<em class="Ep">bufsize</em>
of 1024
is sufficient for current fault descriptions and is suggested.
<p>
Faults are not related to PXER... error codes.
Rather, faults are typically asynchronous events,
such as reporting that the video signal
has been interrupted or corrupted.
Faults are not the error description,
if any, of the last called library function,
with the exception that after
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
fails, the
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
or
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>
may show additional information about the cause of failure.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>1</dt><dd>
Fault occurred and was displayed.
<br></dd><dt>0</dt><dd>
No fault occurred.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_PIXCIopen NX369" class="NX"></a>
<a name="pxd_PIXCIopen" class="Sf"></a>
<a name="PIXCI® Imaging Board: Open and Set Video Format Configuration NX370" class="NX"></a>
<a name="PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen" class="Sf"></a>
<a name="PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen"></a>
<h6 class="Sf">PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen</h6>
<a name="pxd_PIXCIclose NX371" class="NX"></a>
<a name="pxd_PIXCIclose" class="Sg"></a>
<a name="PIXCI® Imaging Board: Close NX372" class="NX"></a>
<a name="PIXCI® Imaging Board: Close   ---   pxd_PIXCIclose" class="Sg"></a>
<a name="PIXCI® Imaging Board: Close   ---   pxd_PIXCIclose"></a>
<h6 class="Sg">PIXCI® Imaging Board: Close   ---   pxd_PIXCIclose</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_PIXCIopen(driverparms, formatname, formatfile);
int pxd_PIXCIclose();
<br>
char                *driverparms;   // Driver configuration parms, or NULL or ""
char                *formatname;    // Video format configuration name, or NULL or ""
char                *formatfile;    // Video format configuration file name, or NULL or ""
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The PIXCI® XCLIB Library and Driver is opened
using driver configuration parameters specified by
<em class="Ep">driverparms</em>
and either the name of a predefined video format specified by
<em class="Ep">formatname</em>
or the file name of a saved video format specified by
<em class="Ep">formatfile</em>.<a href="#Footnote%2024" class="Ff"><sup>[24]</sup></a>
The library and driver must be opened before any other library function
is invoked, except for those functions that explicitly note otherwise.
Once open, the PIXCI® library and driver
should be closed by
<a href="#pxd_PIXCIclose" class="Er">pxd_PIXCIclose</a>
before the program exits.
</p><p>
The
<em class="Ep">driverparms</em>
should be a Driver Configuration Parameter string
as described in
<a href="#Installation+and+Configuration+%3F+Run+Time" class="Er">Installation and Configuration &#8212; Run Time</a>.
When building an application program whose end-users
would need to select the hardware configuration parameters, the
<em class="Ep">driverparms</em>
might be obtained from the ``C'' function
<cite class="Ec">getenv</cite>
(use of the environment name
''PIXCI''
is suggested),
or via the Windows function
<cite class="Ec">GetProfileString</cite>
(use of the environment name
''[EPIX_XC]''
and entry
''PIXCI''
is suggested).
</p><p>
The
<em class="Ep">formatname</em>
or
<em class="Ep">formatfile</em>
allows setting the initial video format configuration.
One and only one of
<em class="Ep">formatname</em>
or
<em class="Ep">formatfile</em>
must be specified, the
other must be NULL or the empty string "".
</p><p>
For PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L imaging boards:
The following predefined
<em class="Ep">formatname</em>'s
allow setting for standard video format configurations:
</p><dl>
<br><dt><code>"RS-170"</code></dt><dd>
The video format is initially set for RS-170 composite video,
capturing 752 pixels per line, 480 lines,
monochrome grey level pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"NTSC"</code></dt><dd>
The video format is initially set for NTSC composite video,
capturing 752 pixels per line, 480 lines,
color YCrCb (for PIXCI®&nbsp;SV2, SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5A, SV5B, SV5L) pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"NTSC/YC"</code></dt><dd>
The video format is initially set for NTSC S-VIDEO (Super VHS),
capturing 752 pixels per line, 480 lines,
color YCrCb (for PIXCI®&nbsp;SV2, SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5L) pixels,
using video input channel 1.
This specification is supported on PIXCI®&nbsp;SV2, SV3, SV4, SV5, and SV5L.
<br></dd><dt><code>"CCIR"</code></dt><dd>
The video format is initially set for CCIR composite video,
capturing 920 pixels per line, 576 lines,
monochrome grey level pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"PAL"</code></dt><dd>
The video format is initially set for PAL (B,D,G,H,I) composite video,
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV2, SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5A, SV5B, SV5L) pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV2, SV4, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"PAL/YC"</code></dt><dd>
The video format is initially set for PAL (B,D,G,H,I) S-VIDEO (Super VHS),
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV2, SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5L) pixels,
using video input channel 1.
This specification is supported on PIXCI®&nbsp;SV2, SV3, SV4, SV5, and SV5L.
<br></dd><dt><code>"PAL(M)"</code></dt><dd>
The video format is initially set for PAL(M) composite video,
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5A, SV5B, SV5L) pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV3, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"PAL(M)/YC"</code></dt><dd>
The video format is initially set for PAL(M) S-VIDEO (Super VHS),
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5L) pixels,
using video input channel 1.
This specification is supported on PIXCI®&nbsp;SV3, SV4, SV5, and SV5L.
<br></dd><dt><code>"PAL(N)"</code></dt><dd>
The video format is initially set for PAL(N) composite video,
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5A, SV5B, SV5L) pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV3, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"PAL(N)/YC"</code></dt><dd>
The video format is initially set for PAL(N) S-VIDEO (Super VHS),
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5L) pixels,
using video input channel 1.
This specification is supported on PIXCI®&nbsp;SV3, SV4, SV5, and SV5L.
<br></dd><dt><code>"SECAM"</code></dt><dd>
The video format is initially set for SECAM composite video,
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5A, SV5B, SV5L) pixels,
using video input channel 2.
This specification is supported on PIXCI®&nbsp;SV3, SV4, SV5, SV5A, SV5B, and SV5L.
<br></dd><dt><code>"SECAM/YC"</code></dt><dd>
The video format is initially set for SECAM S-VIDEO (Super VHS),
capturing 920 pixels per line, 576 lines,
color YCrCb (for PIXCI®&nbsp;SV3) or color RGB (for PIXCI®&nbsp;SV4, SV5, SV5L) pixels,
using video input channel 1.
This specification is supported on PIXCI®&nbsp;SV3, SV4, SV5, and SV5L.
<br></dd><dt><code>"DEFAULT"</code></dt><dd>
For PIXCI®&nbsp;SV2, SV3, SV4, SV5, and SV5L: Same as <code>"NTSC/YC"</code>.
For PIXCI®&nbsp;SV5A and SV5B: Same as <code>"NTSC"</code>.
</dd></dl>
<p>
For PIXCI®&nbsp;SV7 imaging boards:
The following predefined
<em class="Ep">formatname</em>'s
allow setting for standard video format configurations:
</p><dl>
<br><dt><code>"RS-170"</code></dt><dd>
The video format is initially set for RS-170 composite video,
capturing 720 pixels per line, 480 lines,
monochrome grey level pixels.
<br></dd><dt><code>"NTSC"</code></dt><dd>
The video format is initially set for NTSC composite video,
capturing 720 pixels per line, 480 lines,
color YCrCb pixels.
<br></dd><dt><code>"NTSC(J)"</code></dt><dd>
The video format is initially set for NTSC(J) composite video,
capturing 720 pixels per line, 480 lines,
color YCrCb pixels.
<br></dd><dt><code>"NTSC(4.43)"</code></dt><dd>
The video format is initially set for NTSC(4.43) composite video,
capturing 720 pixels per line, 480 lines,
color YCrCb pixels.
<br></dd><dt><code>"CCIR"</code></dt><dd>
The video format is initially set for CCIR composite video,
capturing 720 pixels per line, 576 lines,
monochrome grey level pixels.
<br></dd><dt><code>"PAL"</code></dt><dd>
The video format is initially set for PAL (B,D,G,H,I) composite video,
capturing 720 pixels per line, 576 lines,
color YCrCb pixels.
<br></dd><dt><code>"PAL(M)"</code></dt><dd>
The video format is initially set for PAL(M) composite video,
capturing 720 pixels per line, 576 lines,
color YCrCb pixels.
<br></dd><dt><code>"PAL(N)"</code></dt><dd>
The video format is initially set for PAL(N) composite video,
capturing 720 pixels per line, 576 lines,
color YCrCb pixels.
<br></dd><dt><code>"PAL(60)"</code></dt><dd>
The video format is initially set for PAL(60) composite video,
capturing 720 pixels per line, 576 lines,
color YCrCb pixels.
<br></dd><dt><code>"DEFAULT"</code></dt><dd>
Same as <code>"NTSC"</code>.
</dd></dl>
<p>For PIXCI®&nbsp;A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB,
E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2,
SI, SI1, SI2, and SI4 imaging boards:
The following predefined
<em class="Ep">formatname</em>'s
allow setting for standard video format configurations:
</p><dl>
<br><dt><code>"DEFAULT"</code></dt><dd>
As appropriate for the camera for which the
current PIXCI® imaging board is intended, with maximum resolution.
</dd></dl>
<p>
Alternately, the
<em class="Ep">formatfile</em>
is taken to be the name of a file
containing a video format configuration
(also referred to as a video state) previously exported by the XCAP program
or the XCLIB library.
Video capture parameters, such as the video format, video resolution,
pixel color space, video input channel, and white balancing,
(as appropriate for the imaging board in use)
are all imported from
<em class="Ep">formatfile</em>.
</p><p>
Note: When the XCLIB DLL is called from Visual Basic, VB.NET, LabView, Matlab,
or many other non C/C++ environments, the alternative empty string ("")
should be used, not NULL, for
<em class="Ep">driverparms</em>,
<em class="Ep">formatname</em>,
or
<em class="Ep">formatfile</em>
as required.
A Visual Basic, VB.NET, LabView, or Matlab NULL isn't the same as a C/C++ NULL.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
The PIXCI® XCLIB  Library and Driver is open
and ready for use.
<br></dd><dt>PXERROR</dt><dd>
The PIXCI® imaging board could not be accessed;
either the PIXCI® driver or hardware is not installed correctly.
The
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
may provide more information.
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
<br></dd><dt>PXERNOFILE</dt><dd>
No file named
<em class="Ep">formatfile</em>
found.
<br></dd><dt>PXERDOSIO</dt><dd>
Can't read file named
<em class="Ep">formatfile</em>.
<br></dd><dt>PXERSEARCH</dt><dd>
The
<em class="Ep">formatname</em>
was invalid.
<br></dd><dt>PXERVIDFORM</dt><dd>
The
<em class="Ep">formatname</em>
was one of the strings described above,
but the specified format is not supported on the current imaging board.
<br></dd><dt>PXERBADPARM</dt><dd>
The parameters in
<em class="Ep">driverparms</em>
are invalid.
<br></dd><dt>PXERFILEFORM</dt><dd>
The file format of
<em class="Ep">formatfile</em>
is invalid.
<br></dd><dt>PXERISOPEN</dt><dd>
The library and driver are already open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
See the
<cite class="Ec">PIXCI® USER'S MANUAL</cite>
for discussion of configuration options and settings.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
A PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, or SV7 imaging board is opened for use using RS-170
and video input channel 1.
</p><blockquote>
<pre>int i;
if ((i = pxd_PIXCIopen("", "RS-170", "")) &lt; 0) {
    printf("Open Error\n");
    pxd_mesgFault(1);
    exit(1);
}
printf("Open OK\n");
</pre>
</blockquote>
<p>
Any PIXCI® imaging board is opened for use with default format
and resolution.
</p><blockquote>
<pre>int i;
if ((i = pxd_PIXCIopen("", "default", NULL)) &lt; 0) {
    printf("Open Error\n");
    pxd_mesgFault(1);
    exit(1);
}
printf("Open OK\n");
</pre>
</blockquote>
<hr size="1">
<a name="pxd_readuchar NX373" class="NX"></a>
<a name="pxd_readuchar" class="Sf"></a>
<a name="Read Pixel Values as Unsigned Char NX374" class="NX"></a>
<a name="Read Pixel Values as Unsigned Char   ---   pxd_readuchar" class="Sf"></a>
<a name="Read Pixel Values as Unsigned Char   ---   pxd_readuchar"></a>
<h6 class="Sf">Read Pixel Values as Unsigned Char   ---   pxd_readuchar</h6>
<a name="pxd_readushort NX375" class="NX"></a>
<a name="pxd_readushort" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Short NX376" class="NX"></a>
<a name="Read Pixel Values as Unsigned Short   ---   pxd_readushort" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Short   ---   pxd_readushort"></a>
<h6 class="Sg">Read Pixel Values as Unsigned Short   ---   pxd_readushort</h6>
<a name="pxd_writeuchar NX377" class="NX"></a>
<a name="pxd_writeuchar" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Char NX378" class="NX"></a>
<a name="Write Pixel Values as Unsigned Char   ---   pxd_writeuchar" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Char   ---   pxd_writeuchar"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Char   ---   pxd_writeuchar</h6>
<a name="pxd_writeushort NX379" class="NX"></a>
<a name="pxd_writeushort" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Short NX380" class="NX"></a>
<a name="Write Pixel Values as Unsigned Short   ---   pxd_writeushort" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Short   ---   pxd_writeushort"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Short   ---   pxd_writeushort</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_readuchar  (unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
int pxd_readushort (unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
int pxd_writeuchar (unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
int pxd_writeushort(unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
uchar               membuf[];       // Program's buffer to receive (readuchar) or
                                    // originate (writeuchar) unsigned char values
ushort              membuf[];       // Program's buffer to receive (readushort) or
                                    // originate (writeushort) unsigned short values
size_t              cnt;            // Size of program's buffer referenced by membuf
                                    // in unsigned char's or unsigned short's
char                *colorspace;    // Name of requested color representation
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Pixel values from an image frame buffer and area of interest
are copied into, or copied from, an array
or other memory buffer provided by the application program.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which, or to which,
pixel values are to be read or written.
The
<em class="Ep">framebuf</em>,
1&lt;=<em class="Ep">framebuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
specifies the image frame buffer from which, or to which,
pixel values are to be read or written.
The
<em class="Ep">ulx</em>
and
<em class="Ep">uly</em>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>())
or the extreme bottom vertical coordinate
(i.e.
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>()),
respectively.
</p><p>
The
<em class="Ep">membuf</em>
specifies a program provided array or buffer which pixel
values are to be copied into, or copied from.
The
<em class="Ep">cnt</em>
specifies the
number of unsigned chars
(for
<a href="#pxd_readuchar" class="Er">pxd_readuchar</a>
and
<a href="#pxd_writeuchar" class="Er">pxd_writeuchar</a>)
or unsigned shorts
(for
<a href="#pxd_readushort" class="Er">pxd_readushort</a>
and
<a href="#pxd_writeushort" class="Er">pxd_writeushort</a>),
in the array or buffer referenced by
<em class="Ep">membuf</em>.
The
<em class="Ep">membuf</em>
and
<em class="Ep">cnt</em>
must be large enough to contain all of the pixel
values implied by
<em class="Ep">ulx</em>,
<em class="Ep">uly</em>,
<em class="Ep">lrx</em>,
<em class="Ep">lry</em>,
and
<em class="Ep">colorspace</em>;
the
<em class="Ep">cnt</em>
is not intended to be used to limit the number of pixel values
transferred, but is rather intended to assert the maximum
allowable transfer size and induce an error
if the
<em class="Ep">membuf</em>
and
<em class="Ep">cnt</em>
is too small.
</p><p>
The
<em class="Ep">colorspace</em>
specifies the color space and color component(s)
in which pixel values are to be read into, or written from,
the program provided array or buffer.
Valid choices are:
</p><blockquote>
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
colorspace  
</td>
<td colspan="1" align="left">
 Number of Components 
</td>
<td colspan="1" align="left">
 Color Representation
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RGB"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Red, Green, Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofRGB"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofRGB"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofRGB"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BGR"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Blue, Green, Red (RGB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofBGR"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofBGR"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofBGR"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BSH"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Brightness, Saturation, Hue (HSB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofBSH"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Brightness
</td>
</tr>
<tr>
<td colspan="1" align="left">
"SofBSH"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Saturation
</td>
</tr>
<tr>
<td colspan="1" align="left">
"HofBSH"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Hue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RGBx"      
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Red, Green, Blue, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofRGBx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofRGBx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofRGBx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BGRx"      
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Blue, Green, Red, Pad (RGB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofBGRx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GofBGRx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofBGRx"   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Grey"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GREY"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale (alternate spelling for "Grey")
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Gray"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale (alternate spelling for "Grey")
</td>
</tr>
<tr>
<td colspan="1" align="left">
"GRAY"      
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale (alternate spelling for "Grey")
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YCrCb"     
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YofYCrCb"  
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Intensity
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofYCrCb"  
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofYCrCb"  
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YCrCbX"    
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YofYCrCbX" 
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Intensity
</td>
</tr>
<tr>
<td colspan="1" align="left">
"RofYCrCbX" 
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Red Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"BofYCrCbX" 
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
"Bayer"     
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Raw Bayer Pattern Values
</td>
</tr>
<tr>
<td colspan="1" align="left">
"CbYCrY"    
</td>
<td colspan="1" align="left">
 2 
</td>
<td colspan="1" align="left">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</td>
</tr>
<tr>
<td colspan="1" align="left">
"CMY"       
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Cyan, Magenta, Yellow
</td>
</tr>
<tr>
<td colspan="1" align="left">
"CofCMY"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Cyan
</td>
</tr>
<tr>
<td colspan="1" align="left">
"MofCMY"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Magenta
</td>
</tr>
<tr>
<td colspan="1" align="left">
"YofCMY"    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Yellow
</td>
</tr>
</tbody></table>
</pre>
</blockquote>
<p>
The
''BGRx''
selection, when used with a
''uchar''
<em class="Ep">membuf</em>,
on Intel machines with little-endian architecture
(i.e. least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, results in pixels that are compatible with Windows' RGB() data type.
</p><p>
The
''Bayer''
selection is available only in conjunction with cameras
that actually output raw Bayer pattern values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
</p><p>
The
''CbYCrY''
selection is available only in conjunction with imaging boards
that actually capture CbYCrY (UYVY) values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x), BGR(x), or YCrCb.
</p><p>
While these functions could be used to read or write
a single pixel value with each invocation,
they are intended, and more efficient, for reading
or writing lines, columns, or entire images of pixel values.
</p><p>
Any data type,
''uchar''
or
''ushort'',
and any
<em class="Ep">colorspace</em>
can be chosen regardless of the image frame buffer's
actual format.
However, data type and color conversions
may require additional computational overhead.
</p><p>
Each pixel value component is copied from, or copied into,
a single
''uchar''
or
''ushort'';
pixel values are not
''bit-packed''.
If the data type
has fewer bits that the pixel value component,
the most significant bits of the pixel value component
are copied into the data type, or are copied from the data type
with lower order bits set to 0;
e.g. a 10 bit per pixel component value of 1023 is
stored in an 8 bit
''uchar''
as value 255.
If the data type has more bits than the pixel value
component, the pixel value component is copied into, or copied from,
the data type's least significant bits;
e.g. a 10 bit per pixel component value of 1023
is stored in an 16 bit
''ushort''
as value 1023.
</p><p>
Pixels are read or written, from or to the image,
to or from
<em class="Ep">membuf</em>,
in the order left-to-right and top-to-bottom.
For color pixels with multiple components,
the component values are read or written
in packed, not planer, order.
</p><p>
The XCLIB-Lite only supports the
''RGB'',
''BGR'',
''RGBx'',
''BGRx'',
''Grey'',
''Gray'',
''GREY'',
and
''GRAY''
selections.
The XCLIB-Lite does not provide data conversions;
<a href="#pxd_readuchar" class="Er">pxd_readuchar</a>
and
<a href="#pxd_writeuchar" class="Er">pxd_writeuchar</a>
must be used with 1 through 8 bit component values,
<a href="#pxd_readushort" class="Er">pxd_readushort</a>
and
<a href="#pxd_writeushort" class="Er">pxd_writeushort</a>
must be used with 9 through 16 bit values.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>&#8805;0</dt><dd>
Returns the number of pixel value components copied into,
or copied from, the
<em class="Ep">membuf</em>.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERTOOSMALL</dt><dd>
The
<em class="Ep">membuf</em>
and
<em class="Ep">cnt</em>
is too small to contain the number of pixel value components
specified by
<em class="Ep">ulx</em>,
<em class="Ep">uly</em>,
<em class="Ep">lrx</em>,
<em class="Ep">lry</em>,
and
<em class="Ep">colorspace</em>.
<br></dd><dt>PXERBADMNEMONIC</dt><dd>
The
<em class="Ep">colorspace</em>
is invalid.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">Example</em>
<p>
The center pixel in each
image frame buffer of each imaging board
is read and displayed numerically as both RGB and monochrome.
For convenience, the example uses
''ushort''
data types regardless of the image frame buffer's
pixel bit-depth, letting the library perform conversions as needed.
</p><blockquote>
<pre>ushort  membuf[3];  // room for 1 pixel with three components
int     unit, buf;
<br>
for (unit = 0; unit &lt; pxd_infoUnits(); units++) {
    for (buf = 1; buf &lt; pxd_imageZdim(); buf++) {
        pxd_readushort(1&lt;&lt;unit, buf,
                       pxd_imageXdim()/2,     pxd_imageYdim()/2,
                       1+(pxd_imageXdim()/2), 1+(pxd_imageYdim()/2),
                       membuf,
                       3,   // dimension of membuf
                       "Grey");
        printf("Unit: %d, Buffer: %d, Grey Value: %u\n", unit, buf, membuf[0]);
        pxd_readushort(1&lt;&lt;unit, buf,
                       pxd_imageXdim()/2,     pxd_imageYdim()/2,
                       1+(pxd_imageXdim()/2), 1+(pxd_imageYdim()/2),
                       membuf,
                       3,   // dimension of membuf
                       "RGB");
        printf("Unit: %d, Buffer: %d, RGB Value: %u/%u/%u\n", unit, buf,
               membuf[0], membuf[1], membuf[2]);
    }
}
</pre>
</blockquote>
<hr size="1">
<a name="pxd_renderDIBCreate NX381" class="NX"></a>
<a name="pxd_renderDIBCreate" class="Sf"></a>
<a name="Windows: Create Device Independent Bitmap (DIB) NX382" class="NX"></a>
<a name="Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate" class="Sf"></a>
<a name="Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate"></a>
<h6 class="Sf">Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate</h6>
<a name="pxd_renderDIBFree NX383" class="NX"></a>
<a name="pxd_renderDIBFree" class="Sg"></a>
<a name="Windows: Release Device Independent Bitmap (DIB) NX384" class="NX"></a>
<a name="Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree" class="Sg"></a>
<a name="Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree"></a>
<h6 class="Sg">Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>HGLOBAL pxd_renderDIBCreate(unitmap, framebuf, ulx, uly, lrx, lry, mode, options);
int     pxd_renderDIBFree(hDIB);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
int                 mode;           // Reserved, should be 0
int                 options;        // Reserved, should be 0
<br>
HGLOBAL             hDIB;           // Previously created bitmap
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
An image frame buffer, or an area of interest within the image frame buffer,
is copied to a newly created Windows Device Independent Bitmap (DIB)
in global memory (e.g. using the Windows'
<cite class="Ec">GlobalAlloc</cite>)
and the handle to the DIB returned by
<a href="#pxd_renderDIBCreate" class="Er">pxd_renderDIBCreate</a>.
The bitmap created must be freed by
<a href="#pxd_renderDIBFree" class="Er">pxd_renderDIBFree</a>
when no longer needed.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which the image frame buffer
is to be copied.
The
<em class="Ep">framebuf</em>,
1&lt;=<em class="Ep">framebuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
specifies the image frame buffer to be copied.
The
<em class="Ep">ulx</em>
and
<em class="Ep">uly</em>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>())
or the extreme bottom vertical coordinate
(i.e.
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>()),
respectively.
</p><p>
Color image frame buffers are copied as 24 bit RGB pixels
without compression.
Monochrome image frame buffers are copied
as 8 bit pixels with a monochrome, identity, palette
without compression.
</p><p>
The number of pixels per line, i.e.
<em class="Ep">lrx</em>-<em class="Ep">ulx,</em>
should be a multiple of four;
as some Windows drivers do not properly support
Device Independent Bitmaps which violate this condition.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_renderDIBCreate" class="Er">pxd_renderDIBCreate</a>
returns a handle to
<cite class="Ec">GlobalAlloc</cite>
memory, or 0 if the library is not open for use,
or a parameter is invalid.
</p><p>
The
<a href="#pxd_renderDIBFree" class="Er">pxd_renderDIBFree</a>
returns 0 if successful
or a PXER... code
as appropriate.
</p><hr size="1">
<a name="pxd_renderDirectVideoInit NX385" class="NX"></a>
<a name="pxd_renderDirectVideoInit" class="Sf"></a>
<a name="Windows: Direct Video Display, Init NX386" class="NX"></a>
<a name="Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit" class="Sf"></a>
<a name="Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit"></a>
<h6 class="Sf">Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit</h6>
<a name="pxd_renderDirectVideoDone NX387" class="NX"></a>
<a name="pxd_renderDirectVideoDone" class="Sg"></a>
<a name="Windows: Direct Video Display, Done NX388" class="NX"></a>
<a name="Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone" class="Sg"></a>
<a name="Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone"></a>
<h6 class="Sg">Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_renderDirectVideoInit(unitmap, hWnd);
int pxd_renderDirectVideoDone(unitmap, hWnd);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
HWND                hWnd;           // Handle to window
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="Windows NX389" class="NX"></a>
A connection to the DirectX/DirectDraw feature of Windows
is created in preparation for
displaying live video on the graphics display (S/VGA).
The
<em class="Ep">hWnd</em>
specifies the window to which
DirectX/DirectDraw access is requested
on the single unit specified by
<em class="Ep">unitmap</em>.<a href="#Footnote%2025" class="Ff"><sup>[25]</sup></a>
</p><p>
Since initial connection to DirectX/DirectDraw may require
200 msec or more, the
<a href="#pxd_renderDirectVideoInit" class="Er">pxd_renderDirectVideoInit</a>
may be initialized once, after which
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
may be used multiple times without repeating the connection delay.
When done,
<a href="#pxd_renderDirectVideoDone" class="Er">pxd_renderDirectVideoDone</a>
should be called to release the connection.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Connection established.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
<br></dd><dt>PXERNOMODE</dt><dd>
The current imaging board does not provide
live video to the graphics display (S/VGA).
<br></dd><dt>PXERNOFEATURE</dt><dd>
A connection could not be established to DirectX/DirectDraw;
that feature may not be installed in the current Windows.
<br></dd><dt>PXERNOTNOW</dt><dd>
Another application has exclusive DirectX/DirectDraw
use of the graphics display (S/VGA).
<br></dd><dt>PXERNOTOPEN</dt><dd>
A connection to DirectX/DirectDraw was not created via
<a href="#pxd_renderDirectVideoInit" class="Er">pxd_renderDirectVideoInit</a>.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_renderDirectVideoLive NX390" class="NX"></a>
<a name="pxd_renderDirectVideoLive" class="Sf"></a>
<a name="Windows: Direct Video Display, Start NX391" class="NX"></a>
<a name="Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive" class="Sf"></a>
<a name="Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive"></a>
<h6 class="Sf">Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive</h6>
<a name="pxd_renderDirectVideoUnLive NX392" class="NX"></a>
<a name="pxd_renderDirectVideoUnLive" class="Sg"></a>
<a name="Windows: Direct Video Display, Stop NX393" class="NX"></a>
<a name="Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive" class="Sg"></a>
<a name="Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive"></a>
<h6 class="Sg">Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_renderDirectVideoLive(unitmap, hWnd, nX, nY, nWidth, nHeight, ClrKey1, ClrKey2);
int pxd_renderDirectVideoUnLive(unitmap, hWnd);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
HWND                hWnd;           // Handle to window
uint                nX;             // X position in Window
uint                nY;             // Y position in Window
uint                nWidth;         // Display width in Window, or UINT_MAX
uint                nHeight;        // Display height in Window, or UINT_MAX
COLORREF            ClrKey1;        // Color key, a RGB(,,) or CLR_INVALID
COLORREF            ClrKey2;        // Color key, a RGB(,,) or CLR_INVALID
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="Windows NX394" class="NX"></a>
The
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
initiates displaying of live video directly to the graphics display (S/VGA),
using the Windows' DirectX/DirectDraw feature.
The
<a href="#pxd_renderDirectVideoUnLive" class="Er">pxd_renderDirectVideoUnLive</a>
terminates displaying of live video directly to the graphics display (S/VGA).
The
<a href="#pxd_renderDirectVideoInit" class="Er">pxd_renderDirectVideoInit</a>
must have been used previously to create a connection to the
DirectX/DirectDraw feature.
The
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
and related functions handle the entire DirectX/DirectDraw interface;
the user need not be familiar with the DirectX/DirectDraw API,
nor use the DirectX/DirectDraw SDK.
Familiarity with the standard Windows API is, of course, helpful.
</p><p>
The
<em class="Ep">hWnd</em>
specifies the window upon which
live video is displayed, from
the single unit specified by
<em class="Ep">unitmap</em>.<a href="#Footnote%2026" class="Ff"><sup>[26]</sup></a>
Live video is displayed
at an upper left coordinate of
<em class="Ep">nX</em>
and
<em class="Ep">nY</em>
relative to the
<em class="Ep">hWnd</em>
window,
with a maximum width and height of
<em class="Ep">nWidth</em>
and
<em class="Ep">nHeight</em>.
The
<em class="Ep">nWidth</em>
and
<em class="Ep">nHeight</em>
are reduced so as to not exceed the window's size;
use of
<em class="Ep">nX</em>=0,
<em class="Ep">nY</em>=0,
<em class="Ep">nWidth</em>=UINT_MAX,
and
<em class="Ep">nHeight</em>=UINT_MAX
fills as much of the window as possible.
The displayed video may be smaller than the requested size,
as limited by the current video resolution
(see
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>
and
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>).
The video resolution will be decreased, as needed, to fit within
the display area, but will not be automatically enlarged.
</p><p>
If
<em class="Ep">ClrKey1</em>&#8800;CLR_INVALID,
the color key (chroma key)
feature of the graphics display (S/VGA) is enabled,
so as to allow presenting live video only where the graphics display (S/VGA) screen
has the color of
<em class="Ep">ClrKey1</em>.
This allows presentation of graphics over live video,
through the use of Windows GDI,
so long as the intended graphics are a color different than
<em class="Ep">ClrKey1</em>.
If
<em class="Ep">ClrKey2</em>&#8800;CLR_INVALID,
the color
<em class="Ep">ClrKey2</em>
is drawn on the window prior to activating live video.
Typically,
<em class="Ep">ClrKey2</em>
is the same value as
<em class="Ep">ClrKey1</em>;
but setting
<em class="Ep">ClrKey1</em>&#8800;CLR_INVALID
and
<em class="Ep">ClrKey2</em>=CLR_INVALID,
allows the user to assume responsibility for filling
the window with the
<em class="Ep">ClrKey1</em>
color wherever live video is to appear.
</p><p>
After use of
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>,
it is the application's responsibility to monitor Windows'
WM_MOVE, WM_SIZE, WM_WINDOWPOSCHANGED, and WM_WINDOWPOSCHANGING,
messages, and upon receipt, invoke
<a href="#pxd_renderDirectVideoUnLive" class="Er">pxd_renderDirectVideoUnLive</a>
to stop displaying live video in the old size or window location,
and invoke
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
again to resume displaying live in the new size or location.
</p><p>
Graphics display systems (S/VGA cards), and their drivers, differ widely in their support of live video.
The minimal requirements are:
</p><ol type="1">
<p>
</p><li>
Graphics display system (S/VGA) drivers supporting DirectDraw.
<p>
</p></li><li>
Hardware overlay feature.
<p>
</p></li><li>
For PIXCI®&nbsp;SV2 and SV3 imaging boards:
Overlay surface that accepts UYVY format video.
For PIXCI®&nbsp;SV4, SV5, SV5A, SV5B, and SV5L imaging boards:
Overlay surface that accepts UYVY, VYUY, YUY2, or YVYU format video.
<p>
</p></li><li>
Hardware cursor/sprite/icon support.
<p>
</p></li><li>
Hardware chroma key support (optional).
</li></ol>
In addition, the DirectX/DirectDraw feature must be installed in Windows.
<p>
Each graphics display system (S/VGA card) differs in whether it supports the necessary features
in all modes (i.e. 8 bits per pixel, 24 bits per pixel, etc.)
and resolution (i.e. 640x480, 1024x768, etc.).
The
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
tries to provide live video using the
graphics display system's (S/VGA card's) current mode and resolution,
it does not change the graphics display system's current mode or resolution.
</p><p>For PIXCI®&nbsp;A, CL1, CL2, D, D24, D32, D2X, D3X, E1, E1DB,
E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2,
SI, SI1, and SI4:
No known graphics display system (S/VGA card) supports the data formats
produced
by these imaging boards.
</p><p>
For PIXCI®&nbsp;CL3SD and SI2: The imaging board can't
directly display live video to the graphics display (S/VGA).
</p><p>
The
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
and
<a href="#pxd_renderDirectVideoUnLive" class="Er">pxd_renderDirectVideoUnLive</a>
do not support
use of multiple imaging boards at different
video formats and resolutions.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation successful.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERNOTOPEN</dt><dd>
A connection to DirectX/DirectDraw was not created via
<a href="#pxd_renderDirectVideoInit" class="Er">pxd_renderDirectVideoInit</a>.
<br></dd><dt>PXERNOMODE</dt><dd>
The current graphics display (S/VGA) card can't accept live video,
at least not in a form compatible with the imaging board's current video format.
<br></dd><dt>PXERNODEVMEM</dt><dd>
Insufficient memory on the graphics display system (S/VGA card) for the specified video resolution.
<br></dd><dt>PXERNOFEATURE</dt><dd>
The current graphics display system (S/VGA card) doesn't provide color keying,
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
can only be used with
<em class="Ep">ClrKey1</em>=CLR_INVALID.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">Example</em>
<p>
The
<code class="Em">xclibex2.cpp</code>
example program demonstrates use of
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
and
<a href="#pxd_renderDirectVideoUnLive" class="Er">pxd_renderDirectVideoUnLive</a>,
including the use of chroma keying
and use of
WM_MOVE, WM_SIZE, WM_WINDOWPOSCHANGED, and WM_WINDOWPOSCHANGING,
to track changes to the window's position.
</p><p>
The
<code class="Em">xclibex2.cpp</code>
also demonstrates other techniques for displaying live
video, which may be used regardless of whether the graphics display (S/VGA)
and imaging board features support
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>.
</p><hr size="1">
<a name="pxd_renderStretchDIBits NX395" class="NX"></a>
<a name="pxd_renderStretchDIBits" class="Sf"></a>
<a name="Windows: Display Image Frame Buffer On Device Context NX396" class="NX"></a>
<a name="Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits" class="Sf"></a>
<a name="Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits"></a>
<h6 class="Sf">Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_renderStretchDIBits(unitmap,buffer,ulx,uly,lrx,lry,options,hDC,nX,nY,nWidth,nHeight,winoptions);
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
int                 options;        // Reserved, should be 0
HDC                 hDC;            // Device context
uint                nX;             // Display x position in hDC
uint                nY;             // Display y position in hDC
uint                nWidth;         // Display width in hDC
uint                nHeight;        // Display height in hDC
int                 winoptions;     // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="Windows NX397" class="NX"></a>
An image frame buffer, or an area of interest within the image frame buffer,
is copied/rendered/displayed to a Windows device context,
typically a display window or a printer context.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which the image frame buffer
is to be copied.
The
<em class="Ep">framebuf</em>,
1&lt;=<em class="Ep">framebuf</em>&lt;=<em class="Ep">pxd_imageZdim(),</em>
specifies the image frame buffer to be copied.
The
<em class="Ep">ulx</em>
and
<em class="Ep">uly</em>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>())
or the extreme bottom vertical coordinate
(i.e.
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>()),
respectively.
</p><p>
The image is rendered on the device context defined by
<em class="Ep">hDC</em>,
starting at the
<em class="Ep">nX</em>
and
<em class="Ep">nY</em>
coordinate,
with a width and height of
<em class="Ep">nWidth</em>
and
<em class="Ep">nHeight</em>.
</p><p>
As may be inferred from the name,
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>
uses the Windows GDI
<cite class="Ec">StretchDIBits</cite>
function;
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>
builds a Device Independent Bitmap
of the specified image frame buffer and area of interest,
and invokes:
</p><blockquote>
<pre>StretchDIBits(hDC,nX,nY,nWidth,nHeight,0,0,lrx-ulx,lry-uly,*,*,DIB_RGB_COLORS,SRCCOPY);
</pre>
</blockquote>
or
<blockquote>
<pre>StretchDIBits(hDC,nX,nY+nHeight-1,nWidth,-nHeight,0,0,lrx-ulx,lry-uly,*,*,DIB_RGB_COLORS,SRCCOPY);
</pre>
</blockquote>
The
<cite class="Ec">StretchDIBits</cite>
documentation provides additional discussion regarding the
<em class="Ep">nX</em>,
<em class="Ep">nY</em>,
<em class="Ep">nWidth</em>,
and
<em class="Ep">nHeight</em>
parameters.<a href="#Footnote%2027" class="Ff"><sup>[27]</sup></a>
<p>
The number of pixels per line, i.e.
<em class="Ep">lrx</em>-<em class="Ep">ulx</em>,
should be a multiple of four,
as some Windows display drivers do not properly support
Device Independent Bitmaps which violate this condition.
The number of pixels displayed per line, i.e.
<em class="Ep">nWidth</em>
should also be a multiple of four,
as some Windows display drivers do not properly support
resizing into a display area which violates this condition.
</p><p>
For some graphics display (S/VGA) drivers, the quality of the rendered image can
be significantly improved by using:
</p><blockquote>
<pre>SetStretchBltMode(hDC, STRETCH_DELETESCANS);
</pre>
</blockquote>
before
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>.
<p>
<a name="S/VGA Adapter NX398" class="NX"></a>
<a name="Graphics Display System NX399" class="NX"></a>
Because
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>
relies upon the Windows
<cite class="Ec">StretchDIBits</cite>
for rendering and resizing, the
visual result and rendering speed
is completely dependent upon the graphics display adapter (e.g. S/VGA adapter)
and its driver.
For example, in 16 color (4 bit per pixel) S/VGA mode, monochrome images
might be rendered using only 3 grey levels, with significant
''banding''.
Good results will be obtained
with S/VGA adapters providing at least 16 bits per pixel
for monochrome images, or at least 24 bits per pixel for color images.<a href="#Footnote%2028" class="Ff"><sup>[28]</sup></a>
</p><p>
Alternately, the
<a href="#pxd_renderDIBCreate" class="Er">pxd_renderDIBCreate</a>
can be used to create a standard Windows Device Independent Bitmap
(DIB) which can then be rendered via DrawDibDraw
or via the Video for Windows (MultiMedia) API.
The
visual result and rendering speed is still
completely dependent upon the graphics display adapter (e.g. S/VGA adapter)
and its driver; however, the Windows MultiMedia API, being newer,
tends to perform better than the older Windows
<cite class="Ec">StretchDIBits</cite>.
</p><p>
Finally, the alternate
<cite class="Ec">pxio8_GDIDisplay</cite>,
<cite class="Ec">pxio8_DirectXDisplay</cite>,
or
<cite class="Ec">pxio8_DrawDibDisplay</cite>
functions provided with the
<cite class="Ec">PXIPL Image Processing Library</cite>,
allows pseudo-grey level generation (useful in 16 color S/VGA modes),
selectable methods of image resizing,
provides for integrated drawing of a cross-hair or other image cursor,
performs resizing within the PXIPL function,
avoids the overhead of copying the image into a DIB format
and allows applying a look-up table (palette) as the image is being
rendered.
</p><p>
<a name="Printing NX400" class="NX"></a>
Because
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>
uses
<em class="Ep">hDC</em>,
a handle to a device context rather than a handle to a window,
it may also be used to print images, given a handle to a printer's device context.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Image frame buffer copied/rendered/displayed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
</dd></dl>
<hr size="1">
<a name="pxd_serialConfigure NX401" class="NX"></a>
<a name="pxd_serialConfigure" class="Sf"></a>
<a name="Serial Port: Set Configuration NX402" class="NX"></a>
<a name="Serial Port: Set Configuration   ---   pxd_serialConfigure" class="Sf"></a>
<a name="Serial Port: Set Configuration   ---   pxd_serialConfigure"></a>
<h6 class="Sf">Serial Port: Set Configuration   ---   pxd_serialConfigure</h6>
<a name="pxd_serialRead NX403" class="NX"></a>
<a name="pxd_serialRead" class="Sg"></a>
<a name="Serial Port: Read NX404" class="NX"></a>
<a name="Serial Port: Read   ---   pxd_serialRead" class="Sg"></a>
<a name="Serial Port: Read   ---   pxd_serialRead"></a>
<h6 class="Sg">Serial Port: Read   ---   pxd_serialRead</h6>
<a name="pxd_serialWrite NX405" class="NX"></a>
<a name="pxd_serialWrite" class="Sg"></a>
<a name="Serial Port: Write NX406" class="NX"></a>
<a name="Serial Port: Write   ---   pxd_serialWrite" class="Sg"></a>
<a name="Serial Port: Write   ---   pxd_serialWrite"></a>
<h6 class="Sg">Serial Port: Write   ---   pxd_serialWrite</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_serialConfigure(unitmap, rsvd0, baud, bits, parity, stopbits, rsvd1, rsvd2, rsvd3);
int pxd_serialRead(unitmap, rsvd0, data, cnt);
int pxd_serialWrite(unitmap, rsvd0, data, cnt);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
double              baud;               // Serial baud rate, or 0
int                 bits;               // Bits per character
int                 stopbits;           // Stop bits per character, times 10
int                 parity;             // 0: None
int                 rsvd0;              // Reserved, should be 0
int                 rsvd1;              // Reserved, should be 0
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
char                data[];             // Program's buffer to receive or originate data
int                 cnt;                // Size of data[]
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>,
<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>,
and
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>
allow use of the serial port on
PIXCI® CL1, CL2, CL3SD, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, and EL1DB imaging boards.
</p><p>
The
<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>
sets the serial port's parameters
on the single unit selected by
<em class="Ep">unitmap</em>.
The
<em class="Ep">baud</em>
specifies the baud rate,
the
<em class="Ep">bits</em>
specifies the number of bits per character,
the
<em class="Ep">stopbits</em>
specifies the number of stop bits per character multiplied by 10,
and
<em class="Ep">parity</em>
specifies the type of parity bit.
For the PIXCI® CL1 before Rev. 3 and the PIXCI® CL3SD,
the baud rate may be any value between
95.4 and 6,250,000.0 baud,
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<em class="Ep">stopbits</em>=1)
and parity must be none
(i.e.
<em class="Ep">parity</em>=0).
For the PIXCI® CL2, and the PIXCI® CL1 Rev. 3 and later
the baud rate may be any value between
192.0 and 12,500,000.0 baud,
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<em class="Ep">stopbits</em>=1)
and parity must be none
(i.e.
<em class="Ep">parity</em>=0).
For the PIXCI® E1, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, EL1, and E4
the baud rate may be any value between
512.4 and 12,500,000.0 baud,
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<em class="Ep">stopbits</em>=1)
and parity must be none
(i.e.
<em class="Ep">parity</em>=0).
For the PIXCI® E1DB, ECB2, EL1DB, and E4DB
the baud rate may be any of the values
9600, 19200, 38400, 57600, 115200, 230400, 460800, or 921600 baud
(i.e. the Camera Link V2.0 Specification baud rates),
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<em class="Ep">stopbits</em>=1)
and parity must be none
(i.e.
<em class="Ep">parity</em>=0).
The
<em class="Ep">baud</em>
may also be 0, disabling the serial port;
other serial port parameters are ignored.
</p><p>
The
<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>
reads any previously received but unread data
into the
''char''
array or buffer provided by the application
on the single unit selected by
<em class="Ep">unitmap</em>.
The
<em class="Ep">cnt</em>
specifies the size of the
array or buffer referenced by
<em class="Ep">data</em>,
and the maximum amount of data to be read.
The
<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>
never waits for data to be received,
reading only previously received data,
and returns the number of char's read.
If
<em class="Ep">data</em>=NULL
or
<em class="Ep">cnt</em>=0<em class="Ep">,</em>
the
<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>
returns the number of char's available to
be read without reading or deleting the unread data.
</p><p>
The
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>
writes data from the
''char''
array or buffer provided by the application
on the single unit selected by
<em class="Ep">unitmap</em>.
The
<em class="Ep">cnt</em>
specifies the size of the
array or buffer referenced by
<em class="Ep">data</em>,
and the amount of data to be written.
The
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>
may wait for the
<em class="Ep">data</em>
to be queued for transmission
(i.e. until all the data can be copied into the
internal transmit buffers)
but does not wait until the
<em class="Ep">data</em>
is actually transmitted.
If
<em class="Ep">buf</em>=0
or
<em class="Ep">cnt</em>=0<em class="Ep">,</em>
the
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>
returns the amount of available space in the
internal transmit buffers, and thus the amount of
data that can be
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>'n
without having to wait.
</p><p>
The size of the transmit and received buffers
are currently each 1024 bytes and may not be changed.
</p><p>
Note: The Visual Basic declarations for
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>
and
<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>
are written to expect that the
<em class="Ep">data</em>
will be passed as a VB dimensioned array,
not as a VB double-quoted string.
This allows easier use with cameras whose
serial commands are binary rather than ASCII.
For cameras with ASCII style commands, the ASCII
characters can be inserted into a dimensioned array,
or the VB declaration can be manually changed.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>&#8805;0</dt><dd>
Operation complete
(<a href="#pxd_serialRead" class="Er">pxd_serialRead</a>
and
<a href="#pxd_serialWrite" class="Er">pxd_serialWrite</a>).
<br></dd><dt>0</dt><dd>
Operation complete
(<a href="#pxd_serialConfigure" class="Er">pxd_serialConfigure</a>).
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
See
<a href="#clSerialInit" class="Er">clSerialInit</a>,
<a href="#clSerialClose" class="Er">clSerialClose</a>,
<a href="#clSerialRead" class="Er">clSerialRead</a>,
<a href="#clSerialWrite" class="Er">clSerialWrite</a>
and related functions.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
An example of sending a camera one command
and waiting for a response.
Each camera's commands and responses differ;
the example command and response are for a hypothetical
camera using ASCII style commands.
</p><blockquote>
<pre>    char    databuffer[50];   // buffer large enough for command and response
    int     dataread;
    int     r;
    char    c;
    DWORD   time;
    //
    // Init serial port if not done already
    //
    r = pxd_serialConfigure(0x1, 0,  9600, 8, 0, 1, 0, 0, 0);
    if (r &lt; 0)
        return; // error
    //
    // Format command and send.
    // Here we use an example of an ASCII style, \n terminated, command.
    // If the camera used binary commands, we would likely construct the
    // databuffer byte by byte instead of using sprintf, and we
    // would know the length a priori instead of using strlen().
    //
    sprintf(databuffer, "Set Gain=%f\n", 12.345);
    r = pxd_serialWrite(0x1, 0, databuffer, strlen(databuffer));
    if (r &lt; 0)
        return; // error
    //
    // Wait for and read response. Don't wait forever, in
    // case the camera is not connected or not powered on.
    //
    dataread = 0;
    time = GetTickCount();  // Windows: current time in milliseconds
    for (;;) {
        //
        // Another character arrived?
        //
        r = pxd_serialRead(0x1, 0, &amp;c, 1);
        if (r &lt; 0)
            return;     // error
        if (r == 0) {
            Sleep(1);   // be nice to multitasking OS
            continue;   // nothing arrived since last check
        }
        //
        // Store next character, building up response
        //
        databuffer[dataread++] = c;
        //
        // Have we read a complete response? The test is camera dependent!
        // Here we assume an ASCII response, terminated with a \n .
        //
        if (c == '\n')
            break;
        //
        // If not, have we filled the buffer?
        //
        if (dataread == sizeof(databuffer))
            return;     // error: can't interpret response
        //
        // Have we waited long enough to give up?
        //
        if (GetTickCount()-time &gt; 1000)
            return;     // error: timeout
    }
    //
    // Check the response. This test is camera dependent!
    //
    if (strstr(databuffer, "ACK"))
        return;     // positive acknowledge seen
    if (strstr(databuffer, "NAK"))
        return;     // negative acknowledge seen
    return;         // error: can't interpret response
</pre>
</blockquote>
The above example reads the response one character at a time
for sake of clarity, not necessity.
The first half of the
''for''
loop can be replaced with:
<blockquote>
<pre>    for (;;) {
        //
        // Read up to as many characters as will fit in the remainder
        // of the data buffer.
        //
        r = pxd_serialRead(0x1, 0, &amp;databuffer[dataread], sizeof(databuffer)-dataread);
        if (r &lt; 0)
            return;     // error
        if (r == 0) {
            Sleep(1);   // be nice to multitasking OS
            continue;   // nothing arrived since last check
        }
        dataread += r;
        //
        // Have we read a complete response?
        //
        if (databuffer[dataread-1] == '\n')
            break;
        ...
    }
</pre>
</blockquote>
<hr size="1">
<a name="clSerialInit NX407" class="NX"></a>
<a name="clSerialInit" class="Sf"></a>
<a name="Camera Link Serial: Initialize NX408" class="NX"></a>
<a name="Camera Link Serial: Initialize   ---   clSerialInit" class="Sf"></a>
<a name="Camera Link Serial: Initialize   ---   clSerialInit"></a>
<h6 class="Sf">Camera Link Serial: Initialize   ---   clSerialInit</h6>
<a name="clSerialClose NX409" class="NX"></a>
<a name="clSerialClose" class="Sg"></a>
<a name="Camera Link Serial: Close NX410" class="NX"></a>
<a name="Camera Link Serial: Close   ---   clSerialClose" class="Sg"></a>
<a name="Camera Link Serial: Close   ---   clSerialClose"></a>
<h6 class="Sg">Camera Link Serial: Close   ---   clSerialClose</h6>
<a name="clSerialRead NX411" class="NX"></a>
<a name="clSerialRead" class="Sg"></a>
<a name="Camera Link Serial: Read NX412" class="NX"></a>
<a name="Camera Link Serial: Read   ---   clSerialRead" class="Sg"></a>
<a name="Camera Link Serial: Read   ---   clSerialRead"></a>
<h6 class="Sg">Camera Link Serial: Read   ---   clSerialRead</h6>
<a name="clSerialWrite NX413" class="NX"></a>
<a name="clSerialWrite" class="Sg"></a>
<a name="Camera Link Serial: Write NX414" class="NX"></a>
<a name="Camera Link Serial: Write   ---   clSerialWrite" class="Sg"></a>
<a name="Camera Link Serial: Write   ---   clSerialWrite"></a>
<h6 class="Sg">Camera Link Serial: Write   ---   clSerialWrite</h6>
<a name="clGetNumBytesAvail NX415" class="NX"></a>
<a name="clGetNumBytesAvail" class="Sg"></a>
<a name="Camera Link Serial: Read Available NX416" class="NX"></a>
<a name="Camera Link Serial: Read Available   ---   clGetNumBytesAvail" class="Sg"></a>
<a name="Camera Link Serial: Read Available   ---   clGetNumBytesAvail"></a>
<h6 class="Sg">Camera Link Serial: Read Available   ---   clGetNumBytesAvail</h6>
<a name="clFlushPort NX417" class="NX"></a>
<a name="clFlushPort" class="Sg"></a>
<a name="Camera Link Serial: Read Flush NX418" class="NX"></a>
<a name="Camera Link Serial: Read Flush   ---   clFlushPort" class="Sg"></a>
<a name="Camera Link Serial: Read Flush   ---   clFlushPort"></a>
<h6 class="Sg">Camera Link Serial: Read Flush   ---   clFlushPort</h6>
<a name="clGetErrorText NX419" class="NX"></a>
<a name="clGetErrorText" class="Sg"></a>
<a name="Camera Link Serial: Error Text NX420" class="NX"></a>
<a name="Camera Link Serial: Error Text   ---   clGetErrorText" class="Sg"></a>
<a name="Camera Link Serial: Error Text   ---   clGetErrorText"></a>
<h6 class="Sg">Camera Link Serial: Error Text   ---   clGetErrorText</h6>
<a name="clGetNumSerialPorts NX421" class="NX"></a>
<a name="clGetNumSerialPorts" class="Sg"></a>
<a name="Camera Link Serial: Ports NX422" class="NX"></a>
<a name="Camera Link Serial: Ports   ---   clGetNumSerialPorts" class="Sg"></a>
<a name="Camera Link Serial: Ports   ---   clGetNumSerialPorts"></a>
<h6 class="Sg">Camera Link Serial: Ports   ---   clGetNumSerialPorts</h6>
<a name="clGetSerialPortIdentifier NX423" class="NX"></a>
<a name="clGetSerialPortIdentifier" class="Sg"></a>
<a name="Camera Link Serial: Ports ID NX424" class="NX"></a>
<a name="Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier" class="Sg"></a>
<a name="Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier"></a>
<h6 class="Sg">Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier</h6>
<a name="clGetManufacturerInfo NX425" class="NX"></a>
<a name="clGetManufacturerInfo" class="Sg"></a>
<a name="Camera Link Serial: Manufacturer ID NX426" class="NX"></a>
<a name="Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo" class="Sg"></a>
<a name="Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo"></a>
<h6 class="Sg">Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo</h6>
<a name="clGetSupportedBaudRates NX427" class="NX"></a>
<a name="clGetSupportedBaudRates" class="Sg"></a>
<a name="Camera Link Serial: Get Baud Rates NX428" class="NX"></a>
<a name="Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates" class="Sg"></a>
<a name="Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates"></a>
<h6 class="Sg">Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates</h6>
<a name="clSetBaudRate NX429" class="NX"></a>
<a name="clSetBaudRate" class="Sg"></a>
<a name="Camera Link Serial: Set Baud Rate NX430" class="NX"></a>
<a name="Camera Link Serial: Set Baud Rate   ---   clSetBaudRate" class="Sg"></a>
<a name="Camera Link Serial: Set Baud Rate   ---   clSetBaudRate"></a>
<h6 class="Sg">Camera Link Serial: Set Baud Rate   ---   clSetBaudRate</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int clSerialInit(...);
int clSerialClose(...);
int clSerialRead(...);
int clSerialWrite(...);
int clGetNumBytesAvail(...);
int clFlushPort(...);
int clGetErrorText(...);
int clGetNumSerialPorts(...);
int clGetSerialPortIdentifier(...);
int clGetManufacturerInfo(...);
int clGetSupportedBaudRates(...);
int clSetBaudRate(...);
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Under Windows,
the
<a href="#clSerialInit" class="Er">clSerialInit</a>,
<a href="#clSerialClose" class="Er">clSerialClose</a>,
<a href="#clSerialRead" class="Er">clSerialRead</a>,
<a href="#clSerialWrite" class="Er">clSerialWrite</a>,
<a href="#clGetNumBytesAvail" class="Er">clGetNumBytesAvail</a>,
<a href="#clFlushPort" class="Er">clFlushPort</a>,
<a href="#clGetErrorText" class="Er">clGetErrorText</a>,
<a href="#clGetNumSerialPorts" class="Er">clGetNumSerialPorts</a>,
<a href="#clGetSerialPortIdentifier" class="Er">clGetSerialPortIdentifier</a>,
<a href="#clGetManufacturerInfo" class="Er">clGetManufacturerInfo</a>,
<a href="#clGetSupportedBaudRates" class="Er">clGetSupportedBaudRates</a>,
and
<a href="#clSetBaudRate" class="Er">clSetBaudRate</a>
provide functions to access the serial port of
PIXCI® imaging boards.
These functions' API obeys the Camera Link V1.1 Serial API,<a href="#Footnote%2029" class="Ff"><sup>[29]</sup></a>
except that the instantiation of these functions within the XCLIB
DLL only provide access after XCLIB has been
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>'ed;
the
''serialIndex''
(a Camera Link API parameter)
is the index of a board opened by
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
(i.e. log<sub><small>2</small></sub>
<em class="Ep">unitmap</em>).
</p><p>
These functions are alternatives to using
<a href="#pxd_serialConfigure%22" class="Er">pxd_serialConfigure"</a>,
<a href="#pxd_serialRead%22" class="Er">pxd_serialRead"</a>,
and
<a href="#pxd_serialWrite%22" class="Er">pxd_serialWrite"</a>.
</p><p>
These functions are not a replacement for
somewhat similar, but not identical, functions in the Camera Link's
<code class="Em">clallserial.dll</code>
as described in
<code class="Em">clallserial.h</code>;
which provides single point-of-call access to all Camera Link serial ports
on the current computer regardless of board manufacturer,
by virtue of finding all installed clserXXX.DLL's
and redirecting function calls to them.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described in the Camera Link V1.1 specification.
</p><hr size="1">
<a name="pxd_setExsyncPrin NX431" class="NX"></a>
<a name="pxd_setExsyncPrin" class="Sf"></a>
<a name="Set EXSYNC and PRIN Counter Values NX432" class="NX"></a>
<a name="Set EXSYNC and PRIN Counter Values   ---   pxd_setExsyncPrin" class="Sf"></a>
<a name="Set EXSYNC and PRIN Counter Values   ---   pxd_setExsyncPrin"></a>
<h6 class="Sf">Set EXSYNC and PRIN Counter Values   ---   pxd_setExsyncPrin</h6>
<a name="pxd_getExsync NX433" class="NX"></a>
<a name="pxd_getExsync" class="Sg"></a>
<a name="Get EXSYNC Counter Value NX434" class="NX"></a>
<a name="Get EXSYNC Counter Value   ---   pxd_getExsync" class="Sg"></a>
<a name="Get EXSYNC Counter Value   ---   pxd_getExsync"></a>
<h6 class="Sg">Get EXSYNC Counter Value   ---   pxd_getExsync</h6>
<a name="pxd_getPrin NX435" class="NX"></a>
<a name="pxd_getPrin" class="Sg"></a>
<a name="Get PRIN Counter Value NX436" class="NX"></a>
<a name="Get PRIN Counter Value   ---   pxd_getPrin" class="Sg"></a>
<a name="Get PRIN Counter Value   ---   pxd_getPrin"></a>
<h6 class="Sg">Get PRIN Counter Value   ---   pxd_getPrin</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  pxd_setExsyncPrin(unitmap, exsync, prin);
uint pxd_getExsync(unitmap);
uint pxd_getPrin(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint                exsync;         // The EXSYNC counter value
uint                prin;           // The PRIN counter value
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>The
EXSYNC and PRIN counter values for
PIXCI®&nbsp;A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, and SI4 imaging boards,
are set, or the current values obtained.
Depending upon camera and video format configuration,
these values typically control the camera
integration time and frame period.
The allowable range and units of time of these values
is camera and video format configuration specific,
and discussed in the
<cite class="Ec">PIXCI® User's Manual</cite>.
</p><p>
The
<a href="#pxd_setExsyncPrin" class="Er">pxd_setExsyncPrin</a>
sets the EXSYNC counter value to
<em class="Ep">exsync</em>
and the PRIN counter value to
<em class="Ep">prin</em>
on the multiple units specified by
<em class="Ep">unitmap</em>.
The
<a href="#pxd_getExsync" class="Er">pxd_getExsync</a>
returns the current EXSYNC counter value
on the single unit selected by
<em class="Ep">unitmap</em>.
The
<a href="#pxd_getPrin" class="Er">pxd_getPrin</a>
returns the current PRIN counter value
on the single unit selected by
<em class="Ep">unitmap</em>.
</p><p>
The XCLIB-Lite does not support this feature.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_getExsync" class="Er">pxd_getExsync</a>
and
<a href="#pxd_getPrin" class="Er">pxd_getPrin</a>
returns values as described above, or 0
if the library is not open for use,
XCLIB-Lite is being used,
or the wrong imaging board is in use.
</p><p>
The
<a href="#pxd_setExsyncPrin" class="Er">pxd_setExsyncPrin</a>
returns:
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERNOOPTION</dt><dd>
Wrong imaging board.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_setExsyncPrincMode NX437" class="NX"></a>
<a name="pxd_setExsyncPrincMode" class="Sf"></a>
<a name="Set EXSYNC and PRINC Mode Bits NX438" class="NX"></a>
<a name="Set EXSYNC and PRINC Mode Bits   ---   pxd_setExsyncPrincMode" class="Sf"></a>
<a name="Set EXSYNC and PRINC Mode Bits   ---   pxd_setExsyncPrincMode"></a>
<h6 class="Sf">Set EXSYNC and PRINC Mode Bits   ---   pxd_setExsyncPrincMode</h6>
<a name="pxd_getExsyncMode NX439" class="NX"></a>
<a name="pxd_getExsyncMode" class="Sg"></a>
<a name="Get EXSYNC Mode Bits NX440" class="NX"></a>
<a name="Get EXSYNC Mode Bits   ---   pxd_getExsyncMode" class="Sg"></a>
<a name="Get EXSYNC Mode Bits   ---   pxd_getExsyncMode"></a>
<h6 class="Sg">Get EXSYNC Mode Bits   ---   pxd_getExsyncMode</h6>
<a name="pxd_getPrincMode NX441" class="NX"></a>
<a name="pxd_getPrincMode" class="Sg"></a>
<a name="Get PRINC Mode Bits NX442" class="NX"></a>
<a name="Get PRINC Mode Bits   ---   pxd_getPrincMode" class="Sg"></a>
<a name="Get PRINC Mode Bits   ---   pxd_getPrincMode"></a>
<h6 class="Sg">Get PRINC Mode Bits   ---   pxd_getPrincMode</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  pxd_setExsyncPrincMode(unitmap, exsyncbits, princbits);
uint pxd_getExsyncMode(unitmap);
uint pxd_getPrincMode(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint                exsyncbits;     // The EXSYNC mode bits
uint                princbits;      // The PRINC mode bits
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>The
EXSYNC and PRIN mode bits for
PIXCI®&nbsp;A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, and SI4 imaging boards,
are set, or the current values obtained.
Depending upon camera,
these values typically control the camera's
operating mode, such as pixel clock, binning,
resolution, trigger mode, synchronization, and scaling of the
EXSYNC and/or PRIN counter values used by
<a href="#pxd_setExsyncPrinc" class="Er">pxd_setExsyncPrinc</a>.
The allowable bits and their meaning
are camera specific,
and discussed in the
<cite class="Ec">PIXCI® User's Manual</cite>.
</p><p>
Only those bits which control the
camera's pixel clock frequency, scaling of
EXSYNC and/or PRIN counter values, or similar
features should be changed by using
<a href="#pxd_setExsyncPrincMode" class="Er">pxd_setExsyncPrincMode</a>.
Other features, such as a change to
binning, resolution, or trigger mode
also require a change to the video format configuration,
which this function does not automatically perform.
Use of
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
or
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>
with a video format configuration exported by XCAP
should be used to effect change to all EXSYNC and PRINC
values and bits.
</p><p>
The
<a href="#pxd_setExsyncPrinMode" class="Er">pxd_setExsyncPrinMode</a>
sets the EXSYNC mode bits to
<em class="Ep">exsyncbits</em>
and the PRINC mode bits to
<em class="Ep">princbits</em>
on the multiple units specified by
<em class="Ep">unitmap</em>.
The
<a href="#pxd_getExsyncMode" class="Er">pxd_getExsyncMode</a>
returns the current EXSYNC mode bits
on the single unit selected by
<em class="Ep">unitmap</em>.
The
<a href="#pxd_getPrincMode" class="Er">pxd_getPrincMode</a>
returns the current PRIN mode bits
on the single unit selected by
<em class="Ep">unitmap</em>.
</p><p>
Some versions of the
<cite class="Ec">PIXCI® User's Manual</cite>
may discuss the EXSYNC counter value, the PRIN counter value,
the EXSYNC mode bits, and the PRINC mode bits
in conjunction with the XCOBJ library functions named
<cite class="Ec">pxd_setDalsa01</cite>
<cite class="Ec">pxd_setHitachi01</cite>
or
<cite class="Ec">pxd_setBasler01</cite>.
Each of these XCOBJ functions is actually identical, and they are
equivalent to:
</p><blockquote>
<pre>    #define pxd_setDalsa01(p,e) { \
                pxd_setExsyncPrin(1,e&gt;&gt;16,p&gt;&gt;16); \
                pxd_setExsyncPrincMode(1,e&amp;0xFFFF,p&amp;0xFFFF); \
                                }
</pre>
</blockquote>
<p>
The XCLIB-Lite does not support this feature.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_getExsyncMode" class="Er">pxd_getExsyncMode</a>
and
<a href="#pxd_getPrincMode" class="Er">pxd_getPrincMode</a>
returns values as described above, or 0
if the library is not open for use,
XCLIB-Lite is being used,
or the wrong imaging board is in use.
</p><p>
The
<a href="#pxd_setExsyncPrinMode" class="Er">pxd_setExsyncPrinMode</a>
returns:
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERNOOPTION</dt><dd>
Wrong imaging board.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_setVidMux NX443" class="NX"></a>
<a name="pxd_setVidMux" class="Sf"></a>
<a name="Set Video Input Multiplexer NX444" class="NX"></a>
<a name="Set Video Input Multiplexer   ---   pxd_setVidMux" class="Sf"></a>
<a name="Set Video Input Multiplexer   ---   pxd_setVidMux"></a>
<h6 class="Sf">Set Video Input Multiplexer   ---   pxd_setVidMux</h6>
<a name="pxd_setContrastBrightness NX445" class="NX"></a>
<a name="pxd_setContrastBrightness" class="Sg"></a>
<a name="Set Video Contrast and Brightness NX446" class="NX"></a>
<a name="Set Video Contrast and Brightness   ---   pxd_setContrastBrightness" class="Sg"></a>
<a name="Set Video Contrast and Brightness   ---   pxd_setContrastBrightness"></a>
<h6 class="Sg">Set Video Contrast and Brightness   ---   pxd_setContrastBrightness</h6>
<a name="pxd_setHueSaturation NX447" class="NX"></a>
<a name="pxd_setHueSaturation" class="Sg"></a>
<a name="Set Video Hue and Saturation NX448" class="NX"></a>
<a name="Set Video Hue and Saturation   ---   pxd_setHueSaturation" class="Sg"></a>
<a name="Set Video Hue and Saturation   ---   pxd_setHueSaturation"></a>
<h6 class="Sg">Set Video Hue and Saturation   ---   pxd_setHueSaturation</h6>
<a name="pxd_getVidMux NX449" class="NX"></a>
<a name="pxd_getVidMux" class="Sg"></a>
<a name="Get Video Input Multiplexer NX450" class="NX"></a>
<a name="Get Video Input Multiplexer   ---   pxd_getVidMux" class="Sg"></a>
<a name="Get Video Input Multiplexer   ---   pxd_getVidMux"></a>
<h6 class="Sg">Get Video Input Multiplexer   ---   pxd_getVidMux</h6>
<a name="pxd_getContrast NX451" class="NX"></a>
<a name="pxd_getContrast" class="Sg"></a>
<a name="Get Video Contrast NX452" class="NX"></a>
<a name="Get Video Contrast   ---   pxd_getContrast" class="Sg"></a>
<a name="Get Video Contrast   ---   pxd_getContrast"></a>
<h6 class="Sg">Get Video Contrast   ---   pxd_getContrast</h6>
<a name="pxd_getBrightness NX453" class="NX"></a>
<a name="pxd_getBrightness" class="Sg"></a>
<a name="Get Video Brightness NX454" class="NX"></a>
<a name="Get Video Brightness   ---   pxd_getBrightness" class="Sg"></a>
<a name="Get Video Brightness   ---   pxd_getBrightness"></a>
<h6 class="Sg">Get Video Brightness   ---   pxd_getBrightness</h6>
<a name="pxd_getHue NX455" class="NX"></a>
<a name="pxd_getHue" class="Sg"></a>
<a name="Get Video Hue NX456" class="NX"></a>
<a name="Get Video Hue   ---   pxd_getHue" class="Sg"></a>
<a name="Get Video Hue   ---   pxd_getHue"></a>
<h6 class="Sg">Get Video Hue   ---   pxd_getHue</h6>
<a name="pxd_getUGain NX457" class="NX"></a>
<a name="pxd_getUGain" class="Sg"></a>
<a name="Get Video U Saturation NX458" class="NX"></a>
<a name="Get Video U Saturation   ---   pxd_getUGain" class="Sg"></a>
<a name="Get Video U Saturation   ---   pxd_getUGain"></a>
<h6 class="Sg">Get Video U Saturation   ---   pxd_getUGain</h6>
<a name="pxd_getVGain NX459" class="NX"></a>
<a name="pxd_getVGain" class="Sg"></a>
<a name="Get Video V Saturation NX460" class="NX"></a>
<a name="Get Video V Saturation   ---   pxd_getVGain" class="Sg"></a>
<a name="Get Video V Saturation   ---   pxd_getVGain"></a>
<h6 class="Sg">Get Video V Saturation   ---   pxd_getVGain</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int     pxd_setVidMux(unitmap, inmux);
int     pxd_setContrastBrightness(unitmap, contrast, brightness);
int     pxd_setHueSaturation(unitmap, hue, Ugain, Vgain);
int     pxd_getVidMux(unitmap);
double  pxd_getContrast(unitmap);
double  pxd_getBrightness(unitmap);
double  pxd_getHue(unitmap);
double  pxd_getUGain(unitmap);
double  pxd_getVGain(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 mux;            // Multiplexer selection
double              contrast;       // Percent change of contrast, default=100
double              brightness;     // Percent change of brightness, default=0
double              hue;            // Percent change of hue, default=100
double              Ugain;          // Percent change of U Gain, default=100
double              Vgain;          // Percent change of V Gain, default=100
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
multiplexer selection, contrast, brightness,
and other A/D characteristics of
PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, and SV7 imaging boards,
are set, or the current value obtained.
</p><p>
For the PIXCI®&nbsp;SV2, SV3, SV4, SV5, or SV5L,
the
<a href="#pxd_setVidMux" class="Er">pxd_setVidMux</a>
sets the current multiplexer setting,
on the multiple units specified by
<em class="Ep">unitmap</em>,
with
<em class="Ep">inmux</em>=1
selecting the S-Video connector,
<em class="Ep">inmux</em>=2
selecting the BNC (or mini-BNC on the SV5L) connector
nearest the S-Video
connector, and
<em class="Ep">inmux</em>=3
selecting the last BNC (or mini-BNC on the SV5L) connector
(on SV3, SV4, and SV5 only).
</p><p>
For the PIXCI®&nbsp;SV5A,
the
<a href="#pxd_setVidMux" class="Er">pxd_setVidMux</a>
sets the current multiplexer setting,
on the multiple units specified by
<em class="Ep">unitmap</em>,
with
<em class="Ep">inmux</em>=1
selecting top BNC connector,
<em class="Ep">inmux</em>=2
selecting the middle BNC connector,
and
<em class="Ep">inmux</em>=3
selecting the bottom BNC connector
(nearest the DB-15 connector).
</p><p>
For the PIXCI®&nbsp;SV5B and SV7,
which have a single video input,
the
<a href="#pxd_setVidMux" class="Er">pxd_setVidMux</a>
has no effect.
</p><p>
The
<a href="#pxd_getVidMux" class="Er">pxd_getVidMux</a>
returns the current multiplexer setting,
on the single unit specified by
<em class="Ep">unitmap</em>,
with the same interpretation as used for the
<em class="Ep">inmux</em>
parameter of
<a href="#pxd_setVidMux" class="Er">pxd_setVidMux</a>.
</p><p>
The
<a href="#pxd_setContrastBrightness" class="Er">pxd_setContrastBrightness</a>
sets the A/D contrast and brightness,
on the multiple units specified by
<em class="Ep">unitmap</em>,
to
<em class="Ep">contrast</em>
and
<em class="Ep">brightness</em>.
</p><p>
For the PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L:
The
<em class="Ep">contrast</em>,
between 0.0 and 237.07,
is the percent of the default contrast (gain).
The
<em class="Ep">brightness</em>,
between -50 and +49.61, is the percent
of the maximum pixel value below or above default brightness.
</p><p>
For the PIXCI®&nbsp;SV7,
The
<em class="Ep">contrast</em>,
between 0.00 and 199.22,
is the percent of the default contrast (gain).
The
<em class="Ep">brightness</em>,
between -76.22 and +75.64 IRE units, is the
adjustment below or above default brightness.
</p><p>
The
<a href="#pxd_getContrast" class="Er">pxd_getContrast</a>
and
<a href="#pxd_getBrightness" class="Er">pxd_getBrightness</a>
return the current contrast and brightness setting,
on the single unit specified by
<em class="Ep">unitmap</em>,
with the same interpretation as used for the
<em class="Ep">contrast</em>
and
<em class="Ep">brightness</em>
parameters of
<a href="#pxd_setContrastBrightness" class="Er">pxd_setContrastBrightness</a>.
</p><p>
The
<a href="#pxd_setHueSaturation" class="Er">pxd_setHueSaturation</a>
sets the A/D hue and saturation,
on the multiple units specified by
<em class="Ep">unitmap</em>,
to
<em class="Ep">hue</em>
<em class="Ep">Ugain</em>
and
<em class="Ep">Vgain</em>.
</p><p>
For the PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, and SV5L:
The
<em class="Ep">hue</em>,
between -90.0 and 89.30,
is the color phase shift, in degrees.
The
<em class="Ep">Ugain</em>
and
<em class="Ep">Vgain</em>,
between 0.0 to 201.68,
is the percent of the default U&nbsp;gain and V&nbsp;gain, respectively.
</p><p>
For the PIXCI®&nbsp;SV7:
The
<em class="Ep">hue</em>,
between -45.0 and 45.0,
is the color phase shift, in degrees.
The
<em class="Ep">Ugain</em>
between 0.0 to 199.22,
is the percent of the default saturation.
The
<em class="Ep">Vgain</em>
is not used.
</p><p>
The
<a href="#pxd_getHue" class="Er">pxd_getHue</a>,
<a href="#pxd_getUgain" class="Er">pxd_getUgain</a>,
and
<a href="#pxd_getVgain" class="Er">pxd_getVgain</a>
return the current hue, U&nbsp;gain, and V&nbsp;gain
on the single unit specified by
<em class="Ep">unitmap</em>,
with the same interpretation as used for the
<em class="Ep">hue</em>,
<em class="Ep">Ugain</em>,
and
<em class="Ep">Vgain</em>
parameters of
<a href="#pxd_setHueSaturation" class="Er">pxd_setHueSaturation</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_getVidMux" class="Er">pxd_getVidMux</a>,
<a href="#pxd_getContrast" class="Er">pxd_getContrast</a>,
<a href="#pxd_getBrightness" class="Er">pxd_getBrightness</a>,
<a href="#pxd_getHue" class="Er">pxd_getHue</a>,
<a href="#pxd_getUGain" class="Er">pxd_getUGain</a>,
and
<a href="#pxd_getVGain" class="Er">pxd_getVGain</a>
returns values as described above, or 0
if the library is not open for use or the
wrong imaging board is in use.
</p><p>
The
<a href="#pxd_setVidMux" class="Er">pxd_setVidMux</a>,
<a href="#pxd_setContrastBrightness" class="Er">pxd_setContrastBrightness</a>,
and
<a href="#pxd_setHueSaturation" class="Er">pxd_setHueSaturation</a>
return:
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERNOOPTION</dt><dd>
Wrong imaging board.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_setImageBrightBalance NX461" class="NX"></a>
<a name="pxd_setImageBrightBalance" class="Sf"></a>
<a name="Set Bright White Balance NX462" class="NX"></a>
<a name="Set Bright White Balance   ---   pxd_setImageBrightBalance" class="Sf"></a>
<a name="Set Bright White Balance   ---   pxd_setImageBrightBalance"></a>
<h6 class="Sf">Set Bright White Balance   ---   pxd_setImageBrightBalance</h6>
<a name="pxd_setImageDarkBalance NX463" class="NX"></a>
<a name="pxd_setImageDarkBalance" class="Sg"></a>
<a name="Set Dark White Balance NX464" class="NX"></a>
<a name="Set Dark White Balance   ---   pxd_setImageDarkBalance" class="Sg"></a>
<a name="Set Dark White Balance   ---   pxd_setImageDarkBalance"></a>
<h6 class="Sg">Set Dark White Balance   ---   pxd_setImageDarkBalance</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_setImageDarkBalance(unitmap, referenceRGB[3], targetRGB[3], gamma);
int pxd_setImageBrightBalance(unitmap, referenceRGB[3], targetRGB[3], gamma);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
uint                referenceRGB[3];    // Observed pixel values, R/G/B
uint                targetRGB[3];       // Target pixel values, R/G/B
double              gamma;              // Gamma correction, or 0 to disable balancing
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_setImageDarkBalance" class="Er">pxd_setImageDarkBalance</a>
sets the dark balance subtractive correction so that pixel values of
<em class="Ep">referenceRGB</em>[0],
<em class="Ep">referenceRGB</em>[1],
and
<em class="Ep">referenceRGB</em>[2]
map to
<em class="Ep">targetRGB</em>[0],
<em class="Ep">targetRGB</em>[1],
and
<em class="Ep">targetRGB</em>[2],
respectively.
The
<a href="#pxd_setImageBrightBalance" class="Er">pxd_setImageBrightBalance</a>
sets the bright (white) balance multiplicative correction
so that pixel values of
<em class="Ep">referenceRGB</em>[0],
<em class="Ep">referenceRGB</em>[1],
and
<em class="Ep">referenceRGB</em>[2]
map to
<em class="Ep">targetRGB</em>[0],
<em class="Ep">targetRGB</em>[1],
and
<em class="Ep">targetRGB</em>[2],
respectively.
The
<em class="Ep">referenceRGB</em>
and
<em class="Ep">targetRGB</em>
should range between 0 and the maximum pixel value
(255 for 8 bit pixels).
</p><p>
The
<em class="Ep">gamma</em>
sets the non-linear gamma correction.
There is only a single gamma correction, which can be specified
with either
<a href="#pxd_setImageDarkBalance" class="Er">pxd_setImageDarkBalance</a>
or
<a href="#pxd_setImageBrightBalance" class="Er">pxd_setImageBrightBalance</a>.
A
<em class="Ep">gamma</em>=0
disables dark balancing, bright balancing, and gamma correction.
</p><p>
For PIXCI®&nbsp;A, SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, and SV7 imaging boards:
The
<a href="#pxd_setImageDarkBalance" class="Er">pxd_setImageDarkBalance</a>
and
<a href="#pxd_setImageBrightBalance" class="Er">pxd_setImageBrightBalance</a>
are not used.
</p><p>For PIXCI®&nbsp;CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1,
E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB,
ELS2, SI, SI1, SI2, and SI4 imaging boards:
The
<a href="#pxd_setImageDarkBalance" class="Er">pxd_setImageDarkBalance</a>
and
<a href="#pxd_setImageBrightBalance" class="Er">pxd_setImageBrightBalance</a>
are intended for use only
with Bayer output color cameras.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_videoFieldCount NX465" class="NX"></a>
<a name="pxd_videoFieldCount" class="Sf"></a>
<a name="Get Video Field Count NX466" class="NX"></a>
<a name="Get Video Field Count   ---   pxd_videoFieldCount" class="Sf"></a>
<a name="Get Video Field Count   ---   pxd_videoFieldCount"></a>
<h6 class="Sf">Get Video Field Count   ---   pxd_videoFieldCount</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>pxvbtime_t pxd_videoFieldCount(unitmap);
int                 unitmap;        // Unit selection bit map (1 for single unit)
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The number of elapsed vertical blanking intervals,
i.e. video fields, is returned.
Video fields are counted regardless of whether or not
the field is captured, such as with
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>
or
<a href="#pxd_goLive" class="Er">pxd_goLive</a>.
The counter's frequency is dependent upon the video format
and/or external video sources;
for NTSC or RS-170 the frequency is 60&nbsp;Hz
for CCIR or PAL the frequency is 50&nbsp;Hz.
</p><p>For PIXCI®&nbsp;SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, and SV7
imaging boards:
The count increments even when no video source is
connected to the imaging board.
For PIXCI®&nbsp;A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB,
E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2,
SI, SI1, SI2, and SI4 imaging boards:
The count increments only when a video source is connected to the
imaging board.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="1">
<a name="pxd_videoFieldsPerFrame NX467" class="NX"></a>
<a name="pxd_videoFieldsPerFrame" class="Sf"></a>
<a name="Get Video Field Characteristic NX468" class="NX"></a>
<a name="Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame" class="Sf"></a>
<a name="Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame"></a>
<h6 class="Sf">Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame</h6>
<a name="pxd_videoFieldsPerFrames NX469" class="NX"></a>
<a name="pxd_videoFieldsPerFrames" class="Sg"></a>
<a name="Get Video Field Characteristic NX470" class="NX"></a>
<a name="Get Video Field Characteristic   ---   pxd_videoFieldsPerFrames" class="Sg"></a>
<a name="Get Video Field Characteristic   ---   pxd_videoFieldsPerFrames"></a>
<h6 class="Sg">Get Video Field Characteristic   ---   pxd_videoFieldsPerFrames</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int pxd_videoFieldsPerFrame();
int pxd_videoFieldsPerFrames(unitmap);
<br>
int                 unitmap;        // Unit selection bit map (1 for single unit)
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The number of video fields in each video frame,
for the current video format, is returned.
This does not return a measured characteristic
of the current video signal, but an expectation
defined by the current video format.
</p><p>
The similar
<a href="#pxd_imageIdim" class="Er">pxd_imageIdim</a>
returns the number of stored fields within a frame buffer,
while
<a href="#pxd_videoFieldsPerFrame" class="Er">pxd_videoFieldsPerFrame</a>
returns the number of video fields within a video frame.
The former may be 1 even if the latter is 2,
such as when capturing in a
''field''
mode with each new captured field replacing the former
within the
''field buffer''.
</p><p>
If multiple imaging boards are in use
and operated at different resolutions,
the analogous
<a href="#pxd_videoFieldsPerFrames" class="Er">pxd_videoFieldsPerFrames</a>
function allows obtaining characteristics
relating to the single selected unit; the
<a href="#pxd_videoFieldsPerFrame" class="Er">pxd_videoFieldsPerFrame</a>
provides characteristics for
<em class="Ep">unitmap</em>=1.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="1">
<a name="pxd_videoFormatAsIncluded NX471" class="NX"></a>
<a name="pxd_videoFormatAsIncluded" class="Sf"></a>
<a name="Set Video Configuration as per Compiled Include NX472" class="NX"></a>
<a name="Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded" class="Sf"></a>
<a name="Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded"></a>
<h6 class="Sf">Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  pxd_videoFormatAsIncluded(rsvd);
<br>
int                 rsvd;           // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>
is a macro that allows configuring XCLIB as per a
video format configuration
(also referred to as a video state) previously exported by the XCAP program
or the XCLIB library.
Unlike use of
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
which loads a video format configuration
from a file at run-time, the
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>
changes the video format configuration
without closing the XCLIB library,
and allows use of a video format configuration
which has been compiled into the application.
</p><p>
The expected use of
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>
is:
</p><blockquote>
<pre>    {
        #include "format.fmt"
        pxd_videoFormatAsIncluded(0);
    }
</pre>
</blockquote>
where the
''format.fmt''
is a video format configuration file
(also referred to as a video state) previously exported by the XCAP program
or the XCLIB library.
<p>
The
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>
terminates any video capture currently in progress,
and may result in a change to the values reported by
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>(),
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>(),
<a href="#pxd_imageCdim" class="Er">pxd_imageCdim</a>(),
<a href="#pxd_imageBdim" class="Er">pxd_imageBdim</a>(),
<a href="#pxd_imageZdim" class="Er">pxd_imageZdim</a>(),
<a href="#pxd_imageIdim" class="Er">pxd_imageIdim</a>(),
<a href="#pxd_imageAspectRatio" class="Er">pxd_imageAspectRatio</a>()
and similar functions.
</p><p>
The XCLIB-Lite does not support this feature.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Function performed.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">Example</em>
<p>
Multiple formats can be included for selection; each must be in its own C/C++
''block''.
For example:
</p><blockquote>
<pre>    int selectformat(int format)
    {
        if (format == 0) {
            #include "format0.fmt"
            pxd_videoFormatAsIncluded(0);
        }
        if (format == 1) {
            #include "format1.fmt"
            pxd_videoFormatAsIncluded(0);
        }
        ...
    }
</pre>
</blockquote>
<hr size="1">
<a name="pxd_SILICONVIDEO_setExposureGainOffset NX473" class="NX"></a>
<a name="pxd_SILICONVIDEO_setExposureGainOffset" class="Sf"></a>
<a name="Set SILICON VIDEO Exposure, Gain, and Offset NX474" class="NX"></a>
<a name="Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxd_SILICONVIDEO_setExposureGainOffset" class="Sf"></a>
<a name="Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxd_SILICONVIDEO_setExposureGainOffset"></a>
<h6 class="Sf">Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxd_SILICONVIDEO_setExposureGainOffset</h6>
<a name="pxd_SILICONVIDEO_setExposureColorGainOffsets NX475" class="NX"></a>
<a name="pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure, Gains, and Offsets NX476" class="NX"></a>
<a name="Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxd_SILICONVIDEO_setExposureColorGainOffsets"></a>
<h6 class="Sg">Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxd_SILICONVIDEO_setExposureColorGainOffsets</h6>
<a name="pxd_SILICONVIDEO_setExposure NX477" class="NX"></a>
<a name="pxd_SILICONVIDEO_setExposure" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure NX478" class="NX"></a>
<a name="Set SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_setExposure" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_setExposure"></a>
<h6 class="Sg">Set SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_setExposure</h6>
<a name="pxd_SILICONVIDEO_getExposure NX479" class="NX"></a>
<a name="pxd_SILICONVIDEO_getExposure" class="Sg"></a>
<a name="Get SILICON VIDEO Exposure NX480" class="NX"></a>
<a name="Get SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_getExposure" class="Sg"></a>
<a name="Get SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_getExposure"></a>
<h6 class="Sg">Get SILICON VIDEO Exposure   ---   pxd_SILICONVIDEO_getExposure</h6>
<a name="pxd_SILICONVIDEO_getGainA NX481" class="NX"></a>
<a name="pxd_SILICONVIDEO_getGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Gain A NX482" class="NX"></a>
<a name="Get SILICON VIDEO Gain A   ---   pxd_SILICONVIDEO_getGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Gain A   ---   pxd_SILICONVIDEO_getGainA"></a>
<h6 class="Sg">Get SILICON VIDEO Gain A   ---   pxd_SILICONVIDEO_getGainA</h6>
<a name="pxd_SILICONVIDEO_getGainB NX483" class="NX"></a>
<a name="pxd_SILICONVIDEO_getGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Gain B NX484" class="NX"></a>
<a name="Get SILICON VIDEO Gain B   ---   pxd_SILICONVIDEO_getGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Gain B   ---   pxd_SILICONVIDEO_getGainB"></a>
<h6 class="Sg">Get SILICON VIDEO Gain B   ---   pxd_SILICONVIDEO_getGainB</h6>
<a name="pxd_SILICONVIDEO_getGainsA NX485" class="NX"></a>
<a name="pxd_SILICONVIDEO_getGainsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains A NX486" class="NX"></a>
<a name="Get SILICON VIDEO Color Gains A   ---   pxd_SILICONVIDEO_getGainsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains A   ---   pxd_SILICONVIDEO_getGainsA"></a>
<h6 class="Sg">Get SILICON VIDEO Color Gains A   ---   pxd_SILICONVIDEO_getGainsA</h6>
<a name="pxd_SILICONVIDEO_getGainsB NX487" class="NX"></a>
<a name="pxd_SILICONVIDEO_getGainsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains B NX488" class="NX"></a>
<a name="Get SILICON VIDEO Color Gains B   ---   pxd_SILICONVIDEO_getGainsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains B   ---   pxd_SILICONVIDEO_getGainsB"></a>
<h6 class="Sg">Get SILICON VIDEO Color Gains B   ---   pxd_SILICONVIDEO_getGainsB</h6>
<a name="pxd_SILICONVIDEO_getOffsetsA NX489" class="NX"></a>
<a name="pxd_SILICONVIDEO_getOffsetsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets A NX490" class="NX"></a>
<a name="Get SILICON VIDEO Color Offsets A   ---   pxd_SILICONVIDEO_getOffsetsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets A   ---   pxd_SILICONVIDEO_getOffsetsA"></a>
<h6 class="Sg">Get SILICON VIDEO Color Offsets A   ---   pxd_SILICONVIDEO_getOffsetsA</h6>
<a name="pxd_SILICONVIDEO_getOffsetsB NX491" class="NX"></a>
<a name="pxd_SILICONVIDEO_getOffsetsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets B NX492" class="NX"></a>
<a name="Get SILICON VIDEO Color Offsets B   ---   pxd_SILICONVIDEO_getOffsetsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets B   ---   pxd_SILICONVIDEO_getOffsetsB"></a>
<h6 class="Sg">Get SILICON VIDEO Color Offsets B   ---   pxd_SILICONVIDEO_getOffsetsB</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int    pxd_SILICONVIDEO_setExposureGainOffset(unitmap,rsvd,exposure,gainA,offsetA,
                                              gainB,offsetB);
int    pxd_SILICONVIDEO_setExposureColorGainOffsets(unitmap,rsvd,exposure,
                                              gainsA,gainsB,offsetsA,offsetsB);
double pxd_SILICONVIDEO_getExposure(unitmap);
double pxd_SILICONVIDEO_getGainA(unitmap);
double pxd_SILICONVIDEO_getGainB(unitmap);
int    pxd_SILICONVIDEO_getGainsA(unitmap,gainsA);
int    pxd_SILICONVIDEO_getGainsB(unitmap,gainsB);
int    pxd_SILICONVIDEO_getOffsetsA(unitmap,offsetsA[4]);
int    pxd_SILICONVIDEO_getOffsetsB(unitmap,offsetsB[4]);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              exposure;           // Exposure period, in milliseconds
double              gainA;              // Pre-gain, in dB.
double              gainB;              // Post-gain, in dB.
double              offsetA;            // Pre-offset, scaled to 1.0 for max-pixel value
double              offsetB;            // Post-offset, scaled to 1.0 for max pixel value
double[4]           gainsA;             // Color specific A-gains, Gb/B/R/Gr, in dB, or NULL
double[4]           gainsB;             // Color specific B-gains, Gb/B/R/Gr, in dB, or NULL
double[4]           offsetsA;           // Color specific A-offsets, Gb/B/R/Gr,
                                        // scaled to 1.0 for max pixel value, or NULL
double[4]           offsetsB;           // Color specific B-offsets, Gb/B/R/Gr,
                                        // scaled to 1.0 for max pixel value, or NULL
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO® NX493" class="NX"></a>
The
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
and
<a href="#pxd_SILICONVIDEO_setExposure" class="Er">pxd_SILICONVIDEO_setExposure</a>,
sets the exposure (shutter) period, gain and
offsets (black level) of
SILICON VIDEO® 1281M,
SILICON VIDEO® 1281C,
SILICON VIDEO® 1310,
SILICON VIDEO® 1310C,
SILICON VIDEO® 2112,
SILICON VIDEO® 2112C,
SILICON VIDEO® 5C10,
SILICON VIDEO® 5M10,
SILICON VIDEO® 642M,
SILICON VIDEO® 642C,
SILICON VIDEO® 643M,
SILICON VIDEO® 643C,
SILICON VIDEO® 9C10,
SILICON VIDEO® 9M001,
SILICON VIDEO® 9M001C,
SILICON VIDEO® 9T001C,
SILICON VIDEO® WGA-C,
and
SILICON VIDEO® WGA-M
cameras connected to PIXCI® D2X, D2X1, SI, SI1, SI2, and SI4 imaging boards.
</p><p>
The camera's exposure (shutter) period
is set to
<em class="Ep">exposure</em>
milliseconds.
The allowable values are dependent on the camera's
current operating mode, such as the pixel clock frequency,
AOI width and height, and subsampling.
</p><p>
The camera's per-color A-gain for green-next-to-blue, blue, red, and
green-next-to-red
is set to
<em class="Ep">gainsA[0]</em>,
<em class="Ep">gainsA[1]</em>,
<em class="Ep">gainsA[2]</em>,
and
<em class="Ep">gainsA[3]</em>
dB, respectively.
For cameras that do not implement per-color A-gain,
the gain is set to the average of
<em class="Ep">gainsA[0]</em>,
<em class="Ep">gainsA[1]</em>,
<em class="Ep">gainsA[2]</em>,
and
<em class="Ep">gainsA[3]</em>.
For cameras that only provide color A-gain for red, green, and blue
the gains are set to
<em class="Ep">gainsA[2]</em>,
<em class="Ep">gainsA[1]</em>,
and the average of
<em class="Ep">gainsA[0]</em>
and
<em class="Ep">gainsA[3]</em>,
respectively.
Alternately,
the camera's A-gain(s), whether the camera provides per-color gains
or not,
are each set to
<em class="Ep">gainA</em>
dB.
</p><p>
The camera's per-color, or non-per-color B-gain
is set to
<em class="Ep">gainsB</em>
and/or
<em class="Ep">gainB</em>
dB,
following the same conversion rules for per-color vs non-per-color cameras
as above.
</p><p>
The camera's per-color, or non-per-color A-offset
(black level)
is set to
<em class="Ep">offsetsA</em>
and/or
<em class="Ep">offsetA</em>,
following the same conversion rules for per-color vs non-per-color cameras
as above.
The camera's per-color, or non-per-color B-offset
(black level)
is set to
<em class="Ep">offsetsB</em>
and/or
<em class="Ep">offsetB</em>,
following the same conversion rules for per-color vs non-per-color cameras
as above.
The
<em class="Ep">offsetsA</em>,
<em class="Ep">offsetA</em>,
<em class="Ep">offsetsB</em>,
and
<em class="Ep">offsetB</em>
are scaled such that an offset of 1.0 or -1.0
corresponds to the maximum pixel value or its negative.
However, various camera models do not necessarily provide
the full range of offsets.
Also, for cameras that implement an analog offset,
the correspondance to maximum pixel value is only approximate.
</p><p>
Each of the
<em class="Ep">gainsA</em>,
<em class="Ep">gainsB</em>,
<em class="Ep">offsetsA</em>,
and
<em class="Ep">offsetsB</em>
may be NULL, the camera's corresponding gain or offset
is unchanged.
</p><blockquote>
<pre>    pxd_SILICONVIDEO_setExposureColorGainOffsets(..., 0, exposure,
                                                 NULL, NULL, NULL, NULL);
</pre>
</blockquote>
is a convenient method of changing only the camera's exposure.
<p>
Some cameras may not provide A-gain, B-gain, A-offset, or B-offset;
the corresponding values are ignored.
Any invalid exposure, gain, or offset value is corrected to the nearest valid value.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getExposure" class="Er">pxd_SILICONVIDEO_getExposure</a>
returns the current exposure setting,
in milliseconds.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getGainA" class="Er">pxd_SILICONVIDEO_getGainA</a>
returns the current A-gain, in dB.
For cameras with per-color A-gain,
the average value is returned.
The
<a href="#pxd_SILICONVIDEO_getGainsA" class="Er">pxd_SILICONVIDEO_getGainsA</a>
''returns''
the current per-color A-gain, in dB
in
<em class="Ep">gainsA</em>.
For cameras without per-color A-gain,
the four elements of
<em class="Ep">gainsA</em>
is set to the gain.
For cameras with per-color red, green, and blue
gain, the
<em class="Ep">gainsA[0]</em>
and
<em class="Ep">gainsA[3]</em>
are both set to the green gain.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getGainB" class="Er">pxd_SILICONVIDEO_getGainB</a>
returns the current B-gain, in dB;
the
<a href="#pxd_SILICONVIDEO_getGainsB" class="Er">pxd_SILICONVIDEO_getGainsB</a>
''returns''
the current per-color B-gain, in dB
in
<em class="Ep">gainsB</em>;
following the same conversion rules for per-color vs non-per-color cameras
as above.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getOffsetA" class="Er">pxd_SILICONVIDEO_getOffsetA</a>
returns the current A-offset;
the
<a href="#pxd_SILICONVIDEO_getOffsetsA" class="Er">pxd_SILICONVIDEO_getOffsetsA</a>
''returns''
the current per-color A-offset,
in
<em class="Ep">offsetsA</em>;
the
<a href="#pxd_SILICONVIDEO_getOffsetB" class="Er">pxd_SILICONVIDEO_getOffsetB</a>
returns the current B-offset;
the
<a href="#pxd_SILICONVIDEO_getOffsetsB" class="Er">pxd_SILICONVIDEO_getOffsetsB</a>
''returns''
the current per-color B-offset,
in
<em class="Ep">offsetsB</em>;
following the same conversion rules for per-color vs non-per-color cameras
as above,
all scaled such that an offset of 1.0 or -1.0
corresponds to the maximum pixel value or its negative.
</p><p>
Some cameras may not provide A-gain, B-gain, A-offset, and/or B-offset;
a value of 0 is returned.
</p><p>
Note: The
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
performs partial, quick initialization of XCLIB;
initialization for the
<cite class="Ec">pxd_SILICONVIDEO_</cite>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<cite class="Ec">pxd_SILICONVIDEO_set</cite>
or
<cite class="Ec">pxd_SILICONVIDEO_get</cite>
function once
before entering the application's time critical phase.
</p><p>
<br>
<b class="Hv">Camera Specific.</b>
For
SILICON VIDEO® 1281M
and
SILICON VIDEO® 1281C:
The camera provides a single A-gain
in the range of 3.5 to 31.9 dB.
The camera provides a single A-offset
in the range of 0 to .24.
</p><p>
For
SILICON VIDEO® 1310
and
SILICON VIDEO® 1310C:
The camera provides a single A-gain
in the range of -23.2 to 17.50 dB
and
green-next-to-blue, blue, red, and green-next-to-red
B-gain in the range of -23.2 to 8.8 dB.
The camera provides a single A-offset
in the range of -.11 to +11.
Different per-color gains
can be set for the SILICON VIDEO® 1310
(i.e. monochrome) camera -  the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, the gains are identical for monochrome cameras.
</p><p>
For
SILICON VIDEO® 2112
and
SILICON VIDEO® 2112C:
The camera provides red, green, and blue
A-gain each in the range of 0.0 to 14.0 dB.
Different per-color gains
can be set for the SILICON VIDEO® 2112
(i.e. monochrome) camera -  the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, the gains are identical for monochrome cameras.
</p><p>
For
SILICON VIDEO® 5C10
and
SILICON VIDEO® 5M10:
The camera provides
green-next-to-blue, blue, red, and green-next-to-red
integrated analog/digital A-gain in the range of 0 to 42.1 dB.
Different per-color gains
can be set for the SILICON VIDEO® 5M10
(i.e. monochrome) camera -  the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, the gains are identical for monochrome cameras.
</p><p>
For
SILICON VIDEO® 642M
and
SILICON VIDEO® 642C:
The camera provides
green-next-to-blue, blue, red, and green-next-to-red
A-gain in the range of -6.0 to 19.1 dB in low
gain range mode, or 0 to 25.1 dB in high gain range mode.
Different per-color gains
can be set for the SILICON VIDEO® 642M
(i.e. monochrome) camera -  the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, the gains are identical for monochrome cameras.
</p><p>
For
SILICON VIDEO® 643M
and
SILICON VIDEO® 643C:
The camera provides a single A-gain
in the range of 0 to 23.7 dB.
The camera provides a single A-offset
in the range of 0 to 2.5.
</p><p>
For
SILICON VIDEO® 9C10:
The camera provides
green-next-to-blue, blue, red, and green-next-to-red
analog A-gain in the range of 0 to 27.5 dB.
The camera provides a single digital B-gain
in the range of 0 to 16.9 dB.
</p><p>
For
SILICON VIDEO® 9M001
and
SILICON VIDEO® 9M001C:
The camera provides
green-next-to-blue, blue, red, and green-next-to-red
analog A-gain in the range of 0 to 23.5 dB.
Different per-color gains
can be set for the SILICON VIDEO® 9M001
(i.e. monochrome) camera -  the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, the gains are identical for monochrome cameras.
</p><p>
For
SILICON VIDEO® 9T001C:
The camera provides
green-next-to-blue, blue, red, and green-next-to-red
integrated analog/digital A-gain in the range of 0 to 42.1 dB.
</p><p>
For
SILICON VIDEO® WGA-C
and
SILICON VIDEO® WGA-M:
The camera provides
a single analog A-gain in the range of 0 to 12.0 dB.
The camera provides a single digital B-gain
in the range of 0 to 11.5 dB.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_SILICONVIDEO_getGainA" class="Er">pxd_SILICONVIDEO_getGainA</a>,
<a href="#pxd_SILICONVIDEO_getGainB" class="Er">pxd_SILICONVIDEO_getGainB</a>,
<a href="#pxd_SILICONVIDEO_getOffsetA" class="Er">pxd_SILICONVIDEO_getOffsetA</a>,
and
<a href="#pxd_SILICONVIDEO_getOffsetB" class="Er">pxd_SILICONVIDEO_getOffsetB</a>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
</p><p>
The remaining functions return:
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_SILICONVIDEO_setResolutionAndTiming NX494" class="NX"></a>
<a name="pxd_SILICONVIDEO_setResolutionAndTiming" class="Sf"></a>
<a name="Set SILICON VIDEO Resolution and Timing NX495" class="NX"></a>
<a name="Set SILICON VIDEO Resolution and Timing   ---   pxd_SILICONVIDEO_setResolutionAndTiming" class="Sf"></a>
<a name="Set SILICON VIDEO Resolution and Timing   ---   pxd_SILICONVIDEO_setResolutionAndTiming"></a>
<h6 class="Sf">Set SILICON VIDEO Resolution and Timing   ---   pxd_SILICONVIDEO_setResolutionAndTiming</h6>
<a name="pxd_SILICONVIDEO_getSubsample NX496" class="NX"></a>
<a name="pxd_SILICONVIDEO_getSubsample" class="Sg"></a>
<a name="Get SILICON VIDEO Subsample NX497" class="NX"></a>
<a name="Get SILICON VIDEO Subsample   ---   pxd_SILICONVIDEO_getSubsample" class="Sg"></a>
<a name="Get SILICON VIDEO Subsample   ---   pxd_SILICONVIDEO_getSubsample"></a>
<h6 class="Sg">Get SILICON VIDEO Subsample   ---   pxd_SILICONVIDEO_getSubsample</h6>
<a name="pxd_SILICONVIDEO_getAoiLeft NX498" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAoiLeft" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Left Edge NX499" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Left Edge   ---   pxd_SILICONVIDEO_getAoiLeft" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Left Edge   ---   pxd_SILICONVIDEO_getAoiLeft"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Left Edge   ---   pxd_SILICONVIDEO_getAoiLeft</h6>
<a name="pxd_SILICONVIDEO_getAoiTop NX500" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Top Edge NX501" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Top Edge   ---   pxd_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Top Edge   ---   pxd_SILICONVIDEO_getAoiTop"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Top Edge   ---   pxd_SILICONVIDEO_getAoiTop</h6>
<a name="pxd_SILICONVIDEO_getAoiTop NX502" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Width NX503" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Width   ---   pxd_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Width   ---   pxd_SILICONVIDEO_getAoiTop"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Width   ---   pxd_SILICONVIDEO_getAoiTop</h6>
<a name="pxd_SILICONVIDEO_getAoiTop NX504" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Height NX505" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Height   ---   pxd_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Height   ---   pxd_SILICONVIDEO_getAoiTop"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Height   ---   pxd_SILICONVIDEO_getAoiTop</h6>
<a name="pxd_SILICONVIDEO_getScanDirection NX506" class="NX"></a>
<a name="pxd_SILICONVIDEO_getScanDirection" class="Sg"></a>
<a name="Get SILICON VIDEO Scan Direction NX507" class="NX"></a>
<a name="Get SILICON VIDEO Scan Direction   ---   pxd_SILICONVIDEO_getScanDirection" class="Sg"></a>
<a name="Get SILICON VIDEO Scan Direction   ---   pxd_SILICONVIDEO_getScanDirection"></a>
<h6 class="Sg">Get SILICON VIDEO Scan Direction   ---   pxd_SILICONVIDEO_getScanDirection</h6>
<a name="pxd_SILICONVIDEO_getPixelClock NX508" class="NX"></a>
<a name="pxd_SILICONVIDEO_getPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Pixel Clock Frequency NX509" class="NX"></a>
<a name="Get SILICON VIDEO Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getPixelClock"></a>
<h6 class="Sg">Get SILICON VIDEO Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getPixelClock</h6>
<a name="pxd_SILICONVIDEO_getFramePeriod NX510" class="NX"></a>
<a name="pxd_SILICONVIDEO_getFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Frame Period NX511" class="NX"></a>
<a name="Get SILICON VIDEO Frame Period   ---   pxd_SILICONVIDEO_getFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Frame Period   ---   pxd_SILICONVIDEO_getFramePeriod"></a>
<h6 class="Sg">Get SILICON VIDEO Frame Period   ---   pxd_SILICONVIDEO_getFramePeriod</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int     pxd_SILICONVIDEO_setResolutionAndTiming(unitmap,rsvd1,subsample,aoileft,aoitop,aoiwidth,
                                    aoiheight,scandirection,bitdepth,rsvd3,rsvd4,pixelClkFreq,
                                    framePeriod,rsvd5,rsvd6,rsvd7);
int     pxd_SILICONVIDEO_getSubsample(unitmap);
int     pxd_SILICONVIDEO_getAoiLeft(unitmap);
int     pxd_SILICONVIDEO_getAoiTop(unitmap);
int     pxd_SILICONVIDEO_getAoiWidth(unitmap);
int     pxd_SILICONVIDEO_getAoiHeight(unitmap);
int     pxd_SILICONVIDEO_getScanDirection(unitmap);
double  pxd_SILICONVIDEO_getPixelClock(unitmap);
double  pxd_SILICONVIDEO_getFramePeriod(unitmap);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd1;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
int                 rsvd4;              // Reserved, should be 0
double              rsvd5;              // Reserved, should be 0
double              rsvd6;              // Reserved, should be 0
double              rsvd7;              // Reserved, should be 0
int                 subsample;          // Subsample/decimation
                                        // High byte X, Low byte Y, 0x0101 for none
int                 aoileft;            // Left edge of partial scan AOI
int                 aoitop;             // Top edge of partial scan AOI
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
                                        // aoi* are in reference to sensor
                                        // and independent of subsampling
int                 scandirection;      // ('L'&lt;&lt;8)|'T': Left-Right/Top-Bottom (default)
                                        // ('L'&lt;&lt;8)|'B': Left-Right/Bottom-Top
                                        // ('R'&lt;&lt;8)|'T': Right-Left/Top-Bottom
                                        // ('R'&lt;&lt;8)|'B': Right-Left/Bottom-Top
int                 bitdepth;           // bits per pixel value component
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              framePeriod;        // Frame period, in msec.
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO® NX512" class="NX"></a>
The
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>
sets the pixel clock frequency, frame period (in free-run modes),
pixel bit depth, scan direction, partial scan AOI, and subsampling/decimation
of
SILICON VIDEO® 1281M,
SILICON VIDEO® 1281C,
SILICON VIDEO® 1310,
SILICON VIDEO® 1310C,
SILICON VIDEO® 2112,
SILICON VIDEO® 2112C,
SILICON VIDEO® 5C10,
SILICON VIDEO® 5M10,
SILICON VIDEO® 642M,
SILICON VIDEO® 642C,
SILICON VIDEO® 643M,
SILICON VIDEO® 643C,
SILICON VIDEO® 9C10,
SILICON VIDEO® 9M001,
SILICON VIDEO® 9M001C,
SILICON VIDEO® 9T001C,
SILICON VIDEO® WGA-C,
and
SILICON VIDEO® WGA-M
cameras connected to PIXCI® D2X, D2X1, SI, SI1, SI2, and SI4 imaging boards.
</p><p>
The
<em class="Ep">subsample</em>
selects readout subsampling of the sensor.
If
<em class="Ep">subsample</em>=0x0101,
subsampling is disabled,
if
<em class="Ep">subsample</em>=0x0202,
the readout and captured image consists of every 2'nd pixel,
both horizontally and vertically,
if
<em class="Ep">subsample</em>=0x0404,
the readout and captured image consists of every 4'th pixel,
both horizontally and vertically.
If
<em class="Ep">subsample</em>=V+H*256,
the readout and captured image consists of every H'th pixel
horizontally and V'th pixel vertically.
On some cameras, the
<em class="Ep">subsample</em>
may select bin-averaging of W×H groups of pixels, or
bin-summing of W×H groups of pixels;
in all cases, the common effect of
<em class="Ep">subsample</em>
is to reduce the resulting image resolution by a factor of H
horizontally and V vertically.
</p><p>
The
<em class="Ep">aoileft</em>,
<em class="Ep">aoitop</em>,
<em class="Ep">aoiwidth</em>,
and
<em class="Ep">aoiheight</em>
select partial scan readout of the sensor, selecting
the coordinates of the left edge and top edge of the readout AOI,
and width and height of the readout AOI.
These parameters are always relative to the sensor's full resolution,
and are not to be scaled due to use of
<em class="Ep">subsample</em>.
</p><p>
The
<em class="Ep">scandirection</em>
selects readout scan direction.
If
<em class="Ep">scandirection</em>=('L'&lt;&lt;8)|'T',
the readout is left to right, top to bottom
and is the normal default.
If
<em class="Ep">scandirection</em>=('L'&lt;&lt;8)|'B',
the readout is left to right, bottom to top.
If
<em class="Ep">scandirection</em>=('R'&lt;&lt;8)|'T',
the readout is right to left, top to bottom;
if
<em class="Ep">scandirection</em>=('R'&lt;&lt;8)|'B',
the readout is right to left, bottom to top.
</p><p>
The
<em class="Ep">bitdepth</em>
selects the bit depth of each pixel value component;
i.e. for color pixels, it is the bit depth of each color component.
</p><p>
The
<em class="Ep">pixelClkFreq</em>
specifies the sensor's pixel clock frequency, in MHz.
Lower frequencies provide for longer exposures, but slower
frame rates.
Higher frequencies provide higher frame rates, but shorter
exposures and typically more fixed pattern noise.
</p><p>
The
<em class="Ep">framePeriod</em>
specifies the sensor's frame period, or inverse of frame rate,
in free-run mode, in milliseconds.
A longer frame period allows for longer exposures.
</p><p>
Some cameras may not provide subsampling, partial scan, scan direction,
selectable bit depth, selectable pixel clock, or selectable frame period;
the corresponding values are ignored.
Any invalid values are corrected to the nearest valid value.
In particular,
<em class="Ep">framePeriod</em>=0
can be used to specify the minimum frame period (maximum frame
rate) obtainable with the specified
<em class="Ep">subsample</em>,
<em class="Ep">aoileft</em>,
<em class="Ep">aoitop</em>,
<em class="Ep">aoiwidth</em>,
<em class="Ep">aoiheight</em>,
<em class="Ep">bitdepth</em>,
and
<em class="Ep">pixelClkFreq</em>.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getSubsample" class="Er">pxd_SILICONVIDEO_getSubsample</a>
returns the current subsample setting, coded as described above.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getAoiLeft" class="Er">pxd_SILICONVIDEO_getAoiLeft</a>
<a href="#pxd_SILICONVIDEO_getAoiTop" class="Er">pxd_SILICONVIDEO_getAoiTop</a>
<a href="#pxd_SILICONVIDEO_getAoiWidth" class="Er">pxd_SILICONVIDEO_getAoiWidth</a>
<a href="#pxd_SILICONVIDEO_getAoiHeight" class="Er">pxd_SILICONVIDEO_getAoiHeight</a>
return the current partial scan AOI left and top edges, and
width and height, respectively.
These parameters are always relative to the sensor's full resolution,
and are not scaled due to use of
<em class="Ep">subsample</em>.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getScanDirection" class="Er">pxd_SILICONVIDEO_getScanDirection</a>
returns the current scan direction setting, coded as described above.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getPixelClock" class="Er">pxd_SILICONVIDEO_getPixelClock</a>
returns the current pixel clock frequency, as described above.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getFramePeriod" class="Er">pxd_SILICONVIDEO_getFramePeriod</a>
returns the current frame period, or inverse of frame rate, as described above.
</p><p>
<br>
<b class="Hv">Camera Specific.</b>
For
SILICON VIDEO® 1281M
and
SILICON VIDEO® 1281C:
The camera does not provide
subsampling, selectable scan direction,
or selectable bit depth.
The allowable frame period depends on
the pixel clock frequency, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® 1310
and
SILICON VIDEO® 1310C:
The camera supports subsampling ×1, ×2, ×4, and ×8
both horizontally and vertically, in all combinations.
The camera supports all four scan directions.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® 2112
and
SILICON VIDEO® 2112C:
The camera supports subsampling ×1, ×2, and ×4
both horizontally and vertically, in all combinations.
The camera supports all four scan directions.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, and AOI height.
</p><p>
For
SILICON VIDEO® 5C10
and
SILICON VIDEO® 5M10:
The camera supports subsampling ×1, ×2, and ×4
horizontally and subsampling ×1, ×2, ×4, and ×8
vertically, in all combinations.
The camera supports all four scan directions.
The camera supports 8 and 12 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® 642M
and
SILICON VIDEO® 642C:
The camera does not provide
subsampling or selectable scan direction.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency and AOI height.
</p><p>
For
SILICON VIDEO® 643M
and
SILICON VIDEO® 643C:
The camera does not provide
subsampling or selectable scan direction.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® 9C10:
The camera supports subsampling ×1, ×2, and ×4
horizontally and subsampling ×1, ×2, ×4, ×8, ×16, and ×32
vertically, in all combinations.
The camera supports all four scan directions.
The camera supports 8 and 12 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® 9M001
and
SILICON VIDEO® 9M001C:
The camera supports subsampling ×1, ×2, ×4, and ×8
both horizontally and vertically, in all combinations.
The camera supports
('L'&lt;&lt;8)|'T' and ('L'&lt;&lt;8)|'B'
scan directions.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® 9T001C:
The camera supports subsampling ×1, ×2, ×4, and ×8
both horizontally and vertically, in all combinations.
The camera does not provide
selectable scan direction.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, AOI height, and AOI width.
</p><p>
For
SILICON VIDEO® WGA-C
and
SILICON VIDEO® WGA-M:
The camera supports subsampling ×1, ×2, and ×4
vertically.
The camera supports all four scan directions.
The camera supports 8 and 10 bit depths.
The allowable frame period depends on
the pixel clock frequency, subsampling, AOI height, and AOI width.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_SILICONVIDEO_getSubsample" class="Er">pxd_SILICONVIDEO_getSubsample</a>,
<a href="#pxd_SILICONVIDEO_getAoiLeft" class="Er">pxd_SILICONVIDEO_getAoiLeft</a>,
<a href="#pxd_SILICONVIDEO_getAoiTop" class="Er">pxd_SILICONVIDEO_getAoiTop</a>,
<a href="#pxd_SILICONVIDEO_getAoiTop" class="Er">pxd_SILICONVIDEO_getAoiTop</a>,
<a href="#pxd_SILICONVIDEO_getAoiTop" class="Er">pxd_SILICONVIDEO_getAoiTop</a>,
<a href="#pxd_SILICONVIDEO_getScanDirection" class="Er">pxd_SILICONVIDEO_getScanDirection</a>,
<a href="#pxd_SILICONVIDEO_getPixelClock" class="Er">pxd_SILICONVIDEO_getPixelClock</a>,
and
<a href="#pxd_SILICONVIDEO_getFramePeriod" class="Er">pxd_SILICONVIDEO_getFramePeriod</a>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
</p><p>
The remaining functions return:
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_SILICONVIDEO_setVideoAndTriggerMode NX513" class="NX"></a>
<a name="pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Sf"></a>
<a name="Set SILICON VIDEO Video And Trigger Modes NX514" class="NX"></a>
<a name="Set SILICON VIDEO Video And Trigger Modes   ---   pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Sf"></a>
<a name="Set SILICON VIDEO Video And Trigger Modes   ---   pxd_SILICONVIDEO_setVideoAndTriggerMode"></a>
<h6 class="Sf">Set SILICON VIDEO Video And Trigger Modes   ---   pxd_SILICONVIDEO_setVideoAndTriggerMode</h6>
<a name="pxd_SILICONVIDEO_setCtrlRates NX515" class="NX"></a>
<a name="pxd_SILICONVIDEO_setCtrlRates" class="Sg"></a>
<a name="Set SILICON VIDEO Controlled Rates NX516" class="NX"></a>
<a name="Set SILICON VIDEO Controlled Rates   ---   pxd_SILICONVIDEO_setCtrlRates" class="Sg"></a>
<a name="Set SILICON VIDEO Controlled Rates   ---   pxd_SILICONVIDEO_setCtrlRates"></a>
<h6 class="Sg">Set SILICON VIDEO Controlled Rates   ---   pxd_SILICONVIDEO_setCtrlRates</h6>
<a name="pxd_SILICONVIDEO_getVideoMode NX517" class="NX"></a>
<a name="pxd_SILICONVIDEO_getVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Video Mode NX518" class="NX"></a>
<a name="Get SILICON VIDEO Video Mode   ---   pxd_SILICONVIDEO_getVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Video Mode   ---   pxd_SILICONVIDEO_getVideoMode"></a>
<h6 class="Sg">Get SILICON VIDEO Video Mode   ---   pxd_SILICONVIDEO_getVideoMode</h6>
<a name="pxd_SILICONVIDEO_getCtrlVideoMode NX519" class="NX"></a>
<a name="pxd_SILICONVIDEO_getCtrlVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Video Mode NX520" class="NX"></a>
<a name="Get SILICON VIDEO Controlled Video Mode   ---   pxd_SILICONVIDEO_getCtrlVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Video Mode   ---   pxd_SILICONVIDEO_getCtrlVideoMode"></a>
<h6 class="Sg">Get SILICON VIDEO Controlled Video Mode   ---   pxd_SILICONVIDEO_getCtrlVideoMode</h6>
<a name="pxd_SILICONVIDEO_getCtrlTriggerMode NX521" class="NX"></a>
<a name="pxd_SILICONVIDEO_getCtrlTriggerMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Trigger Mode NX522" class="NX"></a>
<a name="Get SILICON VIDEO Controlled Trigger Mode   ---   pxd_SILICONVIDEO_getCtrlTriggerMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Trigger Mode   ---   pxd_SILICONVIDEO_getCtrlTriggerMode"></a>
<h6 class="Sg">Get SILICON VIDEO Controlled Trigger Mode   ---   pxd_SILICONVIDEO_getCtrlTriggerMode</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int    pxd_SILICONVIDEO_setVideoAndTriggerMode(unitmap,rsvd,videomode,controlledmode,
                                        controlledtrigger,strobemode,rsvd2,rsvd3,rsvd4);
int    pxd_SILICONVIDEO_setCtrlRates(unitmap,rsvd,rsvd11,framerate,rsvd12,rsvd13,rsvd14);
int    pxd_SILICONVIDEO_getVideoMode(unitmap);
int    pxd_SILICONVIDEO_getCtrlVideoMode(unitmap);
int    pxd_SILICONVIDEO_getCtrlTriggerMode(unitmap);
double pxd_SILICONVIDEO_getCtrlFrameRate(unitmap);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
int                 rsvd4;              // Reserved, should be 0
double              rsvd11;             // Reserved, should be 0
double              rsvd12;             // Reserved, should be 0
double              rsvd13;             // Reserved, should be 0
double              rsvd14;             // Reserved, should be 0
int                 videomode;          // Camera video mode:
                                        //  'f':            free-run,
                                        //  'c':            controlled/triggered
                                        //  'c'|('g'&lt;&lt;8)    controlled w. global reset
int                 controlledmode;     // Controlled mode: 'c': continuous, 's': singleshot
int                 triggermode;        // Controlled trigger: 'n': none, '+': rising, '-': falling
double              framerate;          // Controlled frame rate, Hz.
                                        // Or singleshot min. retrigger period, 1/Hz.
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>
sets the video and trigger modes of the
SILICON VIDEO® 1281M,
SILICON VIDEO® 1281C,
SILICON VIDEO® 1310,
SILICON VIDEO® 1310C,
SILICON VIDEO® 2112,
SILICON VIDEO® 2112C,
SILICON VIDEO® 5C10,
SILICON VIDEO® 5M10,
SILICON VIDEO® 642M,
SILICON VIDEO® 642C,
SILICON VIDEO® 643M,
SILICON VIDEO® 643C,
SILICON VIDEO® 9C10,
SILICON VIDEO® 9M001,
SILICON VIDEO® 9M001C,
SILICON VIDEO® 9T001C,
SILICON VIDEO® WGA-C,
and
SILICON VIDEO® WGA-M
cameras connected to PIXCI® D2X, D2X1, SI, SI1, SI2, and SI4 imaging boards.
Within controlled/trigger mode(s),
the
<a href="#pxd_SILICONVIDEO_setCtrlRates" class="Er">pxd_SILICONVIDEO_setCtrlRates</a>
sets the controlled frame rate.
</p><p>
If
<em class="Ep">videomode</em>='f',
the camera is free-running;
the
<em class="Ep">controlledmode</em>,
<em class="Ep">triggermode</em>,
and
<em class="Ep">framerate</em>
parameters have no effect.
</p><p>
If
<em class="Ep">videomode</em>='c',
or
<em class="Ep">videomode</em>='c'|('g'&lt;&lt;8),
initiation of each video field is controlled
via the PIXCI® imaging board.
If
<em class="Ep">controlledmode</em>='c'
and
<em class="Ep">triggermode</em>='n'
video fields are continuously and automatically triggered.
The
<em class="Ep">framerate</em>
specifies the field repetition rate.
If
<em class="Ep">controlledmode</em>='s'
and
<em class="Ep">triggermode</em>='n',
video fields are triggered only upon demand;
video fields are triggered by
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>
or
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
the trigger signal is not used.
</p><p>
If
<em class="Ep">controlledmode</em>='s'
and
<em class="Ep">triggermode</em>='+'
or
<em class="Ep">triggermode</em>='-',
video fields are triggered only upon demand;
video fields are triggered by a rising or falling,
respectively, edge of the trigger signal;
the
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>
or
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>
must be invoked before the hardware trigger
so as to
''arm''
the imaging board.
The
<em class="Ep">framerate</em>
specifies the inverse of the minimum retrigger period;
after a trigger, any additional trigger signals arriving within the
minimum retrigger period are ignored.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getVideoMode" class="Er">pxd_SILICONVIDEO_getVideoMode</a>,
<a href="#pxd_SILICONVIDEO_getCtrlVideoMode" class="Er">pxd_SILICONVIDEO_getCtrlVideoMode</a>,
and
<a href="#pxd_SILICONVIDEO_getCtrlTriggerMode" class="Er">pxd_SILICONVIDEO_getCtrlTriggerMode</a>,
returns the camera's video mode, the controlled video mode,
and the controlled trigger mode, respectively, coded as described above.
The
<a href="#pxd_SILICONVIDEO_getCtrlFrameRate" class="Er">pxd_SILICONVIDEO_getCtrlFrameRate</a>
returns the controlled frame rate, in Hz.
</p><p>
The
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>
and
<a href="#pxd_SILICONVIDEO_setCtrlRates" class="Er">pxd_SILICONVIDEO_setCtrlRates</a>
eliminate having to use
''raw''
values via
<a href="#pxd_setExsyncPrin" class="Er">pxd_setExsyncPrin</a>
to set the controlled exposure and/or frame rate.
</p><p>
<br>
<b class="Hv">Camera Specific.</b>
For
SILICON VIDEO® 1281M
and
SILICON VIDEO® 1281C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
</p><p>
For
SILICON VIDEO® 1310
and
SILICON VIDEO® 1310C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
</p><p>
For
SILICON VIDEO® 2112
and
SILICON VIDEO® 2112C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
</p><p>
For
SILICON VIDEO® 5C10
and
SILICON VIDEO® 5M10:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f';</em>
controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>
selecting rolling reset and rolling shutter,
providing the same exposure period for each line, but lines are exposed in succession;
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'|('g'&lt;&lt;8)</em>
selecting global reset and rolling shutter,
providing shorter delay from trigger to exposure, but expecting use of strobed flash illumination.
</p><p>
For
SILICON VIDEO® 642M
and
SILICON VIDEO® 642C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
</p><p>
For
SILICON VIDEO® 643M
and
SILICON VIDEO® 643C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
</p><p>
For
SILICON VIDEO® 9C10:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f';</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'|('g'&lt;&lt;8)</em>
selecting global reset and rolling shutter,
providing shorter delay from trigger to exposure, but expecting use of strobed flash illumination.
</p><p>
For
SILICON VIDEO® 9M001
and
SILICON VIDEO® 9M001C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
</p><p>
For
SILICON VIDEO® 9T001C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f';</em>
controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>
selecting rolling reset and rolling shutter,
providing the same exposure period for each line, but lines are exposed in succession;
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'|('g'&lt;&lt;8)</em>
selecting global reset and rolling shutter,
providing shorter delay from trigger to exposure, but expecting use of strobed flash illumination.
</p><p>
For
SILICON VIDEO® WGA-M
and
SILICON VIDEO® WGA-C:
The camera supports free-run mode with
<em class="Ep">videomode</em>=<em class="Ep">'f'</em>
and controlled mode with
<em class="Ep">videomode</em>=<em class="Ep">'c'</em>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_SILICONVIDEO_getVideoMode" class="Er">pxd_SILICONVIDEO_getVideoMode</a>,
<a href="#pxd_SILICONVIDEO_getCtrlVideoMode" class="Er">pxd_SILICONVIDEO_getCtrlVideoMode</a>,
<a href="#pxd_SILICONVIDEO_getCtrlTriggerMode" class="Er">pxd_SILICONVIDEO_getCtrlTriggerMode</a>,
and
<a href="#pxd_SILICONVIDEO_getCtrlFrameRate" class="Er">pxd_SILICONVIDEO_getCtrlFrameRate</a>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
</p><p>
The
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>
and
<a href="#pxd_SILICONVIDEO_setCtrlRates" class="Er">pxd_SILICONVIDEO_setCtrlRates</a>
returns:
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_SILICONVIDEO_setAxC NX523" class="NX"></a>
<a name="pxd_SILICONVIDEO_setAxC" class="Sf"></a>
<a name="Set SILICON VIDEO AGC and AEC NX524" class="NX"></a>
<a name="Set SILICON VIDEO AGC and AEC   ---   pxd_SILICONVIDEO_setAxC" class="Sf"></a>
<a name="Set SILICON VIDEO AGC and AEC   ---   pxd_SILICONVIDEO_setAxC"></a>
<h6 class="Sf">Set SILICON VIDEO AGC and AEC   ---   pxd_SILICONVIDEO_setAxC</h6>
<a name="pxd_SILICONVIDEO_getAgcA NX525" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO AGC A Gain NX526" class="NX"></a>
<a name="Get SILICON VIDEO AGC A Gain   ---   pxd_SILICONVIDEO_getAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO AGC A Gain   ---   pxd_SILICONVIDEO_getAgcA"></a>
<h6 class="Sg">Get SILICON VIDEO AGC A Gain   ---   pxd_SILICONVIDEO_getAgcA</h6>
<a name="pxd_SILICONVIDEO_getAgcB NX527" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO AGC B Gain NX528" class="NX"></a>
<a name="Get SILICON VIDEO AGC B Gain   ---   pxd_SILICONVIDEO_getAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO AGC B Gain   ---   pxd_SILICONVIDEO_getAgcB"></a>
<h6 class="Sg">Get SILICON VIDEO AGC B Gain   ---   pxd_SILICONVIDEO_getAgcB</h6>
<a name="pxd_SILICONVIDEO_getAec NX529" class="NX"></a>
<a name="pxd_SILICONVIDEO_getAec" class="Sg"></a>
<a name="Get SILICON VIDEO AEC Exposure NX530" class="NX"></a>
<a name="Get SILICON VIDEO AEC Exposure   ---   pxd_SILICONVIDEO_getAec" class="Sg"></a>
<a name="Get SILICON VIDEO AEC Exposure   ---   pxd_SILICONVIDEO_getAec"></a>
<h6 class="Sg">Get SILICON VIDEO AEC Exposure   ---   pxd_SILICONVIDEO_getAec</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int    pxd_SILICONVIDEO_setAxC(unitmap,rsvd,agcA,agcB,rsvd2,rsvd3,aec,
                                              rsvd4,rsvd5,rsvd6,rsvd7);
int    pxd_SILICONVIDEO_getAgcA(unitmap);
int    pxd_SILICONVIDEO_getAgcB(unitmap);
int    pxd_SILICONVIDEO_getAec(unitmap);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 agcA;               // AGC for A-gain. 0: off, &gt;0: AGC rate
int                 agcB;               // AGC for B-gain. 0: off, &gt;0: AGC rate
int                 aec;                // AEC. 0: off, &gt;0: AEC rate
int                 rsvd2;              // Reserved, should be -1
int                 rsvd3;              // Reserved, should be -1
int                 rsvd4;              // Reserved, should be -1
int                 rsvd5;              // Reserved, should be -1
int                 rsvd6;              // Reserved, should be -1
int                 rsvd7;              // Reserved, should be -1
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO® NX531" class="NX"></a>
<a name="AGC NX532" class="NX"></a>
<a name="AEC NX533" class="NX"></a>
The
<a href="#pxd_SILICONVIDEO_setAxC" class="Er">pxd_SILICONVIDEO_setAxC</a>
sets the automatic gain control (AGC)
and automatic exposure control (AEC)
hardware features of
SILICON VIDEO® WGA-C
and
SILICON VIDEO® WGA-M
cameras connected to PIXCI® D2X, D2X1, SI, SI1, SI2, and SI4 imaging boards.
</p><p>
If
<em class="Ep">agcA</em>=0,
the AGC control of the camera's A-gain
is disabled.
If
<em class="Ep">agcA</em>&gt;0,
the AGC control of the camera's A-gain
is enabled, the value of
<em class="Ep">agcA</em>
sets the AGC
''speed'',
the degree to which
AGC responds to, or ignores,
transient changes in image brightness.
Larger values select quicker responses to changes.
</p><p>
The
<em class="Ep">agcB</em>
is similar, affecting the B-gain.
</p><p>
The
<em class="Ep">aec</em>
is similar, affecting the exposure.
</p><p>
Some cameras may not provide A-gain, B-gain, or exposure
automatic control;
the corresponding values are ignored.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getAgcA" class="Er">pxd_SILICONVIDEO_getAgcA</a>
returns the current A-gain AGC setting.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getAgcB" class="Er">pxd_SILICONVIDEO_getAgcB</a>
returns the current B-gain AGC setting.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getAec" class="Er">pxd_SILICONVIDEO_getAec</a>
returns the current exposure AEC setting.
</p><p>
Some cameras may not provide A-gain, B-gain, or exposure
automatic gain control;
a value of 0 is returned.
</p><p>
Note: The
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
performs partial, quick initialization of XCLIB;
initialization for the
<cite class="Ec">pxd_SILICONVIDEO_</cite>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<cite class="Ec">pxd_SILICONVIDEO_set</cite>
or
<cite class="Ec">pxd_SILICONVIDEO_get</cite>
function once
before entering the application's time critical phase.
</p><p>
<br>
<b class="Hv">Camera Specific.</b>
For
SILICON VIDEO® 1281M
and
SILICON VIDEO® 1281C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 1310
and
SILICON VIDEO® 1310C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 2112
and
SILICON VIDEO® 2112C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 5C10
and
SILICON VIDEO® 5M10:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 642M
and
SILICON VIDEO® 642C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 643M
and
SILICON VIDEO® 643C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 9C10:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 9M001
and
SILICON VIDEO® 9M001C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® 9T001C:
The camera does not provide hardware AGC or AEC features.
</p><p>
For
SILICON VIDEO® WGA-C
and
SILICON VIDEO® WGA-M:
The camera provides AGC control of the A-gain
and AEC control of the exposure (shutter).
In addition to value 0, allowable values for
<em class="Ep">agcA</em>
and
<em class="Ep">aec</em>
are 1 (slow AGC/AEC), 2 (medium AGC/AEC),
3 (fast AGC/AEC).
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxd_SILICONVIDEO_getAgcA" class="Er">pxd_SILICONVIDEO_getAgcA</a>,
<a href="#pxd_SILICONVIDEO_getAgcB" class="Er">pxd_SILICONVIDEO_getAgcB</a>,
and
<a href="#pxd_SILICONVIDEO_getAec" class="Er">pxd_SILICONVIDEO_getAec</a>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
</p><p>
The remaining functions return:
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="pxd_SILICONVIDEO_getMinMaxExposure NX534" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxExposure" class="Sf"></a>
<a name="Get SILICON VIDEO Min/Max Exposure NX535" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Exposure   ---   pxd_SILICONVIDEO_getMinMaxExposure" class="Sf"></a>
<a name="Get SILICON VIDEO Min/Max Exposure   ---   pxd_SILICONVIDEO_getMinMaxExposure"></a>
<h6 class="Sf">Get SILICON VIDEO Min/Max Exposure   ---   pxd_SILICONVIDEO_getMinMaxExposure</h6>
<a name="pxd_SILICONVIDEO_getMinMaxFramePeriod NX536" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Frame Period NX537" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Frame Period   ---   pxd_SILICONVIDEO_getMinMaxFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Frame Period   ---   pxd_SILICONVIDEO_getMinMaxFramePeriod"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Frame Period   ---   pxd_SILICONVIDEO_getMinMaxFramePeriod</h6>
<a name="pxd_SILICONVIDEO_getMinMaxCtrlFrameRate NX538" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxCtrlFrameRate" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Controlled Frame Rate NX539" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxd_SILICONVIDEO_getMinMaxCtrlFrameRate" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxd_SILICONVIDEO_getMinMaxCtrlFrameRate"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxd_SILICONVIDEO_getMinMaxCtrlFrameRate</h6>
<a name="pxd_SILICONVIDEO_getMinMaxPixelClock NX540" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Pixel Clock Frequency NX541" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getMinMaxPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getMinMaxPixelClock"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxd_SILICONVIDEO_getMinMaxPixelClock</h6>
<a name="pxd_SILICONVIDEO_getMinMaxGainA NX542" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain A NX543" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Gain A   ---   pxd_SILICONVIDEO_getMinMaxGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain A   ---   pxd_SILICONVIDEO_getMinMaxGainA"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Gain A   ---   pxd_SILICONVIDEO_getMinMaxGainA</h6>
<a name="pxd_SILICONVIDEO_getMinMaxGainB NX544" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain B NX545" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Gain B   ---   pxd_SILICONVIDEO_getMinMaxGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain B   ---   pxd_SILICONVIDEO_getMinMaxGainB"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Gain B   ---   pxd_SILICONVIDEO_getMinMaxGainB</h6>
<a name="pxd_SILICONVIDEO_getMinMaxOffsetA NX546" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxOffsetA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset A NX547" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Offset A   ---   pxd_SILICONVIDEO_getMinMaxOffsetA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset A   ---   pxd_SILICONVIDEO_getMinMaxOffsetA"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Offset A   ---   pxd_SILICONVIDEO_getMinMaxOffsetA</h6>
<a name="pxd_SILICONVIDEO_getMinMaxOffsetB NX548" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxOffsetB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset B NX549" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Offset B   ---   pxd_SILICONVIDEO_getMinMaxOffsetB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset B   ---   pxd_SILICONVIDEO_getMinMaxOffsetB"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Offset B   ---   pxd_SILICONVIDEO_getMinMaxOffsetB</h6>
<a name="pxd_SILICONVIDEO_getMinMaxAoiWidth NX550" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxAoiWidth" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Width NX551" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AOI Width   ---   pxd_SILICONVIDEO_getMinMaxAoiWidth" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Width   ---   pxd_SILICONVIDEO_getMinMaxAoiWidth"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AOI Width   ---   pxd_SILICONVIDEO_getMinMaxAoiWidth</h6>
<a name="pxd_SILICONVIDEO_getMinMaxAoiHeight NX552" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxAoiHeight" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Height NX553" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AOI Height   ---   pxd_SILICONVIDEO_getMinMaxAoiHeight" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Height   ---   pxd_SILICONVIDEO_getMinMaxAoiHeight"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AOI Height   ---   pxd_SILICONVIDEO_getMinMaxAoiHeight</h6>
<a name="pxd_SILICONVIDEO_getMinMaxAgcA NX554" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC A Gain NX555" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AGC A Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC A Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcA"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AGC A Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcA</h6>
<a name="pxd_SILICONVIDEO_getMinMaxAgcB NX556" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC B Gain NX557" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AGC B Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC B Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcB"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AGC B Gain   ---   pxd_SILICONVIDEO_getMinMaxAgcB</h6>
<a name="pxd_SILICONVIDEO_getMinMaxAec NX558" class="NX"></a>
<a name="pxd_SILICONVIDEO_getMinMaxAec" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AEC Exposure NX559" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AEC Exposure   ---   pxd_SILICONVIDEO_getMinMaxAec" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AEC Exposure   ---   pxd_SILICONVIDEO_getMinMaxAec"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AEC Exposure   ---   pxd_SILICONVIDEO_getMinMaxAec</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>double pxd_SILICONVIDEO_getMinMaxExposure(unitmap, exposure);
double pxd_SILICONVIDEO_getMinMaxFramePeriod(unitmap, framePeriod);
double pxd_SILICONVIDEO_getMinMaxCtrlFrameRate(unitmap, frameRate);
double pxd_SILICONVIDEO_getMinMaxPixelClock(unitmap, pixelClkFreq);
double pxd_SILICONVIDEO_getMinMaxGainA(unitmap, gainA);
double pxd_SILICONVIDEO_getMinMaxGainB(unitmap, gainB);
double pxd_SILICONVIDEO_getMinMaxOffsetA(unitmap, offsetA);
double pxd_SILICONVIDEO_getMinMaxOffsetB(unitmap, offsetB);
int    pxd_SILICONVIDEO_getMinMaxAoiWidth(unitmap, aoiwidth);
int    pxd_SILICONVIDEO_getMinMaxAoiHeight(unitmap, aoiheight);
int    pxd_SILICONVIDEO_getMinMaxAgcA(unitmap, agcA);
int    pxd_SILICONVIDEO_getMinMaxAgcB(unitmap, agcB);
int    pxd_SILICONVIDEO_getMinMaxAec(unitmap, aec);
<br>
int                 unitmap;            // Unit selection bit map (1 for single unit)
double              exposure;           // Exposure period, in milliseconds
double              framePeriod;        // Frame period, in msec.
double              frameRate;          // Frame rate, in Hz
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              gainA;              // Pre-gain, in dB.
double              gainB;              // Post-gain, in dB.
double              offsetA;            // Pre-offset, scaled to 1.0 for max-pixel value
double              offsetB;            // Post-offset, scaled to 1.0 for max pixel value
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
int                 agcA;               // AGC for A-gain. 0: off, &gt;0: AGC rate
int                 agcB;               // AGC for B-gain. 0: off, &gt;0: AGC rate
int                 aec;                // AEC. 0: off, &gt;0: AEC rate
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxd_SIICONVIDEO_getMinMaxExposure" class="Er">pxd_SIICONVIDEO_getMinMaxExposure</a>
and
<a href="#pxd_SIICONVIDEO_getMinMaxFramePeriod" class="Er">pxd_SIICONVIDEO_getMinMaxFramePeriod</a>
corrects the prospective
<em class="Ep">exposure</em>
period
and free-run mode
<em class="Ep">framePeriod</em>,
respectively,
to the nearest valid value.
The corrected value is returned, in milliseconds.
The camera's settings and function are not affected.
</p><p>
The
<a href="#pxd_SIICONVIDEO_getMinMaxCtrlFrameRate" class="Er">pxd_SIICONVIDEO_getMinMaxCtrlFrameRate</a>
corrects the prospective
controlled, continuous mode
<em class="Ep">frameRate</em>
to the nearest valid value.
The corrected value is returned, in milliseconds.
The camera's settings and function are not affected.
</p><p>
The
<a href="#pxd_SIICONVIDEO_getMinMaxPixelClkFreq" class="Er">pxd_SIICONVIDEO_getMinMaxPixelClkFreq</a>
corrects the prospective
<em class="Ep">pixelClkFreq</em>
to the nearest valid value.
The corrected value is returned, in MHz.
The camera's settings and function are not affected.
</p><p>
The
<a href="#pxd_SIICONVIDEO_getMinMaxPixelGainA" class="Er">pxd_SIICONVIDEO_getMinMaxPixelGainA</a>
and
<a href="#pxd_SIICONVIDEO_getMinMaxPixelGainB" class="Er">pxd_SIICONVIDEO_getMinMaxPixelGainB</a>
corrects the prospective
<em class="Ep">gainA</em>
and
<em class="Ep">gainB</em>,
respectively,
to the nearest valid value.
The corrected value is returned, in dB.
The camera's settings and function are not affected.
</p><p>
The
<a href="#pxd_SIICONVIDEO_getMinMaxPixelOffsetA" class="Er">pxd_SIICONVIDEO_getMinMaxPixelOffsetA</a>
and
<a href="#pxd_SIICONVIDEO_getMinMaxPixelOffsetB" class="Er">pxd_SIICONVIDEO_getMinMaxPixelOffsetB</a>
corrects the prospective
<em class="Ep">offsetA</em>
and
<em class="Ep">offsetB</em>,
respectively,
to the nearest valid value.
The corrected value is returned, scaled
in the same manner as used for
<a href="#pxd_SILICONVIDEO_getOffsetsA" class="Er">pxd_SILICONVIDEO_getOffsetsA</a>
and
<a href="#pxd_SILICONVIDEO_getOffsetsB" class="Er">pxd_SILICONVIDEO_getOffsetsB</a>
The camera's settings and function are not affected.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getMinMaxAoiWidth" class="Er">pxd_SILICONVIDEO_getMinMaxAoiWidth</a>
and
<a href="#pxd_SILICONVIDEO_getMinMaxAoiHeight" class="Er">pxd_SILICONVIDEO_getMinMaxAoiHeight</a>
corrects the prospective
<em class="Ep">aoiwidth</em>
and
<em class="Ep">aoiheight</em>,
respectively,
to the nearest valid value.
The corrected value is returned.
The camera's settings and function are not affected.
</p><p>
The
<a href="#pxd_SILICONVIDEO_getMinMaxAgcA" class="Er">pxd_SILICONVIDEO_getMinMaxAgcA</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxAgcB" class="Er">pxd_SILICONVIDEO_getMinMaxAgcB</a>,
and
<a href="#pxd_SILICONVIDEO_getMinMaxAec" class="Er">pxd_SILICONVIDEO_getMinMaxAec</a>
corrects the prospective
<em class="Ep">agcA</em>,
<em class="Ep">agcB</em>,
and
<em class="Ep">aec</em>,
respectively,
to the nearest valid value.
The corrected value is returned.
The camera's settings and function are not affected.
</p><p>
The allowable ranges of the
exposure, frame period, pixel clock frequency,
gain, offset, AOI width and height,
AGC settings, and AEC settings
varies depending on camera model.
For some cameras, the allowable ranges
are also dependent on the camera's settings.
For example, the allowable value for exposure are often dependent
on the camera's pixel clock frequency,
AOI width &amp; height, and subsampling.
These functions allow obtaining the
current minimum and maximum allowable values,
such as by invoking
<a href="#pxd_SIICONVIDEO_getMinMaxExposure" class="Er">pxd_SIICONVIDEO_getMinMaxExposure</a>
with
<em class="Ep">exposure</em>=0.0
or
<em class="Ep">exposure</em>=-9E99
to obtain the minimum allowable exposure,
and by invoking with
<em class="Ep">exposure</em>=9E99
to obtain the maximum allowable exposure.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
Returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="SCF+ Style Interface" class="Ch"></a>
<a name="4.  SCF+ Style Interface"></a>
</p><h1>4.  SCF+ Style Interface</h1>
<p>
The so-called
Simple ``C'' Function Plus
Style Interface
is similar to the
<a href="#SCF%20Style%20Interface" class="Er">SCF Style Interface</a>
functions, but allows access to multiple,
non-identical, image boards.<a href="#Footnote%2030" class="Ff"><sup>[30]</sup></a>
</p><hr size="1">
<a name="pxe_XCLIBinstantiate NX560" class="NX"></a>
<a name="pxe_XCLIBinstantiate" class="Sf"></a>
<a name="PIXCI® Imaging Board Library: Create Instance NX561" class="NX"></a>
<a name="PIXCI® Imaging Board Library: Create Instance   ---   pxe_XCLIBinstantiate" class="Sf"></a>
<a name="PIXCI® Imaging Board Library: Create Instance   ---   pxe_XCLIBinstantiate"></a>
<h6 class="Sf">PIXCI® Imaging Board Library: Create Instance   ---   pxe_XCLIBinstantiate</h6>
<a name="pxe_XCLIBuninstantiate NX562" class="NX"></a>
<a name="pxe_XCLIBuninstantiate" class="Sg"></a>
<a name="PIXCI® Imaging Board Library: Uncreate Instance NX563" class="NX"></a>
<a name="PIXCI® Imaging Board Library: Uncreate Instance   ---   pxe_XCLIBuninstantiate" class="Sg"></a>
<a name="PIXCI® Imaging Board Library: Uncreate Instance   ---   pxe_XCLIBuninstantiate"></a>
<h6 class="Sg">PIXCI® Imaging Board Library: Uncreate Instance   ---   pxe_XCLIBuninstantiate</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>pxdstate_s * pxe_XCLIBinstantiate();
void         pxe_XCLIBuninstantiate(instance);
<br>
pxdstate_s *    instance;           // Library instance
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>
creates an instance of the PIXCI® XCLIB Library
and returns a pointer to the instance.
The
<a href="#pxe_XCLIBuninstantiate" class="Er">pxe_XCLIBuninstantiate</a>
frees the resources acquired by
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>,
after which the pointer to the instance
should not be used.
</p><p>
An explicit instance of the PIXCI® XCLIB Library
is needed to use the various
<a href="#pxe_" class="Er">pxe_</a>
style functions which allow opening and using
multiple imaging boards of different types.
In contrast, the slightly simpler
<a href="#pxd_" class="Er">pxd_</a>
functions use an implicit instance of the PIXCI® XCLIB Library,
but can only operate multiple imaging boards of the same type.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
The
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>
returns a pointer to a new instance,
or NULL for
<cite class="Ec">malloc</cite>
error.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
Assume three PIXCI® imaging boards.
The first two are of the same type
and will be opened within one instance
for convenience of common controls.
</p><blockquote>
<pre>    pxdstate_s  *xclib1 = NULL;
    pxdstate_s  *xclib2 = NULL;
    int i;
<br>
    xclib1 = pxe_XCLIBinstantiate();
    xclib2 = pxe_XCLIBinstantiate();
    if (xclib1 == NULL || xclib2 == NULL) {
        printf("Instantiation Error\n");
        pxe_XCLIBuninstantiate(xclib1);
        pxe_XCLIBuninstantiate(xclib2);
        exit(1);
    }
    // the DM parameter is a bitmap selection of physical units: 3 = units #0 &amp; #1
    if ((i = pxe_PIXCIopen(xclib1, "-DM 3", "Default", "")) &lt; 0) {
        printf("Open Error\n");
        pxe_mesgFault(xclib1, 3);
        pxe_XCLIBuninstantiate(xclib1);
        pxe_XCLIBuninstantiate(xclib2);
        exit(1);
    }
    // the DM parameter is a bitmap selection of physical units: 4 = unit #2
    if ((i = pxe_PIXCIopen(xclib2, "-DM 4", "Default", "")) &lt; 0) {
        printf("Open Error\n");
        pxe_mesgFault(xclib2, 3);
        pxe_PIXCIclose(xclib1)
        pxe_XCLIBuninstantiate(xclib1);
        pxe_XCLIBuninstantiate(xclib2);
        exit(1);
    }
    // the unitmap parameter is a bitmap selection of
    // those units opened within that instance.
    // As the xclib2 instance has only one board open,
    // its unitmap is always 1!
    pxe_doSnap(xclib1, 1, 5, 0);
                // snap imaging board 1 into its buffer #5
    pxe_doSnap(xclib1, 2, 5, 0);
                // snap imaging board 2 into its buffer #5
    pxe_doSnap(xclib1, 3, 5, 0);
                // snap imaging board 1&amp;2 into their respective buffer #5
    pxe_doSnap(xclib2, 1, 5, 0);
                // snap imaging board 3 into its buffer #5
        ...
    pxe_PIXCIclose(xclib1)
    pxe_PIXCIclose(xclib2)
    pxe_XCLIBuninstantiate(xclib1);
    pxe_XCLIBuninstantiate(xclib2);
    exit(0);
</pre>
</blockquote>
<hr size="1">
<a name="pxe_buffersFieldCount NX564" class="NX"></a>
<a name="pxe_buffersFieldCount" class="Sf"></a>
<a name="Buffer's Capture Field Count NX565" class="NX"></a>
<a name="Buffer's Capture Field Count   ---   pxe_buffersFieldCount" class="Sf"></a>
<a name="Buffer's Capture Field Count   ---   pxe_buffersFieldCount"></a>
<h6 class="Sf">Buffer's Capture Field Count   ---   pxe_buffersFieldCount</h6>
<a name="pxe_buffersGPIn NX566" class="NX"></a>
<a name="pxe_buffersGPIn" class="Sg"></a>
<a name="Buffer's Capture General Purpose Input NX567" class="NX"></a>
<a name="Buffer's Capture General Purpose Input   ---   pxe_buffersGPIn" class="Sg"></a>
<a name="Buffer's Capture General Purpose Input   ---   pxe_buffersGPIn"></a>
<h6 class="Sg">Buffer's Capture General Purpose Input   ---   pxe_buffersGPIn</h6>
<a name="pxe_buffersSysTicks NX568" class="NX"></a>
<a name="pxe_buffersSysTicks" class="Sg"></a>
<a name="Buffer's Capture System Time NX569" class="NX"></a>
<a name="Buffer's Capture System Time   ---   pxe_buffersSysTicks" class="Sg"></a>
<a name="Buffer's Capture System Time   ---   pxe_buffersSysTicks"></a>
<h6 class="Sg">Buffer's Capture System Time   ---   pxe_buffersSysTicks</h6>
<a name="pxe_buffersSysTicks2 NX570" class="NX"></a>
<a name="pxe_buffersSysTicks2" class="Sg"></a>
<a name="Buffer's Capture System Time NX571" class="NX"></a>
<a name="Buffer's Capture System Time   ---   pxe_buffersSysTicks2" class="Sg"></a>
<a name="Buffer's Capture System Time   ---   pxe_buffersSysTicks2"></a>
<h6 class="Sg">Buffer's Capture System Time   ---   pxe_buffersSysTicks2</h6>
<a name="pxe_capturedBuffer NX572" class="NX"></a>
<a name="pxe_capturedBuffer" class="Sg"></a>
<a name="Last Captured Buffer: Buffer Number NX573" class="NX"></a>
<a name="Last Captured Buffer: Buffer Number   ---   pxe_capturedBuffer" class="Sg"></a>
<a name="Last Captured Buffer: Buffer Number   ---   pxe_capturedBuffer"></a>
<h6 class="Sg">Last Captured Buffer: Buffer Number   ---   pxe_capturedBuffer</h6>
<a name="pxe_capturedFieldCount NX574" class="NX"></a>
<a name="pxe_capturedFieldCount" class="Sg"></a>
<a name="Last Captured Buffer: Field Count NX575" class="NX"></a>
<a name="Last Captured Buffer: Field Count   ---   pxe_capturedFieldCount" class="Sg"></a>
<a name="Last Captured Buffer: Field Count   ---   pxe_capturedFieldCount"></a>
<h6 class="Sg">Last Captured Buffer: Field Count   ---   pxe_capturedFieldCount</h6>
<a name="pxe_capturedSysTicks NX576" class="NX"></a>
<a name="pxe_capturedSysTicks" class="Sg"></a>
<a name="Last Captured Buffer: System Time NX577" class="NX"></a>
<a name="Last Captured Buffer: System Time   ---   pxe_capturedSysTicks" class="Sg"></a>
<a name="Last Captured Buffer: System Time   ---   pxe_capturedSysTicks"></a>
<h6 class="Sg">Last Captured Buffer: System Time   ---   pxe_capturedSysTicks</h6>
<a name="pxe_setCameraLinkCCOut NX578" class="NX"></a>
<a name="pxe_setCameraLinkCCOut" class="Sg"></a>
<a name="Camera Link CC Output Signal: Set NX579" class="NX"></a>
<a name="Camera Link CC Output Signal: Set   ---   pxe_setCameraLinkCCOut" class="Sg"></a>
<a name="Camera Link CC Output Signal: Set   ---   pxe_setCameraLinkCCOut"></a>
<h6 class="Sg">Camera Link CC Output Signal: Set   ---   pxe_setCameraLinkCCOut</h6>
<a name="pxe_getCameraLinkCCOut NX580" class="NX"></a>
<a name="pxe_getCameraLinkCCOut" class="Sg"></a>
<a name="Camera Link CC Output Signal: Get NX581" class="NX"></a>
<a name="Camera Link CC Output Signal: Get   ---   pxe_getCameraLinkCCOut" class="Sg"></a>
<a name="Camera Link CC Output Signal: Get   ---   pxe_getCameraLinkCCOut"></a>
<h6 class="Sg">Camera Link CC Output Signal: Get   ---   pxe_getCameraLinkCCOut</h6>
<a name="pxe_defineImage NX582" class="NX"></a>
<a name="pxe_defineImage" class="Sg"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer NX583" class="NX"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_defineImage" class="Sg"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_defineImage"></a>
<h6 class="Sg">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_defineImage</h6>
<a name="pxe_defineImage3 NX584" class="NX"></a>
<a name="pxe_defineImage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers NX585" class="NX"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_defineImage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_defineImage3"></a>
<h6 class="Sg">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_defineImage3</h6>
<a name="pxe_definePximage NX586" class="NX"></a>
<a name="pxe_definePximage" class="Sg"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer NX587" class="NX"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_definePximage" class="Sg"></a>
<a name="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_definePximage"></a>
<h6 class="Sg">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxe_definePximage</h6>
<a name="pxe_definePximage3 NX588" class="NX"></a>
<a name="pxe_definePximage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers NX589" class="NX"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_definePximage3" class="Sg"></a>
<a name="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_definePximage3"></a>
<h6 class="Sg">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxe_definePximage3</h6>
<a name="pxe_definePximageFree NX590" class="NX"></a>
<a name="pxe_definePximageFree" class="Sg"></a>
<a name="Get PXIMAGE: Release Access to Imaging Board Frame Buffers NX591" class="NX"></a>
<a name="Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximageFree" class="Sg"></a>
<a name="Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximageFree"></a>
<h6 class="Sg">Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximageFree</h6>
<a name="pxe_definePximage3Free NX592" class="NX"></a>
<a name="pxe_definePximage3Free" class="Sg"></a>
<a name="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers NX593" class="NX"></a>
<a name="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximage3Free" class="Sg"></a>
<a name="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximage3Free"></a>
<h6 class="Sg">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxe_definePximage3Free</h6>
<a name="pxe_doSnap NX594" class="NX"></a>
<a name="pxe_doSnap" class="Sg"></a>
<a name="Video Snap and Wait NX595" class="NX"></a>
<a name="Video Snap and Wait   ---   pxe_doSnap" class="Sg"></a>
<a name="Video Snap and Wait   ---   pxe_doSnap"></a>
<h6 class="Sg">Video Snap and Wait   ---   pxe_doSnap</h6>
<a name="pxe_eventFieldCreate NX596" class="NX"></a>
<a name="pxe_eventFieldCreate" class="Sg"></a>
<a name="Windows: Register Event upon Video Field NX597" class="NX"></a>
<a name="Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate" class="Sg"></a>
<a name="Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate"></a>
<h6 class="Sg">Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate</h6>
<a name="pxe_eventFieldCreate2 NX598" class="NX"></a>
<a name="pxe_eventFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Video Field NX599" class="NX"></a>
<a name="Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate2"></a>
<h6 class="Sg">Windows: Register Event upon Video Field   ---   pxe_eventFieldCreate2</h6>
<a name="pxe_eventFieldClose NX600" class="NX"></a>
<a name="pxe_eventFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Video Field NX601" class="NX"></a>
<a name="Windows: Unregister Event upon Video Field   ---   pxe_eventFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Video Field   ---   pxe_eventFieldClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Video Field   ---   pxe_eventFieldClose</h6>
<a name="pxe_eventCapturedFieldCreate NX602" class="NX"></a>
<a name="pxe_eventCapturedFieldCreate" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field NX603" class="NX"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate"></a>
<h6 class="Sg">Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate</h6>
<a name="pxe_eventCapturedFieldCreate2 NX604" class="NX"></a>
<a name="pxe_eventCapturedFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field NX605" class="NX"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate2"></a>
<h6 class="Sg">Windows: Register Event upon Captured Video Field   ---   pxe_eventCapturedFieldCreate2</h6>
<a name="pxe_eventCapturedFieldClose NX606" class="NX"></a>
<a name="pxe_eventCapturedFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Captured Video Field NX607" class="NX"></a>
<a name="Windows: Unregister Event upon Captured Video Field   ---   pxe_eventCapturedFieldClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Captured Video Field   ---   pxe_eventCapturedFieldClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Captured Video Field   ---   pxe_eventCapturedFieldClose</h6>
<a name="pxe_eventGPTriggerCreate NX608" class="NX"></a>
<a name="pxe_eventGPTriggerCreate" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger NX609" class="NX"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate"></a>
<h6 class="Sg">Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate</h6>
<a name="pxe_eventGPTriggerCreate2 NX610" class="NX"></a>
<a name="pxe_eventGPTriggerCreate2" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger NX611" class="NX"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate2" class="Sg"></a>
<a name="Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate2"></a>
<h6 class="Sg">Windows: Register Event upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate2</h6>
<a name="pxe_eventGPTriggerClose NX612" class="NX"></a>
<a name="pxe_eventGPTriggerClose" class="Sg"></a>
<a name="Windows: Unregister Event upon General Purpose Trigger NX613" class="NX"></a>
<a name="Windows: Unregister Event upon General Purpose Trigger   ---   pxe_eventGPTriggerClose" class="Sg"></a>
<a name="Windows: Unregister Event upon General Purpose Trigger   ---   pxe_eventGPTriggerClose"></a>
<h6 class="Sg">Windows: Unregister Event upon General Purpose Trigger   ---   pxe_eventGPTriggerClose</h6>
<a name="pxe_eventFaultCreate NX614" class="NX"></a>
<a name="pxe_eventFaultCreate" class="Sg"></a>
<a name="Windows: Register Event upon Fault NX615" class="NX"></a>
<a name="Windows: Register Event upon Fault   ---   pxe_eventFaultCreate" class="Sg"></a>
<a name="Windows: Register Event upon Fault   ---   pxe_eventFaultCreate"></a>
<h6 class="Sg">Windows: Register Event upon Fault   ---   pxe_eventFaultCreate</h6>
<a name="pxe_eventFaultCreate2 NX616" class="NX"></a>
<a name="pxe_eventFaultCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Fault NX617" class="NX"></a>
<a name="Windows: Register Event upon Fault   ---   pxe_eventFaultCreate2" class="Sg"></a>
<a name="Windows: Register Event upon Fault   ---   pxe_eventFaultCreate2"></a>
<h6 class="Sg">Windows: Register Event upon Fault   ---   pxe_eventFaultCreate2</h6>
<a name="pxe_eventFaultClose NX618" class="NX"></a>
<a name="pxe_eventFaultClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Fault NX619" class="NX"></a>
<a name="Windows: Unregister Event upon Fault   ---   pxe_eventFaultClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Fault   ---   pxe_eventFaultClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Fault   ---   pxe_eventFaultClose</h6>
<a name="pxe_eventSerialCreate NX620" class="NX"></a>
<a name="pxe_eventSerialCreate" class="Sg"></a>
<a name="Windows: Register Event upon Serial NX621" class="NX"></a>
<a name="Windows: Register Event upon Serial   ---   pxe_eventSerialCreate" class="Sg"></a>
<a name="Windows: Register Event upon Serial   ---   pxe_eventSerialCreate"></a>
<h6 class="Sg">Windows: Register Event upon Serial   ---   pxe_eventSerialCreate</h6>
<a name="pxe_eventSerialClose NX622" class="NX"></a>
<a name="pxe_eventSerialClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Serial NX623" class="NX"></a>
<a name="Windows: Unregister Event upon Serial   ---   pxe_eventSerialClose" class="Sg"></a>
<a name="Windows: Unregister Event upon Serial   ---   pxe_eventSerialClose"></a>
<h6 class="Sg">Windows: Unregister Event upon Serial   ---   pxe_eventSerialClose</h6>
<a name="pxe_eventFieldCreate NX624" class="NX"></a>
<a name="pxe_eventFieldCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Video Field NX625" class="NX"></a>
<a name="DOS: Register Callback upon Video Field   ---   pxe_eventFieldCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Video Field   ---   pxe_eventFieldCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Video Field   ---   pxe_eventFieldCreate</h6>
<a name="pxe_eventFieldClose NX626" class="NX"></a>
<a name="pxe_eventFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Video Field NX627" class="NX"></a>
<a name="DOS: Unregister Callback upon Video Field   ---   pxe_eventFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Video Field   ---   pxe_eventFieldClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Video Field   ---   pxe_eventFieldClose</h6>
<a name="pxe_eventCapturedFieldCreate NX628" class="NX"></a>
<a name="pxe_eventCapturedFieldCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Captured Video Field NX629" class="NX"></a>
<a name="DOS: Register Callback upon Captured Video Field   ---   pxe_eventCapturedFieldCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Captured Video Field   ---   pxe_eventCapturedFieldCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Captured Video Field   ---   pxe_eventCapturedFieldCreate</h6>
<a name="pxe_eventCapturedFieldClose NX630" class="NX"></a>
<a name="pxe_eventCapturedFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Captured Video Field NX631" class="NX"></a>
<a name="DOS: Unregister Callback upon Captured Video Field   ---   pxe_eventCapturedFieldClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Captured Video Field   ---   pxe_eventCapturedFieldClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Captured Video Field   ---   pxe_eventCapturedFieldClose</h6>
<a name="pxe_eventGPTriggerCreate NX632" class="NX"></a>
<a name="pxe_eventGPTriggerCreate" class="Sg"></a>
<a name="DOS: Register Callback upon General Purpose Trigger NX633" class="NX"></a>
<a name="DOS: Register Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate" class="Sg"></a>
<a name="DOS: Register Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate"></a>
<h6 class="Sg">DOS: Register Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate</h6>
<a name="pxe_eventGPTriggerClose NX634" class="NX"></a>
<a name="pxe_eventGPTriggerClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon General Purpose Trigger NX635" class="NX"></a>
<a name="DOS: Unregister Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon General Purpose Trigger   ---   pxe_eventGPTriggerClose</h6>
<a name="pxe_eventFaultCreate NX636" class="NX"></a>
<a name="pxe_eventFaultCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Fault NX637" class="NX"></a>
<a name="DOS: Register Callback upon Fault   ---   pxe_eventFaultCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Fault   ---   pxe_eventFaultCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Fault   ---   pxe_eventFaultCreate</h6>
<a name="pxe_eventFaultClose NX638" class="NX"></a>
<a name="pxe_eventFaultClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Fault NX639" class="NX"></a>
<a name="DOS: Unregister Callback upon Fault   ---   pxe_eventFaultClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Fault   ---   pxe_eventFaultClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Fault   ---   pxe_eventFaultClose</h6>
<a name="pxe_eventSerialCreate NX640" class="NX"></a>
<a name="pxe_eventSerialCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Serial NX641" class="NX"></a>
<a name="DOS: Register Callback upon Serial   ---   pxe_eventSerialCreate" class="Sg"></a>
<a name="DOS: Register Callback upon Serial   ---   pxe_eventSerialCreate"></a>
<h6 class="Sg">DOS: Register Callback upon Serial   ---   pxe_eventSerialCreate</h6>
<a name="pxe_eventSerialClose NX642" class="NX"></a>
<a name="pxe_eventSerialClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Serial NX643" class="NX"></a>
<a name="DOS: Unregister Callback upon Serial   ---   pxe_eventSerialClose" class="Sg"></a>
<a name="DOS: Unregister Callback upon Serial   ---   pxe_eventSerialClose"></a>
<h6 class="Sg">DOS: Unregister Callback upon Serial   ---   pxe_eventSerialClose</h6>
<a name="pxe_eventFieldCreate NX644" class="NX"></a>
<a name="pxe_eventFieldCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Video Field NX645" class="NX"></a>
<a name="Linux: Register Signal upon Video Field   ---   pxe_eventFieldCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Video Field   ---   pxe_eventFieldCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Video Field   ---   pxe_eventFieldCreate</h6>
<a name="pxe_eventFieldClose NX646" class="NX"></a>
<a name="pxe_eventFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Video Field NX647" class="NX"></a>
<a name="Linux: Unregister Signal upon Video Field   ---   pxe_eventFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Video Field   ---   pxe_eventFieldClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Video Field   ---   pxe_eventFieldClose</h6>
<a name="pxe_eventCapturedFieldCreate NX648" class="NX"></a>
<a name="pxe_eventCapturedFieldCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Captured Video Field NX649" class="NX"></a>
<a name="Linux: Register Signal upon Captured Video Field   ---   pxe_eventCapturedFieldCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Captured Video Field   ---   pxe_eventCapturedFieldCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Captured Video Field   ---   pxe_eventCapturedFieldCreate</h6>
<a name="pxe_eventCapturedFieldClose NX650" class="NX"></a>
<a name="pxe_eventCapturedFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Captured Video Field NX651" class="NX"></a>
<a name="Linux: Unregister Signal upon Captured Video Field   ---   pxe_eventCapturedFieldClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Captured Video Field   ---   pxe_eventCapturedFieldClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Captured Video Field   ---   pxe_eventCapturedFieldClose</h6>
<a name="pxe_eventGPTriggerCreate NX652" class="NX"></a>
<a name="pxe_eventGPTriggerCreate" class="Sg"></a>
<a name="Linux: Register Signal upon General Purpose Trigger NX653" class="NX"></a>
<a name="Linux: Register Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate" class="Sg"></a>
<a name="Linux: Register Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate"></a>
<h6 class="Sg">Linux: Register Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerCreate</h6>
<a name="pxe_eventGPTriggerClose NX654" class="NX"></a>
<a name="pxe_eventGPTriggerClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon General Purpose Trigger NX655" class="NX"></a>
<a name="Linux: Unregister Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon General Purpose Trigger   ---   pxe_eventGPTriggerClose</h6>
<a name="pxe_eventFaultCreate NX656" class="NX"></a>
<a name="pxe_eventFaultCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Fault NX657" class="NX"></a>
<a name="Linux: Register Signal upon Fault   ---   pxe_eventFaultCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Fault   ---   pxe_eventFaultCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Fault   ---   pxe_eventFaultCreate</h6>
<a name="pxe_eventFaultClose NX658" class="NX"></a>
<a name="pxe_eventFaultClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Fault NX659" class="NX"></a>
<a name="Linux: Unregister Signal upon Fault   ---   pxe_eventFaultClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Fault   ---   pxe_eventFaultClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Fault   ---   pxe_eventFaultClose</h6>
<a name="pxe_eventSerialCreate NX660" class="NX"></a>
<a name="pxe_eventSerialCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Serial NX661" class="NX"></a>
<a name="Linux: Register Signal upon Serial   ---   pxe_eventSerialCreate" class="Sg"></a>
<a name="Linux: Register Signal upon Serial   ---   pxe_eventSerialCreate"></a>
<h6 class="Sg">Linux: Register Signal upon Serial   ---   pxe_eventSerialCreate</h6>
<a name="pxe_eventSerialClose NX662" class="NX"></a>
<a name="pxe_eventSerialClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Serial NX663" class="NX"></a>
<a name="Linux: Unregister Signal upon Serial   ---   pxe_eventSerialClose" class="Sg"></a>
<a name="Linux: Unregister Signal upon Serial   ---   pxe_eventSerialClose"></a>
<h6 class="Sg">Linux: Unregister Signal upon Serial   ---   pxe_eventSerialClose</h6>
<a name="pxe_getGPIn NX664" class="NX"></a>
<a name="pxe_getGPIn" class="Sg"></a>
<a name="General Purpose Input Signal: Sense NX665" class="NX"></a>
<a name="General Purpose Input Signal: Sense   ---   pxe_getGPIn" class="Sg"></a>
<a name="General Purpose Input Signal: Sense   ---   pxe_getGPIn"></a>
<h6 class="Sg">General Purpose Input Signal: Sense   ---   pxe_getGPIn</h6>
<a name="pxe_setGPIn NX666" class="NX"></a>
<a name="pxe_setGPIn" class="Sg"></a>
<a name="General Purpose Input Signal: Reset NX667" class="NX"></a>
<a name="General Purpose Input Signal: Reset   ---   pxe_setGPIn" class="Sg"></a>
<a name="General Purpose Input Signal: Reset   ---   pxe_setGPIn"></a>
<h6 class="Sg">General Purpose Input Signal: Reset   ---   pxe_setGPIn</h6>
<a name="pxe_setGPOut NX668" class="NX"></a>
<a name="pxe_setGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Set NX669" class="NX"></a>
<a name="General Purpose Output Signal: Set   ---   pxe_setGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Set   ---   pxe_setGPOut"></a>
<h6 class="Sg">General Purpose Output Signal: Set   ---   pxe_setGPOut</h6>
<a name="pxe_getGPOut NX670" class="NX"></a>
<a name="pxe_getGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Get NX671" class="NX"></a>
<a name="General Purpose Output Signal: Get   ---   pxe_getGPOut" class="Sg"></a>
<a name="General Purpose Output Signal: Get   ---   pxe_getGPOut"></a>
<h6 class="Sg">General Purpose Output Signal: Get   ---   pxe_getGPOut</h6>
<a name="pxe_getGPTrigger NX672" class="NX"></a>
<a name="pxe_getGPTrigger" class="Sg"></a>
<a name="General Purpose Trigger Count: Sense NX673" class="NX"></a>
<a name="General Purpose Trigger Count: Sense   ---   pxe_getGPTrigger" class="Sg"></a>
<a name="General Purpose Trigger Count: Sense   ---   pxe_getGPTrigger"></a>
<h6 class="Sg">General Purpose Trigger Count: Sense   ---   pxe_getGPTrigger</h6>
<a name="pxe_getBrightness NX674" class="NX"></a>
<a name="pxe_getBrightness" class="Sg"></a>
<a name="Get Video Brightness NX675" class="NX"></a>
<a name="Get Video Brightness   ---   pxe_getBrightness" class="Sg"></a>
<a name="Get Video Brightness   ---   pxe_getBrightness"></a>
<h6 class="Sg">Get Video Brightness   ---   pxe_getBrightness</h6>
<a name="pxe_getContrast NX676" class="NX"></a>
<a name="pxe_getContrast" class="Sg"></a>
<a name="Get Video Contrast NX677" class="NX"></a>
<a name="Get Video Contrast   ---   pxe_getContrast" class="Sg"></a>
<a name="Get Video Contrast   ---   pxe_getContrast"></a>
<h6 class="Sg">Get Video Contrast   ---   pxe_getContrast</h6>
<a name="pxe_getHue NX678" class="NX"></a>
<a name="pxe_getHue" class="Sg"></a>
<a name="Get Video Hue NX679" class="NX"></a>
<a name="Get Video Hue   ---   pxe_getHue" class="Sg"></a>
<a name="Get Video Hue   ---   pxe_getHue"></a>
<h6 class="Sg">Get Video Hue   ---   pxe_getHue</h6>
<a name="pxe_getUGain NX680" class="NX"></a>
<a name="pxe_getUGain" class="Sg"></a>
<a name="Get Video U Saturation NX681" class="NX"></a>
<a name="Get Video U Saturation   ---   pxe_getUGain" class="Sg"></a>
<a name="Get Video U Saturation   ---   pxe_getUGain"></a>
<h6 class="Sg">Get Video U Saturation   ---   pxe_getUGain</h6>
<a name="pxe_getVGain NX682" class="NX"></a>
<a name="pxe_getVGain" class="Sg"></a>
<a name="Get Video V Saturation NX683" class="NX"></a>
<a name="Get Video V Saturation   ---   pxe_getVGain" class="Sg"></a>
<a name="Get Video V Saturation   ---   pxe_getVGain"></a>
<h6 class="Sg">Get Video V Saturation   ---   pxe_getVGain</h6>
<a name="pxe_getVidMux NX684" class="NX"></a>
<a name="pxe_getVidMux" class="Sg"></a>
<a name="Get Video Input Multiplexer NX685" class="NX"></a>
<a name="Get Video Input Multiplexer   ---   pxe_getVidMux" class="Sg"></a>
<a name="Get Video Input Multiplexer   ---   pxe_getVidMux"></a>
<h6 class="Sg">Get Video Input Multiplexer   ---   pxe_getVidMux</h6>
<a name="pxe_goSnap NX686" class="NX"></a>
<a name="pxe_goSnap" class="Sg"></a>
<a name="Video Snap NX687" class="NX"></a>
<a name="Video Snap   ---   pxe_goSnap" class="Sg"></a>
<a name="Video Snap   ---   pxe_goSnap"></a>
<h6 class="Sg">Video Snap   ---   pxe_goSnap</h6>
<a name="pxe_goSnapPair NX688" class="NX"></a>
<a name="pxe_goSnapPair" class="Sg"></a>
<a name="Video Snap Pair NX689" class="NX"></a>
<a name="Video Snap Pair   ---   pxe_goSnapPair" class="Sg"></a>
<a name="Video Snap Pair   ---   pxe_goSnapPair"></a>
<h6 class="Sg">Video Snap Pair   ---   pxe_goSnapPair</h6>
<a name="pxe_goLive NX690" class="NX"></a>
<a name="pxe_goLive" class="Sg"></a>
<a name="Video Live NX691" class="NX"></a>
<a name="Video Live   ---   pxe_goLive" class="Sg"></a>
<a name="Video Live   ---   pxe_goLive"></a>
<h6 class="Sg">Video Live   ---   pxe_goLive</h6>
<a name="pxe_goLivePair NX692" class="NX"></a>
<a name="pxe_goLivePair" class="Sg"></a>
<a name="Video Live Pair Alternate NX693" class="NX"></a>
<a name="Video Live Pair Alternate   ---   pxe_goLivePair" class="Sg"></a>
<a name="Video Live Pair Alternate   ---   pxe_goLivePair"></a>
<h6 class="Sg">Video Live Pair Alternate   ---   pxe_goLivePair</h6>
<a name="pxe_goLiveSeq NX694" class="NX"></a>
<a name="pxe_goLiveSeq" class="Sg"></a>
<a name="Video Live Sequence NX695" class="NX"></a>
<a name="Video Live Sequence   ---   pxe_goLiveSeq" class="Sg"></a>
<a name="Video Live Sequence   ---   pxe_goLiveSeq"></a>
<h6 class="Sg">Video Live Sequence   ---   pxe_goLiveSeq</h6>
<a name="pxe_goUnLive NX696" class="NX"></a>
<a name="pxe_goUnLive" class="Sg"></a>
<a name="Video UnLive NX697" class="NX"></a>
<a name="Video UnLive   ---   pxe_goUnLive" class="Sg"></a>
<a name="Video UnLive   ---   pxe_goUnLive"></a>
<h6 class="Sg">Video UnLive   ---   pxe_goUnLive</h6>
<a name="pxe_goAbortLive NX698" class="NX"></a>
<a name="pxe_goAbortLive" class="Sg"></a>
<a name="Video Abort NX699" class="NX"></a>
<a name="Video Abort   ---   pxe_goAbortLive" class="Sg"></a>
<a name="Video Abort   ---   pxe_goAbortLive"></a>
<h6 class="Sg">Video Abort   ---   pxe_goAbortLive</h6>
<a name="pxe_goLiveTrig NX700" class="NX"></a>
<a name="pxe_goLiveTrig" class="Sg"></a>
<a name="Video Live Trigger NX701" class="NX"></a>
<a name="Video Live Trigger   ---   pxe_goLiveTrig" class="Sg"></a>
<a name="Video Live Trigger   ---   pxe_goLiveTrig"></a>
<h6 class="Sg">Video Live Trigger   ---   pxe_goLiveTrig</h6>
<a name="pxe_goLiveSeqTrig NX702" class="NX"></a>
<a name="pxe_goLiveSeqTrig" class="Sg"></a>
<a name="Video Live Sequence Trigger NX703" class="NX"></a>
<a name="Video Live Sequence Trigger   ---   pxe_goLiveSeqTrig" class="Sg"></a>
<a name="Video Live Sequence Trigger   ---   pxe_goLiveSeqTrig"></a>
<h6 class="Sg">Video Live Sequence Trigger   ---   pxe_goLiveSeqTrig</h6>
<a name="pxe_goneLive NX704" class="NX"></a>
<a name="pxe_goneLive" class="Sg"></a>
<a name="Video Initiated Status Check NX705" class="NX"></a>
<a name="Video Initiated Status Check   ---   pxe_goneLive" class="Sg"></a>
<a name="Video Initiated Status Check   ---   pxe_goneLive"></a>
<h6 class="Sg">Video Initiated Status Check   ---   pxe_goneLive</h6>
<a name="pxe_imageAspectRatio NX706" class="NX"></a>
<a name="pxe_imageAspectRatio" class="Sg"></a>
<a name="Get Frame Buffer Image Aspect Ratio NX707" class="NX"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio" class="Sg"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio"></a>
<h6 class="Sg">Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio</h6>
<a name="pxe_imageAspectRatio2 NX708" class="NX"></a>
<a name="pxe_imageAspectRatio2" class="Sg"></a>
<a name="Get Frame Buffer Image Aspect Ratio NX709" class="NX"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio2" class="Sg"></a>
<a name="Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio2"></a>
<h6 class="Sg">Get Frame Buffer Image Aspect Ratio   ---   pxe_imageAspectRatio2</h6>
<a name="pxe_imageBdim NX710" class="NX"></a>
<a name="pxe_imageBdim" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth NX711" class="NX"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxe_imageBdim" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxe_imageBdim"></a>
<h6 class="Sg">Get Frame Buffer Image Bit Depth   ---   pxe_imageBdim</h6>
<a name="pxe_imageBdims NX712" class="NX"></a>
<a name="pxe_imageBdims" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth NX713" class="NX"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxe_imageBdims" class="Sg"></a>
<a name="Get Frame Buffer Image Bit Depth   ---   pxe_imageBdims"></a>
<h6 class="Sg">Get Frame Buffer Image Bit Depth   ---   pxe_imageBdims</h6>
<a name="pxe_imageCdim NX714" class="NX"></a>
<a name="pxe_imageCdim" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components NX715" class="NX"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxe_imageCdim" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxe_imageCdim"></a>
<h6 class="Sg">Get Frame Buffer Image Color Components   ---   pxe_imageCdim</h6>
<a name="pxe_imageCdims NX716" class="NX"></a>
<a name="pxe_imageCdims" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components NX717" class="NX"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxe_imageCdims" class="Sg"></a>
<a name="Get Frame Buffer Image Color Components   ---   pxe_imageCdims"></a>
<h6 class="Sg">Get Frame Buffer Image Color Components   ---   pxe_imageCdims</h6>
<a name="pxe_imageIdim NX718" class="NX"></a>
<a name="pxe_imageIdim" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension NX719" class="NX"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxe_imageIdim" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxe_imageIdim"></a>
<h6 class="Sg">Get Frame Buffer Image Field Dimension   ---   pxe_imageIdim</h6>
<a name="pxe_imageIdims NX720" class="NX"></a>
<a name="pxe_imageIdims" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension NX721" class="NX"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxe_imageIdims" class="Sg"></a>
<a name="Get Frame Buffer Image Field Dimension   ---   pxe_imageIdims"></a>
<h6 class="Sg">Get Frame Buffer Image Field Dimension   ---   pxe_imageIdims</h6>
<a name="pxe_imageXdim NX722" class="NX"></a>
<a name="pxe_imageXdim" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension NX723" class="NX"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdim" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdim"></a>
<h6 class="Sg">Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdim</h6>
<a name="pxe_imageXdims NX724" class="NX"></a>
<a name="pxe_imageXdims" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension NX725" class="NX"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdims" class="Sg"></a>
<a name="Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdims"></a>
<h6 class="Sg">Get Frame Buffer Image Horizontal Dimension   ---   pxe_imageXdims</h6>
<a name="pxe_imageYdim NX726" class="NX"></a>
<a name="pxe_imageYdim" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension NX727" class="NX"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdim" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdim"></a>
<h6 class="Sg">Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdim</h6>
<a name="pxe_imageYdims NX728" class="NX"></a>
<a name="pxe_imageYdims" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension NX729" class="NX"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdims" class="Sg"></a>
<a name="Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdims"></a>
<h6 class="Sg">Get Frame Buffer Image Vertical Dimension   ---   pxe_imageYdims</h6>
<a name="pxe_imageZdim NX730" class="NX"></a>
<a name="pxe_imageZdim" class="Sg"></a>
<a name="Get Frame Buffer Image Count NX731" class="NX"></a>
<a name="Get Frame Buffer Image Count   ---   pxe_imageZdim" class="Sg"></a>
<a name="Get Frame Buffer Image Count   ---   pxe_imageZdim"></a>
<h6 class="Sg">Get Frame Buffer Image Count   ---   pxe_imageZdim</h6>
<a name="pxe_imageZdims NX732" class="NX"></a>
<a name="pxe_imageZdims" class="Sg"></a>
<a name="Get Frame Buffer Image Count NX733" class="NX"></a>
<a name="Get Frame Buffer Image Count   ---   pxe_imageZdims" class="Sg"></a>
<a name="Get Frame Buffer Image Count   ---   pxe_imageZdims"></a>
<h6 class="Sg">Get Frame Buffer Image Count   ---   pxe_imageZdims</h6>
<a name="pxe_infoDriverId NX734" class="NX"></a>
<a name="pxe_infoDriverId" class="Sg"></a>
<a name="Get Imaging Board Driver ID NX735" class="NX"></a>
<a name="Get Imaging Board Driver ID   ---   pxe_infoDriverId" class="Sg"></a>
<a name="Get Imaging Board Driver ID   ---   pxe_infoDriverId"></a>
<h6 class="Sg">Get Imaging Board Driver ID   ---   pxe_infoDriverId</h6>
<a name="pxe_infoLibraryId NX736" class="NX"></a>
<a name="pxe_infoLibraryId" class="Sg"></a>
<a name="Get Imaging Board Library ID NX737" class="NX"></a>
<a name="Get Imaging Board Library ID   ---   pxe_infoLibraryId" class="Sg"></a>
<a name="Get Imaging Board Library ID   ---   pxe_infoLibraryId"></a>
<h6 class="Sg">Get Imaging Board Library ID   ---   pxe_infoLibraryId</h6>
<a name="pxe_infoMemsize NX738" class="NX"></a>
<a name="pxe_infoMemsize" class="Sg"></a>
<a name="Get Imaging Board's Frame Buffer Size NX739" class="NX"></a>
<a name="Get Imaging Board's Frame Buffer Size   ---   pxe_infoMemsize" class="Sg"></a>
<a name="Get Imaging Board's Frame Buffer Size   ---   pxe_infoMemsize"></a>
<h6 class="Sg">Get Imaging Board's Frame Buffer Size   ---   pxe_infoMemsize</h6>
<a name="pxe_infoModel NX740" class="NX"></a>
<a name="pxe_infoModel" class="Sg"></a>
<a name="Get Imaging Board's Model NX741" class="NX"></a>
<a name="Get Imaging Board's Model   ---   pxe_infoModel" class="Sg"></a>
<a name="Get Imaging Board's Model   ---   pxe_infoModel"></a>
<h6 class="Sg">Get Imaging Board's Model   ---   pxe_infoModel</h6>
<a name="pxe_infoSubmodel NX742" class="NX"></a>
<a name="pxe_infoSubmodel" class="Sg"></a>
<a name="Get Imaging Board's Submodel NX743" class="NX"></a>
<a name="Get Imaging Board's Submodel   ---   pxe_infoSubmodel" class="Sg"></a>
<a name="Get Imaging Board's Submodel   ---   pxe_infoSubmodel"></a>
<h6 class="Sg">Get Imaging Board's Submodel   ---   pxe_infoSubmodel</h6>
<a name="pxe_infoUnits NX744" class="NX"></a>
<a name="pxe_infoUnits" class="Sg"></a>
<a name="Get Imaging Board Unit Count NX745" class="NX"></a>
<a name="Get Imaging Board Unit Count   ---   pxe_infoUnits" class="Sg"></a>
<a name="Get Imaging Board Unit Count   ---   pxe_infoUnits"></a>
<h6 class="Sg">Get Imaging Board Unit Count   ---   pxe_infoUnits</h6>
<a name="pxe_loadBmp NX746" class="NX"></a>
<a name="pxe_loadBmp" class="Sg"></a>
<a name="Load Image: BMP Format NX747" class="NX"></a>
<a name="Load Image: BMP Format   ---   pxe_loadBmp" class="Sg"></a>
<a name="Load Image: BMP Format   ---   pxe_loadBmp"></a>
<h6 class="Sg">Load Image: BMP Format   ---   pxe_loadBmp</h6>
<a name="pxe_loadTiff NX748" class="NX"></a>
<a name="pxe_loadTiff" class="Sg"></a>
<a name="Load Image: TIFF Format NX749" class="NX"></a>
<a name="Load Image: TIFF Format   ---   pxe_loadTiff" class="Sg"></a>
<a name="Load Image: TIFF Format   ---   pxe_loadTiff"></a>
<h6 class="Sg">Load Image: TIFF Format   ---   pxe_loadTiff</h6>
<a name="pxe_saveBmp NX750" class="NX"></a>
<a name="pxe_saveBmp" class="Sg"></a>
<a name="Save Image: BMP Format NX751" class="NX"></a>
<a name="Save Image: BMP Format   ---   pxe_saveBmp" class="Sg"></a>
<a name="Save Image: BMP Format   ---   pxe_saveBmp"></a>
<h6 class="Sg">Save Image: BMP Format   ---   pxe_saveBmp</h6>
<a name="pxe_savePcx NX752" class="NX"></a>
<a name="pxe_savePcx" class="Sg"></a>
<a name="Save Image: PCX Format NX753" class="NX"></a>
<a name="Save Image: PCX Format   ---   pxe_savePcx" class="Sg"></a>
<a name="Save Image: PCX Format   ---   pxe_savePcx"></a>
<h6 class="Sg">Save Image: PCX Format   ---   pxe_savePcx</h6>
<a name="pxe_saveTga NX754" class="NX"></a>
<a name="pxe_saveTga" class="Sg"></a>
<a name="Save Image: TARGA Format NX755" class="NX"></a>
<a name="Save Image: TARGA Format   ---   pxe_saveTga" class="Sg"></a>
<a name="Save Image: TARGA Format   ---   pxe_saveTga"></a>
<h6 class="Sg">Save Image: TARGA Format   ---   pxe_saveTga</h6>
<a name="pxe_saveTiff NX756" class="NX"></a>
<a name="pxe_saveTiff" class="Sg"></a>
<a name="Save Image: TIFF Format NX757" class="NX"></a>
<a name="Save Image: TIFF Format   ---   pxe_saveTiff" class="Sg"></a>
<a name="Save Image: TIFF Format   ---   pxe_saveTiff"></a>
<h6 class="Sg">Save Image: TIFF Format   ---   pxe_saveTiff</h6>
<a name="pxe_loadRawBuffers NX758" class="NX"></a>
<a name="pxe_loadRawBuffers" class="Sg"></a>
<a name="Load Frame Buffers NX759" class="NX"></a>
<a name="Load Frame Buffers   ---   pxe_loadRawBuffers" class="Sg"></a>
<a name="Load Frame Buffers   ---   pxe_loadRawBuffers"></a>
<h6 class="Sg">Load Frame Buffers   ---   pxe_loadRawBuffers</h6>
<a name="pxe_saveRawBuffers NX760" class="NX"></a>
<a name="pxe_saveRawBuffers" class="Sg"></a>
<a name="Save Frame Buffers NX761" class="NX"></a>
<a name="Save Frame Buffers   ---   pxe_saveRawBuffers" class="Sg"></a>
<a name="Save Frame Buffers   ---   pxe_saveRawBuffers"></a>
<h6 class="Sg">Save Frame Buffers   ---   pxe_saveRawBuffers</h6>
<a name="pxe_mesgFault NX762" class="NX"></a>
<a name="pxe_mesgFault" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults NX763" class="NX"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxe_mesgFault" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxe_mesgFault"></a>
<h6 class="Sg">Errors: Check &amp; Report Faults   ---   pxe_mesgFault</h6>
<a name="pxe_mesgFaultText NX764" class="NX"></a>
<a name="pxe_mesgFaultText" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults NX765" class="NX"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxe_mesgFaultText" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults   ---   pxe_mesgFaultText"></a>
<h6 class="Sg">Errors: Check &amp; Report Faults   ---   pxe_mesgFaultText</h6>
<a name="pxe_PIXCIopen NX766" class="NX"></a>
<a name="pxe_PIXCIopen" class="Sg"></a>
<a name="PIXCI® Imaging Board: Open and Set Video Format Configuration NX767" class="NX"></a>
<a name="PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxe_PIXCIopen" class="Sg"></a>
<a name="PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxe_PIXCIopen"></a>
<h6 class="Sg">PIXCI® Imaging Board: Open and Set Video Format Configuration   ---   pxe_PIXCIopen</h6>
<a name="pxe_PIXCIclose NX768" class="NX"></a>
<a name="pxe_PIXCIclose" class="Sg"></a>
<a name="PIXCI® Imaging Board: Close NX769" class="NX"></a>
<a name="PIXCI® Imaging Board: Close   ---   pxe_PIXCIclose" class="Sg"></a>
<a name="PIXCI® Imaging Board: Close   ---   pxe_PIXCIclose"></a>
<h6 class="Sg">PIXCI® Imaging Board: Close   ---   pxe_PIXCIclose</h6>
<a name="pxe_readuchar NX770" class="NX"></a>
<a name="pxe_readuchar" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Char NX771" class="NX"></a>
<a name="Read Pixel Values as Unsigned Char   ---   pxe_readuchar" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Char   ---   pxe_readuchar"></a>
<h6 class="Sg">Read Pixel Values as Unsigned Char   ---   pxe_readuchar</h6>
<a name="pxe_readushort NX772" class="NX"></a>
<a name="pxe_readushort" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Short NX773" class="NX"></a>
<a name="Read Pixel Values as Unsigned Short   ---   pxe_readushort" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Short   ---   pxe_readushort"></a>
<h6 class="Sg">Read Pixel Values as Unsigned Short   ---   pxe_readushort</h6>
<a name="pxe_writeuchar NX774" class="NX"></a>
<a name="pxe_writeuchar" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Char NX775" class="NX"></a>
<a name="Write Pixel Values as Unsigned Char   ---   pxe_writeuchar" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Char   ---   pxe_writeuchar"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Char   ---   pxe_writeuchar</h6>
<a name="pxe_writeushort NX776" class="NX"></a>
<a name="pxe_writeushort" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Short NX777" class="NX"></a>
<a name="Write Pixel Values as Unsigned Short   ---   pxe_writeushort" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Short   ---   pxe_writeushort"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Short   ---   pxe_writeushort</h6>
<a name="pxe_renderDIBCreate NX778" class="NX"></a>
<a name="pxe_renderDIBCreate" class="Sg"></a>
<a name="Windows: Create Device Independent Bitmap (DIB) NX779" class="NX"></a>
<a name="Windows: Create Device Independent Bitmap (DIB)   ---   pxe_renderDIBCreate" class="Sg"></a>
<a name="Windows: Create Device Independent Bitmap (DIB)   ---   pxe_renderDIBCreate"></a>
<h6 class="Sg">Windows: Create Device Independent Bitmap (DIB)   ---   pxe_renderDIBCreate</h6>
<a name="pxe_renderDIBFree NX780" class="NX"></a>
<a name="pxe_renderDIBFree" class="Sg"></a>
<a name="Windows: Release Device Independent Bitmap (DIB) NX781" class="NX"></a>
<a name="Windows: Release Device Independent Bitmap (DIB)   ---   pxe_renderDIBFree" class="Sg"></a>
<a name="Windows: Release Device Independent Bitmap (DIB)   ---   pxe_renderDIBFree"></a>
<h6 class="Sg">Windows: Release Device Independent Bitmap (DIB)   ---   pxe_renderDIBFree</h6>
<a name="pxe_renderDirectVideoInit NX782" class="NX"></a>
<a name="pxe_renderDirectVideoInit" class="Sg"></a>
<a name="Windows: Direct Video Display, Init NX783" class="NX"></a>
<a name="Windows: Direct Video Display, Init   ---   pxe_renderDirectVideoInit" class="Sg"></a>
<a name="Windows: Direct Video Display, Init   ---   pxe_renderDirectVideoInit"></a>
<h6 class="Sg">Windows: Direct Video Display, Init   ---   pxe_renderDirectVideoInit</h6>
<a name="pxe_renderDirectVideoDone NX784" class="NX"></a>
<a name="pxe_renderDirectVideoDone" class="Sg"></a>
<a name="Windows: Direct Video Display, Done NX785" class="NX"></a>
<a name="Windows: Direct Video Display, Done   ---   pxe_renderDirectVideoDone" class="Sg"></a>
<a name="Windows: Direct Video Display, Done   ---   pxe_renderDirectVideoDone"></a>
<h6 class="Sg">Windows: Direct Video Display, Done   ---   pxe_renderDirectVideoDone</h6>
<a name="pxe_renderDirectVideoLive NX786" class="NX"></a>
<a name="pxe_renderDirectVideoLive" class="Sg"></a>
<a name="Windows: Direct Video Display, Start NX787" class="NX"></a>
<a name="Windows: Direct Video Display, Start   ---   pxe_renderDirectVideoLive" class="Sg"></a>
<a name="Windows: Direct Video Display, Start   ---   pxe_renderDirectVideoLive"></a>
<h6 class="Sg">Windows: Direct Video Display, Start   ---   pxe_renderDirectVideoLive</h6>
<a name="pxe_renderDirectVideoUnLive NX788" class="NX"></a>
<a name="pxe_renderDirectVideoUnLive" class="Sg"></a>
<a name="Windows: Direct Video Display, Stop NX789" class="NX"></a>
<a name="Windows: Direct Video Display, Stop   ---   pxe_renderDirectVideoUnLive" class="Sg"></a>
<a name="Windows: Direct Video Display, Stop   ---   pxe_renderDirectVideoUnLive"></a>
<h6 class="Sg">Windows: Direct Video Display, Stop   ---   pxe_renderDirectVideoUnLive</h6>
<a name="pxe_renderStretchDIBits NX790" class="NX"></a>
<a name="pxe_renderStretchDIBits" class="Sg"></a>
<a name="Windows: Display Image Frame Buffer On Device Context NX791" class="NX"></a>
<a name="Windows: Display Image Frame Buffer On Device Context   ---   pxe_renderStretchDIBits" class="Sg"></a>
<a name="Windows: Display Image Frame Buffer On Device Context   ---   pxe_renderStretchDIBits"></a>
<h6 class="Sg">Windows: Display Image Frame Buffer On Device Context   ---   pxe_renderStretchDIBits</h6>
<a name="pxe_serialConfigure NX792" class="NX"></a>
<a name="pxe_serialConfigure" class="Sg"></a>
<a name="Serial Port: Set Configuration NX793" class="NX"></a>
<a name="Serial Port: Set Configuration   ---   pxe_serialConfigure" class="Sg"></a>
<a name="Serial Port: Set Configuration   ---   pxe_serialConfigure"></a>
<h6 class="Sg">Serial Port: Set Configuration   ---   pxe_serialConfigure</h6>
<a name="pxe_serialRead NX794" class="NX"></a>
<a name="pxe_serialRead" class="Sg"></a>
<a name="Serial Port: Read NX795" class="NX"></a>
<a name="Serial Port: Read   ---   pxe_serialRead" class="Sg"></a>
<a name="Serial Port: Read   ---   pxe_serialRead"></a>
<h6 class="Sg">Serial Port: Read   ---   pxe_serialRead</h6>
<a name="pxe_serialWrite NX796" class="NX"></a>
<a name="pxe_serialWrite" class="Sg"></a>
<a name="Serial Port: Write NX797" class="NX"></a>
<a name="Serial Port: Write   ---   pxe_serialWrite" class="Sg"></a>
<a name="Serial Port: Write   ---   pxe_serialWrite"></a>
<h6 class="Sg">Serial Port: Write   ---   pxe_serialWrite</h6>
<a name="pxe_setExsyncPrin NX798" class="NX"></a>
<a name="pxe_setExsyncPrin" class="Sg"></a>
<a name="Set EXSYNC and PRIN Counter Values NX799" class="NX"></a>
<a name="Set EXSYNC and PRIN Counter Values   ---   pxe_setExsyncPrin" class="Sg"></a>
<a name="Set EXSYNC and PRIN Counter Values   ---   pxe_setExsyncPrin"></a>
<h6 class="Sg">Set EXSYNC and PRIN Counter Values   ---   pxe_setExsyncPrin</h6>
<a name="pxe_getExsync NX800" class="NX"></a>
<a name="pxe_getExsync" class="Sg"></a>
<a name="Get EXSYNC Counter Value NX801" class="NX"></a>
<a name="Get EXSYNC Counter Value   ---   pxe_getExsync" class="Sg"></a>
<a name="Get EXSYNC Counter Value   ---   pxe_getExsync"></a>
<h6 class="Sg">Get EXSYNC Counter Value   ---   pxe_getExsync</h6>
<a name="pxe_getPrin NX802" class="NX"></a>
<a name="pxe_getPrin" class="Sg"></a>
<a name="Get PRIN Counter Value NX803" class="NX"></a>
<a name="Get PRIN Counter Value   ---   pxe_getPrin" class="Sg"></a>
<a name="Get PRIN Counter Value   ---   pxe_getPrin"></a>
<h6 class="Sg">Get PRIN Counter Value   ---   pxe_getPrin</h6>
<a name="pxe_setExsyncPrincMode NX804" class="NX"></a>
<a name="pxe_setExsyncPrincMode" class="Sg"></a>
<a name="Set EXSYNC and PRINC Mode Bits NX805" class="NX"></a>
<a name="Set EXSYNC and PRINC Mode Bits   ---   pxe_setExsyncPrincMode" class="Sg"></a>
<a name="Set EXSYNC and PRINC Mode Bits   ---   pxe_setExsyncPrincMode"></a>
<h6 class="Sg">Set EXSYNC and PRINC Mode Bits   ---   pxe_setExsyncPrincMode</h6>
<a name="pxe_getExsyncMode NX806" class="NX"></a>
<a name="pxe_getExsyncMode" class="Sg"></a>
<a name="Get EXSYNC Mode Bits NX807" class="NX"></a>
<a name="Get EXSYNC Mode Bits   ---   pxe_getExsyncMode" class="Sg"></a>
<a name="Get EXSYNC Mode Bits   ---   pxe_getExsyncMode"></a>
<h6 class="Sg">Get EXSYNC Mode Bits   ---   pxe_getExsyncMode</h6>
<a name="pxe_getPrincMode NX808" class="NX"></a>
<a name="pxe_getPrincMode" class="Sg"></a>
<a name="Get PRINC Mode Bits NX809" class="NX"></a>
<a name="Get PRINC Mode Bits   ---   pxe_getPrincMode" class="Sg"></a>
<a name="Get PRINC Mode Bits   ---   pxe_getPrincMode"></a>
<h6 class="Sg">Get PRINC Mode Bits   ---   pxe_getPrincMode</h6>
<a name="pxe_setVidMux NX810" class="NX"></a>
<a name="pxe_setVidMux" class="Sg"></a>
<a name="Set Video Input Multiplexer NX811" class="NX"></a>
<a name="Set Video Input Multiplexer   ---   pxe_setVidMux" class="Sg"></a>
<a name="Set Video Input Multiplexer   ---   pxe_setVidMux"></a>
<h6 class="Sg">Set Video Input Multiplexer   ---   pxe_setVidMux</h6>
<a name="pxe_setContrastBrightness NX812" class="NX"></a>
<a name="pxe_setContrastBrightness" class="Sg"></a>
<a name="Set Video Contrast and Brightness NX813" class="NX"></a>
<a name="Set Video Contrast and Brightness   ---   pxe_setContrastBrightness" class="Sg"></a>
<a name="Set Video Contrast and Brightness   ---   pxe_setContrastBrightness"></a>
<h6 class="Sg">Set Video Contrast and Brightness   ---   pxe_setContrastBrightness</h6>
<a name="pxe_setHueSaturation NX814" class="NX"></a>
<a name="pxe_setHueSaturation" class="Sg"></a>
<a name="Set Video Hue and Saturation NX815" class="NX"></a>
<a name="Set Video Hue and Saturation   ---   pxe_setHueSaturation" class="Sg"></a>
<a name="Set Video Hue and Saturation   ---   pxe_setHueSaturation"></a>
<h6 class="Sg">Set Video Hue and Saturation   ---   pxe_setHueSaturation</h6>
<a name="pxe_setImageBrightBalance NX816" class="NX"></a>
<a name="pxe_setImageBrightBalance" class="Sg"></a>
<a name="Set Bright White Balance NX817" class="NX"></a>
<a name="Set Bright White Balance   ---   pxe_setImageBrightBalance" class="Sg"></a>
<a name="Set Bright White Balance   ---   pxe_setImageBrightBalance"></a>
<h6 class="Sg">Set Bright White Balance   ---   pxe_setImageBrightBalance</h6>
<a name="pxe_setImageDarkBalance NX818" class="NX"></a>
<a name="pxe_setImageDarkBalance" class="Sg"></a>
<a name="Set Dark White Balance NX819" class="NX"></a>
<a name="Set Dark White Balance   ---   pxe_setImageDarkBalance" class="Sg"></a>
<a name="Set Dark White Balance   ---   pxe_setImageDarkBalance"></a>
<h6 class="Sg">Set Dark White Balance   ---   pxe_setImageDarkBalance</h6>
<a name="pxe_videoFieldCount NX820" class="NX"></a>
<a name="pxe_videoFieldCount" class="Sg"></a>
<a name="Get Video Field Count NX821" class="NX"></a>
<a name="Get Video Field Count   ---   pxe_videoFieldCount" class="Sg"></a>
<a name="Get Video Field Count   ---   pxe_videoFieldCount"></a>
<h6 class="Sg">Get Video Field Count   ---   pxe_videoFieldCount</h6>
<a name="pxe_videoFieldsPerFrame NX822" class="NX"></a>
<a name="pxe_videoFieldsPerFrame" class="Sg"></a>
<a name="Get Video Field Characteristic NX823" class="NX"></a>
<a name="Get Video Field Characteristic   ---   pxe_videoFieldsPerFrame" class="Sg"></a>
<a name="Get Video Field Characteristic   ---   pxe_videoFieldsPerFrame"></a>
<h6 class="Sg">Get Video Field Characteristic   ---   pxe_videoFieldsPerFrame</h6>
<a name="pxe_videoFieldsPerFrames NX824" class="NX"></a>
<a name="pxe_videoFieldsPerFrames" class="Sg"></a>
<a name="Get Video Field Characteristic NX825" class="NX"></a>
<a name="Get Video Field Characteristic   ---   pxe_videoFieldsPerFrames" class="Sg"></a>
<a name="Get Video Field Characteristic   ---   pxe_videoFieldsPerFrames"></a>
<h6 class="Sg">Get Video Field Characteristic   ---   pxe_videoFieldsPerFrames</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>pxvbtime_t        pxe_buffersFieldCount(instance,unitmap,buffer);
int               pxe_buffersGPIn(instance,unitmap,buffer);
uint32            pxe_buffersSysTicks(instance,unitmap,buffer);
int               pxe_buffersSysTicks2(instance,unitmap,buffer,ticks);
pxbuffer_t        pxe_capturedBuffer(instance,unitmap);
pxvbtime_t        pxe_capturedFieldCount(instance,unitmap);
uint32            pxe_capturedSysTicks(instance,unitmap);
int               pxe_setCameraLinkCCOut(instance,unitmap,setoutdata);
int               pxe_getCameraLinkCCOut(instance,unitmap,getoutdata);
struct pximage  * pxe_defineImage (instance,unitmap,framebuf,ulx,uly,lrx,lry,colorspace);
struct pximage3 * pxe_defineImage3(instance,unitmap,startbuf,endbuf,ulx,uly,lrx,lry,colorspace);
struct pximage  * pxe_definePximage (instance,unitmap,framebuf,ulx,uly,lrx,lry,colorspace);
struct pximage3 * pxe_definePximage3(instance,unitmap,startbuf,endbuf,ulx,uly,lrx,lry,colorspace);
void              pxe_definePximageFree(instance,image);
void              pxe_definePximage3Free(instance,image3)
int               pxe_doSnap(instance,unitmap,buffer,timeout);
HANDLE            pxe_eventFieldCreate(instance,unitmap);
HANDLE            pxe_eventFieldCreate2(instance,unitmap,type);
void              pxe_eventFieldClose(instance,unitmap,hEvent);
HANDLE            pxe_eventCapturedFieldCreate(instance,unitmap);
HANDLE            pxe_eventCapturedFieldCreate2(instance,unitmap,type);
void              pxe_eventCapturedFieldClose(instance,unitmap,hEvent);
HANDLE            pxe_eventGPTriggerCreate(instance,unitmap,which,rsvd);
HANDLE            pxe_eventGPTriggerCreate2(instance,unitmap,which,rsvd,type);
void              pxe_eventGPTriggerClose(instance,unitmap,which,rsvd,hEvent);
HANDLE            pxe_eventFaultCreate(instance,unitmap,rsvd);
HANDLE            pxe_eventFaultCreate2(instance,unitmap,rsvd,type);
void              pxe_eventFaultClose(instance,unitmap,rsvd,hEvent);
HANDLE            pxe_eventSerialCreate(instance,unitmap,serwhich,rsvd,type);
void              pxe_eventSerialClose(instance,unitmap,serwhich,rsvd,hEvent);
int               pxe_eventFieldCreate(instance,unitmap,irqfunc,statep);
int               pxe_eventFieldClose(instance,unitmap,irqfunc);
int               pxe_eventCapturedFieldCreate(instance,unitmap,irqfunc,statep);
int               pxe_eventCapturedFieldClose(instance,unitmap,irqfunc);
int               pxe_eventGPTriggerCreate(instance,unitmap,which,rsvd,irqfunc,statep);
int               pxe_eventGPTriggerClose(instance,unitmap,which,rsvd,irqfunc);
int               pxe_eventFaultCreate(instance,unitmap,rsvd,irqfunc,statep);
int               pxe_eventFaultClose(instance,unitmap,rsvd,irqfunc);
int               pxe_eventSerialCreate(instance,unitmap,serwhich,rsvd,irqfunc,statep);
int               pxe_eventSerialClose(instance,unitmap,serwhich,rsvd,irqfunc);
int               pxe_eventFieldCreate(instance,unitmap,signum,rsvd2);
int               pxe_eventFieldClose(instance,unitmap,signum);
int               pxe_eventCapturedFieldCreate(instance,unitmap,signum,rsvd2);
int               pxe_eventCapturedFieldClose(instance,unitmap,signum);
int               pxe_eventGPTriggerCreate(instance,unitmap,which,rsvd,signum,rsvd2);
int               pxe_eventGPTriggerClose(instance,unitmap,which,rsvd,signum);
int               pxe_eventFaultCreate(instance,unitmap,rsvd,signum,rsvd2);
int               pxe_eventFaultClose(instance,unitmap,rsvd,signum);
int               pxe_eventSerialCreate(instance,unitmap,serwhich,rsvd,signum,rsvd2);
int               pxe_eventSerialClose(instance,unitmap,serwhich,rsvd,signum);
int               pxe_getGPIn(instance,unitmap,getindata);
int               pxe_setGPIn(instance,unitmap,setindata);
int               pxe_setGPOut(instance,unitmap,setoutdata);
int               pxe_getGPOut(instance,unitmap,getoutdata);
int               pxe_getGPTrigger(instance,unitmap,which);
double            pxe_getBrightness(instance,unitmap);
double            pxe_getContrast(instance,unitmap);
double            pxe_getHue(instance,unitmap);
double            pxe_getUGain(instance,unitmap);
double            pxe_getVGain(instance,unitmap);
int               pxe_getVidMux(instance,unitmap);
int               pxe_goSnap(instance,unitmap,buffer);
int               pxe_goSnapPair(instance,unitmap,buffer1,buffer2);
int               pxe_goLive(instance,unitmap,buffer);
int               pxe_goLivePair(instance,unitmap,buffer,buffer2);
int               pxe_goLiveSeq(instance,unitmap,startbuf,endbuf,incbuf,numbuf,videoperiod);
int               pxe_goUnLive(instance,unitmap);
int               pxe_goAbortLive(instance,unitmap);
int               pxe_goLiveTrig(instance,unitmap,buffer,
                                gpin10mask,gpout20value,gpout20mask,gpout20when,
                                gpin30wait,gpin30mask,gpout40value,gpout40mask,
                                option50,field50,gpout50value,gpout50mask,delay60,
                                gpout60value,gpout60mask,delay70,field70,capture70,
                                gpin80mask,gpout80value,gpout80mask);
int               pxe_goLiveSeqTrig(instance,int unitmap,startbuf,endbuf,incbuf,numbuf,videoperiod,
                                rsvd1,rsvd2,trig20wait,trig20slct,trig20delay,rsvd3,rsvd4,
                                rsvd5,rsvd6,rsvd7,rsvd8,rsvd9,trig40wait,trig40slct,
                                trig40delay,rsvd10,rsvd11,rsvd12,rsvd13,rsvd14,rsvd15);
int               pxe_goneLive(instance,unitmap,rsvd);
double            pxe_imageAspectRatio(instance);
int               pxe_imageBdim(instance);
int               pxe_imageCdim(instance);
int               pxe_imageIdim(instance);
int               pxe_imageXdim(instance)
int               pxe_imageYdim(instance);
int               pxe_imageZdim(instance);
double            pxe_imageAspectRatios(instance,unitmap);
int               pxe_imageBdims(instance,unitmap);
int               pxe_imageCdims(instance,unitmap);
int               pxe_imageIdims(instance,unitmap);
int               pxe_imageXdims(instance,unitmap)
int               pxe_imageYdims(instance,unitmap);
int               pxe_imageZdims(instance,unitmap);
char*             pxe_infoDriverId(instance);
char*             pxe_infoLibraryId(instance);
ulong             pxe_infoMemsize(instance,unitmap);    // Under 32 bit Windows &amp; Linux
uint64            pxe_infoMemsize(instance,unitmap);    // Under 64 bit Windows &amp; Linux
int               pxe_infoModel(instance,unitmap);
int               pxe_infoSubmodel(instance,unitmap);
int               pxe_infoUnits(instance);
int               pxe_loadBmp(instance,unitmap,pathname,framebuf,ulx,uly,lrx,lry,loadmode,options);
int               pxe_loadTiff(instance,unitmap,pathname,framebuf,ulx,uly,lrx,lry,loadmode,options);
int               pxe_saveBmp(instance,unitmap,pathname,framebuf,ulx,uly,lrx,lry,savemode,options);
int               pxe_savePcx(instance,unitmap,pathname,framebuf,ulx,uly,lrx,lry,savemode,options);
int               pxe_saveTga(instance,unitmap,pathname,framebuf,ulx,uly,lrx,lry,savemode,options);
int               pxe_saveTiff(instance,unitmap,pathname,framebuf,ulx,uly,lrx,lry,savemode,options);
int               pxe_loadRawBuffers(instance,unitmap,pathname,startbuf,endbuf,filehandle,fileoffset,alignment,options);
int               pxe_saveRawBuffers(instance,unitmap,pathname,startbuf,endbuf,filehandle,fileoffset,alignment,options);
int               pxe_mesgFault(instance,unitmap);
int               pxe_mesgFaultText(instance,unitmap,buf,bufsize);
int               pxe_PIXCIopen(instance,driverparms,formatname,formatfile);
int               pxe_PIXCIclose(instance);
int               pxe_readuchar(instance,unitmap,framebuf,ulx,uly,lrx,lry,membuf,cnt,colorspace);
int               pxe_readushort(instance,unitmap,framebuf,ulx,uly,lrx,lry,membuf,cnt,colorspace);
int               pxe_writeuchar(instance,unitmap,framebuf,ulx,uly,lrx,lry,membuf,cnt,colorspace);
int               pxe_writeushort(instance,unitmap,framebuf,ulx,uly,lrx,lry,membuf,cnt,colorspace);
HGLOBAL           pxe_renderDIBCreate(instance,unitmap,framebuf,ulx,uly,lrx,lry,mode,options);
int               pxe_renderDIBFree(instance,hDIB);
int               pxe_renderDirectVideoInit(instance,unitmap,hWnd);
int               pxe_renderDirectVideoDone(instance,unitmap,hWnd);
int               pxe_renderDirectVideoLive(instance,unitmap,hWnd,nX,nY,nWidth,nHeight,ClrKey1,ClrKey2);
int               pxe_renderDirectVideoUnLive(instance,unitmap,hWnd);
int               pxe_renderStretchDIBits(instance,unitmap,buffer,ulx,uly,lrx,lry,options,hDC,nX,nY,nWidth,nHeight,winoptions);
int               pxe_serialConfigure(instance,unitmap,rsvd0,baud,bits,parity,stopbits,rsvd1,rsvd2,rsvd3);
int               pxe_serialRead(instance,unitmap,rsvd0,data,cnt);
int               pxe_serialWrite(instance,unitmap,rsvd0,data,cnt);
int               pxe_setExsyncPrin(instance,unitmap,exsync,prin);
uint              pxe_getExsync(instance,unitmap);
uint              pxe_getPrin(instance,unitmap);
int               pxe_setExsyncPrincMode(instance,unitmap,exsyncbits,princbits);
uint              pxe_getExsyncMode(instance,unitmap);
uint              pxe_getPrincMode(instance,unitmap);
int               pxe_setVidMux(instance,unitmap,inmux);
int               pxe_setContrastBrightness(instance,unitmap,contrast,brightness);
int               pxe_setHueSaturation(instance,unitmap,hue,Ugain,Vgain);
int               pxe_setImageDarkBalance(instance,unitmap,referenceRGB[3],targetRGB[3],gamma);
int               pxe_setImageBrightBalance(instance,unitmap,referenceRGB[3],targetRGB[3],gamma);
pxvbtime_t        pxe_videoFieldCount(instance,unitmap);
int               pxe_videoFieldsPerFrame(instance);
int               pxe_videoFieldsPerFrames(instance,unitmap);
<br>
pxdstate_s *      instance;         // Library instance
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Each of these
<a href="#pxe_" class="Er">pxe_</a>
functions has the same functionality
as the corresponding
<a href="#pxd_" class="Er">pxd_</a>
function,
except the former uses an explicit
instance of the PIXCI® XCLIB Library
and has an extra
<em class="Ep">instance</em>
parameter
as provided by
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>,
while the latter uses an implicit
instance of the PIXCI® XCLIB Library.
</p><p>
An explicit instance of the PIXCI® XCLIB Library
is needed to use the various
<a href="#pxe_" class="Er">pxe_</a>
style functions and allow opening and using
multiple imaging boards of different types.
In contrast, the slightly simpler
<a href="#pxd_" class="Er">pxd_</a>
functions use an implicit instance of the PIXCI® XCLIB Library,
but can only operate multiple imaging boards of the same type.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
See the correspond
<a href="#pxd_" class="Er">pxd_</a>
functions.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
See
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>.
</p><hr size="1">
<a name="pxe_SILICONVIDEO_setExposureGainOffset NX826" class="NX"></a>
<a name="pxe_SILICONVIDEO_setExposureGainOffset" class="Sf"></a>
<a name="Set SILICON VIDEO Exposure, Gain, and Offset NX827" class="NX"></a>
<a name="Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxe_SILICONVIDEO_setExposureGainOffset" class="Sf"></a>
<a name="Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxe_SILICONVIDEO_setExposureGainOffset"></a>
<h6 class="Sf">Set SILICON VIDEO Exposure, Gain, and Offset   ---   pxe_SILICONVIDEO_setExposureGainOffset</h6>
<a name="pxe_SILICONVIDEO_setExposureColorGainOffsets NX828" class="NX"></a>
<a name="pxe_SILICONVIDEO_setExposureColorGainOffsets" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure, Gains, and Offsets NX829" class="NX"></a>
<a name="Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxe_SILICONVIDEO_setExposureColorGainOffsets" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxe_SILICONVIDEO_setExposureColorGainOffsets"></a>
<h6 class="Sg">Set SILICON VIDEO Exposure, Gains, and Offsets   ---   pxe_SILICONVIDEO_setExposureColorGainOffsets</h6>
<a name="pxe_SILICONVIDEO_setExposure NX830" class="NX"></a>
<a name="pxe_SILICONVIDEO_setExposure" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure NX831" class="NX"></a>
<a name="Set SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_setExposure" class="Sg"></a>
<a name="Set SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_setExposure"></a>
<h6 class="Sg">Set SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_setExposure</h6>
<a name="pxe_SILICONVIDEO_getExposure NX832" class="NX"></a>
<a name="pxe_SILICONVIDEO_getExposure" class="Sg"></a>
<a name="Get SILICON VIDEO Exposure NX833" class="NX"></a>
<a name="Get SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_getExposure" class="Sg"></a>
<a name="Get SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_getExposure"></a>
<h6 class="Sg">Get SILICON VIDEO Exposure   ---   pxe_SILICONVIDEO_getExposure</h6>
<a name="pxe_SILICONVIDEO_getGainA NX834" class="NX"></a>
<a name="pxe_SILICONVIDEO_getGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Gain A NX835" class="NX"></a>
<a name="Get SILICON VIDEO Gain A   ---   pxe_SILICONVIDEO_getGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Gain A   ---   pxe_SILICONVIDEO_getGainA"></a>
<h6 class="Sg">Get SILICON VIDEO Gain A   ---   pxe_SILICONVIDEO_getGainA</h6>
<a name="pxe_SILICONVIDEO_getGainB NX836" class="NX"></a>
<a name="pxe_SILICONVIDEO_getGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Gain B NX837" class="NX"></a>
<a name="Get SILICON VIDEO Gain B   ---   pxe_SILICONVIDEO_getGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Gain B   ---   pxe_SILICONVIDEO_getGainB"></a>
<h6 class="Sg">Get SILICON VIDEO Gain B   ---   pxe_SILICONVIDEO_getGainB</h6>
<a name="pxe_SILICONVIDEO_getGainsA NX838" class="NX"></a>
<a name="pxe_SILICONVIDEO_getGainsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains A NX839" class="NX"></a>
<a name="Get SILICON VIDEO Color Gains A   ---   pxe_SILICONVIDEO_getGainsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains A   ---   pxe_SILICONVIDEO_getGainsA"></a>
<h6 class="Sg">Get SILICON VIDEO Color Gains A   ---   pxe_SILICONVIDEO_getGainsA</h6>
<a name="pxe_SILICONVIDEO_getGainsB NX840" class="NX"></a>
<a name="pxe_SILICONVIDEO_getGainsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains B NX841" class="NX"></a>
<a name="Get SILICON VIDEO Color Gains B   ---   pxe_SILICONVIDEO_getGainsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Gains B   ---   pxe_SILICONVIDEO_getGainsB"></a>
<h6 class="Sg">Get SILICON VIDEO Color Gains B   ---   pxe_SILICONVIDEO_getGainsB</h6>
<a name="pxe_SILICONVIDEO_getOffsetsA NX842" class="NX"></a>
<a name="pxe_SILICONVIDEO_getOffsetsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets A NX843" class="NX"></a>
<a name="Get SILICON VIDEO Color Offsets A   ---   pxe_SILICONVIDEO_getOffsetsA" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets A   ---   pxe_SILICONVIDEO_getOffsetsA"></a>
<h6 class="Sg">Get SILICON VIDEO Color Offsets A   ---   pxe_SILICONVIDEO_getOffsetsA</h6>
<a name="pxe_SILICONVIDEO_getOffsetsB NX844" class="NX"></a>
<a name="pxe_SILICONVIDEO_getOffsetsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets B NX845" class="NX"></a>
<a name="Get SILICON VIDEO Color Offsets B   ---   pxe_SILICONVIDEO_getOffsetsB" class="Sg"></a>
<a name="Get SILICON VIDEO Color Offsets B   ---   pxe_SILICONVIDEO_getOffsetsB"></a>
<h6 class="Sg">Get SILICON VIDEO Color Offsets B   ---   pxe_SILICONVIDEO_getOffsetsB</h6>
<a name="pxe_SILICONVIDEO_setResolutionAndTiming NX846" class="NX"></a>
<a name="pxe_SILICONVIDEO_setResolutionAndTiming" class="Sg"></a>
<a name="Set SILICON VIDEO Resolution and Timing NX847" class="NX"></a>
<a name="Set SILICON VIDEO Resolution and Timing   ---   pxe_SILICONVIDEO_setResolutionAndTiming" class="Sg"></a>
<a name="Set SILICON VIDEO Resolution and Timing   ---   pxe_SILICONVIDEO_setResolutionAndTiming"></a>
<h6 class="Sg">Set SILICON VIDEO Resolution and Timing   ---   pxe_SILICONVIDEO_setResolutionAndTiming</h6>
<a name="pxe_SILICONVIDEO_getSubsample NX848" class="NX"></a>
<a name="pxe_SILICONVIDEO_getSubsample" class="Sg"></a>
<a name="Get SILICON VIDEO Subsample NX849" class="NX"></a>
<a name="Get SILICON VIDEO Subsample   ---   pxe_SILICONVIDEO_getSubsample" class="Sg"></a>
<a name="Get SILICON VIDEO Subsample   ---   pxe_SILICONVIDEO_getSubsample"></a>
<h6 class="Sg">Get SILICON VIDEO Subsample   ---   pxe_SILICONVIDEO_getSubsample</h6>
<a name="pxe_SILICONVIDEO_getAoiLeft NX850" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAoiLeft" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Left Edge NX851" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Left Edge   ---   pxe_SILICONVIDEO_getAoiLeft" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Left Edge   ---   pxe_SILICONVIDEO_getAoiLeft"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Left Edge   ---   pxe_SILICONVIDEO_getAoiLeft</h6>
<a name="pxe_SILICONVIDEO_getAoiTop NX852" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Top Edge NX853" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Top Edge   ---   pxe_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Top Edge   ---   pxe_SILICONVIDEO_getAoiTop"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Top Edge   ---   pxe_SILICONVIDEO_getAoiTop</h6>
<a name="pxe_SILICONVIDEO_getAoiTop NX854" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Width NX855" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Width   ---   pxe_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Width   ---   pxe_SILICONVIDEO_getAoiTop"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Width   ---   pxe_SILICONVIDEO_getAoiTop</h6>
<a name="pxe_SILICONVIDEO_getAoiTop NX856" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Height NX857" class="NX"></a>
<a name="Get SILICON VIDEO Aoi Height   ---   pxe_SILICONVIDEO_getAoiTop" class="Sg"></a>
<a name="Get SILICON VIDEO Aoi Height   ---   pxe_SILICONVIDEO_getAoiTop"></a>
<h6 class="Sg">Get SILICON VIDEO Aoi Height   ---   pxe_SILICONVIDEO_getAoiTop</h6>
<a name="pxe_SILICONVIDEO_getScanDirection NX858" class="NX"></a>
<a name="pxe_SILICONVIDEO_getScanDirection" class="Sg"></a>
<a name="Get SILICON VIDEO Scan Direction NX859" class="NX"></a>
<a name="Get SILICON VIDEO Scan Direction   ---   pxe_SILICONVIDEO_getScanDirection" class="Sg"></a>
<a name="Get SILICON VIDEO Scan Direction   ---   pxe_SILICONVIDEO_getScanDirection"></a>
<h6 class="Sg">Get SILICON VIDEO Scan Direction   ---   pxe_SILICONVIDEO_getScanDirection</h6>
<a name="pxe_SILICONVIDEO_getPixelClock NX860" class="NX"></a>
<a name="pxe_SILICONVIDEO_getPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Pixel Clock Frequency NX861" class="NX"></a>
<a name="Get SILICON VIDEO Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getPixelClock"></a>
<h6 class="Sg">Get SILICON VIDEO Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getPixelClock</h6>
<a name="pxe_SILICONVIDEO_getFramePeriod NX862" class="NX"></a>
<a name="pxe_SILICONVIDEO_getFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Frame Period NX863" class="NX"></a>
<a name="Get SILICON VIDEO Frame Period   ---   pxe_SILICONVIDEO_getFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Frame Period   ---   pxe_SILICONVIDEO_getFramePeriod"></a>
<h6 class="Sg">Get SILICON VIDEO Frame Period   ---   pxe_SILICONVIDEO_getFramePeriod</h6>
<a name="pxe_SILICONVIDEO_setVideoAndTriggerMode NX864" class="NX"></a>
<a name="pxe_SILICONVIDEO_setVideoAndTriggerMode" class="Sg"></a>
<a name="Set SILICON VIDEO Video And Trigger Modes NX865" class="NX"></a>
<a name="Set SILICON VIDEO Video And Trigger Modes   ---   pxe_SILICONVIDEO_setVideoAndTriggerMode" class="Sg"></a>
<a name="Set SILICON VIDEO Video And Trigger Modes   ---   pxe_SILICONVIDEO_setVideoAndTriggerMode"></a>
<h6 class="Sg">Set SILICON VIDEO Video And Trigger Modes   ---   pxe_SILICONVIDEO_setVideoAndTriggerMode</h6>
<a name="pxe_SILICONVIDEO_setCtrlRates NX866" class="NX"></a>
<a name="pxe_SILICONVIDEO_setCtrlRates" class="Sg"></a>
<a name="Set SILICON VIDEO Controlled Rates NX867" class="NX"></a>
<a name="Set SILICON VIDEO Controlled Rates   ---   pxe_SILICONVIDEO_setCtrlRates" class="Sg"></a>
<a name="Set SILICON VIDEO Controlled Rates   ---   pxe_SILICONVIDEO_setCtrlRates"></a>
<h6 class="Sg">Set SILICON VIDEO Controlled Rates   ---   pxe_SILICONVIDEO_setCtrlRates</h6>
<a name="pxe_SILICONVIDEO_getVideoMode NX868" class="NX"></a>
<a name="pxe_SILICONVIDEO_getVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Video Mode NX869" class="NX"></a>
<a name="Get SILICON VIDEO Video Mode   ---   pxe_SILICONVIDEO_getVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Video Mode   ---   pxe_SILICONVIDEO_getVideoMode"></a>
<h6 class="Sg">Get SILICON VIDEO Video Mode   ---   pxe_SILICONVIDEO_getVideoMode</h6>
<a name="pxe_SILICONVIDEO_getCtrlVideoMode NX870" class="NX"></a>
<a name="pxe_SILICONVIDEO_getCtrlVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Video Mode NX871" class="NX"></a>
<a name="Get SILICON VIDEO Controlled Video Mode   ---   pxe_SILICONVIDEO_getCtrlVideoMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Video Mode   ---   pxe_SILICONVIDEO_getCtrlVideoMode"></a>
<h6 class="Sg">Get SILICON VIDEO Controlled Video Mode   ---   pxe_SILICONVIDEO_getCtrlVideoMode</h6>
<a name="pxe_SILICONVIDEO_getCtrlTriggerMode NX872" class="NX"></a>
<a name="pxe_SILICONVIDEO_getCtrlTriggerMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Trigger Mode NX873" class="NX"></a>
<a name="Get SILICON VIDEO Controlled Trigger Mode   ---   pxe_SILICONVIDEO_getCtrlTriggerMode" class="Sg"></a>
<a name="Get SILICON VIDEO Controlled Trigger Mode   ---   pxe_SILICONVIDEO_getCtrlTriggerMode"></a>
<h6 class="Sg">Get SILICON VIDEO Controlled Trigger Mode   ---   pxe_SILICONVIDEO_getCtrlTriggerMode</h6>
<a name="pxe_SILICONVIDEO_setAxC NX874" class="NX"></a>
<a name="pxe_SILICONVIDEO_setAxC" class="Sg"></a>
<a name="Set SILICON VIDEO AGC and AEC NX875" class="NX"></a>
<a name="Set SILICON VIDEO AGC and AEC   ---   pxe_SILICONVIDEO_setAxC" class="Sg"></a>
<a name="Set SILICON VIDEO AGC and AEC   ---   pxe_SILICONVIDEO_setAxC"></a>
<h6 class="Sg">Set SILICON VIDEO AGC and AEC   ---   pxe_SILICONVIDEO_setAxC</h6>
<a name="pxe_SILICONVIDEO_getAgcA NX876" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO AGC A Gain NX877" class="NX"></a>
<a name="Get SILICON VIDEO AGC A Gain   ---   pxe_SILICONVIDEO_getAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO AGC A Gain   ---   pxe_SILICONVIDEO_getAgcA"></a>
<h6 class="Sg">Get SILICON VIDEO AGC A Gain   ---   pxe_SILICONVIDEO_getAgcA</h6>
<a name="pxe_SILICONVIDEO_getAgcB NX878" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO AGC B Gain NX879" class="NX"></a>
<a name="Get SILICON VIDEO AGC B Gain   ---   pxe_SILICONVIDEO_getAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO AGC B Gain   ---   pxe_SILICONVIDEO_getAgcB"></a>
<h6 class="Sg">Get SILICON VIDEO AGC B Gain   ---   pxe_SILICONVIDEO_getAgcB</h6>
<a name="pxe_SILICONVIDEO_getAec NX880" class="NX"></a>
<a name="pxe_SILICONVIDEO_getAec" class="Sg"></a>
<a name="Get SILICON VIDEO AEC Exposure NX881" class="NX"></a>
<a name="Get SILICON VIDEO AEC Exposure   ---   pxe_SILICONVIDEO_getAec" class="Sg"></a>
<a name="Get SILICON VIDEO AEC Exposure   ---   pxe_SILICONVIDEO_getAec"></a>
<h6 class="Sg">Get SILICON VIDEO AEC Exposure   ---   pxe_SILICONVIDEO_getAec</h6>
<a name="pxe_SILICONVIDEO_getMinMaxExposure NX882" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxExposure" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Exposure NX883" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Exposure   ---   pxe_SILICONVIDEO_getMinMaxExposure" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Exposure   ---   pxe_SILICONVIDEO_getMinMaxExposure"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Exposure   ---   pxe_SILICONVIDEO_getMinMaxExposure</h6>
<a name="pxe_SILICONVIDEO_getMinMaxFramePeriod NX884" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Frame Period NX885" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Frame Period   ---   pxe_SILICONVIDEO_getMinMaxFramePeriod" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Frame Period   ---   pxe_SILICONVIDEO_getMinMaxFramePeriod"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Frame Period   ---   pxe_SILICONVIDEO_getMinMaxFramePeriod</h6>
<a name="pxe_SILICONVIDEO_getMinMaxCtrlFrameRate NX886" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxCtrlFrameRate" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Controlled Frame Rate NX887" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxe_SILICONVIDEO_getMinMaxCtrlFrameRate" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxe_SILICONVIDEO_getMinMaxCtrlFrameRate"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Controlled Frame Rate   ---   pxe_SILICONVIDEO_getMinMaxCtrlFrameRate</h6>
<a name="pxe_SILICONVIDEO_getMinMaxPixelClock NX888" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Pixel Clock Frequency NX889" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getMinMaxPixelClock" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getMinMaxPixelClock"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Pixel Clock Frequency   ---   pxe_SILICONVIDEO_getMinMaxPixelClock</h6>
<a name="pxe_SILICONVIDEO_getMinMaxGainA NX890" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain A NX891" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Gain A   ---   pxe_SILICONVIDEO_getMinMaxGainA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain A   ---   pxe_SILICONVIDEO_getMinMaxGainA"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Gain A   ---   pxe_SILICONVIDEO_getMinMaxGainA</h6>
<a name="pxe_SILICONVIDEO_getMinMaxGainB NX892" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain B NX893" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Gain B   ---   pxe_SILICONVIDEO_getMinMaxGainB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Gain B   ---   pxe_SILICONVIDEO_getMinMaxGainB"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Gain B   ---   pxe_SILICONVIDEO_getMinMaxGainB</h6>
<a name="pxe_SILICONVIDEO_getMinMaxOffsetA NX894" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxOffsetA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset A NX895" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Offset A   ---   pxe_SILICONVIDEO_getMinMaxOffsetA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset A   ---   pxe_SILICONVIDEO_getMinMaxOffsetA"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Offset A   ---   pxe_SILICONVIDEO_getMinMaxOffsetA</h6>
<a name="pxe_SILICONVIDEO_getMinMaxOffsetB NX896" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxOffsetB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset B NX897" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max Offset B   ---   pxe_SILICONVIDEO_getMinMaxOffsetB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max Offset B   ---   pxe_SILICONVIDEO_getMinMaxOffsetB"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max Offset B   ---   pxe_SILICONVIDEO_getMinMaxOffsetB</h6>
<a name="pxe_SILICONVIDEO_getMinMaxAoiWidth NX898" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxAoiWidth" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Width NX899" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AOI Width   ---   pxe_SILICONVIDEO_getMinMaxAoiWidth" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Width   ---   pxe_SILICONVIDEO_getMinMaxAoiWidth"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AOI Width   ---   pxe_SILICONVIDEO_getMinMaxAoiWidth</h6>
<a name="pxe_SILICONVIDEO_getMinMaxAoiHeight NX900" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxAoiHeight" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Height NX901" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AOI Height   ---   pxe_SILICONVIDEO_getMinMaxAoiHeight" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AOI Height   ---   pxe_SILICONVIDEO_getMinMaxAoiHeight"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AOI Height   ---   pxe_SILICONVIDEO_getMinMaxAoiHeight</h6>
<a name="pxe_SILICONVIDEO_getMinMaxAgcA NX902" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC A Gain NX903" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AGC A Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcA" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC A Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcA"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AGC A Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcA</h6>
<a name="pxe_SILICONVIDEO_getMinMaxAgcB NX904" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC B Gain NX905" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AGC B Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcB" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AGC B Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcB"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AGC B Gain   ---   pxe_SILICONVIDEO_getMinMaxAgcB</h6>
<a name="pxe_SILICONVIDEO_getMinMaxAec NX906" class="NX"></a>
<a name="pxe_SILICONVIDEO_getMinMaxAec" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AEC Exposure NX907" class="NX"></a>
<a name="Get SILICON VIDEO Min/Max AEC Exposure   ---   pxe_SILICONVIDEO_getMinMaxAec" class="Sg"></a>
<a name="Get SILICON VIDEO Min/Max AEC Exposure   ---   pxe_SILICONVIDEO_getMinMaxAec"></a>
<h6 class="Sg">Get SILICON VIDEO Min/Max AEC Exposure   ---   pxe_SILICONVIDEO_getMinMaxAec</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int               pxe_SILICONVIDEO_setExposureGainOffset(instance,unitmap,rsvd,exposure,gainA,offsetA,
                                gainB,offsetB);
int               pxe_SILICONVIDEO_setExposureColorGainOffsets(instance,unitmap,rsvd,exposure,
                                gainsA,gainsB,offsetsA,offsetsB);
double            pxe_SILICONVIDEO_getExposure(instance,unitmap);
double            pxe_SILICONVIDEO_getGainA(instance,unitmap);
double            pxe_SILICONVIDEO_getGainB(instance,unitmap);
int               pxe_SILICONVIDEO_getGainsA(instance,unitmap,gainsA);
int               pxe_SILICONVIDEO_getGainsB(instance,unitmap,gainsB);
int               pxe_SILICONVIDEO_getOffsetsA(instance,unitmap,offsetsA[4]);
int               pxe_SILICONVIDEO_getOffsetsB(instance,unitmap,offsetsB[4]);
int               pxe_SILICONVIDEO_setResolutionAndTiming(instance,unitmap,rsvd1,subsample,aoileft,aoitop,aoiwidth,
                                aoiheight,scandirection,bitdepth,rsvd3,rsvd4,pixelClkFreq,
                                framePeriod,rsvd5,rsvd6,rsvd7);
int               pxe_SILICONVIDEO_getSubsample(instance,unitmap);
int               pxe_SILICONVIDEO_getAoiLeft(instance,unitmap);
int               pxe_SILICONVIDEO_getAoiTop(instance,unitmap);
int               pxe_SILICONVIDEO_getAoiWidth(instance,unitmap);
int               pxe_SILICONVIDEO_getAoiHeight(instance,unitmap);
int               pxe_SILICONVIDEO_getScanDirection(instance,unitmap);
double            pxe_SILICONVIDEO_getPixelClock(instance,unitmap);
double            pxe_SILICONVIDEO_getFramePeriod(instance,unitmap);
int               pxe_SILICONVIDEO_setVideoAndTriggerMode(instance,unitmap,rsvd,videomode,controlledmode,
                                controlledtrigger,strobemode,rsvd2,rsvd3,rsvd4);
int               pxe_SILICONVIDEO_setCtrlRates(instance,unitmap,rsvd,rsvd11,framerate,rsvd12,rsvd13,rsvd14);
int               pxe_SILICONVIDEO_getVideoMode(instance,unitmap);
int               pxe_SILICONVIDEO_getCtrlVideoMode(instance,unitmap);
int               pxe_SILICONVIDEO_getCtrlTriggerMode(instance,unitmap);
double            pxe_SILICONVIDEO_getCtrlFrameRate(instance,unitmap);
int               pxe_SILICONVIDEO_setAxC(instance,unitmap,rsvd,agcA,agcB,rsvd2,rsvd3,aec,
                                                         rsvd4,rsvd5,rsvd6,rsvd7);
int               pxe_SILICONVIDEO_getAgcA(instance,unitmap);
int               pxe_SILICONVIDEO_getAgcB(instance,unitmap);
int               pxe_SILICONVIDEO_getAec(instance,unitmap);
double            pxe_SILICONVIDEO_getMinMaxExposure(instance,unitmap,exposure);
double            pxe_SILICONVIDEO_getMinMaxFramePeriod(instance,unitmap,framePeriod);
double            pxe_SILICONVIDEO_getMinMaxCtrlFrameRate(instance,unitmap,frameRate);
double            pxe_SILICONVIDEO_getMinMaxPixelClock(instance,unitmap,pixelClkFreq);
double            pxe_SILICONVIDEO_getMinMaxGainA(instance,unitmap,gainA);
double            pxe_SILICONVIDEO_getMinMaxGainB(instance,unitmap,gainB);
double            pxe_SILICONVIDEO_getMinMaxOffsetA(instance,unitmap,offsetA);
double            pxe_SILICONVIDEO_getMinMaxOffsetB(instance,unitmap,offsetB);
int               pxe_SILICONVIDEO_getMinMaxAoiWidth(instance,unitmap,aoiwidth);
int               pxe_SILICONVIDEO_getMinMaxAoiHeight(instance,unitmap,aoiheight);
int               pxe_SILICONVIDEO_getMinMaxAgcA(instance,unitmap,agcA);
int               pxe_SILICONVIDEO_getMinMaxAgcB(instance,unitmap,agcB);
int               pxe_SILICONVIDEO_getMinMaxAec(instance,unitmap,aec);
<br>
pxdstate_s *      instance;         // Library instance
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Each of these
<a href="#pxe_" class="Er">pxe_</a>
functions has the same functionality
as the corresponding
<a href="#pxd_" class="Er">pxd_</a>
function,
except the former uses an explicit
instance of the PIXCI® XCLIB Library
and has an extra
<em class="Ep">instance</em>
parameter
as provided by
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>,
while the latter uses an implicit
instance of the PIXCI® XCLIB Library.
</p><p>
An explicit instance of the PIXCI® XCLIB Library
is needed to use the various
<a href="#pxe_" class="Er">pxe_</a>
style functions and allow opening and using
multiple imaging boards of different types.
In contrast, the slightly simpler
<a href="#pxd_" class="Er">pxd_</a>
functions use an implicit instance of the PIXCI® XCLIB Library,
but can only operate multiple imaging boards of the same type.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
See the correspond
<a href="#pxd_" class="Er">pxd_</a>
functions.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
See
<a href="#pxe_XCLIBinstantiate" class="Er">pxe_XCLIBinstantiate</a>.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Open, Close, Information, and Fault Services" class="Ch"></a>
<a name="5.  Structured Style Interface - Open, Close, Information, and Fault Services"></a>
</p><h1>5.  Structured Style Interface - Open, Close, Information, and Fault Services</h1>
<p>
The Open, Close, Information, and Fault services
open the library for use, close the library after use,
identify the types of imaging board(s) and/or functional units present
as well as the versions of library and driver,
and provide descriptions of operational faults.<a href="#Footnote%2031" class="Ff"><sup>[31]</sup></a>
</p><hr size="1">
<a name="xclib_libincid NX908" class="NX"></a>
<a name="xclib_libincid" class="Sf"></a>
<a name="Get Imaging Board Include Files ID NX909" class="NX"></a>
<a name="Get Imaging Board Include Files ID   ---   xclib_libincid" class="Sf"></a>
<a name="Get Imaging Board Include Files ID   ---   xclib_libincid"></a>
<h6 class="Sf">Get Imaging Board Include Files ID   ---   xclib_libincid</h6>
<a name="xclib_liblibid NX910" class="NX"></a>
<a name="xclib_liblibid" class="Sg"></a>
<a name="Get Imaging Board Library ID NX911" class="NX"></a>
<a name="Get Imaging Board Library ID   ---   xclib_liblibid" class="Sg"></a>
<a name="Get Imaging Board Library ID   ---   xclib_liblibid"></a>
<h6 class="Sg">Get Imaging Board Library ID   ---   xclib_liblibid</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int     xclib_liblibid(info);
#define xclib_libincid(info)
<br>
struct pxdevinfo    *info;          // Only 'libraryid' field used
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#xclib_liblibid" class="Er">xclib_liblibid</a>
fills the
<em class="Ep">libraryid</em>
field of the
<em class="Ep">info</em>
instance of the
<a href="#pxdevinfo" class="Er">pxdevinfo</a>
structure with an identification string of the current
imaging board library.
</p><p>
The
<a href="#xclib_libincid" class="Er">xclib_libincid</a>
fills the
<em class="Ep">libraryid</em>
field of the
<em class="Ep">info</em>
instance of the
<a href="#pxdevinfo" class="Er">pxdevinfo</a>
structure with an identification string of the current
include (i.e.
''.h'')
files.
</p><p>
Both
<a href="#xclib_liblibid" class="Er">xclib_liblibid</a>
and
<a href="#xclib_libincid" class="Er">xclib_libincid</a>
may be used with the XCLIB library closed.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">info</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect
(<a href="#xclib_liblibid" class="Er">xclib_liblibid</a>
only).
</dd></dl>
<hr size="1">
<a name="xclib_open NX912" class="NX"></a>
<a name="xclib_open" class="Sf"></a>
<a name="PIXCI® Imaging Board: Structured Open NX913" class="NX"></a>
<a name="PIXCI® Imaging Board: Structured Open   ---   xclib_open" class="Sf"></a>
<a name="PIXCI® Imaging Board: Structured Open   ---   xclib_open"></a>
<h6 class="Sf">PIXCI® Imaging Board: Structured Open   ---   xclib_open</h6>
<a name="xclib_close NX914" class="NX"></a>
<a name="xclib_close" class="Sg"></a>
<a name="PIXCI® Imaging Board: Structured Close NX915" class="NX"></a>
<a name="PIXCI® Imaging Board: Structured Close   ---   xclib_close" class="Sg"></a>
<a name="PIXCI® Imaging Board: Structured Close   ---   xclib_close"></a>
<h6 class="Sg">PIXCI® Imaging Board: Structured Close   ---   xclib_close</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int xclib_open (xclib, drivermodes, driverparms, formatname, formatfile);
int xclib_close(xclib);
<br>
struct xclibs       *xclib;         // Existing instance of struct xclibs
char                *drivermodes;   // Driver open mode
char                *driverparms;   // Driver configuration parms, or NULL or ""
char                *formatname;    // Video format configuration name, or NULL or ""
char                *formatfile;    // Video format configuration file name, or NULL or ""
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#xclib_open" class="Er">xclib_open</a>
opens the PIXCI® XCLIB Library and Driver for use.
The
<em class="Ep">xclib</em>
instance
of the
<a href="#xclibs" class="Er">xclibs</a>
structure, provided by the application, is initialized by
<a href="#xclib_open" class="Er">xclib_open</a>;
thereafter library and driver services are accessed through
function pointers within the
<em class="Ep">xclib</em>.
Once open, the PIXCI® library and driver
should be closed by
<a href="#xclib_close" class="Er">xclib_close</a>
upon the same
<em class="Ep">xclib</em>
before the program exits;
most services accessed through the same
<em class="Ep">xclib</em>
after closing return a PXERNOTOPEN error.
</p><p>
If
<em class="Ep">drivermodes</em>=NULL
or
<em class="Ep">drivermodes</em>=""<em class="Ep">,</em>
the library, driver, and imaging boards(s)
are open for use.
</p><p>
If
<em class="Ep">drivermodes</em>
contains the string "-offline",
the library is opened only for use of off-line services, namely:
<a href="#::allocStateCopy" class="Er">::allocStateCopy</a>,
<a href="#::compareStateCopy" class="Er">::compareStateCopy</a>,
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>,
<a href="#::freeStateCopy" class="Er">::freeStateCopy</a>,
<a href="#::importStateCopy" class="Er">::importStateCopy</a>,
<a href="#::initStateCopy" class="Er">::initStateCopy</a>,
and
<a href="#::errorCodeString" class="Er">::errorCodeString</a>.
The driver and/or imaging board need not be present.
</p><p>
If
<em class="Ep">drivermodes</em>
contains the string "-configure",
the library and driver is opened only for use of configuration services, namely:
<a href="#::allocStateCopy" class="Er">::allocStateCopy</a>,
<a href="#::compareStateCopy" class="Er">::compareStateCopy</a>,
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>,
<a href="#::freeStateCopy" class="Er">::freeStateCopy</a>,
<a href="#::importStateCopy" class="Er">::importStateCopy</a>,
<a href="#::initStateCopy" class="Er">::initStateCopy</a>,
<a href="#::setDevParms" class="Er">::setDevParms</a>,
<a href="#::getDevParms" class="Er">::getDevParms</a>,
and
<a href="#::errorCodeString" class="Er">::errorCodeString</a>.
</p><p>
The
<em class="Ep">driverparms</em>
may be a Driver Configuration Parameter string
as described in
<a href="#Installation+and+Configuration+%3F+Run+Time" class="Er">Installation and Configuration &#8212; Run Time</a>.
</p><p>
The
<em class="Ep">formatfile</em>
may be the file name of a Video Configuration Format
previously saved with
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>
or with the
<cite class="Ec">XCAP</cite>
application.<a href="#Footnote%2032" class="Ff"><sup>[32]</sup></a>
The
<em class="Ep">formatfile</em>
is imported and all of its Video Configuration Formats
are defined for later use via
<a href="#::definedState" class="Er">::definedState</a>.
</p><p>
The
<em class="Ep">formatname</em>
may be the predefined name of a
standard video configuration format
suitable for the imaging board in use;
the valid predefined names are described in
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
The specified standard Video Configuration Format
is defined via
<a href="#::definedState" class="Er">::definedState</a>
for later use with a
video state id of PXMODE_DIGI.
</p><p>
The
<em class="Ep">formatfile</em>
and
<em class="Ep">formatname</em>
may be NULL.
If both are NULL,
a video state must be defined via
<a href="#::importStateCopy" class="Er">::importStateCopy</a>,
or by filling the actual video configuration format
structures and
<a href="#::defineState" class="Er">::defineState</a>,
before capturing, displaying or accessing image frame buffers.
If both are specified, the
<em class="Ep">formatname</em>
is define first; the
<em class="Ep">formatfile</em>
re-defines any video state id of PXMODE_DIGI
that was previously defined.
</p><p>
If the
<a href="#xclib_open" class="Er">xclib_open</a>
fails, the
<a href="#::getFault" class="Er">::getFault</a>,
<a href="#::faultMessageBox" class="Er">::faultMessageBox</a>,
<a href="#::faultPrintf" class="Er">::faultPrintf</a>,
and
<a href="#::errorCodeString" class="Er">::errorCodeString</a>
services may used to obtain additional
information about the cause of failure.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
The PIXCI® XCLIB  Library and Driver is open
and ready for use.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">xclib</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
<br></dd><dt>PXERNOFILE</dt><dd>
No file named
<em class="Ep">formatfile</em>
found.
<br></dd><dt>PXERFILEFORM</dt><dd>
The file format of
<em class="Ep">formatfile</em>
is invalid.
<br></dd><dt>PXERDOSIO</dt><dd>
Can't read file named
<em class="Ep">formatfile</em>.
<br></dd><dt>PXERSEARCH</dt><dd>
The
<em class="Ep">formatname</em>
was invalid.
<br></dd><dt>PXERVIDFORM</dt><dd>
The
<em class="Ep">formatname</em>
was a valid string,
but the specified format is not supported on the current imaging board.
<br></dd><dt>PXERBADPARM</dt><dd>
The parameters in
<em class="Ep">driverparms</em>
are invalid.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxdev.getDevInfo NX916" class="NX"></a>
<a name="::pxdev.getDevInfo" class="Sf"></a>
<a name="Get Imaging Board and Driver Information NX917" class="NX"></a>
<a name="Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo" class="Sf"></a>
<a name="Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo"></a>
<h6 class="Sf">Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo</h6>
<a name="::xcdev.getDevInfo NX918" class="NX"></a>
<a name="::xcdev.getDevInfo" class="Sg"></a>
<a name="Get Extended Imaging Board and Driver Information NX919" class="NX"></a>
<a name="Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo" class="Sg"></a>
<a name="Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo"></a>
<h6 class="Sg">Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo</h6>
<a name="::getDevInfo" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxdev.getDevInfo) (&amp;pxdev, unitmap, rsvd, pxinfo);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct pxdevinfo    *pxinfo;        // Filled with information
<br>
int (xcdev.getDevInfo) (&amp;xcdev, unitmap, rsvd, xcinfo);
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct xcdevinfo    *xcinfo;        // Filled with information
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Information about the driver and about the
single selected
<em class="Ep">unitmap</em>
imaging board is
''returned''
in the
<em class="Ep">pxinfo</em>
instance of the
<a href="#pxdevinfo" class="Er">pxdevinfo</a>
structure,
or the
<em class="Ep">xcinfo</em>
instance of the
<a href="#xcdevinfo" class="Er">xcdevinfo</a>
structure.
</p><p>
A non-exhaustive list of information provided
includes the imaging board model,
imaging board submodel (if applicable),
imaging board revision level (if applicable),
the number of imaging boards open for use,
the total amount of image frame buffer memory per imaging board,
a driver identification string,
and a library identification string.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">pxinfo</em>'s
or the
<em class="Ep">xcinfo</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxdev.getFault NX920" class="NX"></a>
<a name="::pxdev.getFault" class="Sf"></a>
<a name="Obtain Last Logged Fault NX921" class="NX"></a>
<a name="Obtain Last Logged Fault   ---   ::pxdev.getFault" class="Sf"></a>
<a name="Obtain Last Logged Fault   ---   ::pxdev.getFault"></a>
<h6 class="Sf">Obtain Last Logged Fault   ---   ::pxdev.getFault</h6>
<a name="::getFault" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxdev.getFault) (&amp;pxdev, unitmap, rsvd, fault);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct pxdevfault   *fault;         // Fault information
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::getFault" class="Er">::getFault</a>
checks whether a new fault has occurred since the last check,
and if so
''returns''
the fault information, filling the
<em class="Ep">fault</em>
instance of the
<a href="#pxdevfault" class="Er">pxdevfault</a>
structure.
The
<em class="Ep">unitmap</em>
specifies the single unit upon which faults
are checked and displayed.
</p><p>
Faults are not related to PXER... error codes.
Rather, faults are typically asynchronous events,
such as reporting that the video signal
has been interrupted or corrupted.
Faults are not the error description,
if any, of the last called library function,
with the exception that after
<a href="#xclib_open" class="Er">xclib_open</a>
fails, the
<a href="#::getFault" class="Er">::getFault</a>
may provide additional information about the cause of failure.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>1</dt><dd>
Information about a new logged fault
has been returned.
<br></dd><dt>0</dt><dd>
No new logged fault exists, no
information has been returned.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">fault</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::xcdev.getDevParms NX922" class="NX"></a>
<a name="::xcdev.getDevParms" class="Sf"></a>
<a name="Get Driver Parameters NX923" class="NX"></a>
<a name="Get Driver Parameters   ---   ::xcdev.getDevParms" class="Sf"></a>
<a name="Get Driver Parameters   ---   ::xcdev.getDevParms"></a>
<h6 class="Sf">Get Driver Parameters   ---   ::xcdev.getDevParms</h6>
<a name="::xcdev.setDevParms NX924" class="NX"></a>
<a name="::xcdev.setDevParms" class="Sg"></a>
<a name="Set Driver Parameters NX925" class="NX"></a>
<a name="Set Driver Parameters   ---   ::xcdev.setDevParms" class="Sg"></a>
<a name="Set Driver Parameters   ---   ::xcdev.setDevParms"></a>
<h6 class="Sg">Set Driver Parameters   ---   ::xcdev.setDevParms</h6>
<a name="::getDevParms" class="Tr"></a>
<a name="::setDevParms" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.getDevParms) (&amp;xcdev, unitmap, rsvd, parms);
int (xcdev.setDevParms) (&amp;xcdev, unitmap, rsvd, parms);
<br>
struct pxdevservice pxdev;          // A pxdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct xcdevparms   devparm;        // Driver configuration parameters
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::getDevParms" class="Er">::getDevParms</a>
returns the current Driver Configuration Parameters
for the single selected
<em class="Ep">unitmap</em>
in the
<em class="Ep">devparm</em>
instance of the
<a href="#xcdevparms" class="Er">xcdevparms</a>
structure.
These are the same parameters as set by the third
argument of
<a href="#xclib_open" class="Er">xclib_open</a>,
although expressed as structure fields rather than as a string.
The
<a href="#::setDevParms" class="Er">::setDevParms</a>
returns an error; parameters
can't be changed once the driver and imaging board are open for use.
</p><p>
If the XCLIB has been opened in "-configure" mode (see
<a href="#xclib_open" class="Er">xclib_open</a>),
the
<a href="#::getDevParms" class="Er">::getDevParms</a>
returns the default Driver Configuration Parameters in the
<em class="Ep">devparm</em>
instance of the
<a href="#xcdevparms" class="Er">xcdevparms</a>
structure,
and the
<a href="#::setDevParms" class="Er">::setDevParms</a>
sets the default Driver Configuration Parameters from
<em class="Ep">devparm</em>.
The
<em class="Ep">unitmap</em>
is ignored.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">devparm</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Video Format Configuration Services" class="Ch"></a>
<a name="6.  Structured Style Interface - Video Format Configuration Services"></a>
</p><h1>6.  Structured Style Interface - Video Format Configuration Services</h1>
<p>
The Video Format Configuration &amp; Video State ID services
provide for the manipulation of the Video Format Configuration structures,
and associating a Video Format Configuration with a numeric video state id.
</p><p>
The
<a href="#pxvidstate" class="Er">pxvidstate</a>
is the primary Video Format Configuration structure,
which incorporates several substructures,
</p><p>
The
<a href="#::allocStateCopy" class="Er">::allocStateCopy</a>,
<a href="#::compareStateCopy" class="Er">::compareStateCopy</a>,
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>,
<a href="#::freeStateCopy" class="Er">::freeStateCopy</a>,
<a href="#::importStateCopy" class="Er">::importStateCopy</a>,
and
<a href="#::initStateCopy" class="Er">::initStateCopy</a>
services perform off-line manipulation
of Video Format Configuration structures;
their manipulation has no direct effect
on the XCLIB library's or the imaging board's state.
Their names of
''...StateCopy''
are intended to suggest that the
Video Format Configuration structures manipulated
are off-line copies;
not that the
Video Format Configuration structures manipulated
are necessarily copies of any video state in use.
</p><p>
Other services manipulate
Video Format Configuration structures
in the context of the imaging board in use,
with effect upon the library's state.
</p><hr size="1">
<a name="::pxlib.allocStateCopy NX926" class="NX"></a>
<a name="::pxlib.allocStateCopy" class="Sf"></a>
<a name="Allocate Copy of Video State NX927" class="NX"></a>
<a name="Allocate Copy of Video State   ---   ::pxlib.allocStateCopy" class="Sf"></a>
<a name="Allocate Copy of Video State   ---   ::pxlib.allocStateCopy"></a>
<h6 class="Sf">Allocate Copy of Video State   ---   ::pxlib.allocStateCopy</h6>
<a name="::pxlib.freeStateCopy NX928" class="NX"></a>
<a name="::pxlib.freeStateCopy" class="Sg"></a>
<a name="Free Copy of Video State NX929" class="NX"></a>
<a name="Free Copy of Video State   ---   ::pxlib.freeStateCopy" class="Sg"></a>
<a name="Free Copy of Video State   ---   ::pxlib.freeStateCopy"></a>
<h6 class="Sg">Free Copy of Video State   ---   ::pxlib.freeStateCopy</h6>
<a name="::allocStateCopy" class="Tr"></a>
<a name="::freeStateCopy" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxlib.allocStateCopy)    (&amp;pxlib, options, stateid, statepp);
int (pxlib.freeStateCopy)     (&amp;pxlib, options, stateid, statepp);
<br>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statepp;       // Pointer to video state pointer
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::allocStateCopy" class="Er">::allocStateCopy</a>
<cite class="Ec">malloc</cite>'s
a set of Video Format Configuration structures.
The
<em class="Ep">stateid</em>
is reserved and should be 0.
The
*<em class="Ep">statepp</em>
must initially be NULL;
the pointer to the allocated
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure and substructures
is
''returned''
at
*<em class="Ep">statepp</em>.
The
''returned''
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure and substructures
are initialized to zero, with the
<a href="#ddch.len" class="Er">ddch.len</a>
and
<a href="#ddch.mos" class="Er">ddch.mos</a>
signatures set.
</p><p>
The
<a href="#::freeStateCopy" class="Er">::freeStateCopy</a>
<cite class="Ec">free</cite>'s
a set of previously
<cite class="Ec">malloc</cite>'ed
Video Format Configuration structures referenced by
*<em class="Ep">statepp</em>.
The
<em class="Ep">stateid</em>
is reserved and should be 0.
After
<a href="#::freeStateCopy" class="Er">::freeStateCopy</a>,
the
*<em class="Ep">statepp</em>
is invalid, set to NULL, and must not be used with any function.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxlib.compareStateCopy NX930" class="NX"></a>
<a name="::pxlib.compareStateCopy" class="Sf"></a>
<a name="Compare Pair of Video State Copies NX931" class="NX"></a>
<a name="Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy" class="Sf"></a>
<a name="Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy"></a>
<h6 class="Sf">Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy</h6>
<a name="::compareStateCopy" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxlib.compareStateCopy)  (&amp;pxlib, options, stateid, statep, state2p);
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statep;        // Pointer to video state
struct pxvidstate   *state2p;       // Pointer to second video state
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::compareStateCopy" class="Er">::compareStateCopy</a>
compares Video Format Configuration settings
of the Video Format Configurations referenced by the
<em class="Ep">statep</em>
and
<em class="Ep">state2p</em>
instances of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure.
Value 1 or 0 is returned
if the settings are identical or not identical, respectively.
The
<em class="Ep">stateid</em>
is reserved and should be 0.
</p><p>
The
<a href="#::compareStateCopy" class="Er">::compareStateCopy</a>
is not equivalent to a simple
<cite class="Ec">memcmp</cite>
of
<em class="Ep">statep</em>
and
<em class="Ep">state2p</em>;
substructures within each are
referenced by pointers which may point to different
instances of Video Format Configuration substructures.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>1</dt><dd>
The Video Format Configuration
are identical.
<br></dd><dt>0</dt><dd>
The Video Format Configuration
are not identical.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">statep</em>'s
or
<em class="Ep">state2p</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxlib.defineState NX932" class="NX"></a>
<a name="::pxlib.defineState" class="Sf"></a>
<a name="Define Video State NX933" class="NX"></a>
<a name="Define Video State   ---   ::pxlib.defineState" class="Sf"></a>
<a name="Define Video State   ---   ::pxlib.defineState"></a>
<h6 class="Sf">Define Video State   ---   ::pxlib.defineState</h6>
<a name="::pxlib.deleteState NX934" class="NX"></a>
<a name="::pxlib.deleteState" class="Sg"></a>
<a name="Delete Video State NX935" class="NX"></a>
<a name="Delete Video State   ---   ::pxlib.deleteState" class="Sg"></a>
<a name="Delete Video State   ---   ::pxlib.deleteState"></a>
<h6 class="Sg">Delete Video State   ---   ::pxlib.deleteState</h6>
<a name="::pxlib.getState NX936" class="NX"></a>
<a name="::pxlib.getState" class="Sg"></a>
<a name="Get Video State NX937" class="NX"></a>
<a name="Get Video State   ---   ::pxlib.getState" class="Sg"></a>
<a name="Get Video State   ---   ::pxlib.getState"></a>
<h6 class="Sg">Get Video State   ---   ::pxlib.getState</h6>
<a name="::defineState" class="Tr"></a>
<a name="::deleteState" class="Tr"></a>
<a name="::getState" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxlib.defineState)  (&amp;pxlib, options, stateid, statep);
int (pxlib.deleteState)  (&amp;pxlib, options, stateid, statep);
int (pxlib.getState)     (&amp;pxlib, options, stateid, statep);
<br>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id
struct pxvidstate   *statep;        // Pointer to video state
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::defineState" class="Er">::defineState</a>
copies and stores the Video Configuration Parameters
contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure,
assigning it a video state id of
<em class="Ep">stateid</em>.
The
<em class="Ep">stateid</em>
may be an arbitrary integer greater than 0.
After
<a href="#::defineState" class="Er">::defineState</a>,
the
<em class="Ep">statep</em>
may be
<cite class="Ec">free</cite>'ed
or changed without affecting the
Video Configuration Parameters
associated with the
<em class="Ep">stateid</em>.
</p><p>
The
<a href="#::deleteState" class="Er">::deleteState</a>
deletes any
Video Configuration Parameters
associated with the
<em class="Ep">stateid</em>.
The
<em class="Ep">statep</em>
is ignored.
</p><p>
The
<a href="#::getState" class="Er">::getState</a>
retrieves and copies the
Video Configuration Parameters
associated with the
<em class="Ep">stateid</em>
into the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure.
</p><p>
Using
<a href="#::defineState" class="Er">::defineState</a>
or
<a href="#::deleteState" class="Er">::deleteState</a>
on a video state id already in
use as the current
Video Configuration Parameters
for a video capture or display activity
does not automatically affect
the video capture or display activity.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">statep</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXERMALLOC</dt><dd>
Memory allocation error.
<br></dd><dt>PXERNOITEM</dt><dd>
The specified
<em class="Ep">stateid</em>
was not previously defined (for
<a href="#::deleteState" class="Er">::deleteState</a>
and
<a href="#::getState" class="Er">::getState</a>).
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxlib.exportStateCopy NX938" class="NX"></a>
<a name="::pxlib.exportStateCopy" class="Sf"></a>
<a name="Export Copy of Video State NX939" class="NX"></a>
<a name="Export Copy of Video State   ---   ::pxlib.exportStateCopy" class="Sf"></a>
<a name="Export Copy of Video State   ---   ::pxlib.exportStateCopy"></a>
<h6 class="Sf">Export Copy of Video State   ---   ::pxlib.exportStateCopy</h6>
<a name="::pxlib.importStateCopy NX940" class="NX"></a>
<a name="::pxlib.importStateCopy" class="Sg"></a>
<a name="Import Copy of Video State NX941" class="NX"></a>
<a name="Import Copy of Video State   ---   ::pxlib.importStateCopy" class="Sg"></a>
<a name="Import Copy of Video State   ---   ::pxlib.importStateCopy"></a>
<h6 class="Sg">Import Copy of Video State   ---   ::pxlib.importStateCopy</h6>
<a name="::exportStateCopy" class="Tr"></a>
<a name="::importStateCopy" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxlib.exportStateCopy)(&amp;pxlib, options, stateid, statep, stateindex, pathname, filemode,
                            progname, filecomment);
int (pxlib.importStateCopy)(&amp;pxlib, options, stateid, statep, stateindex, pathname, filemode);
<br>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id
struct pxvidstate   *statep;        // Pointer to video state
int                 stateindex;     // Index into file
char                *pathname;      // File path and name
char                *filemode;      // File open mode, or NULL
char                *progname;      // Optional name of program
char                *filecomment;   // Optional additional comment
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>
exports the Video Format Configuration settings
contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure
to a file in a format compatible with
<a href="#::importStateCopy" class="Er">::importStateCopy</a>
and with the
<cite class="Ec">XCAP</cite>
application (using the same version of libraries).
</p><p>
The
<em class="Ep">::importStateCopy</em>
imports one set of Video Format Configuration settings
into the provided
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure.
</p><p>
The
<em class="Ep">pathname</em>
specifies the file's path name.<a href="#Footnote%2033" class="Ff"><sup>[33]</sup></a>
The
<em class="Ep">filemode</em>
specifies the file's
<cite class="Ec">fopen</cite>
mode, or may be NULL for default.
For
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>
and the default
<em class="Ep">filemode</em>,
any existing file
<em class="Ep">pathname</em>
is deleted and a new file
<em class="Ep">pathname</em>
created.
</p><p>
For
<a href="#::exportStateCopy" class="Er">::exportStateCopy</a>,
the optional
<em class="Ep">progname</em>
and
<em class="Ep">filecomment</em>
provide text for comments to be written into the file.
The
<em class="Ep">stateindex</em>
is reserved and should be 0.
The
<em class="Ep">stateid</em>
is an arbitrary, non-zero, numeric state identification
which distinguishes the Video Format Configuration settings
from others in the same file.
It does NOT necessarily reference a video state id
currently defined in the library.
</p><p>
For
<a href="#::importStateCopy" class="Er">::importStateCopy</a>,
the
<em class="Ep">pathname</em>
may contain multiple Video Format Configurations.
If
<em class="Ep">stateid</em>&gt;0,
a Video Format Configuration previously
saved with the same
<em class="Ep">stateid</em>
is imported.
<em class="Ep">stateid</em>&lt;0,
the
<em class="Ep">stateindex</em>'th
sequential Video Format Configuration in the
<em class="Ep">pathname</em>
is imported;
where the
<em class="Ep">stateindex</em>
is 1 for the first, 2 for the second, etc.
The
<em class="Ep">stateid</em>
does NOT necessarily reference a video state id
currently defined in the library.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>9999</dt><dd>
A complete set of Video Format Configuration
structures and substructures imported (for
<a href="#::importVideoState" class="Er">::importVideoState</a>).
<br></dd><dt>&#8805;0</dt><dd>
The number of Video Format Configuration
substructures imported (for
<a href="#::importVideoState" class="Er">::importVideoState</a>).
<br></dd><dt>0</dt><dd>
Operation complete (for
<a href="#::exportVideoState" class="Er">::exportVideoState</a>).
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">statep</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXERNOFILE</dt><dd>
File can't be read (for
<a href="#::importVideoState" class="Er">::importVideoState</a>).
<br></dd><dt>PXERNEWFILE</dt><dd>
File can't be created or written (for
<a href="#::exportVideoState" class="Er">::exportVideoState</a>).
<br></dd><dt>PXERFILEFORM</dt><dd>
The file format is invalid.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::xclib.fixxStateCopy NX942" class="NX"></a>
<a name="::xclib.fixxStateCopy" class="Sf"></a>
<a name="Fixup Video State NX943" class="NX"></a>
<a name="Fixup Video State   ---   ::xclib.fixxStateCopy" class="Sf"></a>
<a name="Fixup Video State   ---   ::xclib.fixxStateCopy"></a>
<h6 class="Sf">Fixup Video State   ---   ::xclib.fixxStateCopy</h6>
<a name="::xclib.fillStateCopy NX944" class="NX"></a>
<a name="::xclib.fillStateCopy" class="Sg"></a>
<a name="Fill Video State NX945" class="NX"></a>
<a name="Fill Video State   ---   ::xclib.fillStateCopy" class="Sg"></a>
<a name="Fill Video State   ---   ::xclib.fillStateCopy"></a>
<h6 class="Sg">Fill Video State   ---   ::xclib.fillStateCopy</h6>
<a name="::xclib.signStateCopy NX946" class="NX"></a>
<a name="::xclib.signStateCopy" class="Sg"></a>
<a name="Sign Video State NX947" class="NX"></a>
<a name="Sign Video State   ---   ::xclib.signStateCopy" class="Sg"></a>
<a name="Sign Video State   ---   ::xclib.signStateCopy"></a>
<h6 class="Sg">Sign Video State   ---   ::xclib.signStateCopy</h6>
<a name="::fixxStateCopy" class="Tr"></a>
<a name="::fillStateCopy" class="Tr"></a>
<a name="::signStateCopy" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xclib.fixxStateCopy)  (&amp;xclib, options, stateid, statep);
int (xclib.fillStateCopy)  (&amp;xclib, options, stateid, statep, buffer);
int (xclib.signStateCopy)  (&amp;xclib, options, stateid, statep, adrsspace, mode);
<br>
struct xclibservice xclib;          // A xclibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statep;        // Pointer to video state
pxbuffer_t          buffer;         // Image frame buffer
<br>
int                 mode;           // 's': sign, 'c': check signature, 'r': get adrsspace
int                 adrsspace;      // 'i': image frame buffer memory
                                    // 'p': physical memory
                                    // 'u': application memory
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::fixxStateCopy" class="Er">::fixxStateCopy</a>
normalizes
the Video Configuration Parameters referenced by the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure.
The
Video Configuration Parameters
are normalized to be internally consistent
(typically by reference to the contents
of the
<a href="#pxvidformat" class="Er">pxvidformat</a>
structure),
and to be consistent with the capabilities
of the current imaging board.
</p><p>
The
<a href="#::fillStateCopy" class="Er">::fillStateCopy</a>
fills the
<a href="#pxvidphys" class="Er">pxvidphys</a>
structure of the
Video Configuration Parameters
to refer to image frame buffer number
<em class="Ep">buffer</em>,
<em class="Ep">buffer</em>&#8805;1,
within the imaging board's frame buffer memory.
</p><p>
The
<a href="#::signStateCopy" class="Er">::signStateCopy</a>
signs the
<a href="#pxvidphys" class="Er">pxvidphys</a>
structure of the
Video Configuration Parameters
as containing valid addresses
which refer to memory other than the
image frame buffer memory,
or checks whether the
<a href="#pxvidphys" class="Er">pxvidphys</a>
structure of the Video Configuration Parameters
is properly signed.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
In particular, for
<a href="#::fillStateCopy" class="Er">::fillStateCopy</a>,
a
<em class="Ep">buffer</em>
which is less than one or greater than
the number of buffers which fit within
frame buffer memory.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">statep</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxlib.initStateCopy NX948" class="NX"></a>
<a name="::pxlib.initStateCopy" class="Sf"></a>
<a name="Set Default Configuration Copy of Video State NX949" class="NX"></a>
<a name="Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy" class="Sf"></a>
<a name="Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy"></a>
<h6 class="Sf">Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy</h6>
<a name="::compareStateCopy" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxlib.initStateCopy)     (&amp;pxlib, options, stateid, statep, infop, formatname, vidmode);
<br>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statep;        // Pointer to video state
struct pxdevinfo    *info;          // Description of imaging board
char                *formatname;    // A predefined name of video format
int                 vidmode;        // A PXMODE_ value
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::initStateCopy" class="Er">::initStateCopy</a>
initializes the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure
to the default Video Configuration Parameters
appropriate to the imaging board described in
<em class="Ep">info</em>,
with the
<em class="Ep">formatname</em>
predefined name of a
standard video configuration format,
and suitable to an activity
specified by
<em class="Ep">vidmode.</em>
</p><p>
The
<em class="Ep">info</em>
for the current imaging board may be obtained from
<a href="#::getDevInfo" class="Er">::getDevInfo</a>.
The allowable predefined names
of standard video configuration format
are described in
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
The
<em class="Ep">vidmode</em>
is a PXMODE_ type value,
such as PXMODE_DIGI to indicate that the
Video Configuration Parameters are to be used for capturing.
<br>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">statep</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXERSEARCH</dt><dd>
The
<em class="Ep">formatname</em>
was invalid.
<br></dd><dt>PXERVIDFORM</dt><dd>
The
<em class="Ep">formatname</em>
is a valid string,
but the specified format is not supported on the imaging board
described by
<em class="Ep">info</em>.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="xclib_DeclareVidStateStructs NX950" class="NX"></a>
<a name="xclib_DeclareVidStateStructs" class="Sf"></a>
<a name="Declare Instance of Video Format Configuration Structures NX951" class="NX"></a>
<a name="Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs" class="Sf"></a>
<a name="Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs"></a>
<h6 class="Sf">Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs</h6>
<a name="xclib_InitVidStateStructs NX952" class="NX"></a>
<a name="xclib_InitVidStateStructs" class="Sg"></a>
<a name="Initialize Instance of Video Format Configuration Structures NX953" class="NX"></a>
<a name="Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs" class="Sg"></a>
<a name="Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs"></a>
<h6 class="Sg">Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>#define xclib_DeclareVidStateStructs(Name)
#define xclib_InitVidStateStruct(Name)
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#xclib_DeclareVidStateStructs" class="Er">xclib_DeclareVidStateStructs</a>
macro declares a instance of a
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure named
<em class="Ep">Name</em>,
and all of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
substructures with decorated names starting with
<em class="Ep">Name</em>.
</p><p>
The
<a href="#xclib_InitVidStateStruct" class="Er">xclib_InitVidStateStruct</a>
initializes the structures previously declared by
<a href="#xclib_DeclareVidStateStructs" class="Er">xclib_DeclareVidStateStructs</a>,
setting the
<a href="#pxvidstate" class="Er">pxvidstate</a>
fields to point its substructures,
and setting the
<a href="#ddch.mos" class="Er">ddch.mos</a>
and
<a href="#ddch.len" class="Er">ddch.len</a>
structure signatures.
</p><p>
These macros provide only C/C++
declaration and initialization
of structures; there is no effect
on the XCLIB library's or the imaging board's state.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Memory Access Services" class="Ch"></a>
<a name="7.  Structured Style Interface - Memory Access Services"></a>
</p><h1>7.  Structured Style Interface - Memory Access Services</h1>
<p>
The Memory Access services
provide several methods of accessing image data
or other memory associated with the imaging board.
</p><p>
The
<a href="#::initPximage" class="Er">::initPximage</a>,
<a href="#::initPximage3" class="Er">::initPximage3</a>,
<a href="#::initFilteredPximage" class="Er">::initFilteredPximage</a>,
and
<a href="#::initFilteredPximage3" class="Er">::initFilteredPximage3</a>,
are the suggested services for accessing imaging board memory.
Use of the low level
<a href="#::io" class="Er">::io</a>,
<a href="#::getImap" class="Er">::getImap</a>,
and
<a href="#::freeImap" class="Er">::freeImap</a>
services should be minimized.
</p><hr size="1">
<a name="::pxdev.getImap NX954" class="NX"></a>
<a name="::pxdev.getImap" class="Sf"></a>
<a name="Obtain Pointer into Imaging Board Memory NX955" class="NX"></a>
<a name="Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap" class="Sf"></a>
<a name="Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap"></a>
<h6 class="Sf">Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap</h6>
<a name="::pxdev.freeImap NX956" class="NX"></a>
<a name="::pxdev.freeImap" class="Sg"></a>
<a name="Free Pointer into Imaging Board Memory NX957" class="NX"></a>
<a name="Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap" class="Sg"></a>
<a name="Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap"></a>
<h6 class="Sg">Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap</h6>
<a name="::getImap" class="Tr"></a>
<a name="::freeImap" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxdev.getImap)  (pxdevservice_s *me, options, unitmap, adrs, altspace, accessptr, accesslen);
int (pxdev.freeImap) (pxdevservice_s *me, options, unitmap, adrs, altspace, accessptr, accesslen);
<br>
struct pxdevservice pxdev;          // A pxdevservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint32              adrs;           // Address of imaging board memory
uint                altspace;       // 0: image frame buffer memory
uchar _farimap      **accessptr;    // Returned pointer to imaging board memory address
pximaplen_t         *accesslen;     // Returned access length, may be NULL
                                    // _farimap is a predefined adjective:
                                    //    &lt;blank&gt;  [in Windows 32 bit environments]
                                    //    &lt;blank&gt;  [in Windows 64 bit environments]
                                    //    &lt;blank&gt;  [in Linux 32 bit environments]
                                    //    &lt;blank&gt;  [in Linux 64 bit environments]
                                    //    _far     [in DOS+Tenberry environments]
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::getImap" class="Er">::getImap</a>
obtains and returns a pointer into memory associated
with the imaging board, if available.
The
<a href="#::freeImap" class="Er">::freeImap</a>
frees a pointer previously obtained with
<a href="#::getImap" class="Er">::getImap</a>.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit
to which a pointer is to be obtained.
The
<em class="Ep">adrs</em>
specifies the zero based address
within the imaging board memory.
The
<em class="Ep">altspace</em>=0
selects the image frame buffer memory.
</p><p>
If a pointer to the requested memory can be obtained,
the pointer is
''returned''
at
*<em class="Ep">accessptr</em>,
and the length in bytes for which
the pointer is valid is
''returned''
at
*<em class="Ep">accesslen</em>.
The
<em class="Ep">accesslen</em>
may be NULL; no length information is returned.
</p><p>
The
*<em class="Ep">accessptr</em>
and
*<em class="Ep">accesslen</em>
allows accessing a range of memory
without additional use of
<a href="#::getImap" class="Er">::getImap</a>;
the bytes of imaging board memory from
<em class="Ep">adrs</em>
through
<em class="Ep">adrs</em>+<em class="Ep">accesslen</em>-1
can be accessed by using
*<em class="Ep">accessptr</em>
through
*<em class="Ep">accessptr</em>+<em class="Ep">accesslen</em>-1.
</p><p>
The availability of a direct pointer into imaging board memory
varies with the type of imaging board, the state of the imaging board,
the current operating system,
and the current Driver Configuration Parameters.
</p><p>
Under Windows 95, 98, ME, NT, 2000, XP, XP(x64), Vista, Vista(x64), 7 and 7(x64):
The access pointer
provided by
<a href="#::getImap" class="Er">::getImap</a>
can be used by the application to access imaging board memory,
but cannot be passed to other applications or to system
services such as file I/O.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxlib.initPximage NX958" class="NX"></a>
<a name="::pxlib.initPximage" class="Sf"></a>
<a name="Obtain pximage Access into Imaging Board Memory NX959" class="NX"></a>
<a name="Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage" class="Sf"></a>
<a name="Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage"></a>
<h6 class="Sf">Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage</h6>
<a name="::pxlib.initPximage3 NX960" class="NX"></a>
<a name="::pxlib.initPximage3" class="Sg"></a>
<a name="Obtain pximage3 Access into Imaging Board Memory NX961" class="NX"></a>
<a name="Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3" class="Sg"></a>
<a name="Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3"></a>
<h6 class="Sg">Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3</h6>
<a name="::pxlib.initFilteredPximage NX962" class="NX"></a>
<a name="::pxlib.initFilteredPximage" class="Sg"></a>
<a name="Obtain Filtered pximage Access into Imaging Board Memory NX963" class="NX"></a>
<a name="Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage" class="Sg"></a>
<a name="Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage"></a>
<h6 class="Sg">Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage</h6>
<a name="::pxlib.initFilteredPximage3 NX964" class="NX"></a>
<a name="::pxlib.initFilteredPximage3" class="Sg"></a>
<a name="Obtain Filtered pximage3 Access into Imaging Board Memory NX965" class="NX"></a>
<a name="Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3" class="Sg"></a>
<a name="Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3"></a>
<h6 class="Sg">Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3</h6>
<a name="::initPximage" class="Tr"></a>
<a name="::initPximage3" class="Tr"></a>
<a name="::initFilteredPximage" class="Tr"></a>
<a name="::initFilteredPximage3" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxlib.initPximage)         (&amp;pxlib, unitmap, ip,  ipcnt, colorhint, altspace, stateid,
                                 framebuf, mbpcihint);
int (pxlib.initPximage3)        (&amp;pxlib, unitmap, ip3, ipcnt, colorhint, altspace, stateid,
                                 unused,   mbpcihint);
int (pxlib.initFilteredPximage) (&amp;pxlib, unitmap, ip,  ipcnt, colorhint, altspace, stateid,
                                 framebuf, mbpcihint, colormap);
int (pxlib.initFilteredPximage3)(&amp;pxlib, unitmap, ip3, ipcnt, colorhint, altspace, stateid,
                                 unused,   mbpcihint, colormap);
<br>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
struct pximage      ip[];           // Array of pximage's
struct pximage      ip3[];          // Array of pximage3's
int                 ipcnt;          // Dimension of ip or ip3
int                 colorhint;      // Requested color representation
uint                altspace;       // 0: image frame buffer memory
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
int                 mbpcihint;      // Reserved, should be 0
int                 colormap;       // Pixel value component selection
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
A
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>
is initialized so as to provide access
to the imaging board's frame buffers,
or to other memory associated with the imaging board.
The
<a href="#::initPximage" class="Er">::initPximage</a>
provides access to a single image frame buffers,
in the color space(s) directly obtainable
from the image frame buffer.
The
<a href="#::initPximage3" class="Er">::initPximage3</a>
provides access to a sequence of all image frame buffers,
in the color space(s) directly obtainable
from the image frame buffer.
The
<a href="#::initFilteredPximage" class="Er">::initFilteredPximage</a>
and
<a href="#::initFilteredPximage3" class="Er">::initFilteredPximage3</a>
are similar, but initializes additional
conversions, as needed, to provide
any supported color space interpretation
of the image frame buffers.
</p><p>
These services initialize the
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>
structures provided;
thereafter these structures
can be used to access
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>
services.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit
to which access is to be provided.
The
<em class="Ep">stateid</em>
specifies a video state id
previously defined by
<a href="#::defineState" class="Er">::defineState</a>,
against which the
<em class="Ep">framebuf</em>
is interpreted.
</p><p>
The
<em class="Ep">ip</em>
or
<em class="Ep">ip3</em>
specify instances of an array of
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>
structures;
the
<em class="Ep">ipcnt</em>
specifies the number of structures provided.
In the worst case,
<a href="#::initPximage" class="Er">::initPximage</a>
and
<a href="#::initPximage3" class="Er">::initPximage3</a>
may require
<em class="Ep">ipcnt</em>=PXMAX_IRBGF,
<a href="#::initFilteredPximage" class="Er">::initFilteredPximage</a>
and
<a href="#::initFilteredPximage3" class="Er">::initFilteredPximage3</a>
may require
<em class="Ep">ipcnt</em>=PXMAX_FIRBGF.
</p><p>
The
<em class="Ep">colorhint</em>
is a PXHINT...
type value specifying the desired color space.
The
<em class="Ep">colorhint</em>
may not be available; the
<em class="Ep">ip</em>
or
<em class="Ep">ip3</em>
may be initialized so as to access the image frame buffers
with a different color space.
More
<em class="Ep">colorhint</em>'s
are available through use of
<a href="#::initFilteredPximage" class="Er">::initFilteredPximage</a>
and
<a href="#::initFilteredPximage3" class="Er">::initFilteredPximage3</a>
instead of
<a href="#::initPximage" class="Er">::initPximage</a>
and
<a href="#::initPximage3" class="Er">::initPximage3</a>.
</p><p>
For
<a href="#::initFilteredPximage" class="Er">::initFilteredPximage</a>
and
<a href="#::initFilteredPximage3" class="Er">::initFilteredPximage3</a>,
the
<em class="Ep">colormap</em>
selects which color component values are to be accessed.
The
<em class="Ep">colormap</em>
is a bit-map; the i'th
bit selects the i'th color component.
</p><p>
If
<em class="Ep">altspace</em>=0,
access is provided to image frame buffers.
For PIXCI® A, CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI,
SI1, SI2, and SI4 imaging boards,
using
<em class="Ep">altspace</em>=(('t'&lt;&lt;8)|'s')
provides access to the four byte video field counter
attached to each captured frame buffer.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>&#8805;1</dt><dd>
Operation complete.
The return value indicates the
number of
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>
structures used.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERMORESPACE</dt><dd>
There are insufficient
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>
structures to provide access.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxdev.io NX966" class="NX"></a>
<a name="::pxdev.io" class="Sf"></a>
<a name="Read/Write Imaging Board Memory NX967" class="NX"></a>
<a name="Read/Write Imaging Board Memory   ---   ::pxdev.io" class="Sf"></a>
<a name="Read/Write Imaging Board Memory   ---   ::pxdev.io"></a>
<h6 class="Sf">Read/Write Imaging Board Memory   ---   ::pxdev.io</h6>
<a name="::pxdev.iosparse NX968" class="NX"></a>
<a name="::pxdev.iosparse" class="Sg"></a>
<a name="Read/Write Imaging Board Memory, Sparsely NX969" class="NX"></a>
<a name="Read/Write Imaging Board Memory, Sparsely   ---   ::pxdev.iosparse" class="Sg"></a>
<a name="Read/Write Imaging Board Memory, Sparsely   ---   ::pxdev.iosparse"></a>
<h6 class="Sg">Read/Write Imaging Board Memory, Sparsely   ---   ::pxdev.iosparse</h6>
<a name="::io" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxdev.io)       (&amp;pxdev, options, unitmap, adrs, altspace, buf, cnt, rw, async, time);
int (pxdev.iosparse) (&amp;pxdev, options, unitmap, adrs, altspace, buf, cnt, rw, async, time,blksize,blkpitch);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint32              adrs;           // Address of imaging board memory
uint                altspace;       // 0: image frame buffer memory
void                *buf;           // Application program buffer
size_t              cnt;            // Transfer count, bytes
uint                rw;             // PXREAD: Copy into application buffer
                                    // PXRITE: Copy from application buffer
pxasync_s           *async;         // Reserved, should be NULL
pxtimespec_s        *time;          // Reserved, should be NULL
size_t              blksize;        // Count   sparse
size_t              blkpitch;       // Address sparse
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The contents of imaging board memory
is copied to or from an array or buffer provided
by the application.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit
from which memory is to be copied.
The
<em class="Ep">adrs</em>
specifies the zero based address
within the imaging board memory.
The
<em class="Ep">altspace</em>=0
selects the image frame buffer memory.
The
<em class="Ep">buf</em>
specifies an array or buffer provided by the application.
The
<em class="Ep">cnt</em>
specifies the number of bytes to be read or written.
The
<em class="Ep">rw</em>=PXREAD
chooses read of the imaging board memory
into the
*<em class="Ep">buf</em>;
<em class="Ep">rw</em>=PXRITE
chooses write of the imaging board memory
from the
*<em class="Ep">buf</em>.
</p><p>
For
<a href="#::iosparse" class="Er">::iosparse</a>,
the
<em class="Ep">cnt</em>
bytes are accessed at non consecutive locations in frame buffer memory,
to or from consecutive locations in the array or buffer provided by the
application;
<em class="Ep">blksize</em>
bytes at location
<em class="Ep">adrs</em>,
followed by
<em class="Ep">blksize</em>
bytes at location
<em class="Ep">adrs</em>+<em class="Ep">blkpitch</em>,
etc.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Video Services" class="Ch"></a>
<a name="8.  Structured Style Interface - Video Services"></a>
</p><h1>8.  Structured Style Interface - Video Services</h1>
<p>
</p><hr size="1">
<a name="::xcdev.getLiveStatus NX970" class="NX"></a>
<a name="::xcdev.getLiveStatus" class="Sf"></a>
<a name="Get Live/Snap Status NX971" class="NX"></a>
<a name="Get Live/Snap Status   ---   ::xcdev.getLiveStatus" class="Sf"></a>
<a name="Get Live/Snap Status   ---   ::xcdev.getLiveStatus"></a>
<h6 class="Sf">Get Live/Snap Status   ---   ::xcdev.getLiveStatus</h6>
<a name="::getLiveStatus" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.getLiveStatus) (&amp;xcdev, unitmap, rsvd1, mode);
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 mode;           // Status to check
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The status of the current video snap or live
modes initiated by
<a href="#::setSnapBuf" class="Er">::setSnapBuf</a>,
<a href="#::setSnapPairBuf" class="Er">::setSnapPairBuf</a>,
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>,
<a href="#::setLivePairBuf" class="Er">::setLivePairBuf</a>,
<a href="#::setLiveSeqBuf" class="Er">::setLiveSeqBuf</a>,
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>,
<a href="#::setLivePhys" class="Er">::setLivePhys</a>,
<a href="#::setUnLive" class="Er">::setUnLive</a>,
or
<a href="#::setAbortLive" class="Er">::setAbortLive</a>
is returned.
</p><p>
The
<em class="Ep">mode</em>
specifies the status to be returned.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
mode                            
</td>
<td colspan="1" align="left">
 status returned
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_QUEUED | PXVIST_STATEID  
</td>
<td colspan="1" align="left">
 video state id in queue for captured
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_QUEUED | PXVIST_BUFFER   
</td>
<td colspan="1" align="left">
 image frame buffer in queue for captured
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_QUEUED | PXVIST_VIDMODE  
</td>
<td colspan="1" align="left">
 video mode (PXMODE...) in queue for captured
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_RUNNING | PXVIST_STATEID 
</td>
<td colspan="1" align="left">
 video state id now being captured
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_RUNNING | PXVIST_BUFFER  
</td>
<td colspan="1" align="left">
 image frame buffer now being captured
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_RUNNING | PXVIST_VIDMODE 
</td>
<td colspan="1" align="left">
 video mode (PXMODE...) now being captured
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_DONE | PXVIST_STATEID    
</td>
<td colspan="1" align="left">
 video state id of last captured buffer
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_DONE | PXVIST_BUFFER     
</td>
<td colspan="1" align="left">
 image frame buffer of last captured buffer
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_DONE | PXVIST_VIDMODE    
</td>
<td colspan="1" align="left">
 video mode (PXMODE...) of last captured buffer
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_DONE | PXVIST_VCNT       
</td>
<td colspan="1" align="left">
 video field count of last captured buffer
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_DONE | PXVIST_SYSTICKS0  
</td>
<td colspan="1" align="left">
 low uint of system time of last captured buffer
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXVIST_DONE | PXVIST_SYSTICKS1  
</td>
<td colspan="1" align="left">
 high uint of system time of last captured buffer
</td>
</tr>
</tbody></table>
</pre>
</div>
With
<em class="Ep">mode</em>=PXVIST_DONE|PXVIST_SYSTICKS0
and
<em class="Ep">mode</em>=PXVIST_DONE|PXVIST_SYSTICKS1
the return value should be interpreted as,
and cast to, a
''uint''.
The return value is 0 if the status request does not apply,
such as using PXVIST_RUNNING|PXVIST_STATEID
when the imaging board is done capturing.
<p>
For
<em class="Ep">mode</em>=PXVIST_DONE|PXVIST_SYSTICKS0
and
<em class="Ep">mode</em>=PXVIST_DONE|PXVIST_SYSTICKS1<em class="Ep">:</em>
Under Windows 95, 98, and ME,
the system time is in 1 millisecond units
with a resolution of approximately 50 milliseconds
(i.e.
<cite class="Ec">Get_Last_Updated_System_Time</cite>).
Under Windows NT,
the system time is in 100 nanosecond units
with a resolution of approximately 10 milliseconds
(i.e.
<cite class="Ec">KeQuerySystemTime</cite>).
Under Windows 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64)
the system time is in 100 nanosecond units
with resolution dependent upon the host computer
(i.e.
<cite class="Ec">KeQueryInterruptTime</cite>).
Under Windows NT, 2000, XP, XP(x64), Vista, Vista(x64), 7, and 7(x64)
if the high resolution timer option (see
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>)
is used, the units and resolution are dependent
upon Windows and the host computer
(i.e.
<cite class="Ec">KeQueryPerformanceCounter</cite>).
Under DOS+Tenberry,
the system time is in 54.94 millisecond (i.e. 1/18.2&nbsp;Hz)
units with the same resolution.
Under Linux, the system time units
are dependent on the Linux version and host computer;
for common 2.4 and 2.6 kernels on a PC, the system time is in 10 millisecond units
with the same resolution
(i.e.
<cite class="Ec">jiffies</cite>
and
<cite class="Ec">HZ</cite>).
Under Linux,
if the high resolution timer option (see
<a href="#Driver%20Configuration%20Parameters" class="Er">Driver Configuration Parameters</a>)
is used, the units are 1 microsecond,
with resolution dependent on the host computer
(i.e.
<cite class="Ec">gettimeofday</cite>).
</p><p>
The time provided by the operating system is recorded
by software's response to a hardware interrupt
after the frame is captured, and provided on request.
No claim is made regarding the operating system clock's
accuracy, repeatability, or resolution,
nor the latency between the end of frame capture
and software's recording of the time.
</p><p>
The
<em class="Ep">::getLiveStatus</em>
normally obtains the status of the
single unit selected by
<em class="Ep">unitmap</em>.
If the
<em class="Ep">mode</em>
is OR'ed with PXVIST_ORUNITS,
<em class="Ep">::getLiveStatus</em>
obtains the status of the
multiple units selected by
<em class="Ep">unitmap</em>;
OR'ing the individual status of each unit together
and returning the result.
This, combined with the default return value of 0
when the status request does not apply,
allows checking whether all units have completed
a snap or live operation with a single invocation.
</p><p>
The differentiation and exact timing of whether
or when an imaging board's status qualifies for
PXVIST_RUNNING or for PXVIST_QUEUED
is imaging board dependent.
For example, when
<a href="#::setSnapBuf" class="Er">::setSnapBuf</a>
is issued, and before the start of the next video frame
arrives, the pending request might considered either
PXVIST_RUNNING or PXVIST_QUEUED.
Similarly, after issuing
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>
and continuously capturing into a single buffer,
during the blanking period between frames
the PXVIST_RUNNING modes may return zero.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
Returns video status.
Also may return PXER... codes.
</p><hr size="1">
<a name="::pxdev.getVidStatus NX972" class="NX"></a>
<a name="::pxdev.getVidStatus" class="Sf"></a>
<a name="Get Current Video Status NX973" class="NX"></a>
<a name="Get Current Video Status   ---   ::pxdev.getVidStatus" class="Sf"></a>
<a name="Get Current Video Status   ---   ::pxdev.getVidStatus"></a>
<h6 class="Sf">Get Current Video Status   ---   ::pxdev.getVidStatus</h6>
<a name="::xcdev.getVidStatus NX974" class="NX"></a>
<a name="::xcdev.getVidStatus" class="Sg"></a>
<a name="Get Extended Video Status NX975" class="NX"></a>
<a name="Get Extended Video Status   ---   ::xcdev.getVidStatus" class="Sg"></a>
<a name="Get Extended Video Status   ---   ::xcdev.getVidStatus"></a>
<h6 class="Sg">Get Extended Video Status   ---   ::xcdev.getVidStatus</h6>
<a name="::pxdev.getVidStatusValue NX976" class="NX"></a>
<a name="::pxdev.getVidStatusValue" class="Sg"></a>
<a name="Get Current Video Status Value NX977" class="NX"></a>
<a name="Get Current Video Status Value   ---   ::pxdev.getVidStatusValue" class="Sg"></a>
<a name="Get Current Video Status Value   ---   ::pxdev.getVidStatusValue"></a>
<h6 class="Sg">Get Current Video Status Value   ---   ::pxdev.getVidStatusValue</h6>
<a name="::getVidStatus" class="Tr"></a>
<a name="::getVidStatusValue" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int    (pxdev.getVidStatus)      (&amp;pxdev, unitmap, rsvd1, pxstatus, mode);
int    (xcdev.getVidStatus)      (&amp;xcdev, unitmap, rsvd1, xcstatus, mode);
uint32 (pxdev.getVidStatusValue) (&amp;pxdev, unitmap, rsvd1, mode, offset);
<br>
struct pxdevservice pxdev;          // A pxdevservice instance
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 mode;           // Selection mode
struct pxvidstatus  *pxstatus;      // Video status
struct pxvidstatus  *xcstatus;      // Extended video status
size_t              offset;         // Offset to single value in pxvidstats
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::pxdev.getVidStatus" class="Er">::pxdev.getVidStatus</a>
obtains the current video status
of the single imaging board selected by
<em class="Ep">unitmap</em>,
''returning''
the status in the
<em class="Ep">pxstatus</em>
instance of the
<a href="#pxvidstatus" class="Er">pxvidstatus</a>
structure.
</p><p>
The
<a href="#::xcdev.getVidStatus" class="Er">::xcdev.getVidStatus</a>
obtains the current extended video status
of the single imaging board selected by
<em class="Ep">unitmap</em>,
''returning''
the status in the
<em class="Ep">xcstatus</em>
instance of the
<a href="#xcvidstatus" class="Er">xcvidstatus</a>
structure.
</p><p>
The
<a href="#::getVidStatusValue" class="Er">::getVidStatusValue</a>
returns one
''uint32''
value of the current video status
of the single imaging board selected by
<em class="Ep">unitmap</em>,
avoiding having to transfer an entire structure
in order to observe one value.
The most common use is to obtain the current video field
count:
</p><blockquote>
<pre>    xclib.pxdev.getVidStatusValue(&amp;xclibs.pxdev, 1, 0, PXSTAT_LASTIRQ, Offset(pxvidstatus2, time.vcnt));
</pre>
</blockquote>
where the
<cite class="Ec">Offset</cite>
macro is defined in the C/C++ library.
<p>
If
<em class="Ep">mode</em>=PXSTAT_LASTIRQ,
the video status returned is as of the last interrupt,
regardless of the interrupt's cause.
If
<em class="Ep">mode</em>=PXSTAT_LASTVSP,
the video status returned is as of the last
Vertical Switch Point interrupt;
typically the start or end (imaging board dependent)
of vertical drive at which a
''switch''
of capture video status is performed.
If
<em class="Ep">mode</em>=PXSTAT_UPDATED,
the video status returned is that as of the instant
of execution of
<a href="#::pxdev.getVidStatus" class="Er">::pxdev.getVidStatus</a>,
<a href="#::xcdev.getVidStatus" class="Er">::xcdev.getVidStatus</a>,
or
<a href="#::getVidStatusValue" class="Er">::getVidStatusValue</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
For
<a href="#::pxdev.getVidStatus" class="Er">::pxdev.getVidStatus</a>
and
<a href="#::xcdev.getVidStatus" class="Er">::xcdev.getVidStatus</a>:
</p><dl>
<br><dt>0</dt><dd>
Operation complete
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<p>
The
<a href="#::getVidStatusValue" class="Er">::getVidStatusValue</a>
returns the requested value, or a
PXER... code cast to a uint32.
</p><hr size="1">
<a name="::pxlib.goingBufStatus NX978" class="NX"></a>
<a name="::pxlib.goingBufStatus" class="Sf"></a>
<a name="Get Current Buffer Status NX979" class="NX"></a>
<a name="Get Current Buffer Status   ---   ::pxlib.goingBufStatus" class="Sf"></a>
<a name="Get Current Buffer Status   ---   ::pxlib.goingBufStatus"></a>
<h6 class="Sf">Get Current Buffer Status   ---   ::pxlib.goingBufStatus</h6>
<a name="::goingBufStatus&quot;" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int    (pxlib.goingBufStatus)    (&amp;pxlib, options, unitmap, buffer, status);
<br>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
int                 mode;           // Selection mode
struct pxbufstatus *status;         // Buffer status
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::pxlib.goingBufStatus" class="Er">::pxlib.goingBufStatus</a>
obtains the status of image frame
<em class="Ep">buffer</em>
of the single imaging board selected by
<em class="Ep">unitmap</em>,
''returning''
the status in the
<em class="Ep">status</em>
instance of the
<a href="#pxbufstatus" class="Er">pxbufstatus</a>
structure.
</p><p>
Some of the status information returned is similar
or identical to that obtained via
<a href="#::getLiveStatus" class="Er">::getLiveStatus</a>.
However, the
<a href="#::getLiveStatus" class="Er">::getLiveStatus</a>
returns information on the current status,
or the status when the last buffer was captured.
In contrast, the
<a href="#::pxlib.goingBufStatus" class="Er">::pxlib.goingBufStatus</a>
obtains status information about a specific buffer,
returning status information stored with the buffer.
</p><p>
Capture status information may not stored for each frame buffer,
depending on frame buffer memory configuration
such as use of forceful memory allocation and/or the
''-MU''
<a href="#Device%20Configuration%20Parameters" class="Er">Device Configuration Parameters</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::xcdev.setSnapBuf NX980" class="NX"></a>
<a name="::xcdev.setSnapBuf" class="Sf"></a>
<a name="Initiate Snap into Frame Buffer NX981" class="NX"></a>
<a name="Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf" class="Sf"></a>
<a name="Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf"></a>
<h6 class="Sf">Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf</h6>
<a name="::xcdev.setSnapPairBuf NX982" class="NX"></a>
<a name="::xcdev.setSnapPairBuf" class="Sg"></a>
<a name="Initiate Snap Pair into Frame Buffers NX983" class="NX"></a>
<a name="Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf" class="Sg"></a>
<a name="Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf"></a>
<h6 class="Sg">Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf</h6>
<a name="::xcdev.setLiveBuf NX984" class="NX"></a>
<a name="::xcdev.setLiveBuf" class="Sg"></a>
<a name="Initiate Continuous Capture into Frame Buffer NX985" class="NX"></a>
<a name="Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf" class="Sg"></a>
<a name="Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf"></a>
<h6 class="Sg">Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf</h6>
<a name="::xcdev.setLivePairBuf NX986" class="NX"></a>
<a name="::xcdev.setLivePairBuf" class="Sg"></a>
<a name="Initiate Continuous Alternate Capture into Frame Buffers NX987" class="NX"></a>
<a name="Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf" class="Sg"></a>
<a name="Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf"></a>
<h6 class="Sg">Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf</h6>
<a name="::setLivePhys NX988" class="NX"></a>
<a name="::setLivePhys" class="Sg"></a>
<a name="Initiate Continuous Capture into Memory Space NX989" class="NX"></a>
<a name="Initiate Continuous Capture into Memory Space   ---   ::setLivePhys" class="Sg"></a>
<a name="Initiate Continuous Capture into Memory Space   ---   ::setLivePhys"></a>
<h6 class="Sg">Initiate Continuous Capture into Memory Space   ---   ::setLivePhys</h6>
<a name="::setSnapBuf" class="Tr"></a>
<a name="::setSnapPairBuf" class="Tr"></a>
<a name="::setLiveBuf" class="Tr"></a>
<a name="::setLivePairBuf" class="Tr"></a>
<a name="::setLivePhys" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.setSnapBuf)     (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1);
int (xcdev.setSnapPairBuf) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1, buf2,
                            tracker2);
int (xcdev.setLiveBuf)     (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1);
int (xcdev.setLivePairBuf) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1, buf2,
                            tracker2, period);
int (xcdev.setLivePhys)    (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, vidphys);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   *time;          // Reserved, should be NULL
pxbuffer_t          buf1;           // Image frame buffer
pxbuffer_t          buf2;           // Image frame buffer
int                 tracker1;       // Reserved, should be 0
int                 tracker2;       // Reserved, should be 0
int                 period;         // Reserved, should be 1
struct pxvidphys    vidphys[];      // Memory space specification
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::setSnapBuf" class="Er">::setSnapBuf</a>
initiates a snap of a single video field or frame
on the multiple units selected by
<em class="Ep">unitmap</em>
into image frame buffer
<em class="Ep">buf1</em>.
</p><p>
The
<a href="#::setSnapPairBuf" class="Er">::setSnapPairBuf</a>
initiates a snap of a pair of video fields or frames
on the multiple units selected by
<em class="Ep">unitmap</em>
into image frame buffers
<em class="Ep">buf1</em>
and
<em class="Ep">buf2</em>;
it is intended for use only with cameras with a so-called
''Triggered Dual Exposure''
mode.
</p><p>
The
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>
initiates continuous capture of video fields or frames
on the multiple units selected by
<em class="Ep">unitmap</em>
into image frame buffer
<em class="Ep">buf1</em>.
</p><p>
The
<a href="#::setLivePairBuf" class="Er">::setLivePairBuf</a>
initiates continuous capture of video fields or frames
on the multiple units selected by
<em class="Ep">unitmap</em>
into alternating image frame buffers
<em class="Ep">buf1</em>
and
<em class="Ep">buf2</em>.
</p><p>
If
<em class="Ep">stateid</em>&#8800;0,
the Video Format Configuration
associated with that video state id
by
<a href="#::defineState" class="Er">::defineState</a>
is used to interpret the
<em class="Ep">buf1</em>
and
<em class="Ep">buf2</em>.
If
<em class="Ep">statep</em>&#8800;NULL,
the Video Format Configuration contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure is used to interpret the
<em class="Ep">buf1</em>
and
<em class="Ep">buf2</em>.
The
<em class="Ep">stateid</em>&#8800;0
and
<em class="Ep">statep</em>&#8800;NULL
should not both be specified.
</p><p>
The
<a href="#::setVideoConfig" class="Er">::setVideoConfig</a>
must have been previously invoked
to configure the imaging board to the
Video Format Configuration
specified by
<em class="Ep">stateid</em>
or
<em class="Ep">statep</em>.
</p><p>
The
<a href="#::setLivePhys" class="Er">::setLivePhys</a>
initiates continuous capture of video fields or frames
on the multiple units selected by
<em class="Ep">unitmap</em>
into the memory space specified by
<em class="Ep">vidphys</em>.
There must be one element of
<em class="Ep">vidphys</em>
for each unit
<u class="U">selected</u>
by
<em class="Ep">unitmap</em>;
e.g. for
<em class="Ep">unitmap</em>=9,
the
<em class="Ep">vidphys</em>[0]
is used for unit 0, and the
<em class="Ep">vidphys</em>[1]
is used for unit 3.
</p><p>
The
<a href="#::setSnapBuf" class="Er">::setSnapBuf</a>,
<a href="#::setSnapPairBuf" class="Er">::setSnapPairBuf</a>,
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>,
<a href="#::setLivePairBuf" class="Er">::setLivePairBuf</a>,
and
<a href="#::setLivePhys" class="Er">::setLivePhys</a>
have effect and return
''immediately'';
i.e. without regards to, or waiting for, video sync
or completion of capture of the video field or frames.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::setLiveSeqBuf NX990" class="NX"></a>
<a name="::setLiveSeqBuf" class="Sf"></a>
<a name="Initiate Sequence Capture into Frame Buffers NX991" class="NX"></a>
<a name="Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf" class="Sf"></a>
<a name="Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf"></a>
<h6 class="Sf">Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf</h6>
<a name="::setLiveSeqBuf" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.setLiveSeqBuf)(&amp;xcdev, unitmap, rsvd1, stateid, statep, time, startbuf, endbuf,
                          incbuf, numbuf, period, trackers);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   *time;          // Reserved, should be NULL
pxbuffer_t          startbuf;       // Image frame buffer start
pxbuffer_t          endbuf;         // Image frame buffer end
pxbuffer_t          incbuf;         // Image frame buffer increment
pxbuffer_t          numbuf          // Number of Image frame buffers
int                 period;         // Period between captured fields or frames
int                 trackers;       // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::setLiveSeqBuf" class="Er">::setLiveSeqBuf</a>
initiates a snap of a sequence of video fields or frames
on the multiple units selected by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#::setLiveSeqBuf" class="Er">::setLiveSeqBuf</a>
initiates sequence capture of images into
<em class="Ep">startbuf</em>
through
<em class="Ep">endbuf</em>.
The sequence capture starts into
<em class="Ep">startbuf</em>
and continues into frame buffers
<em class="Ep">startbuf</em>+<em class="Ep">incbuf</em>*1,
<em class="Ep">startbuf</em>+<em class="Ep">incbuf</em>*2,
etc., wrapping around from the
<em class="Ep">endbuf</em>
back to the
<em class="Ep">startbuf</em>.
Typically
<em class="Ep">incbuf</em>=1
for use of consecutive ascending frame buffers.
The
<em class="Ep">numbuf</em>
specifies the number image frame buffers
to be captured.
Typically,
<em class="Ep">numbuf</em>
is
endbuf<em class="Ep">-</em>startbuf<em class="Ep">+1</em>
for simple sequence capture, or 0
for continuous (i.e.
''circular'')
sequence capture.
The
<em class="Ep">videoperiod</em>
specifies the time interval, in video fields or frames,
between captured image frame buffers.
Typically,
<em class="Ep">videoperiod</em>=1
for video rate capture.
For non-interlaced video formats, the
<em class="Ep">videoperiod</em>
is in fields.
For interlaced video formats, the
<em class="Ep">videoperiod</em>
is in units of frames,
unless,
a)&nbsp;Each image frame buffer is configured to
contain only one field, and
b)&nbsp;Video
''switching''
is configured to take place after the
''next'',
rather than after an
''odd''
or an
''even''
field.
</p><p>
If
<em class="Ep">stateid</em>&#8800;0,
the Video Format Configuration
associated with that video state id
by
<a href="#::defineState" class="Er">::defineState</a>
is used to interpret the
<em class="Ep">startbuf</em>
through
<em class="Ep">endbuf</em>.
If
<em class="Ep">statep</em>&#8800;NULL,
the Video Format Configuration contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure is used to interpret the
<em class="Ep">startbuf</em>
through
<em class="Ep">endbuf</em>.
The
<em class="Ep">stateid</em>&#8800;0
and
<em class="Ep">statep</em>&#8800;NULL
should not both be specified.
</p><p>
The
<a href="#::setVideoConfig" class="Er">::setVideoConfig</a>
must have been previously invoked
to configure the imaging board to the
Video Format Configuration
specified by
<em class="Ep">stateid</em>
or
<em class="Ep">statep</em>.
</p><p>
The
<a href="#::setLiveSeqBuf" class="Er">::setLiveSeqBuf</a>
has effect and returns
''immediately'';
i.e. without regards to, or waiting for, video sync
or completion of capture of the video field or frames.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::setLiveTrigBuf NX992" class="NX"></a>
<a name="::setLiveTrigBuf" class="Sf"></a>
<a name="Initiate Triggered Capture into Frame Buffer NX993" class="NX"></a>
<a name="Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf" class="Sf"></a>
<a name="Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf"></a>
<h6 class="Sf">Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf</h6>
<a name="::setLiveTrigBuf" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.setLiveTrigBuf)(&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf, tracker, trigspec);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   *time;          // Reserved, should be NULL
pxbuffer_t          buffer;         // Image frame buffer
int                 tracker;        // Reserved, should be 0
struct pxtrigspec   trigspec;       // Trigger specification
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>
initiates a triggered capture of a video field or frame
on the multiple units selected by
<em class="Ep">unitmap</em>.
</p><p>
The
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>is not
intended, and not needed
for PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB,
EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1,
SI2, and SI4 imaging boards
where the PIXCI® and/or camera hardware
provides dedicated (typically asynchronous) triggering and
''single-shot''
capabilities.
The
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>
is intended for cameras producing continuous
video, and where the imaging board's
General Purpose Input/Output signals
are used to sense external events, and control
external devices.
</p><p>
The
<em class="Ep">trigspec</em>
instance of the
<a href="#pxtrigspec" class="Er">pxtrigspec</a>
structure
specifies how the
General Purpose Input
signal(s) are to be sensed,
how the General Purpose Output
signals are to be controlled,
how many fields or frames to wait at each step,
and when to conclude the capture.
</p><p>
The
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>
is not available for PIXCI® SV2 and SV3
imaging boards.
For PIXCI® D, D24, and D32 imaging boards,
the actual non-zero value of
<em class="Ep">trigspec</em>.<em class="Ep">gpin30wait</em>
is immaterial; the imaging board's hardware determines
the edge sensitivity of the General Purpose Input.
</p><p>
If
<em class="Ep">stateid</em>&#8800;0,
the Video Format Configuration
associated with that video state id
by
<a href="#::defineState" class="Er">::defineState</a>
is used to interpret the
<em class="Ep">buffer</em>.
If
<em class="Ep">statep</em>&#8800;NULL,
the Video Format Configuration contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure is used to interpret the
<em class="Ep">buffer</em>.
The
<em class="Ep">stateid</em>&#8800;0
and
<em class="Ep">statep</em>&#8800;NULL
should not both be specified.
</p><p>
The
<a href="#::setVideoConfig" class="Er">::setVideoConfig</a>
must have been previously invoked
to configure the imaging board to the
Video Format Configuration
specified by
<em class="Ep">stateid</em>
or
<em class="Ep">statep</em>.
</p><p>
The
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>
has effect and returns
''immediately'';
i.e. without regards to, or waiting for, video sync
or completion of capture of the video field or frames.
In execution, the
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>
implements continuous capture of multiple fields or frames
(i.e. effectively a
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>)
into the same
<em class="Ep">buffer</em>
which at the appropriate time is terminated
(i.e. effectively a
<a href="#::setUnLive" class="Er">::setUnLive</a>)
leaving the last captured field or frame.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERRESOURCEBUSY</dt><dd>
Video is already being captured
and must be terminated before
initiating a new capture.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::xcdev.setUnLive NX994" class="NX"></a>
<a name="::xcdev.setUnLive" class="Sf"></a>
<a name="Terminate Live/Snap into Frame Buffer NX995" class="NX"></a>
<a name="Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive" class="Sf"></a>
<a name="Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive"></a>
<h6 class="Sf">Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive</h6>
<a name="::xcdev.setAbortLive NX996" class="NX"></a>
<a name="::xcdev.setAbortLive" class="Sg"></a>
<a name="Abort Live/Snap into Frame Buffer NX997" class="NX"></a>
<a name="Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive" class="Sg"></a>
<a name="Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive"></a>
<h6 class="Sg">Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive</h6>
<a name="::setUnLive" class="Tr"></a>
<a name="::setAbortLive" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.setUnLive)    (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
int (xcdev.setAbortLive) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 mode;           // Status to check
int                 stateid;        // Reserved, should be 0
struct pxvidstate   *statep;        // Reserved, should be NULL
struct pxtimespec   *time;          // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The current video capture mode initiated
by
<a href="#::setSnapBuf" class="Er">::setSnapBuf</a>,
<a href="#::setSnapPairBuf" class="Er">::setSnapPairBuf</a>,
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>,
<a href="#::setLivePairBuf" class="Er">::setLivePairBuf</a>,
<a href="#::setLiveSeqBuf" class="Er">::setLiveSeqBuf</a>
or
<a href="#::setLiveTrigBuf" class="Er">::setLiveTrigBuf</a>
is terminated.
The
<a href="#::setUnLive" class="Er">::setUnLive</a>
causes video capture to be terminated at
the next appropriate field or frame boundary.
The
<a href="#::setAbortLive" class="Er">::setAbortLive</a>
causes video capture to be terminated immediately,
regardless of video timing.
</p><p>
Both
<a href="#::setUnLive" class="Er">::setUnLive</a>
and
<a href="#::setAbortLive" class="Er">::setAbortLive</a>
return
''immediately''
without waiting for completion.
</p><p>
For PIXCI® CL3SD, the
<a href="#::setAbortLive" class="Er">::setAbortLive</a>
currently behaves the same as
<a href="#::setUnLive" class="Er">::setUnLive</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::xcdev.setCameraConfig NX998" class="NX"></a>
<a name="::xcdev.setCameraConfig" class="Sf"></a>
<a name="Set Camera Configuration NX999" class="NX"></a>
<a name="Set Camera Configuration   ---   ::xcdev.setCameraConfig" class="Sf"></a>
<a name="Set Camera Configuration   ---   ::xcdev.setCameraConfig"></a>
<h6 class="Sf">Set Camera Configuration   ---   ::xcdev.setCameraConfig</h6>
<a name="::setCameraConfig" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.setCameraConfig) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   time;           // Reserved, should be NULL
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::setCameraConfig" class="Er">::setCameraConfig</a>
configures the cameras connected to multiple imaging boards
selected by
<em class="Ep">unitmap</em>
to the camera control component of a Video Format Configuration.
</p><p>
The camera control component of a Video Format Configuration
currently supports:
</p><ol type="a">
<p>
</p><li>
Serial commands for Camera Link cameras.
Only selected Camera Link cameras are supported.
<p>
</p></li><li>
I<sup><small>2</small></sup>C commands for SILICON VIDEO® cameras.
</li></ol>
The camera control component of a Video Format Configuration
is intended to allow initializing the camera to a desired state;
a state consistent with the portions of the Video Format Configuration
used by
<a href="#::setVideoConfig" class="Er">::setVideoConfig</a>.
XCLIB does not modify or maintain the camera control component;
specifically, it does not record the commands send via other XCLIB
services.
<p>
If
<em class="Ep">stateid</em>&#8800;0,
the Video Format Configuration
associated with that video state id
by
<a href="#::defineState" class="Er">::defineState</a>
is used.
If
<em class="Ep">statep</em>&#8800;NULL,
the Video Format Configuration contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure is used.
The
<em class="Ep">stateid</em>&#8800;0
and
<em class="Ep">statep</em>&#8800;NULL
should not both be specified.
</p><p>
The
<a href="#::setCameraConfig" class="Er">::setCameraConfig</a>
has effect and returns
''immediately'';
i.e. without regards to video timing.
</p><p>
For most cameras,
<a href="#::setCameraConfig" class="Er">::setCameraConfig</a>
checks the camera's response to each command.
Thus, for most cameras,
<a href="#::setCameraConfig" class="Er">::setCameraConfig</a>
will fail if
the Video Format Configuration
contains camera commands and
the camera is not connected.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERNOFEATURE</dt><dd>
The
camera control component of a Video Format Configuration
did not contain any camera commands appropriate to the selected PIXCI®
imaging card.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::xcdev.setVideoConfig NX1000" class="NX"></a>
<a name="::xcdev.setVideoConfig" class="Sf"></a>
<a name="Set Video Configuration NX1001" class="NX"></a>
<a name="Set Video Configuration   ---   ::xcdev.setVideoConfig" class="Sf"></a>
<a name="Set Video Configuration   ---   ::xcdev.setVideoConfig"></a>
<h6 class="Sf">Set Video Configuration   ---   ::xcdev.setVideoConfig</h6>
<a name="::xcdev.setVideoAdjust NX1002" class="NX"></a>
<a name="::xcdev.setVideoAdjust" class="Sg"></a>
<a name="Adjust Video Configuration NX1003" class="NX"></a>
<a name="Adjust Video Configuration   ---   ::xcdev.setVideoAdjust" class="Sg"></a>
<a name="Adjust Video Configuration   ---   ::xcdev.setVideoAdjust"></a>
<h6 class="Sg">Adjust Video Configuration   ---   ::xcdev.setVideoAdjust</h6>
<a name="::setVideoConfig" class="Tr"></a>
<a name="::setVideoAdjust" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.setVideoConfig) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
int (xcdev.setVideoAdjust) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   time;           // Reserved, should be NULL
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::setVideoConfig" class="Er">::setVideoConfig</a>
configures the multiple imaging boards
selected by
<em class="Ep">unitmap</em>
to a Video Format Configuration.
Configuration always implies terminating any video capture
currently in progress; termination is always immediate.
</p><p>
The
<a href="#::setVideoAdjust" class="Er">::setVideoAdjust</a>
adjusts the multiple imaging boards
selected by
<em class="Ep">unitmap</em>
to a Video Format Configuration.
Only those features which can be adjusted
without reconfiguration of image frame buffers
or without terminating any video capture in progress
are set.
</p><p>
If
<em class="Ep">stateid</em>&#8800;0,
the Video Format Configuration
associated with that video state id
by
<a href="#::defineState" class="Er">::defineState</a>
is used.
If
<em class="Ep">statep</em>&#8800;NULL,
the Video Format Configuration contained in the
<em class="Ep">statep</em>
instance of the
<a href="#pxvidstate" class="Er">pxvidstate</a>
structure is used.
The
<em class="Ep">stateid</em>&#8800;0
and
<em class="Ep">statep</em>&#8800;NULL
should not both be specified.
</p><p>
The
<a href="#::setVideoConfig" class="Er">::setVideoConfig</a>
and
<a href="#::setVideoAdjust" class="Er">::setVideoAdjust</a>
have effect and return
''immediately'';
i.e. without regards to video timing.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Miscellaneous Services" class="Ch"></a>
<a name="9.  Structured Style Interface - Miscellaneous Services"></a>
</p><h1>9.  Structured Style Interface - Miscellaneous Services</h1>
<p>
</p><hr size="1">
<a name="::xcdev.getGpin NX1004" class="NX"></a>
<a name="::xcdev.getGpin" class="Sf"></a>
<a name="General Purpose Input Signal: Sense NX1005" class="NX"></a>
<a name="General Purpose Input Signal: Sense   ---   ::xcdev.getGpin" class="Sf"></a>
<a name="General Purpose Input Signal: Sense   ---   ::xcdev.getGpin"></a>
<h6 class="Sf">General Purpose Input Signal: Sense   ---   ::xcdev.getGpin</h6>
<a name="::xcdev.setGpin NX1006" class="NX"></a>
<a name="::xcdev.setGpin" class="Sg"></a>
<a name="General Purpose Input Signal: Reset NX1007" class="NX"></a>
<a name="General Purpose Input Signal: Reset   ---   ::xcdev.setGpin" class="Sg"></a>
<a name="General Purpose Input Signal: Reset   ---   ::xcdev.setGpin"></a>
<h6 class="Sg">General Purpose Input Signal: Reset   ---   ::xcdev.setGpin</h6>
<a name="::xcdev.setGpout NX1008" class="NX"></a>
<a name="::xcdev.setGpout" class="Sg"></a>
<a name="General Purpose Output Signal: Set NX1009" class="NX"></a>
<a name="General Purpose Output Signal: Set   ---   ::xcdev.setGpout" class="Sg"></a>
<a name="General Purpose Output Signal: Set   ---   ::xcdev.setGpout"></a>
<h6 class="Sg">General Purpose Output Signal: Set   ---   ::xcdev.setGpout</h6>
<a name="::xcdev.getGpout NX1010" class="NX"></a>
<a name="::xcdev.getGpout" class="Sg"></a>
<a name="General Purpose Output Signal: Get NX1011" class="NX"></a>
<a name="General Purpose Output Signal: Get   ---   ::xcdev.getGpout" class="Sg"></a>
<a name="General Purpose Output Signal: Get   ---   ::xcdev.getGpout"></a>
<h6 class="Sg">General Purpose Output Signal: Get   ---   ::xcdev.getGpout</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (xcdev.getGpin) (&amp;xcdev, unitmap, time, rsvd1, rsvd2);
int (xcdev.setGpin) (&amp;xcdev, unitmap, time, rsvd1, value);
int (xcdev.getGpout)(&amp;xcdev, unitmap, time, rsvd1, rsvd2);
int (xcdev.setGpout)(&amp;xcdev, unitmap, time, rsvd1, value);
<br>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
struct pxtimespec   *time;          // Reserved, should be 0
int                 rsvd1;          // Reserved, should be 0
int                 value;          // Binary value(s) to set or reset
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The general purpose input and output
signals are sensed, set, or reset.
</p><p>
The
<a href="#::getGpin" class="Er">::getGpin</a>
obtains the current value of the general purpose
input signals, if any.
</p><p>
The
<a href="#::setGpin" class="Er">::setGpin</a>
resets the current value of the general purpose
input signals, if any, as per
<em class="Ep">value</em>,
for imaging boards where the
general purpose inputs are latched rather than level sensitive.
</p><p>
The
<a href="#::setGpout" class="Er">::setGpout</a>
sets the current value of the general purpose
output signals, if any, to
<em class="Ep">value</em>.
</p><p>
The
<a href="#::getGpout" class="Er">::getGpout</a>
gets the current value of the general purpose
output signals, if any,
returning a value in the same format as
the
<em class="Ep">value</em>
parameter of
<a href="#::setGpout" class="Er">::setGpout</a>.
</p><p>
For
<a href="#::getGpin" class="Er">::getGpin</a>
and
<a href="#::getGpout" class="Er">::getGpout</a>,
the
<em class="Ep">unitmap</em>
specifies the single unit for which the general
purpose input signals are sensed or the current value of
the general purpose output signals are obtained.
For
<a href="#::setGpin" class="Er">::setGpin</a>
and
<a href="#::setGpout" class="Er">::setGpout</a>,
the
<em class="Ep">unitmap</em>
specifies the multiple units for which the general
purpose input signals are reset or the general purpose
output signals are set.
</p><p>
For the PIXCI®&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
The boards' four general purpose output signals, XD4, XD5, XD6, and XD7,
are set to the bits 0x01, 0x02, 0x04, and 0x08 of
<em class="Ep">value</em>,
respectively.
The boards' four general purpose input signals, XD0, XD1, XD2, and XD3,
are sensed in bits
0x01, 0x02, 0x04, and 0x08,
respectively,
of the returned value of
<a href="#::getGpin" class="Er">::getGpin</a>.
The general purpose inputs are level sensitive,
the
<a href="#::setGpin" class="Er">::setGpin</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;SV5B imaging boards:
The board does not provide purpose input or output signals.
</p><p>
For the PIXCI®&nbsp;SV5L imaging board:
The boards' general purpose output signal, XD4,
is set to bit 0x01 of
<em class="Ep">value</em>.
The boards' general purpose input signal, XD0,
is sensed in bit
0x01
of the returned value of
<a href="#::getGpin" class="Er">::getGpin</a>.
The general purpose inputs are level sensitive,
the
<a href="#::setGpin" class="Er">::setGpin</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;ECB1-34 and ECB2 imaging boards:
The board does not provide purpose input or output signals.
</p><p>
For the PIXCI®&nbsp;D, D24, and D32 imaging boards:
The availability of general purpose inputs and outputs
depends upon the board model, revision level, and video format configuration.
The boards may have a single general purpose latched input signal,
sensed as bit 0x01 of the returned value of
<a href="#::getGpin" class="Er">::getGpin</a>,
and reset as bit 0x01
of the
<em class="Ep">value</em>
of
<a href="#::setGpin" class="Er">::setGpin</a>.
The boards may have a single general purpose latched output signal,
set to bit 0x01 of
<em class="Ep">value</em>.
</p><p>
For the PIXCI®&nbsp;CL2, CL3SD, D2X, D3X, E1, E4, EB1, EB1-PoCL, EC1, EL1, SI, and SI1 imaging boards,
and for each functional unit of the PIXCI®&nbsp;E1DB, EL1DB, E4DB, ELS2, SI2, SI4, and SV7 imaging boards:
The two general purpose output signals
are set to bits 0x01 and 0x02 of
<em class="Ep">value</em>.
The two general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<a href="#::getGpin" class="Er">::getGpin</a>.
The general purpose inputs are level sensitive,
the
<a href="#::setGpin" class="Er">::setGpin</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;ECB1 imaging board:
The one general purpose output signal
is set to bit 0x01 of
<em class="Ep">value</em>.
The one general purpose input signal
are sensed in bit
0x01
of the returned value of
<a href="#::getGpin" class="Er">::getGpin</a>.
The general purpose inputs are level sensitive,
the
<a href="#::setGpin" class="Er">::setGpin</a>
has no effect.
</p><p>
For the PIXCI®&nbsp;CL1 imaging boards:
The board's one (revision one boards) or two (revision two and later boards)
general purpose output signals
are set to bits 0x01 and 0x02 of
<em class="Ep">value</em>.
The board's one (revision one boards) or two (revision two and later boards)
general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<a href="#::getGpin" class="Er">::getGpin</a>.
The general purpose inputs are level sensitive,
the
<a href="#::setGpin" class="Er">::setGpin</a>
has no effect.
</p><p>Note:
The general purpose input(s) and output(s)
are those
''auxiliary''
features available on some imaging boards
where, at the hardware level, the signal has no direct effect
on video capture.
The general purpose input(s) and output(s)
are not related to, and not needed for,
camera specific, hardware supported, typically asynchronous exposure,
triggering features available on some cameras when used with
the PIXCI®&nbsp;CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4,
E4DB, EB1, EB1-PoCL, EC1, EL1, EL1DB, ELS2, SI, SI1, SI2, or SI4.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Function performed,
however this returned value is not proof that the
imaging board supports the general purpose input(s) and
output(s).
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxdev.ioctl NX1012" class="NX"></a>
<a name="::pxdev.ioctl" class="Sf"></a>
<a name="Device Control NX1013" class="NX"></a>
<a name="Device Control   ---   ::pxdev.ioctl" class="Sf"></a>
<a name="Device Control   ---   ::pxdev.ioctl"></a>
<h6 class="Sf">Device Control   ---   ::pxdev.ioctl</h6>
<a name="::ioctl" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxdev.ioctl) (&amp;pxdev,options,unitmap,adrs,space,subspace,buf,cnt,rw,async,time);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint32              adrs;           // Address of device
uint                space;          // Device selection space
uint                subspace;       // Device selection subspace
void                *buf;           // Application program buffer
size_t              cnt;            // Transfer count, bytes
uint                rw;             // PXREAD: Copy into program buffer
                                    // PXRITE: Copy from program buffer
pxasync_s           *async;         // Reserved, should be NULL
pxtimespec_s        *time;          // Reserved, should be NULL
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Various imaging board features are accessed and controlled.
</p><p>
For the PIXCI® CL1, CL2, CL3SD, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, and EL1DB,
using
<a href="#ioctl" class="Er">ioctl</a>
with
<em class="Ep">space</em>=CCCC('U','A','R','T')
provides access and control to the serial ports.<a href="#Footnote%2034" class="Ff"><sup>[34]</sup></a>
The
<em class="Ep">unitmap</em>
specifies the single unit's serial port to
be accessed and controlled.
</p><p>
If
<em class="Ep">subspace</em>=CCCC('C','F','G','a')
and
<em class="Ep">rw</em>=PXRITE,
the serial port is configured.
The
<em class="Ep">buf</em>
and
<em class="Ep">cnt</em>
are expected to be a pointer to, and size of:
</p><blockquote>
<pre>    int config[5];
<br>
    config[0] = 96000;  // baud rate * 10
    config[1] = 0;      // reserved
    config[2] = 8;      // data bits
    config[3] = 'n';    // parity selection
    config[4] = 1;      // stop bits
</pre>
</blockquote>
which specify the serial format.
Values shown above correspond to the Camera Link standard.
The PIXCI® CL2, and the PIXCI® CL1 Rev. 3 and later
supports any baud rate between
192.0 and 12,500,000.0 baud, other serial format characteristics
are fixed in hardware.
The PIXCI® CL1 before Rev. 3 and the PIXCI® CL3SD support any baud rate between
95.4 and 6,250,000.0 baud, other serial format characteristics
are fixed in hardware.
The PIXCI® E1, E4, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, and EL1
supports any baud rate between
512.4 and 12,500,000.0 baud, other serial format characteristics
are fixed in hardware.
The PIXCI® E1DB, ECB2, EL1DB, and E4DB
supports any of the baud rates
9600, 19200, 38400, 57600, 115200, 230400, 460800, or 921600 baud
(the Camera Link V2.0 Specification baud rates),
other serial format characteristics
are fixed in hardware.
<p>
If
<em class="Ep">rw</em>=PXREAD,
<em class="Ep">cnt</em>=0,
and
<em class="Ep">subspace</em>=CCCC('R','C','V','1'),
<em class="Ep">subspace</em>=CCCC('R','C','V','0'),
or
<em class="Ep">subspace</em>=CCCC('R','C','V','2'),
the number of received characters waiting to be transferred
from the internal receive queue,
the space in characters available in the internal receive queue,
or the size in characters of the internal receive queue,
respectively,
is returned.
The
<em class="Ep">buf</em>
must be a valid pointer, even though it is not used.
</p><p>
If
<em class="Ep">subspace</em>=CCCC('R','C','V','!'),
<em class="Ep">rw</em>=PXREAD,
and
<em class="Ep">cnt</em>&gt;0,
received characters are transferred from the internal receive
queue to the buffer
<em class="Ep">buf</em>,
and deleted from the receive queue.
The number of characters transferred is the smaller of
<em class="Ep">cnt</em>
and the number of characters waiting in the receive queue;
the same number is returned.
</p><p>
If
<em class="Ep">rw</em>=PXREAD,
<em class="Ep">cnt</em>=0,
and
<em class="Ep">subspace</em>=CCCC('X','M','T','0'),
<em class="Ep">subspace</em>=CCCC('X','M','T','1'),
or
<em class="Ep">subspace</em>=CCCC('X','M','T','2'),
the number of characters of empty space available
in the transmit queue,
the number of characters used in the transmit queue,
or the size in characters of the transmit queue,
respectively,
is returned.
The
<em class="Ep">buf</em>
must be a valid pointer, even though it is not used.
</p><p>
If
<em class="Ep">subspace</em>=CCCC('U','A','R','T'),
<em class="Ep">rw</em>=PXRITE,
and
<em class="Ep">cnt</em>&gt;0,
<em class="Ep">cnt</em>
characters are transferred from buffer
<em class="Ep">buf</em>
to the transmit queue.
The number of characters actually added to the transmit queue
is the smaller of
<em class="Ep">cnt</em>
and the number of characters of empty space available
in the transmit queue; the same number is returned.
</p><p>
None of the serial port features wait for data to
be received, or data to be transmitted; all return
''immediately'',
save minimal execution time.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Auxiliary Services" class="Ch"></a>
<a name="10.  Structured Style Interface - Auxiliary Services"></a>
</p><h1>10.  Structured Style Interface - Auxiliary Services</h1>
<p>
The group of Auxiliary Services provides
''convenience''
features.
These features could also be obtained by
using more fundamental Structured Style Interface
services, either combining several such services,
or combining such services along with the Windows API, the
''C''
library API,
and/or the
<cite class="Ec">PXIPL Image Processing Library</cite>
functions.
</p><p>
For example, the
<a href="#::imageReadUChar" class="Er">::imageReadUChar</a>,
and
<a href="#::imageWriteUChar" class="Er">::imageWriteUChar</a>,
is a combination of
<a href="#::initPximage" class="Er">::initPximage</a>
along with the pximage's
<a href="#::ioread" class="Er">::ioread</a>;
the
<a href="#::imageLoadBmp" class="Er">::imageLoadBmp</a>
and
<a href="#::imageSaveBmp" class="Er">::imageSaveBmp</a>
combines
<a href="#::initPximage" class="Er">::initPximage</a>
with
<cite class="Ec">pxio8_bmpread</cite>
and
<cite class="Ec">pxio8_bmpwrite</cite>
of the
<cite class="Ec">PXIPL Image Processing Library</cite>;
and the
<a href="#::MessageBoxFault" class="Er">::MessageBoxFault</a>
combines
<a href="#::getFault" class="Er">::getFault</a>
with
<cite class="Ec">MessageBox</cite>
of the Windows API.
</p><hr size="1">
<a name="::pxaux.bufferLoadStream NX1014" class="NX"></a>
<a name="::pxaux.bufferLoadStream" class="Sf"></a>
<a name="Load Frame Buffers as Stream NX1015" class="NX"></a>
<a name="Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream" class="Sf"></a>
<a name="Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream"></a>
<h6 class="Sf">Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream</h6>
<a name="::pxaux.bufferSaveStream NX1016" class="NX"></a>
<a name="::pxaux.bufferSaveStream" class="Sg"></a>
<a name="Save Frame Buffers as Stream NX1017" class="NX"></a>
<a name="Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream" class="Sg"></a>
<a name="Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream"></a>
<h6 class="Sg">Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream</h6>
<a name="::bufferLoadStream" class="Tr"></a>
<a name="::bufferSaveStream" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxaux.bufferSaveStream) (&amp;pxaux, abortp, options, unitmap, stateid, startbuf,
                              endbuf, pathname, filehandle, fileoffset, alignsector,
                              rsvd2, rsvd3);
int (pxaux.bufferLoadStream) (&amp;pxaux, abortp, options, unitmap, stateid, startbuf,
                              endbuf, pathname, filehandle, fileoffset, alignsector,
                              rsvd2, rsvd3);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
pxabortfunc_t       **abortp;       // Premature termination function, or NULL
int                 options;        // Options, should be 0, except as described below
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          startbuf;       // First image frame buffer
pxbuffer_t          endbuf;         // Last image frame buffer, inclusive
char                *pathname;      // File path name to be read or written, or NULL
void                *filehandle;    // Existing file handle to be read or written, or NULL
pxbuffer_t          fileoffset;     // Offset into file, in units of image frame buffers
uint32              alignsector;    // Pad image frame buffer size to multiple of ...
uint32              rsvd2;          // Reserved, should be 0
uint32              rsvd3;          // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
A sequence of one or more consecutive image frame buffers
is saved to, for
<a href="#::bufferSaveStream" class="Er">::bufferSaveStream</a>,
or loaded from, for
<a href="#::bufferLoadStream" class="Er">::bufferLoadStream</a>,
a file.
</p><p>
If
<em class="Ep">pathname</em>&#8800;NULL,
the image frame buffers are saved to, or loaded from, the
<em class="Ep">pathname</em>;
for
<a href="#::bufferSaveStream" class="Er">::bufferSaveStream</a>
an already existing
is not deleted and recreated, but partially or fully overwritten
allowable replacement of one or more images within an existing file.<a href="#Footnote%2035" class="Ff"><sup>[35]</sup></a>
Alternately, a
<em class="Ep">filehandle</em>&#8800;NULL,
to a file previously opened by the application may be supplied.
Under Windows the
<em class="Ep">filehandle</em>
is expected to be a
<cite class="Ec">HANDLE</cite>
provided by
<cite class="Ec">CreateFile</cite>.
Under Linux the
<em class="Ep">filehandle</em>
is expected to be a
''file descriptor''
provided by
<cite class="Ec">_open</cite>.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which, or to which,
image frame buffers are to be saved or loaded.
The
<em class="Ep">startbuf</em>
and
<em class="Ep">endbuf</em>,
<em class="Ep">startbuf</em>&lt;=<em class="Ep">endbuf</em>,
specify the first and last image frame buffers, inclusive,
to be saved or loaded.
The entire image frame buffer is loaded or saved.
The
<em class="Ep">stateid</em>
specifies a video state id
previously defined by
<a href="#::defineState" class="Er">::defineState</a>,
against which the
<em class="Ep">startbuf</em>
and
<em class="Ep">endbuf</em>
are interpreted.
</p><p>
Each image frame buffer is saved to, or loaded from,
the file sequentially starting at position
<em class="Ep">fileoffset</em>,
where
<em class="Ep">fileoffset</em>
is interpreted in units
of the size of an image frame buffer.
For example,
<em class="Ep">fileoffset</em>=0
starts at the beginning of the file,
while
<em class="Ep">fileoffset</em>=1
starts with the second image frame buffer in the file.
If
<em class="Ep">alignsector</em>&#8800;0,
the size of each saved image frame buffer, and thus the starting position
relative to the beginning of the file, is padded to a multiple
of
<em class="Ep">alignsector</em>
bytes; typically so that each saved image frame buffer can
be aligned on a multiple of the file system's sector size,
or the operating system's virtual page size.
</p><p>
The image frame buffers are saved or loaded
with a file format which is an exact copy, byte for byte, of
the imaging board's frame buffer memory.
The file format is intended for efficient saving and loading
of image frame buffers; the actual format will vary
with different imaging boards, or different video formats
with a single imaging board.
Use of these functions, and the file format created,
is contraindicated for export to other
(i.e. non-EPIX® imaging software) applications.
Use is also contraindicated for archival storage,
as reloading an image requires the presence of the same
imaging board set to the same video format.
</p><p>
If
<em class="Ep">options</em>&amp;1,
then additional capture status information is prepended to each image frame buffer
as saved, or the capture status information is set as each image frame buffer is loaded.
The information saved or loaded is similar to that obtained via
<a href="#::pxlib.goingBufStatus" class="Er">::pxlib.goingBufStatus</a>,
but encoded within a
<a href="#pxbufstatusfile" class="Er">pxbufstatusfile</a>
structure instead of a
<a href="#pxbufstatus" class="Er">pxbufstatus</a>
structure.
The
<a href="#pxbufstatusfile" class="Er">pxbufstatusfile</a>
currently has a size of 64 bytes;
all discussion above regarding the frame buffer size
in the context of
<em class="Ep">fileoffset</em>
and
<em class="Ep">alignsector</em>
should be interpreted as the frame buffer size plus
the size of the
<a href="#pxbufstatusfile" class="Er">pxbufstatusfile</a>
structure.
Depending on frame buffer memory configuration,
the capture status information may not be available,
or a frame buffer being saved may never have been captured;
when saving, the applicable fields of the
<a href="#pxbufstatusfile" class="Er">pxbufstatusfile</a>
structure are set to 0 values.
</p><p>
Use of the phrase
''stream''
is intended to suggest that memory containing multiple frame buffers
can be saved or loaded efficiently, without
delays due to frame buffer boundaries.
It is not intended to suggest that these functions, by themselves,
continuously save or load an ongoing video stream.
</p><p>
The operation will terminate prematurely if
<em class="Ep">abortp</em>&#8800;NULL,
and
<em class="Ep">(*abortp)(...)</em>,
tested periodically, returns a nonzero value.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERNOFILE</dt><dd>
File doesn't exist (for
<a href="#::bufferLoadStream" class="Er">::bufferLoadStream</a>).
<br></dd><dt>PXERNEWFILE</dt><dd>
File can't be created (for
<a href="#::bufferSaveStream" class="Er">::bufferSaveStream</a>).
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxaux.errorCodeString NX1018" class="NX"></a>
<a name="::pxaux.errorCodeString" class="Sf"></a>
<a name="Errors: Translate Error Code to String NX1019" class="NX"></a>
<a name="Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString" class="Sf"></a>
<a name="Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString"></a>
<h6 class="Sf">Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  (pxaux.errorCodeString) (&amp;pxaux, errorcode);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 errorcode;      // Error return code
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Any of the
''PXER...''
error codes returned by various library functions,
given as the
<em class="Ep">errorcode</em>
parameter, is translated and returned as a
suitable, concise, NULL terminated
error message string.
A NULL value is returned if
<em class="Ep">errorcode</em>
is not a recognized
''PXER...''
code.
</p><p>
The
<a href="#::errorCodeString" class="Er">::errorCodeString</a>
is identical to
<a href="#pxd_mesgErrorCode" class="Er">pxd_mesgErrorCode</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
A char&nbsp;* to an error message, or NULL.
</p><hr size="1">
<a name="::pxaux.faultMessageBox NX1020" class="NX"></a>
<a name="::pxaux.faultMessageBox" class="Sf"></a>
<a name="Errors: Check &amp; Report Faults NX1021" class="NX"></a>
<a name="Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox" class="Sf"></a>
<a name="Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox"></a>
<h6 class="Sf">Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox</h6>
<a name="::pxaux.faultPrintf NX1022" class="NX"></a>
<a name="::pxaux.faultPrintf" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults NX1023" class="NX"></a>
<a name="Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf" class="Sg"></a>
<a name="Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf"></a>
<h6 class="Sg">Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf</h6>
<a name="::MessageBoxFault" class="Tr"></a>
<a name="::printfFault" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int (pxaux.faultMessageBox) (&amp;pxaux, options, unitmap, fault, hWnd, lpCaption, uType);
int (pxaux.faultPrintf)     (&amp;pxaux, options, unitmap, fault, stdio, head, tail);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
struct pxdevfault   *fault;         // Fault to report, or NULL to check for new fault
<br>
HWND                hWnd;           // Parent Window for MessageBox
LPCSTR              lpCaption;      // Caption for MessageBox, or NULL for default
UINT                uType;          // Type of MessageBox, or 0 for default.
<br>
FILE                *stdio;         // Pointer to stream
char                *head;          // Header to displayed fault, or NULL
char                *tail;          // Footer to displayed fault, or NULL
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::faultMessageBox" class="Er">::faultMessageBox</a>
and
<a href="#::faultPrintf" class="Er">::faultPrintf</a>
display faults as described in a
<a href="#pxdevfault" class="Er">pxdevfault</a>
structure.
</p><p>
If
<em class="Ep">fault</em>=NULL,
<a href="#::faultMessageBox" class="Er">::faultMessageBox</a>
and
<a href="#::faultPrintf" class="Er">::faultPrintf</a>
check whether a fault has occurred since the last check,
and if so displays the fault.
The
<em class="Ep">unitmap</em>
specifies the single unit for which faults
are checked and displayed.
</p><p>
If
<em class="Ep">fault</em>&#8800;NULL,
<a href="#::faultMessageBox" class="Er">::faultMessageBox</a>
and
<a href="#::faultPrintf" class="Er">::faultPrintf</a>
display the fault described by the
<em class="Ep">fault</em>
instance of the
<a href="#pxdevfault" class="Er">pxdevfault</a>
structure;
no check is made for any faults that may have occurred
since the last check and
<em class="Ep">unitmap</em>
is ignored.
</p><p>
For
<a href="#::faultMessageBox" class="Er">::faultMessageBox</a>,
the fault's description is displayed in a Windows
<cite class="Ec">MessageBox</cite>;
the
<em class="Ep">Hwnd</em>,
<em class="Ep">lpCation</em>,
and
<em class="Ep">uType</em>
are the window handle, caption, and type parameters passed to the
<cite class="Ec">MessageBox</cite>.
If
<em class="Ep">lpCation</em>=NULL,
a default caption is used.
If
<em class="Ep">uType</em>=0,
a type of MB_OK|MB_TASKMODAL is used.
</p><p>
For
<a href="#::faultPrintf" class="Er">::faultPrintf</a>,
the fault's description is output via the
''C''
standard I/O stream referenced by
<em class="Ep">stdio</em>.
The optional
<em class="Ep">head</em>
and
<em class="Ep">tail</em>
may contain new-line ('\n') terminated text
to be output above and below the fault's
description.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>1</dt><dd>
Fault displayed.
<br></dd><dt>0</dt><dd>
No fault displayed.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERBADSTRUCT</dt><dd>
The
<em class="Ep">fault</em>'s
<a href="#ddch.mos" class="Er">ddch.mos</a>
or
<a href="#ddch.len" class="Er">ddch.len</a>
signature was incorrect.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
See
<a href="#::getFault" class="Er">::getFault</a>
for additional discussion
regarding the cause and nature of faults.
</p><hr size="1">
<a name="::pxaux.imageLoadBmp NX1024" class="NX"></a>
<a name="::pxaux.imageLoadBmp" class="Sf"></a>
<a name="Load Image: BMP Format NX1025" class="NX"></a>
<a name="Load Image: BMP Format   ---   ::pxaux.imageLoadBmp" class="Sf"></a>
<a name="Load Image: BMP Format   ---   ::pxaux.imageLoadBmp"></a>
<h6 class="Sf">Load Image: BMP Format   ---   ::pxaux.imageLoadBmp</h6>
<a name="::pxaux.imageLoadTiff NX1026" class="NX"></a>
<a name="::pxaux.imageLoadTiff" class="Sg"></a>
<a name="Load Image: TIFF Format NX1027" class="NX"></a>
<a name="Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff" class="Sg"></a>
<a name="Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff"></a>
<h6 class="Sg">Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff</h6>
<a name="::pxaux.imageSaveBmp NX1028" class="NX"></a>
<a name="::pxaux.imageSaveBmp" class="Sg"></a>
<a name="Save Image: BMP Format NX1029" class="NX"></a>
<a name="Save Image: BMP Format   ---   ::pxaux.imageSaveBmp" class="Sg"></a>
<a name="Save Image: BMP Format   ---   ::pxaux.imageSaveBmp"></a>
<h6 class="Sg">Save Image: BMP Format   ---   ::pxaux.imageSaveBmp</h6>
<a name="::pxaux.imageSavePcx NX1030" class="NX"></a>
<a name="::pxaux.imageSavePcx" class="Sg"></a>
<a name="Save Image: PCX Format NX1031" class="NX"></a>
<a name="Save Image: PCX Format   ---   ::pxaux.imageSavePcx" class="Sg"></a>
<a name="Save Image: PCX Format   ---   ::pxaux.imageSavePcx"></a>
<h6 class="Sg">Save Image: PCX Format   ---   ::pxaux.imageSavePcx</h6>
<a name="::pxaux.imageSaveTga NX1032" class="NX"></a>
<a name="::pxaux.imageSaveTga" class="Sg"></a>
<a name="Save Image: TARGA Format NX1033" class="NX"></a>
<a name="Save Image: TARGA Format   ---   ::pxaux.imageSaveTga" class="Sg"></a>
<a name="Save Image: TARGA Format   ---   ::pxaux.imageSaveTga"></a>
<h6 class="Sg">Save Image: TARGA Format   ---   ::pxaux.imageSaveTga</h6>
<a name="::pxaux.imageSaveTiff NX1034" class="NX"></a>
<a name="::pxaux.imageSaveTiff" class="Sg"></a>
<a name="Save Image: TIFF Format NX1035" class="NX"></a>
<a name="Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff" class="Sg"></a>
<a name="Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff"></a>
<h6 class="Sg">Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff</h6>
<a name="TIFF Format NX1036" class="NX"></a>
<a name="BMP Format NX1037" class="NX"></a>
<a name="TARGA Format NX1038" class="NX"></a>
<a name="PCX Format NX1039" class="NX"></a>
<a name="::imageLoadBmp" class="Tr"></a>
<a name="::imageLoadTiff" class="Tr"></a>
<a name="::imageSaveBmp" class="Tr"></a>
<a name="::imageSavePcx" class="Tr"></a>
<a name="::imageSaveTga" class="Tr"></a>
<a name="::imageSaveTiff" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  (pxaux.imageLoadBmp) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageLoadTiff)(&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSaveBmp) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSavePcx) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSaveTga) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSaveTiff)(&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
char                *pathname;      // File path name to load from, or save to
int                 loadmode;       // Resize: 'b': Bilinear, 'n': Nearest neighbor
                                    // Color Space: 0x100: convert, 0: no convert
int                 savemode;       // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
An image frame buffer, or an area of interest within the frame buffer,
is loaded from, or saved to, a file named
<em class="Ep">pathname</em>.
</p><p>
The
<a href="#::imageLoadBmp" class="Er">::imageLoadBmp</a>,
<a href="#::imageLoadTiff%20," class="Er">::imageLoadTiff ,</a>
<a href="#::imageSaveBmp" class="Er">::imageSaveBmp</a>,
<a href="#::imageSavePcx" class="Er">::imageSavePcx</a>,
<a href="#::imageSaveTga" class="Er">::imageSaveTga</a>,
and
<a href="#::imageSaveTiff" class="Er">::imageSaveTiff</a>,
are identical to
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>,
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>,
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>,
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>,
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>,
and
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>,
respectively,
except allowing use with an
explicit instance of the XCLIB
library via the
<em class="Ep">pxaux</em>
parameter and using an explicit
video state id specified by
<em class="Ep">stateid</em>,
previously defined by
<a href="#::defineState" class="Er">::defineState</a>,
against which the
<em class="Ep">framebuf</em>
and other parameters are interpreted.
All other parameters of
<a href="#::imageLoadBmp" class="Er">::imageLoadBmp</a>,
<a href="#::imageLoadTiff%20," class="Er">::imageLoadTiff ,</a>
<a href="#::imageSaveBmp" class="Er">::imageSaveBmp</a>,
<a href="#::imageSavePcx" class="Er">::imageSavePcx</a>,
<a href="#::imageSaveTga" class="Er">::imageSaveTga</a>,
and
<a href="#::imageSaveTiff" class="Er">::imageSaveTiff</a>,
correspond in name and meaning to the
parameters of
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>,
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>,
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>,
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>,
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>,
and
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
Same as
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>,
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>,
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>,
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>,
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>,
and
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>.
</p><hr size="1">
<a name="::pxaux.imageReadUChar NX1040" class="NX"></a>
<a name="::pxaux.imageReadUChar" class="Sf"></a>
<a name="Read Pixel Values as Unsigned Char NX1041" class="NX"></a>
<a name="Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar" class="Sf"></a>
<a name="Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar"></a>
<h6 class="Sf">Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar</h6>
<a name="::pxaux.imageReadUShort NX1042" class="NX"></a>
<a name="::pxaux.imageReadUShort" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Short NX1043" class="NX"></a>
<a name="Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort"></a>
<h6 class="Sg">Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort</h6>
<a name="::pxaux.imageReadUInt NX1044" class="NX"></a>
<a name="::pxaux.imageReadUInt" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Int NX1045" class="NX"></a>
<a name="Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt" class="Sg"></a>
<a name="Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt"></a>
<h6 class="Sg">Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt</h6>
<a name="::pxaux.imageWriteUChar NX1046" class="NX"></a>
<a name="::pxaux.imageWriteUChar" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Char NX1047" class="NX"></a>
<a name="Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar</h6>
<a name="::pxaux.imageWriteUShort NX1048" class="NX"></a>
<a name="::pxaux.imageWriteUShort" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Short NX1049" class="NX"></a>
<a name="Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort</h6>
<a name="::pxaux.imageWriteUInt NX1050" class="NX"></a>
<a name="::pxaux.imageWriteUInt" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Int NX1051" class="NX"></a>
<a name="Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt" class="Sg"></a>
<a name="Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt"></a>
<h6 class="Sg">Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt</h6>
<a name="::imageReadUChar" class="Tr"></a>
<a name="::imageReadUShort" class="Tr"></a>
<a name="::imageReadUInt" class="Tr"></a>
<a name="::imageWriteUChar" class="Tr"></a>
<a name="::imageWriteUShort" class="Tr"></a>
<a name="::imageWriteUInt" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  (pxaux.imageReadUChar)  (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ucharbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageReadUShort) (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ushortbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageReadUInt)   (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,uintbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageWriteUChar) (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ucharbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageWriteUShort)(&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ushortbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageWriteUInt)  (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,uintbuf,
                              cnt,colorspace,colormap,iomode,iodata);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
uchar               ucharbuf[];     // Program's buffer to receive or originate values
ushort              ushortbuf[];    // Program's buffer to receive or originate values
uint                uintbuf[];      // Program's buffer to receive or originate values
size_t              cnt;            // Size of ucharbuf, ushortbuf, or uintbuf,
                                    //  in uchar's, ushort's or uint's, respectively.
int                 colorspace;     // Requested color representation
int                 colormap;       // Pixel value component selection
int                 iomode;         // Reserved, should be 0
int                 iodata;         // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Pixel values from an image frame buffer
are copied into, or copied from,
an array or other memory buffer provided
by the application program.
</p><p>
The
<a href="#::imageReadUChar" class="Er">::imageReadUChar</a>
copies pixels from an image frame buffer
into an
''unsigned char''
array or buffer provided by the application;
the
<a href="#::imageWriteUChar" class="Er">::imageWriteUChar</a>
does the reverse.
The
<a href="#::imageReadUShort" class="Er">::imageReadUShort</a>
copies pixels from an image frame buffer
into an
''unsigned short''
array or buffer provided by the application;
the
<a href="#::imageWriteUShort" class="Er">::imageWriteUShort</a>
does the reverse.
The
<a href="#::imageReadUInt" class="Er">::imageReadUInt</a>
copies pixels from an image frame buffer
into an
''unsigned int''
array or buffer provided by the application;
the
<a href="#::imageWriteUInt" class="Er">::imageWriteUInt</a>
does the reverse.
</p><p>
The
<em class="Ep">unitmap</em>
specifies the single unit from which, or to which,
pixel values are to be read or written.
The
<em class="Ep">framebuf</em>
specifies the image frame buffer from which, or to which,
pixel values are to be read or written.
The
<em class="Ep">ulx</em>
and
<em class="Ep">uly</em>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<em class="Ep">lrx</em>
and
<em class="Ep">lry</em>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>())
or the extreme bottom vertical coordinate
(i.e.
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>()),
respectively.
The
<em class="Ep">stateid</em>
specifies a video state id
previously defined by
<a href="#::defineState" class="Er">::defineState</a>,
against which the
<em class="Ep">framebuf</em>,
<em class="Ep">ulx</em>,
<em class="Ep">uly</em>,
<em class="Ep">lrx</em>,
and
<em class="Ep">lry</em>
are interpreted.
</p><p>
The
<em class="Ep">colorspace</em>
and
<em class="Ep">colormap</em>
specifies the color space and color component(s)
in which pixel values are to be read into, or written from,
the program provided array or buffer.
Valid choices for
<em class="Ep">colorspace</em>
are:
</p><blockquote>
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
colorspace    
</td>
<td colspan="1" align="left">
 Number of Components 
</td>
<td colspan="1" align="left">
 Color Representation
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGB     
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Red, Green, Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGR     
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Blue, Green, Red (RGB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBSH     
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Brightness, Saturation, Hue (HSB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGBX    
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Red, Green, Blue, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGRX    
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Blue, Green, Red, Pad (RGB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTGREY    
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Grey Scale
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCB   
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCBX  
</td>
<td colspan="1" align="left">
 4 
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYER   
</td>
<td colspan="1" align="left">
 1 
</td>
<td colspan="1" align="left">
 Raw Bayer Pattern Values
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCBYCRY  
</td>
<td colspan="1" align="left">
 2 
</td>
<td colspan="1" align="left">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCMY     
</td>
<td colspan="1" align="left">
 3 
</td>
<td colspan="1" align="left">
 Cyan, Magenta, Yellow
</td>
</tr>
</tbody></table>
</pre>
</blockquote>
<p>
The
''PXHINTBGRX''
selection, when read into a
''uchar''
buffer on Intel machines with little-endian architecture
(i.e. least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, results in pixels that are compatible with Windows' RGB() data type.
</p><p>
The
''PXHINTBAYER''
selection is available only in conjunction with cameras
that actually output raw Bayer pattern values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
</p><p>
The
''PXHINTCBYCRY''
selection is available only in conjunction with imaging boards
that actually capture CbYCrY (UYVY) values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x), BGR(x), or YCrCb.
</p><p>
The
<em class="Ep">colormap</em>
specifies which color components of the selected
<em class="Ep">colorspace</em>
are to be read into, or written from,
the program provided array or buffer.
The
<em class="Ep">colormap</em>
is a bit-map; the i'th
bit selects the i'th color component.
Example (but not an exhaustive list of) choices are:
</p><blockquote>
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
colorspace    
</td>
<td colspan="1" align="left">
 colormap 
</td>
<td colspan="1" align="left">
 Color Components Selected
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGB     
</td>
<td colspan="1" align="left">
 0x01     
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGB     
</td>
<td colspan="1" align="left">
 0x02     
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGB     
</td>
<td colspan="1" align="left">
 0x04     
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGB     
</td>
<td colspan="1" align="left">
 0x07     
</td>
<td colspan="1" align="left">
 Red, Green, Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGBX    
</td>
<td colspan="1" align="left">
 0x0F     
</td>
<td colspan="1" align="left">
 Red, Green, Blue, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGR     
</td>
<td colspan="1" align="left">
 0x01     
</td>
<td colspan="1" align="left">
 Blue
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGR     
</td>
<td colspan="1" align="left">
 0x02     
</td>
<td colspan="1" align="left">
 Green
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGR     
</td>
<td colspan="1" align="left">
 0x04     
</td>
<td colspan="1" align="left">
 Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGR     
</td>
<td colspan="1" align="left">
 0x07     
</td>
<td colspan="1" align="left">
 Blue, Green, Red
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGRX    
</td>
<td colspan="1" align="left">
 0x0F     
</td>
<td colspan="1" align="left">
 Blue, Green, Red, Pad
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBSH     
</td>
<td colspan="1" align="left">
 0x01     
</td>
<td colspan="1" align="left">
 Brightness
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBSH     
</td>
<td colspan="1" align="left">
 0x02     
</td>
<td colspan="1" align="left">
 Saturation
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBSH     
</td>
<td colspan="1" align="left">
 0x04     
</td>
<td colspan="1" align="left">
 Hue
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBSH     
</td>
<td colspan="1" align="left">
 0x07     
</td>
<td colspan="1" align="left">
 Brightness, Saturation, Hue (HSB reordered)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTGREY    
</td>
<td colspan="1" align="left">
 0x01     
</td>
<td colspan="1" align="left">
 Grey Scale
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCB   
</td>
<td colspan="1" align="left">
 0x01     
</td>
<td colspan="1" align="left">
 Intensity
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCB   
</td>
<td colspan="1" align="left">
 0x02     
</td>
<td colspan="1" align="left">
 Red Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCB   
</td>
<td colspan="1" align="left">
 0x04     
</td>
<td colspan="1" align="left">
 Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCB   
</td>
<td colspan="1" align="left">
 0x07     
</td>
<td colspan="1" align="left">
 Intensity, Red Chroma, Blue Chroma
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCBYCRY  
</td>
<td colspan="1" align="left">
 0x03     
</td>
<td colspan="1" align="left">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</td>
</tr>
</tbody></table>
</pre>
</blockquote>
Typically, only values of
<em class="Ep">colormap</em>
which either select a single component,
or select all components, are supported.
Values of
<em class="Ep">colormap</em>
which select other combinations
of components are generally not supported.
<p>
The
<em class="Ep">ucharbuf</em>,
<em class="Ep">ushortbuf</em>,
or
<em class="Ep">uintbuf</em>
specifies a program provided array or buffer which pixel
values are to be copied into, or copied from.
The
<em class="Ep">cnt</em>
specifies the
number of unsigned chars ,
unsigned shorts
or unsigned ints
in the array or buffer referenced by
<em class="Ep">ucharbuf</em>,
<em class="Ep">ushortbuf</em>,
or
<em class="Ep">uintbuf</em>,
respectively.
The
<em class="Ep">cnt</em>
and the
<em class="Ep">ucharbuf</em>,
<em class="Ep">ushortbuf</em>,
or
<em class="Ep">uintbuf</em>
must be large enough to contain all of the pixel
values implied by
<em class="Ep">ulx</em>,
<em class="Ep">uly</em>,
<em class="Ep">lrx</em>,
<em class="Ep">lry</em>,
<em class="Ep">colorspace</em>,
and
<em class="Ep">colormap</em>;
the
<em class="Ep">cnt</em>
is not intended to be used to limit the number of pixel values
transferred, but is rather intended to assert the maximum
allowable transfer size and induce an error
if the
<em class="Ep">cnt</em>
is too small.
</p><p>
While these functions could be used to read or write
a single pixel value with each invocation,
they are intended, and more efficient, for reading
or writing lines, columns, or entire images of pixel values.
</p><p>
Any data type,
''uchar'',
''ushort'',
or
''uint'',
and any
<em class="Ep">colorspace</em>
can be chosen regardless of the image frame buffer's
actual format.
However, data type and color conversions
may require additional computational overhead.
</p><p>
Each pixel value component is copied from, or copied into,
a single
''uchar'',
''ushort'',
or
''uint'';
pixel values are not
''bit-packed''.
If the data type
has fewer bits that the pixel value component,
the most significant bits of the pixel value component
are copied into the data type, or are copied from the data type
with lower order bits set to 0;
e.g. a 10 bit per pixel component value of 1023 is
stored in an 8 bit
''uchar''
as value 255.
If the data type has more bits than the pixel value
component, the pixel value component is copied into, or copied from,
the data type's least significant bits;
e.g. a 10 bit per pixel component value of 1023
is stored in an 16 bit
''ushort''
as value 1023.
</p><p>
Pixels are read or written, from or to the image,
to or from
<em class="Ep">membuf</em>,
in the order left-to-right and top-to-bottom.
For color pixels with multiple components,
the component values are read or written
in packed, not planer, order.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>&#8805;0</dt><dd>
Returns the number of pixel value components copied into,
or copied from, the
<em class="Ep">membuf</em>.
<br></dd><dt>PXERNOTOPEN</dt><dd>
The library is not open for use.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXERTOOSMALL</dt><dd>
The
<em class="Ep">cnt</em>
is too small to contain the number of pixel value components
specified by
<em class="Ep">ulx</em>,
<em class="Ep">uly</em>,
<em class="Ep">lrx</em>,
<em class="Ep">lry</em>,
<em class="Ep">colorspace</em>,
and
<em class="Ep">colormap.</em>
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">See Also</em>
<p>
The
<a href="#::initPximage" class="Er">::initPximage</a>,
<a href="#::initPximage3" class="Er">::initPximage3</a>,
<a href="#::initFilteredPximage" class="Er">::initFilteredPximage</a>,
and
<a href="#::initFilteredPximage3" class="Er">::initFilteredPximage3</a>
provides alternate methods of reading and writing
pixel values, including top-to-bottom and left-to-right
order, and, depending on memory configuration and
<em class="Ep">colorspace</em>
options,
direct pointer access to the pixel data.
</p><hr size="1">
<a name="::pxaux.makeDIB NX1052" class="NX"></a>
<a name="::pxaux.makeDIB" class="Sf"></a>
<a name="Windows: Make Device Independent Bitmap NX1053" class="NX"></a>
<a name="Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB" class="Sf"></a>
<a name="Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB"></a>
<h6 class="Sf">Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB</h6>
<a name="::pxaux.freeDIB NX1054" class="NX"></a>
<a name="::pxaux.freeDIB" class="Sg"></a>
<a name="Windows: Free Device Independent Bitmap NX1055" class="NX"></a>
<a name="Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB" class="Sg"></a>
<a name="Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB"></a>
<h6 class="Sg">Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB</h6>
<a name="::makeDIB" class="Tr"></a>
<a name="::freeDIB" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  (pxaux.makeDIB) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,Hdibp);
int  (pxaux.freeDIB) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,Hdibp);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
HANDLE              *Hdibp          // *NULL, becomes *HGLOBAL to DIB
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
An image frame buffer, or an area of interest within the image frame buffer,
is copied to a newly created Windows Device Independent Bitmap (DIB)
in global memory (e.g. using the Windows'
<cite class="Ec">GlobalAlloc</cite>)
and the handle to the DIB returned.
</p><p>
The
<em class="Ep">::makeDIB</em>
is identical to
<a href="#pxd_renderDIBCreate" class="Er">pxd_renderDIBCreate</a>
except allowing use with an
explicit instance of the XCLIB
library via the
<em class="Ep">pxaux</em>
parameter and using an explicit
video state id specified by
<em class="Ep">stateid</em>,
previously defined by
<a href="#::defineState" class="Er">::defineState</a>,
against which the
<em class="Ep">framebuf</em>
and other parameters are interpreted.
The
*<em class="Ep">Hdibp</em>
must initially be NULL;
the handle to the DIB is
''returned''
at
*<em class="Ep">Hdibp</em>.
</p><p>
The bitmap created must be freed by
<a href="#::freeDIB" class="Er">::freeDIB</a>
when no longer needed.
The
<em class="Ep">options</em>,
<em class="Ep">unitmap</em>,
<em class="Ep">stateid</em>,
<em class="Ep">framebuf</em>,
<em class="Ep">ulx</em>,
<em class="Ep">uly</em>,
<em class="Ep">lrx</em>,
and
<em class="Ep">lry</em>
parameters are not used and must be 0.
After
<a href="#::freeDIB" class="Er">::freeDIB</a>,
the
*<em class="Ep">Hdibp</em>
is invalid, set to NULL, and must not be used with any function.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="::pxaux.StretchDIBits NX1056" class="NX"></a>
<a name="::pxaux.StretchDIBits" class="Sf"></a>
<a name="Windows: Display Image Frame Buffer On Device Context NX1057" class="NX"></a>
<a name="Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits" class="Sf"></a>
<a name="Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits"></a>
<h6 class="Sf">Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits</h6>
<a name="::StretchDIBits" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  (pxaux.StretchDIBits) (&amp;pxaux, options, unitmap, stateid, framebuf, ulx, uly, lrx, lry,
                            winopts, hDC, nX, nY, nWidth, nHeight);
<br>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
HDC                 hDC;            // Device context
uint                nX;             // Display x position in hDC
uint                nY;             // Display y position in hDC
uint                nWidth;         // Display width in hDC
uint                nHeight;        // Display height in hDC
int                 winoptions;     // Reserved, should be 0
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="Windows NX1058" class="NX"></a>
An image frame buffer, or an area of interest within the image frame buffer,
is copied-rendered-displayed to a Windows device context,
typically a display window or a printer context.
</p><p>
The
<em class="Ep">::StretchDIBits</em>,
is identical to
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>
except allowing use with an
explicit instance of the XCLIB
library via the
<em class="Ep">pxaux</em>
parameter and using an explicit
video state id specified by
<em class="Ep">stateid</em>,
previously defined by
<a href="#::defineState" class="Er">::defineState</a>,
against which the
<em class="Ep">framebuf</em>
and other parameters are interpreted.
All other parameters of
<em class="Ep">::StretchDIBits</em>,
correspond in name and meaning to the
parameters of
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
Same as
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Structured Style Interface - Camera Services" class="Ch"></a>
<a name="11.  Structured Style Interface - Camera Services"></a>
</p><h1>11.  Structured Style Interface - Camera Services</h1>
<p>
</p><hr size="1">
<a name="PXCam_SILICONVIDEO2112 NX1059" class="NX"></a>
<a name="PXCam_SILICONVIDEO2112" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 2112 NX1060" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 2112   ---   PXCam_SILICONVIDEO2112" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 2112   ---   PXCam_SILICONVIDEO2112"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® 2112   ---   PXCam_SILICONVIDEO2112</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO2112(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV2112State_s *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV2112State_s *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV2112State NX1061" class="NX"></a>
<a name="PXCam_SV2112State, struct NX1062" class="NX"></a>
<a name="PXCam_SV2112State_s NX1063" class="NX"></a>
struct PXCam_SV2112State {
    struct  pxddch  ddch;
<br>
    int         id;                 // sensor id, as reported by camera
    int         frameMode;          // 's': still frame, 'v': video
    int         aoiLeft;            // AOI. These values are ..
    int         aoiTop;             // .. always relative to ..
    int         aoiWidth;           // .. full resolution and ..
    int         aoiHeight;          // .. independent of decimation
    int         testRamp;           // 0: off, 1: on
    int         pixelRegistration;  // 0: off, 1: on
    int         scanDirection;      // ('L'&lt;&lt;8)|'T': L-R/T-B
                                    // ('R'&lt;&lt;8)|'T': R-L/T-B
                                    // ('L'&lt;&lt;8)|'B': L-R/B-T
                                    // ('R'&lt;&lt;8)|'B': R-L/B-T
    int         decimation;         // encoded as 0xHHVV
                                    // 0x0101: none
                                    // 0x0202: 2x2
                                    // 0x0404: 4x4
    double      gain[3];            // for R,G,B respectively, in db
    double      exposure;           // in milliseconds
    int         rgbGainLock;        // 0: off, 1: on
    double      extendedLineTime;   // in microseconds
    double      pixelClkFreq;       // in MHz. Info only which must be supplied
<br>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        double  framerate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  exposure;           // millisec
        int     trigger;            // 'n', '+', '-'
        int     strobe;             // 'n', 'p'
        int     bits;               // 8, 10
          ...                       // internal use
    } adj;
};
typedef struct PXCam_SV2112State PXCam_SV2112State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO 2112 NX1064" class="NX"></a>
<a name="SILICON VIDEO 2112C NX1065" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO2112" class="Er">PXCam_SILICONVIDEO2112</a>
allows controlling the various options of the SILICON VIDEO® 2112
and SILICON VIDEO® 2112C cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<em class="Ep">camstatep</em>
are downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">exposure</em>,
<em class="Ep">aoiWidth</em>,
<em class="Ep">aoiHeight</em>,
and
<em class="Ep">gain</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<br>
<br>
<br>
<em class="Ss">Example</em>
<p>
The following example adjusts the camera's exposure and gain.
It does not assume that the camera's current parameters are being
kept in a
<em class="Ep">PXCam_SV2112State_s</em>
from one invocation to the next.
Should the programmer choose to maintain a copy of the camera's
current parameters, much of the following function could be simplified.
</p><blockquote>
<pre>int set2112ExposureAndGain(int unitmap, double exposure, double redgain, double grngain, double blugain)
{
    extern xclibs_s     xclib;          /* library instance, assumed opened */
    PXCam_SV2112State_s camstate;
    int r;
<br>
    memset(&amp;camstate, 0, siz(camstate));
    camstate.ddch.len = siz(camstate));
    camstate.ddch.mos = PXMOS_CAMSV2112STATE;
    //
    // Must get camera clock frequency from video state!
    // Or the camera's downloaded exposure and other values
    // won't be computed properly!
    //
    {
        xclib_DeclareVidStateStructs(vidstate);
        xclib_InitVidStateStructs(vidstate);
        xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
        r = PXCam_SILICONVIDEO2112(PXCam_MapVideoStateToCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, &amp;vidstate);
        if (r &lt; 0)
            return(r);
    }
    //
    // Get camera's current state.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_DownloadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Modify the portions corresponding to gain and exposure.
    //
    camstate.gain[0]  = redgain;
    camstate.gain[1]  = grngain;
    camstate.gain[2]  = blugain;
    camstate.exposure = exposure;
    //
    // In case the caller had supplied invalid parameters, correct.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_SetCorrectValuesInCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Upload state to camera.
    // The frame grabber's video state isn't affected by changes
    // to exposure and gain, and need not be reflected back.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_UploadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    return(r);
}
</pre>
</blockquote>
The following example adjusts the camera's area of interest.
Unlike the example above, the change of the camera area of interest must also
be reflected to the frame grabber.
<blockquote>
<pre>int set2112AOI(int unitmap, int ulx, int uly, int width, int height)
{
    extern xclibs_s     xclib;            /* library instance, assumed opened */
    PXCam_SV2112State_s camstate;
    int r;
    xclib_DeclareVidStateStructs(vidstate);
    xclib_InitVidStateStructs(vidstate);
<br>
    memset(&amp;camstate, 0, siz(camstate));
    camstate.ddch.len = siz(camstate));
    camstate.ddch.mos = PXMOS_CAMSV2112STATE;
    //
    // Must get camera clock frequency from video state!
    // Or the camera's downloaded exposure and other values
    // won't be computed properly!
    //
    xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
    r = PXCam_SILICONVIDEO2112(PXCam_MapVideoStateToCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, &amp;vidstate);
    if (r &lt; 0)
        return(r);
    //
    // Get camera's current state.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_DownloadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Modify the portions corresponding to area of interest.
    //
    camstate.aoiLeft     = ulx;
    camstate.aoiTop      = uly;
    camstate.aoiWidth    = width;
    camstate.aoiHeight   = height;
    //
    // In case the caller had supplied invalid parameters, correct.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_SetCorrectValuesInCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Video capture should have been turned off before
    // calling this service. Make sure, but don't wait for
    // end-of-frame termination.
    //
    r =  xclib.xcdev.setAbortLive(&amp;xclib.xcdev, unitmap, 0, PXMODE_DIGI, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Upload state to camera.
    // The frame grabber's video state isn't affected by changes
    // to exposure and gain, and need not be reflected back.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_UploadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Reflect AOI into video state.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_MapCameraStateToVideoState, 0, unitmap, 0, NULL, &amp;camstate, NULL, &amp;vidstate);
    if (r &lt; 0)
        return(r);
    //
    // Load video state into frame grabber.
    //
    r = xclib.pxlib.defineState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate)
    if (r &lt; 0)
        return(r);
    r = xclib.xcdev.setVideoConfig(&amp;xclib.xcdev, unitmap, 0, PXMODE_DIGI, NULL, NULL);
    if (r &lt; 0)
        return(r);
    return(0);
}
</pre>
</blockquote>
<hr size="1">
<a name="PXCam_SILICONVIDEO1310 NX1066" class="NX"></a>
<a name="PXCam_SILICONVIDEO1310" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 1310 NX1067" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 1310   ---   PXCam_SILICONVIDEO1310" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 1310   ---   PXCam_SILICONVIDEO1310"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® 1310   ---   PXCam_SILICONVIDEO1310</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO1310(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV1310State_s *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV1310State_s *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV1310State NX1068" class="NX"></a>
<a name="PXCam_SV1310State, struct NX1069" class="NX"></a>
<a name="PXCam_SV1310State_s NX1070" class="NX"></a>
struct PXCam_SV1310State {
    struct  pxddch  ddch;
<br>
    int         id;                 // sensor id, as reported by camera
    int         negADCRef;          // mV
    int         posADCRef;          // mV
    int         power;              // 1 or 0
    int         videoMode;          // 'c': free-run, 's': controlled
    int         subsampleMode;      // 0: default: 'm': mono, 'b': bayer
    int         subsample;          // encoded as 0xHHVV
                                    // 0x101: none  0x102:  0x208:  0x802:
                                    // 0x202: 2x2   0x104:  0x401:  0x804:
                                    // 0x404: 4x4   0x108:  0x402:
                                    // 0x808: 8x8   0x201:  0x408:
                                    // etc.         0x204:  0x801:
    int         aoiLeft;            // AOI. these values are ..
    int         aoiTop;             // .. always relative to ..
    int         aoiWidth;           // .. full resolution and ..
    int         aoiHeight;          // .. independent of subsample
    int         readoutDirection;   // CC('L', 'T'): L-R/T-B
                                    // CC('R', 'T'): R-L/T-B
                                    // CC('L', 'B'): L-R/B-T
                                    // CC('R', 'B'): R-L/B-T
    int         offsetCorrection[64+1]; // mV * 10
    int         frameWidth;         // extended columns to increase frame period
    int         frameHeight;        // extended rows to increase frame period
    int         expGainMode;        // 0: raw, 1: lin1, 2: lin2
    int         clrGainMode;        // 0: raw, 1: lin1
    int         analogOffset;       // mV
    double      colorGain[4];       // gain for Bayer mosaic, Gr, R, B, Gb
    double      gain;               // common gain
    double      exposure;           // msec
    double      framePeriod;        // msec
    int         aoiFramePeriodMin;  // rsvd
                                    // 0: off
    int         strobeMode;         // 0:  disabled
                                    // '1': One Line
                                    // 'e': exposure
    int         shA;                // internal use
    int         shB;                // internal use
    int         sofDelay;           // internal use
    int         frameClampHeight;   // internal use
    int         frameClampTop;      // internal use
    int         frameClamp;         // 1: auto frame clamp on, 0: off
<br>
    double      pixelClkFreq;       // in MHz. Info only which must
                                    // be supplied
<br>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        double  framerate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  maxframerate;       // internal use
        int     trigger;            // 'n', '+', '-', 'b'
        int     strobe;             // 'n', 'p'
        int     bits;               // 8, 10
         ...                        // internal use
    } adj;
};
typedef struct PXCam_SV1310State PXCam_SV1310State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO 1310 NX1071" class="NX"></a>
<a name="SILICON VIDEO 1310C NX1072" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO1310" class="Er">PXCam_SILICONVIDEO1310</a>
allows controlling the various options of the SILICON VIDEO® 1310
and SILICON VIDEO® 1310C cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<em class="Ep">camstatep</em>
are downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">colorGain</em>,
<em class="Ep">aoiWidth</em>,
and
<em class="Ep">aoiHeight</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="PXCam_SILICONVIDEO1281 NX1073" class="NX"></a>
<a name="PXCam_SILICONVIDEO1281" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 1281 NX1074" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 1281   ---   PXCam_SILICONVIDEO1281" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 1281   ---   PXCam_SILICONVIDEO1281"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® 1281   ---   PXCam_SILICONVIDEO1281</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO1281(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV1281State_s *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV1281State_s *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV1281State NX1075" class="NX"></a>
<a name="PXCam_SV1281State, struct NX1076" class="NX"></a>
<a name="PXCam_SV1281State_s NX1077" class="NX"></a>
struct PXCam_SV1281State {
    struct  pxddch  ddch;
<br>
    int         productID1;         // as reported
    int         productID2;         // as reported
    int         productID3;         // as reported
    int         blacklevel;         // black level, 0 thru 62
    int         sleep;              // sleep mode. 0: off, 1: on
    int         videomode;          // CC('v','i'): video mode
                                    // CC('s','x'): controlled mode
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         extendHBlank;       // lengthen H blanking
    int         extendVBlank;       // lengthen V blanking
                                    // (no effect on current chips)
    double      gain;               // dB. log(1.5) thru log(39.375)
    double      exposure;           // msec
    double      frameperiod;        // rsvd
    double      pixelClkFreq;       // in MHz. Info only which must be supplied
<br>
    //
    // Chip tweaks which are almost never changed.
    //
    int         bandgap;            // 0: internal, 1: external. reference
    int         clkSchmitt;         // Schmitt trigger. 0: off, 1: on
    int         autoblack;          // 0: internal, 1: external reference
    int         _1stcolamp_rst_cnt; // internal use
    int         _pre_int_rst_cnt;   // internal use
    int         _ds_rst_cnt;        // internal use
    int         _row_sel_wait_cnt;  // internal use
    int         _feed_thru_cnt;     // internal use
    int         rsvd[8];            // internal use
<br>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        double  framerate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  exposure;           // msec. not used
          ...                       // internal use
    } adj;
};
typedef struct PXCam_SV1281State PXCam_SV1281State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO 1281M NX1078" class="NX"></a>
<a name="SILICON VIDEO 1281C NX1079" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO1281" class="Er">PXCam_SILICONVIDEO1281</a>
allows controlling the various options of the SILICON VIDEO® 1281M
and SILICON VIDEO® 1281C cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<em class="Ep">camstatep</em>
are downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">gain</em>,
<em class="Ep">blacklevel</em>,
<em class="Ep">aoiWidth</em>,
and
<em class="Ep">aoiHeight</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="PXCam_SILICONVIDEO9M001 NX1080" class="NX"></a>
<a name="PXCam_SILICONVIDEO9M001" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 9M001 NX1081" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 9M001   ---   PXCam_SILICONVIDEO9M001" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 9M001   ---   PXCam_SILICONVIDEO9M001"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® 9M001   ---   PXCam_SILICONVIDEO9M001</h6>
<a name="PXCam_SILICONVIDEO9M001 NX1082" class="NX"></a>
<a name="PXCam_SILICONVIDEO9M001" class="Sg"></a>
<a name="Camera Control: SILICON VIDEO® 9T001 NX1083" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 9T001   ---   PXCam_SILICONVIDEO9M001" class="Sg"></a>
<a name="Camera Control: SILICON VIDEO® 9T001   ---   PXCam_SILICONVIDEO9M001"></a>
<h6 class="Sg">Camera Control: SILICON VIDEO® 9T001   ---   PXCam_SILICONVIDEO9M001</h6>
<a name="PXCam_SILICONVIDEO9M001 NX1084" class="NX"></a>
<a name="PXCam_SILICONVIDEO9M001" class="Sg"></a>
<a name="Camera Control: SILICON VIDEO® 5M10/5C10 NX1085" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 5M10/5C10   ---   PXCam_SILICONVIDEO9M001" class="Sg"></a>
<a name="Camera Control: SILICON VIDEO® 5M10/5C10   ---   PXCam_SILICONVIDEO9M001"></a>
<h6 class="Sg">Camera Control: SILICON VIDEO® 5M10/5C10   ---   PXCam_SILICONVIDEO9M001</h6>
<a name="PXCam_SILICONVIDEO9M001 NX1086" class="NX"></a>
<a name="PXCam_SILICONVIDEO9M001" class="Sg"></a>
<a name="Camera Control: SILICON VIDEO® 9C10 NX1087" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 9C10   ---   PXCam_SILICONVIDEO9M001" class="Sg"></a>
<a name="Camera Control: SILICON VIDEO® 9C10   ---   PXCam_SILICONVIDEO9M001"></a>
<h6 class="Sg">Camera Control: SILICON VIDEO® 9C10   ---   PXCam_SILICONVIDEO9M001</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO9M001(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV9M001State_s *camstatep;    // Pointer to SILICON VIDEO parameters
PXCam_SV9M001State_s *camstate2p;   // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV9M001State NX1088" class="NX"></a>
<a name="PXCam_SV9M001State, struct NX1089" class="NX"></a>
<a name="PXCam_SV9M001State_s NX1090" class="NX"></a>
struct PXCam_SV9M001State {
    struct  pxddch  ddch;
<br>
    int         ID;                 // sensor id, as reported by camera
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         subsample;          // encoded as 0xHHVV
                                    // 0x0101: none  0x0204: 2x4
                                    // 0x0202: 2x2   0x0208: 2x8
                                    // 0x0404: 4x4   0x0401: 4x1
                                    // 0x0808: 8x8   0x0402: 4x2
                                    // 0x0102: 1x2   0x0408: 4x8
                                    // 0x0104: 1x4   0x0801: 8x1
                                    // 0x0108: 1x8   0x0802: 8x2
                                    // 0x0201: 2x1   0x0804: 8x4
                                    // 0x0110: 1x16  0x0210: 2x16
                                    // 0x0120: 1x32  0x0220: 2x32
                                    // 0x0410: 4x16
                                    // 0x0420: 4x32
                                    // SV9M001/SV9T001: no x__10, x__20
                                    // SV5x10: no x08__, x__10, x__20
                                    // SV9C10: no x08__
    int         subbinning;         // Bit 0=0: subsample is subsampling
                                    // Bit 0=1: subsample is binning
                                    // SV9T001/SV5x10 only
                                    // Bit 1=0: binning is averaging
                                    // Bit 1=1: binning is summing
                                    // SV5x10 only
    int         scanDirection;      // CC('R','T'): L-R/T-B
                                    // CC('R','B'): L-R/B-T
                                    // SV9M001/SV5x10/SV9C10 only
                                    // CC('L','T'): R-L/T-B
                                    // CC('L','B'): R-L/B-T
                                    // SV5x10/SV9C10 only
    int         testdata;           // 0: off, 1: on
                                    // SV9M001/SV9T001
                                    // 0: off, 1 thru 9: on-various
                                    // SV5x10
                                    // 0: off, 1-4, 256-258: on-various
                                    // SV9x10
    int         chipenable;         // 1: on, 0: off
                                    // SV9M001/SV9T001 only
    int         videoMode;          // 'c': free-run, 's': controlled
                                    // SV5x10: 'g'^'s': controlled global
                                    // SV9T001:'r'^'s': controlled global
                                    // SV9C10: 'g'^'s': controlledglobal
                                    // SV9C10: no 's'
    int         hBlank;             // lengthen H blanking - set via framePeriod
                                    // SV9C10: actual line length
    int         vBlank;             // lengthen V blanking - set via framePeriod
                                    // SV9C10: actual frame length
    int         blackLevelMode;     // 'n': auto/ADC, 'c': auto (SV9M001 only)
                                    // 'm': manual, 'd': disabled (SV9M001 only)
    int         strobeMode;         //   0 : disabled
                                    //  'e': exposure
                                    //  '1': one line
                                    //  SV9M001/SV9T001 only
                                    //    0 : disabled
                                    //   'e': enabled
                                    //   'i': inverted
                                    //  SV5x10 only
                                    // 'p': programmed
                                    // SV9C10 only
    int         microExposure;      // 1: allow short exposure less than 1 line,
                                    // 0: don't
                                    // SV9M001 only
    int         macroExposure;      // 1: allow long exposure
                                    // 0: don't
                                    // SV9T001/SV5x10/SV9C10 only
    int         blackrgb[4];        // rsvd. 0
    int         blacklevel;         // black level
                                    // SV9T001 only
    int         strobeStart;        // 0/1/2/3: select start timing
                                    // SV5x10 only
    int         strobeEnd;          // 0/1/2/3: select strobe duration
                                    // SV5x10 only
        ...                         // internal use
    double      gainrgb[4];         // Gb/B/R/Gr dB
    double      exposure;           // exposure period, msec
    double      shutterDelay;       // rsvd. 0
    double      framePeriod;        // frame period, msec
    double      pixelClkFreq;       // in MHz. Info only which must be supplied
    double      digitalgain;        // SV9M001: not used
                                    // SV9T001: deprecated, dB
                                    // SV5x10:  not used
                                    // SV9C10:  used
    double      strobePeriod;       // strobe period, msec: SV9C10 only
        ...                         // internal use
<br>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        double  framerate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  exposure;           // msec. not used
        int     bits;               // 8, 10 (SV9M001/SV9T001)
                                    // 8, 12 (SV5x10,SV9C10)
        int     bitpack;            // 0: off, 1: on w. bits!=8
                                    // only w. PIXCI(R) SI1, SI2, SI4
        int     strobepolarity: 1;  // 0: normal, 1: invert strobe
                                    // SV5x10: not needed
        int     smaoutSI4;          // sma trig output connector is
                                    // sma trig in or camera N expose
                                    // PIXCI SI4 only
          ...                       // internal use
    } adj;
};
typedef struct PXCam_SV9M001State PXCam_SV9M001State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO 9M001 NX1091" class="NX"></a>
<a name="SILICON VIDEO 9M001C NX1092" class="NX"></a>
<a name="SILICON VIDEO 9T001C NX1093" class="NX"></a>
<a name="SILICON VIDEO 5C10 NX1094" class="NX"></a>
<a name="SILICON VIDEO 5M10 NX1095" class="NX"></a>
<a name="SILICON VIDEO 9C10 NX1096" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO9M001" class="Er">PXCam_SILICONVIDEO9M001</a>
allows controlling the various options of the
SILICON VIDEO® 9M001,
SILICON VIDEO® 9M001C,
SILICON VIDEO® 9T001C,
SILICON VIDEO® 5C10,
SILICON VIDEO® 5M10,
and
SILICON VIDEO® 9C10,
cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<em class="Ep">camstatep</em>
are downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
Because
<a href="#PXCam_SILICONVIDEO9M001" class="Er">PXCam_SILICONVIDEO9M001</a>
is intended to operate
several similar, but different, cameras, the
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle
must be used to obtain the camera ID so that other commands, below,
can adapt properly.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">gainrgb[]</em>,
<em class="Ep">aoiWidth</em>,
<em class="Ep">aoiHeight</em>,
and
<em class="Ep">exposure</em>,
and
<em class="Ep">digitalgain</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
</p><p>
For
SILICON VIDEO® 9T001C cameras,
use of the
<em class="Ep">digitalgain</em>
member
is deprecated; the former, separate digital
gain has been integrated into the
<em class="Ep">gainrgb[]</em>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="PXCam_SILICONVIDEO642 NX1097" class="NX"></a>
<a name="PXCam_SILICONVIDEO642" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 642 NX1098" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 642   ---   PXCam_SILICONVIDEO642" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 642   ---   PXCam_SILICONVIDEO642"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® 642   ---   PXCam_SILICONVIDEO642</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO642(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV642State_s  *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV642State_s  *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV642State NX1099" class="NX"></a>
<a name="PXCam_SV642State, struct NX1100" class="NX"></a>
<a name="PXCam_SV642State_s NX1101" class="NX"></a>
struct PXCam_SV642State {
    struct  pxddch  ddch;
<br>
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         hBlank;             // lengthen H blanking - set via framePeriod
    int         vBlank;             // lengthen V blanking - set via framePeriod
    int         gainrange;          // 10: high range, 5: low range
    int         videoMode;          // CCC('m','c','i'): free-run
                                    // CCC('s','s','e'): controlled
                                    // CCC('m','c','e'): master/Cont/Seq
                                    // CCC('s','c','e'): slave/Cont/Seq
    int         interlaceMode;      // 0: progressive
                                    // 1: interlaced
                                    // 2: one field
    int         macroExposure;      // 1: allow long exposure
                                    // 0: don't
<br>
    int         VLNAMP;             // voltage references and internal
    int         VLNOUT;             // default versus explicit selection
    int         VLN1;               //  ..
    int         VLN2;               //  ..
    int         VLN2BOOST;          //  ..
    int         VLP;                //  ..
    int         VREF;               //  ..
    int         VOFF;               //  ..
    int         VREF1;              //  ..
    int         VREF2;              //  ..
    int         vref;               //  ..
    int         vref2;              //  ..
    int         vref1;              //  ..
    int         voff;               //  ..
    int         rsvd1[8];
<br>
    double      exposure;           // exposure period, msec
    double      framePeriod;        // frame period, msec
    double      gainrgb[4];         // Gb/B/R/Gr dB
    double      pixelClkFreq;       // in MHz. Info only which must
                                    // be supplied
        ...                         // internal use
<br>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        int     bits;               // 8, 10
        ...                         // internal use
        double  framerate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  exposure;           // msec. not used
        double  maxframerate;
        ...                         // internal use
    } adj;
<br>
};
typedef struct PXCam_SV642State PXCam_SV642State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO 642M NX1102" class="NX"></a>
<a name="SILICON VIDEO 642C NX1103" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO642" class="Er">PXCam_SILICONVIDEO642</a>
allows controlling the various options of the
SILICON VIDEO® 642M
and
SILICON VIDEO® 642C
cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<em class="Ep">camstatep</em>
are downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">gainrgb[]</em>,
<em class="Ep">aoiWidth</em>,
and
<em class="Ep">aoiHeight</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="PXCam_SILICONVIDEO643 NX1104" class="NX"></a>
<a name="PXCam_SILICONVIDEO643" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 643 NX1105" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® 643   ---   PXCam_SILICONVIDEO643" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® 643   ---   PXCam_SILICONVIDEO643"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® 643   ---   PXCam_SILICONVIDEO643</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO643(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV643State_s  *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV643State_s  *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV643State NX1106" class="NX"></a>
<a name="PXCam_SV643State, struct NX1107" class="NX"></a>
<a name="PXCam_SV643State_s NX1108" class="NX"></a>
struct PXCam_SV643State {
    struct  pxddch  ddch;
<br>
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         scanDirection;      // CC('R', 'B'): L-R/T-B
                                    // CC('R', 'T'): L-R/B-T
    int         subsample;          // 0x0101: none
                                    // 0x0102: none
    int         videoMode;          // 'c': free-run
                                    // 's': controlled
    int         pixelClkGran;       // internal use
    int         frameTransfer;      // internal use
    int         macroExposure;      // 1: allow long exposure
                                    // 0: don't
    int         expmode;            // 1: normal
                                    // 2: dual slope
                                    // 3: triple slope
      ...                           // internal use
<br>
    double      pixelClkFreq;       // in MHz. Info only which must
                                    // be supplied
    double      gain;               // dB.   20*log10( 1.00)
                                    // thru  20*log10(15.38)
    double      framePeriod;        // frame period, msec
    double      exposure;           // free-run exposure period, msec
    double      Vcal;               // A-D voltage. See Cypress data sheet
    double      Vblack;             // A-D voltage. See Cypress data sheet
    double      Voffset;            // A-D voltage. See Cypress data sheet
    double      exposure2;          // dual slope exposure/reset
    double      exposure3;          // triple slope exposure/reset
      ...                           // internal use
<br>
    struct {
                                    // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        int     bits;               // 8, 10
        int     strobepolarity;     // 'p', 'n'
        int     bitpack;            // 0: off, 1: on w. bits!=8
                                    // only w. PIXCI(R) SI1, SI2, SI4
           ...
        double  framerate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  exposure;           // controlled exposure, msec
           ...                      // internal use
    } adj;
};
typedef struct PXCam_SV643State PXCam_SV643State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO 643M NX1109" class="NX"></a>
<a name="SILICON VIDEO 643C NX1110" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO643" class="Er">PXCam_SILICONVIDEO643</a>
allows controlling the various options of the
SILICON VIDEO® 643M
and
SILICON VIDEO® 643C
cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">gain</em>,
<em class="Ep">aoiWidth</em>,
and
<em class="Ep">aoiHeight</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateSerialToCameraState
the SPI commands within the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
Other function arguments are not used.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="1">
<a name="PXCam_SILICONVIDEO032 NX1111" class="NX"></a>
<a name="PXCam_SILICONVIDEO032" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® WGA NX1112" class="NX"></a>
<a name="Camera Control: SILICON VIDEO® WGA   ---   PXCam_SILICONVIDEO032" class="Sf"></a>
<a name="Camera Control: SILICON VIDEO® WGA   ---   PXCam_SILICONVIDEO032"></a>
<h6 class="Sf">Camera Control: SILICON VIDEO® WGA   ---   PXCam_SILICONVIDEO032</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int PXCam_SILICONVIDEO032(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV032State_s  *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV032State_s  *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<br>
<a name="Struct PXCam_SV032State NX1113" class="NX"></a>
<a name="PXCam_SV032State, struct NX1114" class="NX"></a>
<a name="PXCam_SV032State_s NX1115" class="NX"></a>
struct PXCam_SV032State {
    struct  pxddch  ddch;
<br>
    int         id;                 // chip ID as reported
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         scanDirection;      // CC('R', 'T'): L-R/T-B
                                    // CC('R', 'B'): L-R/B-T
                                    // CC('L', 'T'): R-L/T-B
                                    // CC('L', 'B'): R-L/B-T
    int         subsample;          // encoded as 0xHHVV
                                    // 0x0101: none
                                    // 0x0102: 1x2
                                    // 0x0104: 1x4
    int         videoMode;          // 'c': free-run
                                    // 's': controlled
    int         hBlank;             // lengthen H blanking
    int         vBlank;             // lengthen V blanking
    int         adcMode;            // 10: linear, 12: companded
    int         adcModeColor;       // 0: neutral, 1: warmer
    int         testPattern;        // 0: off, 1-3: various
    int         agc;                // 0: off, 1: auto gain on
    int         aec;                // 0: off, 1: auto exposure on
    int         strobeMode;         // 0: disabled, 'e': enabled,
                                    // 'i': inverted
    int         readoutMode;        // 'i': overlaps exposure
                                    // 'e': follows exposure (not fully
                                    //      supported)
    int         exposureMode;       // 'l': linear
                                    // 'x': high dynamic range (HDR)
    int         macroExposure;      // 1: allow long exposure
                                    // 0: don't
    int         aecMaxmax;
    int         agcUpdates;         // 1-16: agc update period
    int         aecUpdates;         // 1-16: aec update period
    int         aegcTarget;         // 16-1008: agc/aec image target value
    int         aecLpf;             // 0-2: aec low pass filtering
    int         agcLpf;             // 0-2: agc low pass filtering
    int         aegcCount;          // 0-65535: pixels analyzed for aec/agc
    int         hdrMode;            // 'a': auto HDR, 'm': manual HDR
    int         hdrKnee;            // 1-2: # of HDR knees
    int         ecl;                // 0: off, 1: anti-eclipse on
    ...
<br>
    double      gain;               // in dB.
    double      exposure;           // in milliseconds
    double      framePeriod;        // frame period, msec
    double      agcMax;             // max gain set by AGC, in dB.
    double      aecMax;             // max exposure set by AEC, in msec.
    double      digitalGain;        // in dB.
    double      vref;               // ADC Ref., V.
    double      v1;                 // ADC V1, V.
    double      v2;                 // ADC V2, V.
    double      v3;                 // ADC V3, V.
    double      v4;                 // ADC V4, V.
    double      hdrT2;              // HDR T2 &amp; T3 ratio ..
    double      hdrT3;              // .. pow(.5, 15) - pow(.5, 0)
    double      hdrExp1;            // HDR T1 exposure, msec.
    double      hdrExp2;            // HDR T1 exposure, msec.
    double      eclRef;             // anti-eclipse reference, V.
    ...
<br>
    struct {
        int         isColor;        // 0: sensor is mono, 1: is color
                                    // Info only which must be supplied
        double      pixelClkFreq;   // in MHz. Info only which must
                                    // be supplied
    } adi;
<br>
    struct {
                                    // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
<br>
        int     bits;               // 8, 10
        int     bitpack;            // 0: off, 1: on w. bits!=8
                                    // only w. PIXCI(R) SI1,SI2,SI4
        int     strobePolarity;     // not used
        ...
<br>
        double  frameRate;          // rate in 'c' mode, Hz.
                                    // min. retrigger period
                                    // in 's' mode (1/Hz).
        double  exposure;           // msec. not used
        double  maxFrameRate;       // internal use
        double  resetDelay;         // internal use
        ...
    } adj;
};
typedef struct PXCam_SV032State PXCam_SV032State_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
<a name="SILICON VIDEO WGA-M NX1116" class="NX"></a>
<a name="SILICON VIDEO WGA-C NX1117" class="NX"></a>
The
<a href="#PXCam_SILICONVIDEO032" class="Er">PXCam_SILICONVIDEO032</a>
allows controlling the various options of the
SILICON VIDEO® WGA-M
and
SILICON VIDEO® WGA-C
cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<em class="Ep">camstatep</em>
are downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is initialized with camera default parameters.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<em class="Ep">camstatep</em>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<em class="Ep">camstatep</em>
is used to modify the video state referenced by
<em class="Ep">vidstatep</em>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<em class="Ep">vidstatep</em>
is used to modify the camera state referenced by
<em class="Ep">camstatep</em>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<em class="Ep">camstatep</em>
which is different than the corresponding portions
of the camera state referenced
<em class="Ep">camstate2p</em>
are uploaded to the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<em class="Ep">camstatep</em>
is downloaded from the camera.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<em class="Ep">porttype</em>
must be PXCam_PortIspxdevservice,
the
<em class="Ep">port</em>
must be a (pxdevservice_s*).
Other function arguments are not used.
</p><p>
If
<em class="Ep">cmnd</em>=PXCam_SetMinimumValuesInCameraState
or
<em class="Ep">cmnd</em>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<em class="Ep">camstate2p</em>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<em class="Ep">camstatep</em>.
Only the
<em class="Ep">gainrgb[]</em>,
<em class="Ep">aoiWidth</em>,
and
<em class="Ep">aoiHeight</em>
members of the camera state referenced by
<em class="Ep">camstate2p</em>
are currently set.
Other function arguments are not used.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
</p><dl>
<br><dt>0</dt><dd>
Operation complete.
<br></dd><dt>PXERROR</dt><dd>
Invalid parameters.
<br></dd><dt>PXER...</dt><dd>
Other error codes as appropriate.
</dd></dl>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Device Independent Image Access Interface" class="Ch"></a>
<a name="12.  Device Independent Image Access Interface"></a>
</p><h1>12.  Device Independent Image Access Interface</h1>
<p>
The
<em class="Ep">pximage</em>
and
<em class="Ep">pximage3</em>
interfaces support a variety of device independent services
to access image buffers.
They are device independent in that,
in conjunction with the
<cite class="Ec">PXIPL Image Processing Library</cite>,
a
<em class="Ep">pximage</em>
or
<em class="Ep">pximage3</em>
can be constructed to provide access to images in program memory buffers,
disk files, or other media;
using any pixel format, resolution, and bit depth
unconstrained by PIXCI(rg support.
All such images described by a
<em class="Ep">pximage</em>
or
<em class="Ep">pximage3</em>
can be accessed in the same manner, or processed by
<cite class="Ec">PXIPL</cite>
functions.<a href="#Footnote%2036" class="Ff"><sup>[36]</sup></a>
</p><hr size="1">
<a name="Struct pximage NX1118" class="NX"></a>
<a name="Struct pximage" class="Sf"></a>
<a name="PXIMAGE: Image and Pixel Specifications NX1119" class="NX"></a>
<a name="PXIMAGE: Image and Pixel Specifications   ---   Struct pximage" class="Sf"></a>
<a name="PXIMAGE: Image and Pixel Specifications   ---   Struct pximage"></a>
<h6 class="Sf">PXIMAGE: Image and Pixel Specifications   ---   Struct pximage</h6>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre><a name="Type pxcoord_t NX1120" class="NX"></a>
<a name="pxcoord_t NX1121" class="NX"></a>
<a name="pxcoord_t" class="Tr"></a>
typedef int pxcoord_t;      // a coordinate
<br>
<a name="Struct pxy NX1122" class="NX"></a>
<a name="pxy, struct NX1123" class="NX"></a>
<a name="pxy_s NX1124" class="NX"></a>
<a name="pxypoint_s NX1125" class="NX"></a>
<a name="pxy" class="Tr"></a>
<a name="pxy_s" class="Tr"></a>
<a name="pxypoint_s" class="Tr"></a>
struct pxy {                // a pair of coordinates
    pxcoord_t   x;
    pxcoord_t   y;
};
typedef struct pxy pxy_s;
typedef struct pxy pxypoint_s;
<br>
<a name="Struct pxywindow NX1126" class="NX"></a>
<a name="pxywindow, struct NX1127" class="NX"></a>
<a name="pxywindow_s NX1128" class="NX"></a>
<a name="pxywindow" class="Tr"></a>
<a name="pxywindow_s" class="Tr"></a>
struct pxywindow {          // a pair of 2-d points
    struct  pxy nw;         // north west corner inclusive
    struct  pxy se;         // south east corner, usually exclusive
};
typedef struct pxywindow pxywindow_s;
<br>
<a name="Struct pxyz NX1129" class="NX"></a>
<a name="pxyz, struct NX1130" class="NX"></a>
<a name="pxyz_s NX1131" class="NX"></a>
<a name="pxyzpoint_s NX1132" class="NX"></a>
<a name="pxyz" class="Tr"></a>
<a name="pxyz_s" class="Tr"></a>
<a name="pxyzpoint_s" class="Tr"></a>
struct pxyz {               // a triplet of coordinates
    pxcoord_t   x;
    pxcoord_t   y;
    pxcoord_t   z;
};
typedef struct pxyz pxyz_s;
typedef struct pxyz pxyzpoint_s;
<br>
<a name="Struct pxyzwindow NX1133" class="NX"></a>
<a name="pxyzwindow, struct NX1134" class="NX"></a>
<a name="pxyzwindow_s NX1135" class="NX"></a>
<a name="pxyzwindow" class="Tr"></a>
<a name="pxyzwindow_s" class="Tr"></a>
struct pxyzwindow {         // a pair of 3-d points
    struct  pxyz nw;        // north west inner corner inclusive
    struct  pxyz se;        // south east outer corner, usually exclusive
};
typedef struct pxyzwindow pxyzwindow_s;
<br>
struct pximagedata {        // pixel and pixie data descriptor
    int     pixietype;      // pixel type: PXDATUCHAR, PXDATUSHORT, PXDATULONG, PXDATFLOAT, etc.
    int     pixies;         // samples/colors/components per pixel: 1, 2, 3, ...
    int     pixelhint;      // hints on pixel interpretation
<br>
    union {
      struct {              //for (unsigned) integer pixels
        int bitsused;       //   significant bits per pixie: 8,12,...
        int bitsxsb;        //   PXDATMSB | PXDATLSB: significant bits @ lsb|msb
                            //                  both: all bits used
        uint16 dirtyread;   //   PXDATDIRTY: unused read bits may not be zero
                            //            0: unused read bits are zero
        uint16 dirtyrite;   //   PXDATDIRTY: unused written bits needn't be zero?
                            //            0: unused written bits must    be zero?
        uint16 endian;      //  PXDATENDIAN: has wrong byte endian for current
                            //            0: has correct byte endian for host
      } i;                  //for (unsigned) integer pixels
<br>
      struct {              //for real (float) pixels
        float minvalue;     //   bottom of range
        float maxvalue;     //   top of range
      } r;                  //for real (float) pixels
    } u;
};
typedef struct pximagedata  pximagedata_s;
<br>
struct pximagefacts {       // derived facts and other image status
                            // derived from pixies, pixietype
    int     pixiesize;      // bytes per component value
    int     pixelsize;      // bytes per pixel
<br>
                            // derived from pixies, pixietype:
    uint    pixieuint: 1;   // - pixel components are positive ints
    uint    pixiereal: 1;   // - pixel components are real
<br>
    ...
};
typedef struct pximagefacts pximagefacts_s;
<br>
struct pximagehints {
    float   pixelwidth;     // X axis width of 1 pixel. 0 if unknown
    float   pixelheight;    // Y axis height of 1 pixel. 0 if unknown
    float   pixeldepth;     // Z axis depth of 1 pixel. 0 if unknown
    uchar   widthunits;     // PXUNIT* real world units
    uchar   heightunits;    // PXUNIT* real world units
    uchar   depthunits;     // PXUNIT* real world units
<br>
    ...
};
typedef struct pximagehints pximagehints_s;
<br>
struct pximage {
    struct pxywindow wind;      // size: subwindow within imdim
    pxcoord_t        pad2[2];
    struct pxywindow imdim;     // size: nw.x = nw.y = 0, se.x &amp; se.y is dimension of image
    pxcoord_t        pad1[2];
<br>
    struct pximagedata  d;      // type: pixel descriptor
    struct pximagefacts f;      // type: derived &amp; other facts
    struct pximagehints h;      // interpretation hints
<br>
    ... member functions (methods) ...
    ... private state ...
};
<br>
struct pximage3 {
    struct pxyzwindow wind;     // size: subwindow within imdim
    struct pxyzwindow imdim;    // size: nw.x = nw.y = 0, se.x &amp; se.y is dimension of image
<br>
    struct pximagedata  d;      // type: pixel descriptor
    struct pximagefacts f;      // type: derived &amp; other facts
    struct pximagehints h;      // interpretation hints
<br>
    ... member functions (methods) ...
    ... private state ...
};
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
A
<em class="Ep">pximage</em>
structure, after successful construction by
<a href="#::pxlib.initPximage" class="Er">::pxlib.initPximage</a>,
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>,
<cite class="Ec">pximage_file</cite>,
<cite class="Ec">pximage_memory</cite><a href="#Footnote%2037" class="Ff"><sup>[37]</sup></a>,
or similar functions,
provides several members (fields)
with values of interest to the application program(er).
The public fields of interest,
excepting the member functions (methods), are shown above.
</p><p>
If using a prewritten image processing function on the
<em class="Ep">pximage</em>,
only the
<em class="Ep">imdim</em>
and
<em class="Ep">wind</em>
are typically needed &#8212;
to set an area of interest to the full dimensions of the image,
or a subset thereof.
</p><p>
If writing custom image processing functions,
additional members which specify the type, precision, and dimensionality
of pixels are typically used.
</p><p>
Except where explicitly differentiated, this discussion applies
to both two-dimensional
<em class="Ep">pximage</em>
as well as three-dimensional
<em class="Ep">pximage3</em>
structures;
the
<em class="Ep">pximage3</em>
differing with three-dimensional spatial coordinates.
</p><p>
Except for the
<em class="Ep">wind</em>
member, and (rarely) the
<em class="Ep">pixelhint</em>
and
<em class="Ep">h</em>
members, discussed below, the various members of the
<em class="Ep">pximage</em>
must never be directly modified by the application program.
</p><p>
The
<em class="Ep">imdim</em>
specifies the image's dimensions;
the
<em class="Ep">imdim.se.x</em>,
<em class="Ep">imdim.se.y</em>,
and
<em class="Ep">imdim.se.z</em>
(for
<em class="Ep">pximage3</em>)
are the
''x''
(horizontal),
''y''
(vertical),
and
''z''
(depth for
<em class="Ep">pximage3</em>)
dimensions.
The
<em class="Ep">imdim.nw.x</em>,
<em class="Ep">imdim.nw.y</em>,
and
<em class="Ep">imdim.nw.z</em>
(for
<em class="Ep">pximage3</em>)
are always 0,
and allow convenient use of the
<em class="Ep">imdim</em>
as a
<em class="Ep">pxywindow</em>
(or
<em class="Ep">pxyzwindow</em>)
which specifies a full image window.
</p><p>
The
<em class="Ep">wind</em>
specifies an area of interest, equal to or smaller than
the full image resolution.
The
<em class="Ep">imdim.nw.x</em>,
<em class="Ep">imdim.nw.y</em>,
and
<em class="Ep">imdim.nw.z</em>
(for
<em class="Ep">pximage3</em>)
are the
''x''
(horizontal),
''y''
(vertical),
and
''z''
(depth for
<em class="Ep">pximage3</em>)
coordinates of the area of interest's upper left corner, inclusive;
the
<em class="Ep">imdim.se.x</em>,
<em class="Ep">imdim.se.y</em>,
and
<em class="Ep">imdim.se.z</em>
(for
<em class="Ep">pximage3</em>)
are coordinates of the area of interest's lower left corner, exclusive.
The choice of inclusive/exclusive coordinates allows a full image area
of interest to be specified by the same values as within
<em class="Ep">imdim</em>.
For historical reasons, the
<em class="Ep">wind</em>
members may be directly altered by the application program;
although such direct modification is not suggested for new applications
(use the
<em class="Ep">::xwind</em>
service instead).
When modified directly, it is the application program's
responsibility to maintain legitimate values in
<em class="Ep">wind</em>
&#8212; i.e. window dimensions larger than 0 and smaller than or equal to the
image dimensions.
</p><p>
The
<em class="Ep">d.pixies</em>
is the number of numeric components
(i.e. ``pixies''),
or the dimensionality, of each pixel.
The
<em class="Ep">d.pixies</em>
would be 1 for monochrome imagery,
2 for complex values (either real and imaginary or magnitude and phase),
and 3 or 4 for RGB, YIQ, CMYK, HSI, or other color spaces.
</p><p>
The
<em class="Ep">d.pixietype</em>
is the fundamental, optimal, data type to be used for each pixie.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
C Type                  
</td>
<td colspan="1" align="left">
 pixietype
</td>
</tr>
<tr>
<td colspan="1" align="left">
unsigned char           
</td>
<td colspan="1" align="left">
 PXDATUCHAR
</td>
</tr>
<tr>
<td colspan="1" align="left">
unsigned short          
</td>
<td colspan="1" align="left">
 PXDATUSHORT
</td>
</tr>
<tr>
<td colspan="1" align="left">
unsigned int            
</td>
<td colspan="1" align="left">
 PXDATUINT
</td>
</tr>
<tr>
<td colspan="1" align="left">
unsigned long           
</td>
<td colspan="1" align="left">
 PXDATULONG
</td>
</tr>
<tr>
<td colspan="1" align="left">
float                   
</td>
<td colspan="1" align="left">
 PXDATFLOAT
</td>
</tr>
<tr>
<td colspan="1" align="left">
double                  
</td>
<td colspan="1" align="left">
 PXDATDOUBLE
</td>
</tr>
<tr>
<td colspan="1" align="left">
 8 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT8
</td>
</tr>
<tr>
<td colspan="1" align="left">
16 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT16
</td>
</tr>
<tr>
<td colspan="1" align="left">
32 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT32
</td>
</tr>
<tr>
<td colspan="1" align="left">
(see NULL image, below) 
</td>
<td colspan="1" align="left">
 0
</td>
</tr>
</tbody></table>
</pre>
</div>
Some of the above constants are synonymous,
as per the current programming environment.
For example, in typical 32 bit environments
PXDATUINT8 is identical both in meaning and value to PXDATUCHAR,
PXDATUINT16 is identical to PXDATUSHORT,
and
PXDATUINT32 is identical to PXDATUINT.
The PXDATULONG is not available in programming environments where a
''long''
is 64 bits.
Use of PXDATUINT8, PXDATUINT16, and PXDATUINT32
instead of PXDATUCHAR, PXDATUSHORT, PXDATUINT, and PXDATULONG
is recommended for easier portability between 16, 32, and 64 bit
programming environments.
<p>
Some
<em class="Ep">pximage</em>
device drivers
may allow pixies to be read or written into types other than
<em class="Ep">d.pixietype</em>,
but reading or writing into a data type matching
<em class="Ep">d.pixietype</em>
would be more efficient.
</p><p>
For
<em class="Ep">d.pixietype</em>'s
that are unsigned integer, the
<em class="Ep">f.pixieuint</em>
will be one, and the
<em class="Ep">u.i</em>
members provide additional interpretation
of the pixie's values.
The
<em class="Ep">u.i.bitsused</em>
is the number of bits of each
<em class="Ep">d.pixietype</em>
actually used.
When fewer
<em class="Ep">u.i.bitsused</em>
are used than actually available in each
<em class="Ep">d.pixietype</em>,
the
<em class="Ep">u.i.bitsxsb</em>
is PXDATLSB to indicate the bits used are right justified
within the data type,
or PXDATMSB to indicate the bits used are left justified
within the data type.
When all bits of the
<em class="Ep">d.pixietype</em>,
are used, the
<em class="Ep">u.i.bitsxsb</em>
is PXDATMSB|PXDATLSB.
</p><p>
For example, on hosts where an
''unsigned short''
is 16 bits, if
<em class="Ep">u.i.bitsused</em>=12
and
<em class="Ep">u.i.bitsxsb</em>=PXDATLSB,
the range of pixel values is from 0 to 2<small><sup>12</sup></small>-1 (4095) in steps of 1.
If
<em class="Ep">u.i.bitsused</em>=10
and
<em class="Ep">u.i.bitsxsb</em>=PXDATMSB,
the range of pixel values is from 0 to 2<small><sup>16</sup></small>-1 (65535)
in steps of 2<small><sup>6</sup></small> (64).<a href="#Footnote%2038" class="Ff"><sup>[38]</sup></a>
</p><p>
When fewer
<em class="Ep">u.i.bitsused</em>
are used than actually available in each
<em class="Ep">d.pixietype</em>,
the
<em class="Ep">u.i.dirtyread</em>
indicates whether the unused bits will be read as zero
or may contain random values.
Likewise, the
<em class="Ep">u.i.dirtyrite</em>
indicates whether the unused bits must be written as zero,
or may contain random values.
</p><p>
For
<em class="Ep">d.pixietype</em>'s
utilizing more than 1 byte,
the
<em class="Ep">u.i.endian</em>
indicates whether the byte order, little endian or big endian,
matches the host's natural default.
</p><p>
For
<em class="Ep">d.pixietype</em>'s
that are floating point,
the
<em class="Ep">f.pixiereal</em>
will be one and the
<em class="Ep">u.r</em>
members provide additional interpretation
of the pixie's values.
The
<em class="Ep">u.r.minvalue</em>
and
<em class="Ep">u.r.maxvalue</em>
specify the pixie's
minimum and maximum values, respectively.
</p><p>
The
<em class="Ep">d.pixelhint</em>
is a hint to how the pixel, particularly multiple component pixels
(i.e. color), is to be interpreted.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
pixelhint      
</td>
<td colspan="1" align="left">
 Number of  
</td>
<td colspan="1" align="left">
 Interpretation
</td>
</tr>
<tr>
<td colspan="1" align="left">
               
</td>
<td colspan="1" align="left">
 Components 
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTNONE (=0)
</td>
<td colspan="1" align="left">
 unknown    
</td>
<td colspan="1" align="left">
 Unknown
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTGREY     
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Grey scale monochrome
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTINDEX    
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Index into (unspecified) palette
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYER    
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Bayer pattern RGB
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYER0   
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Bayer pattern RGB starting w. red
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYER1   
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Bayer pattern RGB starting w. grn-red
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYER2   
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Bayer pattern RGB starting w. grn-blu
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYER3   
</td>
<td colspan="1" align="left">
 1          
</td>
<td colspan="1" align="left">
 Bayer pattern RGB starting w. blu
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCOMPLEX  
</td>
<td colspan="1" align="left">
 2          
</td>
<td colspan="1" align="left">
 Complex, probably of monochrome data
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCBYCRY   
</td>
<td colspan="1" align="left">
 2          
</td>
<td colspan="1" align="left">
 Cb,Y,Cr,Y,Cb,Y,Cr,Y,... (YCrCb,UYVY)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCBYCR   
</td>
<td colspan="1" align="left">
 2          
</td>
<td colspan="1" align="left">
 Y,Cb,Y,Cr,Y,Cb,Y,Cr,... (YCrCb,YUY2)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCRYCBY   
</td>
<td colspan="1" align="left">
 2          
</td>
<td colspan="1" align="left">
 Cr,Y,Cb,Y,Cr,Y,Cb,Y,... (YCrCb,VYUY)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRYCB   
</td>
<td colspan="1" align="left">
 2          
</td>
<td colspan="1" align="left">
 Y,Cr,Y,Cb,Y,Cr,Y,Cb,... (YCrCb,YVYU)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGR      
</td>
<td colspan="1" align="left">
 3          
</td>
<td colspan="1" align="left">
 Blue,Green,Red,... (RGB)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCB    
</td>
<td colspan="1" align="left">
 3          
</td>
<td colspan="1" align="left">
 Y,Cr,Cb,Y,Cr,Cb,... (YCrCb)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBSH      
</td>
<td colspan="1" align="left">
 3          
</td>
<td colspan="1" align="left">
 Brightness,Saturation,Hue,... (HSB)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGB      
</td>
<td colspan="1" align="left">
 3          
</td>
<td colspan="1" align="left">
 Red,Green,Blue,... (RGB)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYIQ      
</td>
<td colspan="1" align="left">
 3          
</td>
<td colspan="1" align="left">
 YIQ
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCMY      
</td>
<td colspan="1" align="left">
 3          
</td>
<td colspan="1" align="left">
 Cyan,Magent,Yellow (CMY)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBGRX     
</td>
<td colspan="1" align="left">
 4          
</td>
<td colspan="1" align="left">
 Blue,Green,Red,Pad,... (RGB)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTYCRCBX   
</td>
<td colspan="1" align="left">
 4          
</td>
<td colspan="1" align="left">
 Y,Cr,Cb,Pad,Y,Cr,Cb,Pad,...  (YCrCb)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTRGBX     
</td>
<td colspan="1" align="left">
 4          
</td>
<td colspan="1" align="left">
 Red,Green,Blue,Pad,... (RGB)
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTBAYERX4  
</td>
<td colspan="1" align="left">
 4          
</td>
<td colspan="1" align="left">
 Bayer pattern w. R Gr Gb B values each pixel
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXHINTCMYK     
</td>
<td colspan="1" align="left">
 4          
</td>
<td colspan="1" align="left">
 Cyan,Magent,Yellow,Black (CMYK)
</td>
</tr>
<tr><td colspan="3"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
PXHINTUSER     
</td>
<td colspan="1" align="left">
 unknown    
</td>
<td colspan="1" align="left">
 User-defined types: from PXHINTUSER
</td>
</tr>
<tr>
<td colspan="1" align="left">
               
</td>
<td colspan="1" align="left">
            
</td>
<td colspan="1" align="left">
 thru PXHINTUSER+PXHINTUSERN
</td>
</tr>
</tbody></table>
</pre>
</div>
For example, PXHINTBGRX hints that the first pixie is the Blue value,
followed by values of Green, Red, and a fourth, unused, pixie value.<a href="#Footnote%2039" class="Ff"><sup>[39]</sup></a>
<p>
The
<em class="Ep">h.pixelwidth</em>,
<em class="Ep">h.pixelheight</em>
and
<em class="Ep">h.pixeldepth</em>
provide a hint on the real-world width, height, and depth
of a pixel;
any may be 0 if no information is available.
The
<em class="Ep">h.widthunits</em>,
<em class="Ep">h.heightunits</em>,
and
<em class="Ep">h.depthunits</em>
specify the units of the
<em class="Ep">h.pixelwidth</em>,
<em class="Ep">h.pixelheight</em>,
and
<em class="Ep">h.pixeldepth</em>
values, respectively.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
widthunits        
</td>
</tr>
<tr>
<td colspan="1" align="left">
heightunits       
</td>
</tr>
<tr>
<td colspan="1" align="left">
depthunits        
</td>
<td colspan="1" align="left">
 Interpretation
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITUNKNOWN (=0)
</td>
<td colspan="1" align="left">
 Unknown
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITRATIO       
</td>
<td colspan="1" align="left">
 Unitless, relative ratio
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITINCH        
</td>
<td colspan="1" align="left">
 Inches
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITFOOT        
</td>
<td colspan="1" align="left">
 Feet
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITMETER       
</td>
<td colspan="1" align="left">
 Meters
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITMILLIMETER  
</td>
<td colspan="1" align="left">
 Millimeters
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITCENTIMETER  
</td>
<td colspan="1" align="left">
 Centimeters
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXUNITSECOND      
</td>
<td colspan="1" align="left">
 Seconds
</td>
</tr>
</tbody></table>
</pre>
</div>
<p>
A
<em class="Ep">pximage</em>
which has been unsuccessfully constructed will be a so-called NULL image.
All members shown above will be 0; thus the image dimensions
will be 0, as will the
<em class="Ep">d.pixietype</em>.
The member functions (methods) can be safely invoked; they refer
to no-op functions which do nothing.
</p><hr size="1">
<a name="pximage::xwind NX1136" class="NX"></a>
<a name="pximage::xwind" class="Sf"></a>
<a name="PXIMAGE: Set &amp; Get Area of Interest Window NX1137" class="NX"></a>
<a name="PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind" class="Sf"></a>
<a name="PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind"></a>
<h6 class="Sf">PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind</h6>
<a name="::xwind NX1138" class="NX"></a>
<a name="::xwind" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>struct pxywindow * (ip-&gt;xwind)(ip, wp, mode);
struct pximage      *ip;            // Pointer to pximage instance
struct pxywindow    *wp;            // Pointer to area of interest, or NULL
int                 mode;           // 'i': Get full image dimensions
                                    // 'w': Det area of interest dimensions
                                    // 's': Set area of interest dimensions
<br>
struct pxyzwindow * (ip3-&gt;xwind)(ip3, wp3, mode);
struct pximage3     *ip3;           // Pointer to pximage3 instance
struct pxyzwindow   *wp3;           // Pointer to area of interest, or NULL
int                 mode;           // As above
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The area of interest window associated with the
<em class="Ep">pximage</em>
instance referenced by
<em class="Ep">ip</em>,
or the
<em class="Ep">pximage3</em>
instance referenced by
<em class="Ep">ip3</em>,
is retrieved or modified.
</p><p>
If
<em class="Ep">mode</em>='i',
the
<em class="Ep">ip</em>'s
(<em class="Ep">ip3</em>'s)
full image dimensions, expressed as a
<em class="Ep">pxywindow</em>
(<em class="Ep">pxyzwindow</em>)
structure are retrieved.
A pointer to the
<em class="Ep">pxywindow</em>
(<em class="Ep">pxyzwindow</em>)
dimensions is returned, and
if
<em class="Ep">wp</em>&#8800;NULL
(<em class="Ep">wp3</em>&#8800;NULL),
the
<em class="Ep">pxywindow</em>
(<em class="Ep">pxyzwindow</em>)
is also copied to
*<em class="Ep">wp</em>
(*<em class="Ep">wp3).</em>
</p><p>
If
<em class="Ep">mode</em>='w',
the
<em class="Ep">ip</em>'s
(<em class="Ep">ip3</em>'s)
current area of interest dimensions, expressed as a
<em class="Ep">pxywindow</em>
(<em class="Ep">pxyzwindow</em>)
structure are retrieved.
A pointer to the
<em class="Ep">pxywindow</em>
(<em class="Ep">pxyzwindow</em>)
dimensions is returned, and
if
<em class="Ep">wp</em>&#8800;NULL
(<em class="Ep">wp3</em>&#8800;NULL),
the
<em class="Ep">pxywindow</em>
(<em class="Ep">pxyzwindow</em>)
is also copied to
*<em class="Ep">wp</em>
(*<em class="Ep">wp3).</em>
</p><p>
If
<em class="Ep">mode</em>='s',
the
<em class="Ep">ip</em>'s
(<em class="Ep">ip3</em>'s)
area of interest is set to
*<em class="Ep">wp</em>
(*<em class="Ep">wp3</em>);
if
<em class="Ep">wp</em>=NULL
(<em class="Ep">wp3</em>=NULL),
the area of interest is set to the full image dimensions.
A pointer to the new area of interest dimensions is returned.
</p><p>
If the area of interest specified by
*<em class="Ep">wp</em>
(*<em class="Ep">wp3</em>)
is invalid, all members of the area of interest window
are set to 0 and the
<em class="Ep">pximage</em>'s
(<em class="Ep">pximage3</em>'s)
<em class="Ep">::ioset</em>,
<em class="Ep">::bxts</em>,
and
<em class="Ep">::imapset</em>
services will not succeed
until a valid area of interest window is set.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="1">
<a name="pximage::aeiou NX1139" class="NX"></a>
<a name="pximage::aeiou" class="Sf"></a>
<a name="PXIMAGE: Get Advice, Errors, Info &amp; Options NX1140" class="NX"></a>
<a name="PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou" class="Sf"></a>
<a name="PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou"></a>
<h6 class="Sf">PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou</h6>
<a name="::aeiou NX1141" class="NX"></a>
<a name="::aeiou" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>pximaeiou_t (ip-&gt;aeiou) (ip,  service, parm1, parm2, parm3);
pximaeiou_t (ip3-&gt;aeiou)(ip3, service, parm1, parm2, parm3);
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 service;        // As described below
int                 parm1;          // Option
int                 parm2;          // Option
void                *parm3;         // Rsvd. should be NULL
<br>
<a name="Type pximaeiou_t NX1142" class="NX"></a>
<a name="pximaeiou_t NX1143" class="NX"></a>
<a name="pximaeiou_t" class="Tr"></a>
typedef ulong       pximaeiou_t;    // in 16 &amp; 32 bit environments
typedef uint        pximaeiou_t;    // in 64 bit environments
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
Advice, errors, and/or information
associated with activity on the
<em class="Ep">pximage</em>
instance referenced by
<em class="Ep">ip</em>,
or the
<em class="Ep">pximage3</em>
instance referenced by
<em class="Ep">ip3</em>,
is obtained.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
Service 
</td>
<td colspan="1" align="left">
 Return Value  
</td>
<td colspan="1" align="left">
 Meaning                                   
</td>
<td colspan="1" align="left">
 Parm1  
</td>
<td colspan="1" align="left">
 Parm2
</td>
</tr>
<tr>
<td colspan="1" align="left">
        
</td>
<td colspan="1" align="left">
 Cast Into     
</td>
<td colspan="1" align="left">
                                           
</td>
<td colspan="1" align="left">
        
</td>
</tr>
<tr>
<td colspan="1" align="left">
'I'     
</td>
<td colspan="1" align="left">
 (uint)        
</td>
<td colspan="1" align="left">
 Suggested access cnt, ioread()/iorite()   
</td>
<td colspan="1" align="left">
 0      
</td>
<td colspan="1" align="left">
 0
</td>
</tr>
<tr>
<td colspan="1" align="left">
'B'     
</td>
<td colspan="1" align="left">
 (uint)        
</td>
<td colspan="1" align="left">
 Suggested access cnt, bxta()              
</td>
<td colspan="1" align="left">
 0      
</td>
<td colspan="1" align="left">
 0
</td>
</tr>
<tr><td colspan="5"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
'i'     
</td>
<td colspan="1" align="left">
               
</td>
<td colspan="1" align="left">
 Image access dope, ioread()/iorite()      
</td>
<td colspan="1" align="left">
 0      
</td>
<td colspan="1" align="left">
 0
</td>
</tr>
<tr>
<td colspan="1" align="left">
'b'     
</td>
<td colspan="1" align="left">
               
</td>
<td colspan="1" align="left">
 Image access dope, bxta()                 
</td>
<td colspan="1" align="left">
 0      
</td>
<td colspan="1" align="left">
 0
</td>
</tr>
<tr>
<td colspan="1" align="left">
'm'     
</td>
<td colspan="1" align="left">
               
</td>
<td colspan="1" align="left">
 Image access dope, imap()                 
</td>
<td colspan="1" align="left">
 0      
</td>
<td colspan="1" align="left">
 0
</td>
</tr>
<tr><td colspan="5"><hr noshade="noshade" size="1"></td></tr>
<tr>
<td colspan="1" align="left">
'e'     
</td>
<td colspan="1" align="left">
 (int)         
</td>
<td colspan="1" align="left">
 Previous error, or 0                      
</td>
<td colspan="1" align="left">
 clear  
</td>
<td colspan="1" align="left">
 recurse
</td>
</tr>
</tbody></table>
</pre>
</div>
<p>
If
<em class="Ep">service</em>='I',
the suggested, or optimal, access count for use with
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
is returned.
The returned value is never larger than UINT_MAX.
The
<em class="Ep">parm1</em>
and
<em class="Ep">parm2</em>
are ignored.
</p><p>
If
<em class="Ep">service</em>='B',
the suggested, or optimal, access count for use with
<a href="#::bxta" class="Er">::bxta</a>
is returned.
The returned value
is never larger than:
</p><blockquote>
<pre>UINT_MAX / sizeof(struct pximadrs)
</pre>
</blockquote>
The
<em class="Ep">parm1</em>
and
<em class="Ep">parm2</em>
are ignored.
<p>
If
<em class="Ep">service</em>='i',
information about image access time and overhead for pixels read or written via
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
is returned.
If
<em class="Ep">service</em>='b',
information about image access time and overhead for pixels read, written, or modified via
<a href="#::bxta" class="Er">::bxta</a>
is returned.
If
<em class="Ep">service</em>='m',
information about image access time and overhead for pixels read or written via
a pointer provided by
<a href="#::imap" class="Er">::imap</a>
is returned.<a href="#Footnote%2040" class="Ff"><sup>[40]</sup></a>
The
<em class="Ep">parm1</em>
and
<em class="Ep">parm2</em>
are ignored.
The returned information is described further in
<code class="Em">pximage.h</code>.
</p><p>
If
<em class="Ep">service</em>='e',
the last error code, if any, associated with activity on the
<em class="Ep">pximage</em>
instance referenced by
<em class="Ep">ip</em>,
or the
<em class="Ep">pximage3</em>
instance referenced by
<em class="Ep">ip3</em>,
is retrieved.
If
<em class="Ep">parm1</em>&#8800;0,
the error code is also cleared, so that a subsequent query
doesn't return the same code.
</p><p>
If
<em class="Ep">parm2</em>&#8800;0,
and the
<em class="Ep">ip</em>
(<em class="Ep">ip3</em>)
is a filter used in front of another
<em class="Ep">pximage</em>
(<em class="Ep">pximage3</em>),
the first error code found in the chain of
<em class="Ep">pximage</em>'s
(<em class="Ep">pximage3</em>'s),
is retrieved.
Further, if
<em class="Ep">parm1</em>&#8800;0,
the one error code, on the specific
<em class="Ep">pximage</em>
(<em class="Ep">pximage3</em>)
where it was found, is cleared.
</p><p>
Error codes typically report an error that occurred while
reading or writing pixels.
The values of error codes, cast to an
''int''
are interpreted as described in
<a href="#pxerrnomesg" class="Er">pxerrnomesg</a>.
Some
<em class="Ep">pximage</em>
(<em class="Ep">pximage3</em>)
devices, such as those accessed via
<cite class="Ec">pximage_memory</cite>,
never have error conditions.
Others, such as those accessed via
<cite class="Ec">pximage_file</cite>
record errors if/when an I/O error occurs reading or writing the
underlying image file.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="1">
<a name="pximage::ioset NX1144" class="NX"></a>
<a name="pximage::ioset" class="Sf"></a>
<a name="PXIMAGE: Set to Access Sequential Pixels NX1145" class="NX"></a>
<a name="PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset" class="Sf"></a>
<a name="PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset"></a>
<h6 class="Sf">PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset</h6>
<a name="pximage::ioread NX1146" class="NX"></a>
<a name="pximage::ioread" class="Sg"></a>
<a name="PXIMAGE: Read Sequential Pixels NX1147" class="NX"></a>
<a name="PXIMAGE: Read Sequential Pixels   ---   pximage::ioread" class="Sg"></a>
<a name="PXIMAGE: Read Sequential Pixels   ---   pximage::ioread"></a>
<h6 class="Sg">PXIMAGE: Read Sequential Pixels   ---   pximage::ioread</h6>
<a name="pximage::iorite NX1148" class="NX"></a>
<a name="pximage::iorite" class="Sg"></a>
<a name="PXIMAGE: Write Sequential Pixels NX1149" class="NX"></a>
<a name="PXIMAGE: Write Sequential Pixels   ---   pximage::iorite" class="Sg"></a>
<a name="PXIMAGE: Write Sequential Pixels   ---   pximage::iorite"></a>
<h6 class="Sg">PXIMAGE: Write Sequential Pixels   ---   pximage::iorite</h6>
<a name="pximage::iowait NX1150" class="NX"></a>
<a name="pximage::iowait" class="Sg"></a>
<a name="PXIMAGE: Wait for Sequential Access Completion NX1151" class="NX"></a>
<a name="PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait" class="Sg"></a>
<a name="PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait"></a>
<h6 class="Sg">PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait</h6>
<a name="pximage::iolen NX1152" class="NX"></a>
<a name="pximage::iolen" class="Sg"></a>
<a name="PXIMAGE: Obtain Sequential Access Pixel Count NX1153" class="NX"></a>
<a name="PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen" class="Sg"></a>
<a name="PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen"></a>
<h6 class="Sg">PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen</h6>
<a name="::ioset NX1154" class="NX"></a>
<a name="::ioread NX1155" class="NX"></a>
<a name="::iorite NX1156" class="NX"></a>
<a name="::iowait NX1157" class="NX"></a>
<a name="::iolen NX1158" class="NX"></a>
<a name="::ioset" class="Tr"></a>
<a name="::ioread" class="Tr"></a>
<a name="::iorite" class="Tr"></a>
<a name="::iowait" class="Tr"></a>
<a name="::iolen" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int       (ip-&gt;ioset) (ip, mode, data, colormap);
pximcnt_t (ip-&gt;ioread)(ip, mode, bufp, cnt, x, y);
pximcnt_t (ip-&gt;iorite)(ip, mode, bufp, cnt, x, y);
int       (ip-&gt;iowait)(ip, wait, bufp);
pximcnt_t (ip-&gt;iolen) (ip, cnt, x, y);
<br>
int       (ip3-&gt;ioset) (ip3, mode, data, colormap);
pximcnt_t (ip3-&gt;ioread)(ip3, mode, bufp, cnt, x, y, z);
pximcnt_t (ip3-&gt;iorite)(ip3, mode, bufp, cnt, x, y, z);
int       (ip3-&gt;iowait)(ip3, wait, bufp);
pximcnt_t (ip3-&gt;iolen) (ip3, cnt, x, y, z);
<br>
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 mode;           // As described below
int                 data;           // PXDATUCHAR, PXDATUSHORT, etc.
                                    // or'ed with PXDATLSB or PXDATMSB
uint                colormap;       // Pixie selection bit map
void _far           *bufp;          // Host memory [16 bit environments]
void                *bufp;          // Host memory [32 bit environments]
pximcnt_t           cnt;            // Number of pixels to access
pxcoord_t           x;              // Access x (horizontal) coordinate
pxcoord_t           y;              // Access y (vertical) coordinate
pxcoord_t           z;              // Access z (depth) coordinate
int                 wait;           // PXAWAIT,PXASYNC,PXABORT
<br>
<a name="Type pximcnt_t NX1159" class="NX"></a>
<a name="pximcnt_t NX1160" class="NX"></a>
<a name="pximcnt_t" class="Tr"></a>
typedef uint        pximcnt_t;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::ioset" class="Er">::ioset</a>,
<a href="#::ioread" class="Er">::ioread</a>,
<a href="#::iorite" class="Er">::iorite</a>,
<a href="#::iowait" class="Er">::iowait</a>,
and
<a href="#::iolen" class="Er">::iolen</a>
provide access to sequences of pixels in the
<em class="Ep">pximage</em>
instance referenced by
<em class="Ep">ip</em>,
or the
<em class="Ep">pximage3</em>
instance referenced by
<em class="Ep">ip3</em>.
The
<a href="#::ioset" class="Er">::ioset</a>
must be used before other functions in this group;
<a href="#::ioset" class="Er">::ioset</a>
establishes various modes which affect how the other functions operate.
The
<em class="Ep">ip</em>'s
(or
<em class="Ep">ip3</em>'s)
area of interest window must not be changed
between setting an access mode with
<a href="#::ioset" class="Er">::ioset</a>
and using the other functions in this group.
</p><p>
<br>
<b class="Hv">::ioset.</b>
The
<a href="#::ioset" class="Er">::ioset</a>
establishes the sequence orientation (horizontal, vertical, depth),
and the data type for later
<a href="#::ioread" class="Er">::ioread</a>
and
<a href="#::iorite" class="Er">::iorite</a>.
</p><p>
If
<em class="Ep">mode</em>=PXRXSCAN,
sequential access is in order of increasing
''x'',
then
increasing
''y''
(and then
increasing
''z'').
If
<em class="Ep">mode</em>=PXRYSCAN,
sequential access is in order of increasing
''y'',
then
increasing
''x''
(and then
increasing
''z'').
(If
<em class="Ep">mode</em>=PXRZSCAN,
sequential access is in order of increasing
''z'',
then increasing
''x'',
and then increasing
''y'').
</p><p>
If the
<em class="Ep">mode</em>
is OR'ed with
PXIWRAP,
a single sequential access may
''wrap''
around at the end of the specified line (PXRXSCAN), column (PXRYSCAN),
or depth vector (PXRZSCAN),
allowing several lines, columns, or depth vectors to be transferred
at the same time.
Otherwise, a single
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
access will stop at the end of the specified
line (PXRXSCAN), column (PXRYSCAN) (or depth vector (PXRZSCAN)).
If the
<em class="Ep">mode</em>
is OR'ed with PXIXYVALID, the
''x'',
''y'',
(or
''z'')
coordinates specified by
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
are assumed to be valid, requiring less overhead for checking.
</p><p>
The
<em class="Ep">data</em>
specifies the data type that
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
will provide for pixel data.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
C Type                      
</td>
<td colspan="1" align="left">
 data
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) unsigned char    
</td>
<td colspan="1" align="left">
 PXDATUCHAR
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) unsigned short   
</td>
<td colspan="1" align="left">
 PXDATUSHORT
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) unsigned int     
</td>
<td colspan="1" align="left">
 PXDATUINT
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) unsigned long    
</td>
<td colspan="1" align="left">
 PXDATULONG
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) float            
</td>
<td colspan="1" align="left">
 PXDATFLOAT
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) double           
</td>
<td colspan="1" align="left">
 PXDATDOUBLE
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of)  8 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT8
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) 16 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT16
</td>
</tr>
<tr>
<td colspan="1" align="left">
(array of) 32 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT32
</td>
</tr>
</tbody></table>
</pre>
</div>
For the unsigned integer types, the
<em class="Ep">data</em>
may be OR'ed with PXDATLSB or PXDATMSB.
If the specified data type has the same number of bits as
<em class="Ep">ip</em>-&gt;<em class="Ep">u.i.bitsused</em>
(<em class="Ep">ip3</em>-&gt;<em class="Ep">u.i.bitsused),</em>
use of PXDATLSB or PXDATMSB has no effect.
Otherwise, PXDATLSB specifies that the significant bits are to be
read/written to/from the specified data type right justified,
PXDATMSB specifies that the significant bits are to be
read/written to/from the specified data type left justified.
If the data type has fewer bits than
<em class="Ep">ip</em>-&gt;<em class="Ep">u.i.bitsused</em>,
the most significant pixel bits are kept.
If neither PXDATLSB or PXDATMSB is used, the pixel data is not shifted;
the right most bits of the pixel are read/written to/from the specified data
type, and the least significant bits are kept.
<p>
For the unsigned integer types, the
<em class="Ep">data</em>
may also be OR'ed with PXDATDIRTY.
If the specified data type has the same number of bits as
<em class="Ep">ip</em>-&gt;<em class="Ep">u.i.bitsused</em>
(<em class="Ep">ip3</em>-&gt;<em class="Ep">u.i.bitsused),</em>
use of PXDATDIRTY has no effect.
Otherwise, for
<a href="#::iorite" class="Er">::iorite</a>
PXDATDIRTY indicates that the values being written
have random values in the unused bits, rather than zeros.
For
<a href="#::ioread" class="Er">::ioread</a>
PXDATDIRTY indicates that the values being read
are allowed to have random values in the unused bits, rather than zeros.
</p><p>
The
<em class="Ep">colormap</em>
specifies which pixie components are to be accessed;
bit 0x01 of
<em class="Ep">colormap</em>
represent the first pixie component,
bit 0x02 the second pixie component, etc.
Multiple components may be accessed;
<em class="Ep">colormap</em>=0x07
specifies access to three components.
Not all
<em class="Ep">pximage</em>
(<em class="Ep">pximage3</em>)
devices support access to arbitrary subsets of pixies.
For example, a
<em class="Ep">pximage</em>
(<em class="Ep">pximage3</em>)
device providing 4 pixies must support
<em class="Ep">colormap</em>=0x1F,
and may, or may not, support (in decreasing order of likelihood):
(a)&nbsp;A
<em class="Ep">colormap</em>
with a single bit set providing access to any one pixie,
(b)&nbsp;A
<em class="Ep">colormap</em>
with a contiguous block of bits set (e.g. 0x18, 0x07, or 0x06)
providing access to a contiguous group of pixies,
or
(c) A
<em class="Ep">colormap</em>
with an arbitrary pattern of bits set (e.g. 0x09)
providing access to a arbitrary group of pixies.
</p><p>
The
<a href="#::ioset" class="Er">::ioset</a>
returns a value greater than 0 if successful, or less than 0 if the
image can't be accessed in the manner requested.
</p><p>
<br>
<b class="Hv">::ioread &amp; ::iorite.</b>
The
<a href="#::ioread" class="Er">::ioread</a>
and
<a href="#::iorite" class="Er">::iorite</a>
respectively read pixel data from the image to a host buffer and write
pixel data from a host buffer to the image.
The
<em class="Ep">cnt</em>
is the maximum number of pixels (not pixies!) to be accessed,
starting at coordinates
<em class="Ep">x</em>,
<em class="Ep">y</em>,
(and
<em class="Ep">z</em>)
relative to the current area of interest;
and proceeding in the PXRXSCAN, PXRYSCAN, (or
PXRZSCAN) order, as specified previously via
<a href="#::ioset" class="Er">::ioset</a>.
Fewer than
<em class="Ep">cnt</em>
pixels may actually be accessed;
access stops when the end of the image area of interest is reached,
or, if PXIWRAP was not previously specified via
<a href="#::ioset" class="Er">::ioset</a>,
when the end of the current row, column, (or depth vector) is reached.
</p><p>
The return value of
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
indicates the number of pixels (not pixies!) transferred.
</p><p>
The
<em class="Ep">bufp</em>
must reference
an array of the data type specified previously via
<a href="#::ioset" class="Er">::ioset</a>,
with size no smaller than
<em class="Ep">cnt</em>
times the number of pixies encoded in the
<em class="Ep">colormap</em>
specified via
<a href="#::ioset" class="Er">::ioset</a>.
The elements of
<em class="Ep">bufp</em>
are filled in pixel by pixel, for each pixel the
lowest numbered pixie first, followed
by higher numbered pixies.
</p><p>
If
<em class="Ep">mode</em>=PXIASYNC,
the pixel access is done asynchronously, if possible.
If the return value of
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
is non-zero, asynchronous operation isn't available
and the operation is complete.
A return value of zero indicates that the operation is pending
and may not be complete; the
<a href="#::iowait" class="Er">::iowait</a>
must be used to wait or test for completion.
For each instance of a
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>,
only one asynchronous operation may be pending at any one time.
</p><p>
The
<em class="Ep">mode</em>
may also be OR'ed with PXIMAYMOD.
The PXIMAYMOD has no effect for
<a href="#::ioread" class="Er">::ioread</a>.
For
<a href="#::iorite" class="Er">::iorite</a>,
PXIMAYMOD indicates that the (contents of)
<em class="Ep">bufp</em>
array is disposable, and may be modified
at the whim of the
<em class="Ep">pximage</em>
device driver.
</p><p>
<br>
<b class="Hv">::iowait.</b>
The
<a href="#::iowait" class="Er">::iowait</a>
need be used only when PXIASYNC
is used with
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>.
The
<em class="Ep">bufp</em>
must be the same value as used with
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>.
The
<em class="Ep">wait</em>
must be either:
(a)&nbsp;PXAWAIT,
for which return is delayed until the previous operation is complete, returning the
value PXODONE;
(b)&nbsp;PXASYNC, for which return is immediate and the return
value is PXODONE to indicate the operation is complete or PXOPRUN
to indicate the operation is not yet complete;
or
(c)&nbsp;PXABORT, to prematurely terminate (if possible) the pending operation,
returning value PXODONE.
</p><p>
<br>
<b class="Hv">::iolen.</b>
The
<a href="#::iolen" class="Er">::iolen</a>
returns the number of pixels that
<a href="#::ioread" class="Er">::ioread</a>
or
<a href="#::iorite" class="Er">::iorite</a>
would access, if given the same
<em class="Ep">cnt</em>,
<em class="Ep">x</em>,
<em class="Ep">y</em>,
and
<em class="Ep">z</em>
parameters.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
<br>
<br>
<br>
<em class="Ss">Example</em>
</p><p>
</p><blockquote>
<pre>/*
 * Read one and return one pixel value component.
 * The x &amp; y parameters are assumed relative to the window AOI, if any.
 *
 * Note: Reading or writing one pixel or one pixel component
 * at a time is not efficient; this is provided as an educational
 * example, not as a recommendation for use. Reading or writing lines,
 * columns or the entire image at one time is supported and highly recommended.
 *
 * Return is a signed long to accomodate errors.
 */
long imagepixie(struct pximage *ip, pxcoord_t x, pxcoord_t y, int pixie)
{
    union {
        uchar   c;
        ushort  s;
    } v;
<br>
    if (!ip)
        return(-1);     // missing pximage*
    //
    // Following tests aren't really necessary;
    // the ioset/ioread ends up doing the same.
    // They help illustrate use of the pximage fields.
    //
    if (x &lt; 0 || x &gt;= ip-&gt;imdim.se.x
     || y &lt; 0 || y &gt;= ip-&gt;imdim.se.y)
        return(-1);     // x or y out of image bounds
    if (pixie &lt; 0 || pixie &gt;= ip-&gt;d.pixies)
        return(-1);     // pixie out of bounds
    if (x &gt;= ip-&gt;wind.se.x-ip-&gt;wind.nw.x
     || y &gt;= ip-&gt;wind.se.y-ip-&gt;wind.nw.y)
        return(-1);     // x or y out of AOI bounds
<br>
    //
    // Setup for read.
    //
    if ((*ip-&gt;ioset)(ip, PXRXSCAN, ip-&gt;d.pixietype, 1&lt;&lt;pixie) &lt; 0)
        return(-1);
    //
    // Read
    //
    #if 1
        //
        // On some architectures, depending on little vs big endian
        // and on how loose one wants to be with C, one can do
        // the following for both PXDATUCHAR and PXDATUSHORT.
        //
        if (ip-&gt;d.pixietype == PXDATUCHAR
         || ip-&gt;d.pixietype == PXDATUSHORT) {
            v.s = 0;
            if ((*ip-&gt;ioread)(ip, 0, &amp;v, 1, x, y) &lt; 0)
                return(-1);
            return(v.s);
        }
     #else
        //
        // The alternative is safe but verbose.
        //
        switch (ip-&gt;d.pixietype) {
          case PXDATUCHAR:
            if ((*ip-&gt;ioread)(ip, 0, &amp;v.c, 1, x, y) &lt; 0)
                return(-1)
            return(v.c);
          case PXDATUSHORT:
            if ((*ip-&gt;ioread)(ip, 0, &amp;v.s, 1, x, y) &lt; 0)
                return(-1)
            return(v.s);
        }
    #endif
    return(-1);     // data type unsupported by this example
}
</pre>
</blockquote>
<p>
</p><blockquote>
<pre>/*
 * Read all one or three components of one pixel.
 * See comments above regarding efficiency.
 * Assumes that all components can be shifted and fit into a long.
 */
long imagepixel(struct pximage *ip, pxcoord_t x, pxcoord_t y)
{
    union {
        uchar   c[3];
        ushort  s[3];
        ulong   l;
    } v;
    int     i;
    long    l;
<br>
    if (!ip)
        return(-1);     // missing pximage*
    //
    // Following tests aren't really necessary;
    // the ioset/ioread ends up doing the same.
    // They help illustrate use of the pximage fields.
    //
    if (x &lt; 0 || x &gt;= ip-&gt;imdim.se.x
     || y &lt; 0 || y &gt;= ip-&gt;imdim.se.y)
        return(-1);     // x or y out of image bounds
    if (x &gt;= ip-&gt;wind.se.x-ip-&gt;wind.nw.x
     || y &gt;= ip-&gt;wind.se.y-ip-&gt;wind.nw.y)
        return(-1);     // x or y out of AOI bounds
<br>
    //
    // Setup for read.
    // The last paramater to ::ioset is a bit map selecting
    // all pixel components, with a maximum of 3.
    //
    if ((*ip-&gt;ioset)(ip, PXRXSCAN, ip-&gt;d.pixietype, max(7, (1&lt;&lt;ip-&gt;d.pixies)-1)) &lt; 0)
        return(-1);
    //
    // Read
    //
    #if 1
        //
        // On some architectures, depending on little vs big endian
        // and on how loose one wants to be with C, one can do
        // the following for PXDATUCHAR.
        //
        if (ip-&gt;d.pixietype == PXDATUCHAR) {
            if ((*ip-&gt;ioread)(ip, 0, &amp;v.c[0], 1, x, y) &lt; 0)
                return(-1);
            return(v.l);
        }
    #endif
    //
    // The alternative is safe but verbose.
    //
    switch (ip-&gt;d.pixietype) {
      case PXDATUCHAR:
        if ((*ip-&gt;ioread)(ip, 0, &amp;v.c, 1, x, y) &lt; 0)
            return(-1);
        for (l = i = 0; i &lt; min(3, ip-&gt;d.pixies); i++)
            l = (l&lt;&lt;ip-&gt;d.u.i.bitsused) | v.c[i];
        return(l);
<br>
      case PXDATUSHORT:
        if ((*ip-&gt;ioread)(ip, 0, &amp;v.s, 1, x, y) &lt; 0)
            return(-1);
        for (l = i = 0; i &lt; min(3, ip-&gt;d.pixies); i++)
            l = (l&lt;&lt;ip-&gt;d.u.i.bitsused) | v.s[i];
        return(l);
    }
    return(-1);     // data type unsupported by this example
}
</pre>
</blockquote>
<hr size="1">
<a name="pximage::bxts NX1161" class="NX"></a>
<a name="pximage::bxts" class="Sf"></a>
<a name="PXIMAGE: Set to Access Non-Sequential Pixels NX1162" class="NX"></a>
<a name="PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts" class="Sf"></a>
<a name="PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts"></a>
<h6 class="Sf">PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts</h6>
<a name="pximage::bxtp NX1163" class="NX"></a>
<a name="pximage::bxtp" class="Sg"></a>
<a name="PXIMAGE: Prepare for Non-Sequential Pixel Access NX1164" class="NX"></a>
<a name="PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp" class="Sg"></a>
<a name="PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp"></a>
<h6 class="Sg">PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp</h6>
<a name="pximage::bxta NX1165" class="NX"></a>
<a name="pximage::bxta" class="Sg"></a>
<a name="PXIMAGE: Access Non-Sequential Pixels NX1166" class="NX"></a>
<a name="PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta" class="Sg"></a>
<a name="PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta"></a>
<h6 class="Sg">PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta</h6>
<a name="pximage::bxtw NX1167" class="NX"></a>
<a name="pximage::bxtw" class="Sg"></a>
<a name="PXIMAGE: Wait for Non-Sequential Access Completion NX1168" class="NX"></a>
<a name="PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw" class="Sg"></a>
<a name="PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw"></a>
<h6 class="Sg">PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw</h6>
<a name="::bxts NX1169" class="NX"></a>
<a name="::bxtp NX1170" class="NX"></a>
<a name="::bxta NX1171" class="NX"></a>
<a name="::bxtw NX1172" class="NX"></a>
<a name="::bxts" class="Tr"></a>
<a name="::bxtp" class="Tr"></a>
<a name="::bxta" class="Tr"></a>
<a name="::bxtw" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int       (ip-&gt;bxts)(ip, mode, data, colormap);
int       (ip-&gt;bxtp)(ip, mode, bufp, adrsp, cnt, op);
pximcnt_t (ip-&gt;bxta)(ip, mode, bufp, adrsp, cnt, op);
int       (ip-&gt;bxtw)(ip, wait, bufp, adrsp);
<br>
int       (ip3-&gt;bxts)(ip3, mode, data, colormap);
int       (ip3-&gt;bxtp)(ip3, mode, bufp, adrsp, cnt, op);
pximcnt_t (ip3-&gt;bxta)(ip3, mode, bufp, adrsp, cnt, op);
int       (ip3-&gt;bxtw)(ip3, wait, bufp, adrsp);
<br>
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 mode;           // As described below
int                 data;           // PXDATUCHAR, PXDATUSHORT, etc.
                                    // or'ed with PXDATLSB or PXDATMSB
uint                colormap;       // Pixie selection bit map
void _far           *bufp;          // Host memory [16 bit environments]
void                *bufp;          // Host memory [32 bit environments]
struct pximadrs _far *adrsp;        // List of pixel locations [16 bit environments]
struct pximadrs      *adrsp;        // List of pixel locations [32 bit environments]
pximcnt_t           cnt;            // Number of pixels to access
int                 op;             // Operation: PXPIXBLT, PXPIXBATN, PXPIXBUTN,
                                    //            PXPIXBRT, PXPIXBWT, PXPIXBXT,
int                 wait;           // PXAWAIT,PXASYNC,PXABORT
<br>
<a name="Struct pximadrs NX1173" class="NX"></a>
<a name="pximadrs, struct NX1174" class="NX"></a>
<a name="pximadrs_s NX1175" class="NX"></a>
<a name="pximadrs" class="Tr"></a>
<a name="pximadrs_s" class="Tr"></a>
struct pximadrs {                   // list of pixel locations
    union {
        struct  pxy  xy;            // x, y coordinates
        struct  pxyz xyz;           // x, y, z coordinates
<br>
        ulong   devadrs;            // internal usage ...
        uint    devstate[3];        // .. device specific
        void    *devptr0;           // .. coordinates
        ...
    } adrs;
};
typedef struct pximadrs pximadrs_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::bxts" class="Er">::bxts</a>,
<a href="#::bxtp" class="Er">::bxtp</a>,
<a href="#::bxta" class="Er">::bxta</a>,
and
<a href="#::bxtw" class="Er">::bxtw</a>
provide access to a list of pixels in arbitrary locations in the
<em class="Ep">pximage</em>
instance referenced by
<em class="Ep">ip</em>,
or the
<em class="Ep">pximage3</em>
instance referenced by
<em class="Ep">ip3</em>.
The
<a href="#::bxts" class="Er">::bxts</a>
must be used before other functions in this group;
<a href="#::bxts" class="Er">::bxts</a>
establishes various modes which affect how the other functions operate.
The
<em class="Ep">ip</em>'s
(or
<em class="Ep">ip3</em>'s)
area of interest window must not be changed
between setting an access mode with
<a href="#::bxts" class="Er">::bxts</a>
and using the other functions in this group.
</p><p>
<br>
<b class="Hv">Overview.</b>
Application programs prepare an array of
<em class="Ep">pximadrs</em>
structures, one
<em class="Ep">pximadrs</em>
for each pixel to be accessed.
The
<em class="Ep">adrs.xy</em>
(or
<em class="Ep">adrs.xyz</em>)
of each
<em class="Ep">pximadrs</em>
is initialized with a pixel's coordinates
relative to the current area of interest.
For each pixel in the list, a pixel read, write,
or modify operation is performed;
reading pixel values into the
<em class="Ep">bufp</em>,
writing pixel values from the
<em class="Ep">bufp</em>,
or modifying pixel values with values from the
<em class="Ep">bufp</em>.
</p><p>
<br>
<b class="Hv">::bxts.</b>
The
<a href="#::bxts" class="Er">::bxts</a>
establishes the data type for later
<a href="#::bxta" class="Er">::bxta</a>.
The
<em class="Ep">mode</em>
is reserved, and should be PXIXYVALID.
The
<em class="Ep">data</em>
and
<em class="Ep">colormap</em>
of
<em class="Ep">::bxts</em>
specifies the data type the
<em class="Ep">bufp</em>
is expected to reference, and
which pixel components are to be accessed,
as described above for
<a href="#::ioset" class="Er">::ioset</a>.
</p><p>
The
<a href="#::bxts" class="Er">::bxts</a>
returns a value greater than 0 if successful, or less than 0 if the
image can't be accessed in the manner requested.
Some
<em class="Ep">pximage</em>
(or
<em class="Ep">pximage3</em>
device drivers may not support the
::bxt*
services.
</p><p>
<br>
<b class="Hv">::bxtp.</b>
If
<em class="Ep">mode</em>&amp;PXIBXTC,
the
<a href="#::bxtp" class="Er">::bxtp</a>
translates the
<em class="Ep">adrs.xy</em>
(or
<em class="Ep">adrs.xyz</em>)
of the
<em class="Ep">adrsp</em>
list containing
<em class="Ep">cnt</em>
elements of
<em class="Ep">pximadrs</em>
structures into an internal, device dependent, form.
The
<em class="Ep">adrs.xy</em>
(or
<em class="Ep">adrs.xyz)</em>
coordinates are assumed valid!
The
<em class="Ep">op</em>
is the operation to be performed, as described below
for
<a href="#::bxta" class="Er">::bxta</a>.
(The
<em class="Ep">op</em>
is currently ignored and may be 0).
</p><p>
The address translation
can be done when pixels are accessed with
<a href="#::bxta" class="Er">::bxta</a>,
explicit translation and modification
allows reusing the same list with lower overhead.
</p><p>
The
<a href="#::bxtp" class="Er">::bxtp</a>
return value is the
<em class="Ep">mode</em>
with the PXIBXTC bit set if the
<em class="Ep">adrs.xy</em>
(or
<em class="Ep">adrs.xyz)</em>
were modified or overwritten,
otherwise the PXIBXTC bit is reset (if the device driver
chooses to work with the original
''x'',
''y'',
and
''z''
coordinates).
</p><p>
<br>
<b class="Hv">::bxta.</b>
The
<a href="#::bxta" class="Er">::bxta</a>
reads, writes, or modifies the
<em class="Ep">cnt</em>
pixels whose coordinates are specified by the
<em class="Ep">adrsp</em>
list of
<em class="Ep">cnt</em>
elements of
<em class="Ep">pximadrs</em>
structures.
The
<em class="Ep">bufp</em>
must reference
an array of the data type specified previously via
<a href="#::bxts" class="Er">::bxts</a>,
with size no smaller than
<em class="Ep">cnt</em>
times the number of pixies encoded in the
<em class="Ep">colormap</em>
specified via
<a href="#::bxts" class="Er">::bxts</a>;
successive pixies from
<em class="Ep">bufp</em>
are associated with successive pixel addresses from
<em class="Ep">adrsp</em>.
The
<em class="Ep">op</em>
specifies the desired operation:
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
op value   
</td>
<td colspan="1" align="left">
 operation
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBLT   
</td>
<td colspan="1" align="left">
 exchange value in bufp[] with pixel
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBATN  
</td>
<td colspan="1" align="left">
 add value in bufp[] to pixel
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBUTN  
</td>
<td colspan="1" align="left">
 subtract value in bufp[] from pixel
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBUTN  
</td>
<td colspan="1" align="left">
 subtract value in bufp[] from pixel
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBRT   
</td>
<td colspan="1" align="left">
 read pixel value into bufp[]
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBWT   
</td>
<td colspan="1" align="left">
 write value in bufp[] to pixel
</td>
</tr>
<tr>
<td colspan="1" align="left">
PXPIXBXT   
</td>
<td colspan="1" align="left">
 XOR value in bufp[] with pixel (unsigned integer pixels only)
</td>
</tr>
</tbody></table>
</pre>
</div>
For PXPIXBLT, PXPIXBATN, PXPIXBUTN,
PXPIXBWT, and PXPIXBXT,
the pixels in the buffer referenced by
<em class="Ep">bufp</em>
should be initialized with a value before using
<a href="#::bxta" class="Er">::bxta</a>.
For PXPIXBLT and PXPIXBRT, the
pixels in the buffer referenced by
<em class="Ep">bufp</em>
will be modified.
<p>
The
<em class="Ep">mode</em>
should be 0, OR'ed with the following options.
If
<em class="Ep">mode</em>
is OR'ed with PXIBXTC
<a href="#::bxta" class="Er">::bxta</a>
also performs the effect of
<a href="#::bxtp" class="Er">::bxtp</a>,
avoiding having to explicitly invoke
<a href="#::bxtp" class="Er">::bxtp</a>.
</p><p>
The return value of
<a href="#::bxta" class="Er">::bxta</a>
indicates the number of pixels accessed.
</p><p>
The
<em class="Ep">mode</em>
may be OR'ed with PXIASYNC;
the pixel access is done asynchronously, if possible.
If the return value of
<a href="#::bxta" class="Er">::bxta</a>
is non-zero, asynchronous operation isn't available
and the operation is complete.
A return value of zero indicates that the operation is pending
and may not be complete; the
<a href="#::bxtw" class="Er">::bxtw</a>
must be used to wait or test for completion.
For each instance of a
<a href="#pximage" class="Er">pximage</a>
or
<a href="#pximage3" class="Er">pximage3</a>,
only one asynchronous operation may be pending at any one time.
</p><p>
<br>
<b class="Hv">::bxtw.</b>
The
<a href="#::bxtw" class="Er">::bxtw</a>
need be used only when PXIASYNC
is used with
<a href="#::bxta" class="Er">::bxta</a>.
The
<em class="Ep">bufp</em>
and
<em class="Ep">adrsp</em>
must be the same values as used with
<a href="#::bxta" class="Er">::bxta</a>.
The
<em class="Ep">wait</em>
must be either:
(a)&nbsp;PXAWAIT,
for which return is delayed until the previous operation is complete, returning the
value PXODONE;
(b)&nbsp;PXASYNC, for which return is immediate and the return
value is PXODONE to indicate the operation is complete or PXOPRUN
to indicate the operation is not yet complete;
or
(c)&nbsp;PXABORT, to prematurely terminate (if possible) the pending operation,
returning value PXODONE.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="1">
<a name="pximage::imapset NX1176" class="NX"></a>
<a name="pximage::imapset" class="Sf"></a>
<a name="PXIMAGE: Set to Obtain Pointer to Pixels NX1177" class="NX"></a>
<a name="PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset" class="Sf"></a>
<a name="PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset"></a>
<h6 class="Sf">PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset</h6>
<a name="pximage::imap NX1178" class="NX"></a>
<a name="pximage::imap" class="Sg"></a>
<a name="PXIMAGE: Obtain Pointer to Pixels NX1179" class="NX"></a>
<a name="PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap" class="Sg"></a>
<a name="PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap"></a>
<h6 class="Sg">PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap</h6>
<a name="pximage::imapr NX1180" class="NX"></a>
<a name="pximage::imapr" class="Sg"></a>
<a name="PXIMAGE: Release Pointer to Pixels NX1181" class="NX"></a>
<a name="PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr" class="Sg"></a>
<a name="PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr"></a>
<h6 class="Sg">PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr</h6>
<a name="::imapset NX1182" class="NX"></a>
<a name="::imap NX1183" class="NX"></a>
<a name="::imapr NX1184" class="NX"></a>
<a name="::imapset" class="Tr"></a>
<a name="::imap" class="Tr"></a>
<a name="::imapr" class="Tr"></a>
<br>
<br>
<br>
<em class="Ss">Summary</em>
<blockquote>
<pre>int  (ip-&gt;imapset)(ip, mode, data, colormap);
int  (ip-&gt;imap)(ip, mp, x, y);
void (ip-&gt;imapr)(ip, mp);
<br>
int  (ip3-&gt;imapset)(ip3, mode, data, colormap);
int  (ip3-&gt;imap)(ip3, mp, x, y, z);
void (ip3-&gt;imapr)(ip3, pixp);
<br>
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 mode;           // As described below
int                 data;           // PXDATUCHAR, PXDATUSHORT, etc.
                                    // or'ed with PXDATLSB or PXDATMSB
uint                colormap;       // Pixie selection bit map
struct pximap       *mp;            // Pixel reference 'handle'
<br>
pxcoord_t           x;              // Access x (horizontal) coordinate
pxcoord_t           y;              // Access y (vertical) coordinate
pxcoord_t           z;              // Access z (depth) coordinate
<br>
<a name="Struct pximap NX1185" class="NX"></a>
<a name="pximap, struct NX1186" class="NX"></a>
<a name="pximap" class="Tr"></a>
struct pximap
{
    int         valid;  // imap()'s return value, clr'ed by imapr()
    void _far   *p;     // pointer to image memory [segmented (i86) environments]
    void        *p;     // pointer to image memory [non-segmented environments]
<br>
    size_t      inc;    // increment to next pixie, always in ..
                        // .. sizeof(char), regardless of pixie type
    size_t      len;    // number of following pixels that can be accessed ..
                        // .. at increasing x,y,z by using the inc
<br>
                        // if imap() mode 2 (PXIMAP2): (future)
    size_t      xinc;   // increment to next pixel (X) in row
    size_t      yinc;   // increment to next row (Y) in image
    size_t      zinc;   // increment to next image (Z) in sequence (3-D)
                        // all in sizeof(char), regardless of pixie type
    size_t      xdim;   // # of accessible pixels at increasing X
    size_t      ydim;   // # of accessible pixels at increasing Y
    size_t      zdim;   // # of accessible pixels at increasing Z
};
typedef struct pximap pximap_s;
</pre>
</blockquote>
<br>
<br>
<br>
<em class="Ss">Description</em>
<p>
The
<a href="#::imapset" class="Er">::imapset</a>,
<a href="#::imap" class="Er">::imap</a>,
and
<a href="#::imapr" class="Er">::imapr</a>
provides direct pointer access to pixels in the
<em class="Ep">pximage</em>
instance referenced by
<em class="Ep">ip</em>,
or the
<em class="Ep">pximage3</em>
instance referenced by
<em class="Ep">ip3</em>.
Some
<em class="Ep">pximage</em>
(or
<em class="Ep">pximage3</em>)
device drivers do not support the
<a href="#::imap" class="Er">::imap</a>
service, or may provide the service
under limited conditions.<a href="#Footnote%2041" class="Ff"><sup>[41]</sup></a>
</p><p>
The
<a href="#::imapset" class="Er">::imapset</a>
must be used before other functions in this group;
<a href="#::imapset" class="Er">::imapset</a>
establishes various modes which affect how the other functions operate.
The
<em class="Ep">ip</em>'s
(or
<em class="Ep">ip3</em>'s)
area of interest window must not be changed
between setting an access mode with
<a href="#::imapset" class="Er">::imapset</a>
and using the other functions in this group.
</p><p>
<br>
<b class="Hv">Overview.</b>
The
<a href="#::imap" class="Er">::imap</a>
requests access to the pixel at coordinates
<em class="Ep">x</em>,
<em class="Ep">y</em>,
(and
<em class="Ep">z</em>),
relative to the image area of interest,
and as many of the following pixels as possible; the
<em class="Ep">mode</em>
of
<em class="Ep">::imapset</em>
specifies the sense of
''following pixels'';
in order of increasing
<em class="Ep">x</em>,
<em class="Ep">y</em>,
(or
<em class="Ep">z</em>).
The
<em class="Ep">data</em>
and
<em class="Ep">colormap</em>
of
<em class="Ep">::imapset</em>
specifies the data type the pointer is expected to reference, and
which pixel components are to be accessed.
If direct access is possible,
<em class="Ep">::imap</em>
returns a suitable pointer,
which, after being cast to the correct data type, can read or write pixel values.
Also returned are the number of following pixels that can be accessed,
and the increment to be added to the pointer to access the following pixels.
When done, the direct access is released with
<em class="Ep">::imapr</em>.
</p><p>
<br>
<b class="Hv">::imapset.</b>
The
<a href="#::imapset" class="Er">::imapset</a>
establishes the sequence orientation (horizontal, vertical, depth),
and the data type for later use of
<a href="#::imap" class="Er">::imap</a>.
</p><p>
The
<em class="Ep">mode</em>
should be PXRXSCAN, PXRYSCAN, (or PXRZSCAN).
If
<em class="Ep">mode</em>=PXRXSCAN,
the sense of
''following pixels''
is in order of increasing
''x'',
then
increasing
''y''
(and then
increasing
''z'').
If
<em class="Ep">mode</em>=PXRYSCAN,
the sense is in order of increasing
''y'',
then
increasing
''x''
(and then
increasing
''z'').
(If
<em class="Ep">mode</em>=PXRZSCAN,
the sense is in order of increasing
''z'',
then increasing
''x'',
and then increasing
''y'').
</p><p>
If
<em class="Ep">mode</em>
is OR'ed with PXIWRAP,
the sense of
''following pixels''
''wraps''
around at the end of the specified line (PXRXSCAN), column (PXRYSCAN),
or depth vector (PXRZSCAN),
allowing several lines, columns, or depth vectors to be available
at the same time.
Otherwise,
the sense of
''following pixels''
stops at the end of the specified
line (PXRXSCAN), column (PXRYSCAN) (or depth vector (PXRZSCAN)).
</p><p>
If
<em class="Ep">mode</em>
is not OR'ed with PXIMAPINC,
the returned
<em class="Ep">mp</em>-&gt;<em class="Ep">inc</em>
(assuming direct access service is available at all)
is always the size of the data type specified by
<em class="Ep">data</em>;
in other words, the assumptions expressed by:
</p><blockquote>
<pre>    struct  pximap  imap;
    uint16  _far    *lp;    // _far only in segmented environments
<br>
    if ((ip-&gt;imapset)(ip, PXRXSCAN, PXDATUINT16, 0x01) &gt; 0) {
        if ((ip-&gt;imap)(ip, &amp;imap, 0, 0)) {
            lp = imap.p;
            while (imap.len--)
                *lp++ = 0;
            (ip-&gt;imapr)(ip, &amp;imap);
        }
    }
</pre>
</blockquote>
are valid.
If
<em class="Ep">mode</em>
is OR'ed with PXIMAPINC, the
<em class="Ep">mp</em>-&gt;<em class="Ep">inc</em>,
may not be the data size, but more pixels may thereby be accessible.
The above extract must be modified to:
<blockquote>
<pre>    struct  pximap  imap;
<br>
    if ((ip-&gt;imapset)(ip, PXRXSCAN|PXIMAPINC, PXDATUINT16, 0x01) &gt; 0)
        if ((ip-&gt;imap)(ip, &amp;imap, 0, 0)) {
            while (imap.len--) {
                *((uint16 _far*)imap.p) = 0;     // _far only in segmented environments
                (uchar _far*) imap.p += imap.inc;
            }
            (ip-&gt;imapr)(ip, &amp;imap);
        }
</pre>
</blockquote>
<br>
<b class="Hv">Note:</b>
The
<em class="Ep">mp</em>-&gt;<em class="Ep">inc</em>
is always in units of
''uchars''!!!
<p>
If
<em class="Ep">mode</em>
is OR'ed with PXIMAPNOTFAR, the
<a href="#::imapset" class="Er">::imapset</a>
will succeed only if the pointer returned by
<em class="Ep">::imap</em>
can have the
''_far''
adjective cast off;
the assumptions expressed by:
</p><blockquote>
<pre>    struct  pximap imap;
    uint16  *lp;    // a default pointer!! All environments!!
<br>
    if ((ip-&gt;imapset)(ip, PXRXSCAN|PXIMAPNOTFAR, PXDATUINT16, 0x01) &gt; 0)
        if ((ip-&gt;imap)(ip, &amp;imap, 0, 0)) {
            lp = imap.p;            // ignore compiler warning
            lp = (uint16*)(imap.p);  // or explicitly cast it
            while (imap.len--)
                *lp++ = 0;
            (ip-&gt;imapr)(ip, &amp;imap);
        }
</pre>
</blockquote>
are valid.
In nonsegmented environments which do not require the
''_far''
adjective,
on in environments such as Microsoft 32 Bit C which doesn't support
''_far''
pointers, the
PXIMAPNOTFAR is ignored.
<p>
If
<em class="Ep">mode</em>
is OR'ed with PXIXYVALID,
the
''x'',
''y'',
(and
''z'')
coordinates given to
<em class="Ep">::imap</em>
are assumed valid,
requiring less overhead for checking.
</p><p>
The
<em class="Ep">data</em>
specifies the intended data type of the returned pointer.
</p><div align="center">
<pre><table frame="box" rules="groups">
<tbody><tr>
<td colspan="1" align="left">
pointer type            
</td>
<td colspan="1" align="left">
 data
</td>
</tr>
<tr>
<td colspan="1" align="left">
uchar                   
</td>
<td colspan="1" align="left">
 PXDATUCHAR
</td>
</tr>
<tr>
<td colspan="1" align="left">
ushort                  
</td>
<td colspan="1" align="left">
 PXDATUSHORT
</td>
</tr>
<tr>
<td colspan="1" align="left">
uint                    
</td>
<td colspan="1" align="left">
 PXDATUINT
</td>
</tr>
<tr>
<td colspan="1" align="left">
ulong                   
</td>
<td colspan="1" align="left">
 PXDATULONG
</td>
</tr>
<tr>
<td colspan="1" align="left">
float                   
</td>
<td colspan="1" align="left">
 PXDATFLOAT
</td>
</tr>
<tr>
<td colspan="1" align="left">
double                  
</td>
<td colspan="1" align="left">
 PXDATDOUBLE
</td>
</tr>
<tr>
<td colspan="1" align="left">
8 bit unsigned integer  
</td>
<td colspan="1" align="left">
 PXDATUINT8
</td>
</tr>
<tr>
<td colspan="1" align="left">
16 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT16
</td>
</tr>
<tr>
<td colspan="1" align="left">
32 bit unsigned integer 
</td>
<td colspan="1" align="left">
 PXDATUINT32
</td>
</tr>
</tbody></table>
</pre>
</div>
For the unsigned integer types, the
<em class="Ep">data</em>
may also be OR'ed with PXDATMSB, PXDATLSB, and/or PXDATDIRTY.
These specifications are interpreted in a similar manner as the
<em class="Ep">data</em>
parameter described for
<a href="#::ioset" class="Er">::ioset</a>.
If PXDATMSB is used,
<a href="#::imapset" class="Er">::imapset</a>
will succeed only if the unused bits, if any, are right justified.
If PXDATLSB is used,
<a href="#::imapset" class="Er">::imapset</a>
will succeed only if the unused bits, if any, are left justified.
The PXDATMSB and PXDATLSB should not be used together.
If PXDATDIRTY is not used,
<a href="#::imapset" class="Er">::imapset</a>
will succeed only if the unused bits, if any, are 0.
<p>
The
<em class="Ep">colormap</em>
specifies which pixie components are to be accessed,
in the same manner as the
<em class="Ep">colormap</em>
parameter described for
<a href="#::ioset" class="Er">::ioset</a>.
</p><p>
The
<em class="Ep">::imapset</em>
returns a value greater than 0 if successful; or
less than 0 if the service is not available,
or the requested/expected
<em class="Ep">data</em>
and
<em class="Ep">colormap</em>
is not consistent with the actual pixel data.
</p><p>
<br>
<b class="Hv">::imap.</b>
The
<em class="Ep">::imap</em>
requests a direct access pointer to the pixel at
''x'',
''y'',
(and
''z'')
relative to the image area of interest,
and to following pixels;
where the orientation of
''following pixels'',
and the expected data type of the pointer
are as specified by the
<em class="Ep">mode</em>,
<em class="Ep">data</em>,
and
<em class="Ep">colormap</em>
or
<em class="Ep">::imapset.</em>
</p><p>
The
<em class="Ep">::imap</em>
returns 1 if access is granted, and fills in the
<em class="Ep">pximap</em>
structure referenced by
<em class="Ep">mp</em>.
The
<em class="Ep">mp</em>-&gt;<em class="Ep">p</em>
is the direct access pointer,
the
<em class="Ep">mp</em>-&gt;<em class="Ep">len</em>
is the number of pixels that can be accessed with
<em class="Ep">mp</em>-&gt;<em class="Ep">p</em>
by incrementing by
<em class="Ep">mp</em>-&gt;<em class="Ep">inc</em>
''uchars''.
The
<em class="Ep">mp</em>-&gt;<em class="Ep">valid</em>
is set to 1.
</p><p>
The
<em class="Ep">::imap</em>
returns 0
if the access is denied, and sets
<em class="Ep">mp</em>-&gt;<em class="Ep">valid</em>
to 0.
The
<em class="Ep">::imap</em>
may fail even if
<em class="Ep">::imapset</em>
succeeds.<a href="#Footnote%2042" class="Ff"><sup>[42]</sup></a>
</p><p>
Multiple, simultaneous, direct access pointers may be requested from
the same
<em class="Ep">pximage</em>
(or
<em class="Ep">pximage3</em>),
although hardware limitations may restrict ability of some device drivers
to fulfill the second or later requests.
</p><p>
Under environments other than real-mode DOS:
For
<em class="Ep">pximage</em>'s
(or
<em class="Ep">pximage3</em>'s),
which access buffers on imaging boards
(such as on the SILICON VIDEO® MUX or the 4MEG VIDEO imaging boards),
the direct access pointer provided by
<em class="Ep">::imap</em>
may be used by the requesting application,
but can not be passed to other applications or to system
services such as file I/O.
</p><p>
<br>
<b class="Hv">::imapr.</b>
The
<em class="Ep">::imapr</em>
releases a direct access pointer provided by
<em class="Ep">::imap</em>
and sets
<em class="Ep">mp</em>-&gt;<em class="Ep">valid</em>
to 0.
For convenience, the
<em class="Ep">::imapr</em>
may be called even if
<em class="Ep">::imap</em>
failed (using the same
<em class="Ep">mp</em>)
without ill effect.
Also, for convenience, the
<em class="Ep">mp</em>-&gt;<em class="Ep">p</em>,
<em class="Ep">mp</em>-&gt;<em class="Ep">len</em>,
and
<em class="Ep">mp</em>-&gt;<em class="Ep">cnt</em>,
(but not
<em class="Ep">mp</em>-&gt;<em class="Ep">valid</em>)
may be altered between invocations of
<em class="Ep">::imap</em>
and
<em class="Ep">::imapr</em>.
<br>
<br>
<br>
<em class="Ss">Returns</em>
</p><p>
As described above.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Deprecated Functions" class="Ch"></a>
<a name="13.  Deprecated Functions"></a>
</p><h1>13.  Deprecated Functions</h1>
<a name="pxd_SV2112_setExposureAndGain NX1187" class="NX"></a>
<a name="pxd_SV2112_getExposure NX1188" class="NX"></a>
<a name="pxd_SV2112_getGain NX1189" class="NX"></a>
<a name="pxd_SV2112_setResolutionAndTiming NX1190" class="NX"></a>
<a name="pxd_SV2112_getDecimation NX1191" class="NX"></a>
<a name="pxd_SV2112_getAoiTop NX1192" class="NX"></a>
<a name="pxd_SV2112_getAoiLeft NX1193" class="NX"></a>
<a name="pxd_SV2112_getPixelClock NX1194" class="NX"></a>
<a name="pxd_SV2112_getScanDirection NX1195" class="NX"></a>
<a name="pxd_SV2112_setVideoAndTriggerMode NX1196" class="NX"></a>
<a name="pxd_SV2112_setCtrlExposureAndRate NX1197" class="NX"></a>
<a name="pxd_SV2112_getVideoMode NX1198" class="NX"></a>
<a name="pxd_SV2112_getCtrlVideoMode NX1199" class="NX"></a>
<a name="pxd_SV2112_getCtrlTriggerMode NX1200" class="NX"></a>
<a name="pxd_SV2112_getCtrlFrameRate NX1201" class="NX"></a>
<a name="pxd_SV2112_getCtrlExposure NX1202" class="NX"></a>
<a name="pxd_SV2112_getMinMaxExposure NX1203" class="NX"></a>
<a name="pxd_SV2112_getMinMaxCtrlExposure NX1204" class="NX"></a>
<p>
Use of camera specific functions
<cite class="Ec">pxd_SV2112_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV2112_getExposure</cite>,
<cite class="Ec">pxd_SV2112_getGain</cite>,
<cite class="Ec">pxd_SV2112_setResolutionAndTiming</cite>,
<cite class="Ec">pxd_SV2112_getDecimation</cite>,
<cite class="Ec">pxd_SV2112_getAoiTop</cite>,
<cite class="Ec">pxd_SV2112_getAoiLeft</cite>,
<cite class="Ec">pxd_SV2112_getPixelClock</cite>,
<cite class="Ec">pxd_SV2112_getScanDirection</cite>,
<cite class="Ec">pxd_SV2112_setVideoAndTriggerMode</cite>,
<cite class="Ec">pxd_SV2112_setCtrlExposureAndRate</cite>,
<cite class="Ec">pxd_SV2112_getVideoMode</cite>,
<cite class="Ec">pxd_SV2112_getCtrlVideoMode</cite>,
<cite class="Ec">pxd_SV2112_getCtrlTriggerMode</cite>,
<cite class="Ec">pxd_SV2112_getCtrlFrameRate</cite>,
<cite class="Ec">pxd_SV2112_getCtrlExposure</cite>,
<cite class="Ec">pxd_SV2112_getMinMaxExposure</cite>,
and
<cite class="Ec">pxd_SV2112_getMinMaxCtrlExposure</cite>
is deprecated;
new applications should use
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>,
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>,
<a href="#pxd_SILICONVIDEO_setCtrlExposureAndRate" class="Er">pxd_SILICONVIDEO_setCtrlExposureAndRate</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxExposure" class="Er">pxd_SILICONVIDEO_getMinMaxExposure</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxCtrlExposure" class="Er">pxd_SILICONVIDEO_getMinMaxCtrlExposure</a>,
and related functions.
<a name="pxd_SV1281_setExposureGainOffset NX1205" class="NX"></a>
<a name="pxd_SV1281_getExposure NX1206" class="NX"></a>
<a name="pxd_SV1281_getGain NX1207" class="NX"></a>
<a name="pxd_SV1281_getOffset NX1208" class="NX"></a>
<a name="pxd_SV1281_setResolutionAndTiming NX1209" class="NX"></a>
<a name="pxd_SV1281_getAoiTop NX1210" class="NX"></a>
<a name="pxd_SV1281_getAoiLeft NX1211" class="NX"></a>
<a name="pxd_SV1281_getPixelClock NX1212" class="NX"></a>
<a name="pxd_SV1281_setVideoAndTriggerMode NX1213" class="NX"></a>
<a name="pxd_SV1281_setCtrlRate NX1214" class="NX"></a>
<a name="pxd_SV1281_getVideoMode NX1215" class="NX"></a>
<a name="pxd_SV1281_getCtrlVideoMode NX1216" class="NX"></a>
<a name="pxd_SV1281_getCtrlTriggerMode NX1217" class="NX"></a>
<a name="pxd_SV1281_getCtrlFrameRate NX1218" class="NX"></a>
<a name="pxd_SV1281_getMinMaxExposure NX1219" class="NX"></a>
</p><p>
Use of camera specific functions
<cite class="Ec">pxd_SV1281_setExposureGainOffset</cite>,
<cite class="Ec">pxd_SV1281_getExposure</cite>,
<cite class="Ec">pxd_SV1281_getGain</cite>,
<cite class="Ec">pxd_SV1281_getOffset</cite>,
<cite class="Ec">pxd_SV1281_setResolutionAndTiming</cite>,
<cite class="Ec">pxd_SV1281_getAoiTop</cite>,
<cite class="Ec">pxd_SV1281_getAoiLeft</cite>,
<cite class="Ec">pxd_SV1281_getPixelClock</cite>,
<cite class="Ec">pxd_SV1281_setVideoAndTriggerMode</cite>,
<cite class="Ec">pxd_SV1281_setCtrlRate</cite>,
<cite class="Ec">pxd_SV1281_getVideoMode</cite>,
<cite class="Ec">pxd_SV1281_getCtrlVideoMode</cite>,
<cite class="Ec">pxd_SV1281_getCtrlTriggerMode</cite>,
<cite class="Ec">pxd_SV1281_getCtrlFrameRate</cite>,
and
<cite class="Ec">pxd_SV1281_getMinMaxExposure</cite>
is deprecated;
new applications should use
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>,
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>,
<a href="#pxd_SILICONVIDEO_setCtrlExposureAndRate" class="Er">pxd_SILICONVIDEO_setCtrlExposureAndRate</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxExposure" class="Er">pxd_SILICONVIDEO_getMinMaxExposure</a>,
and related functions.
<a name="pxd_SV1310_setExposureGainOffset NX1220" class="NX"></a>
<a name="pxd_SV1310_getExposure NX1221" class="NX"></a>
<a name="pxd_SV1310_getGain NX1222" class="NX"></a>
<a name="pxd_SV1310_getOffset NX1223" class="NX"></a>
<a name="pxd_SV1310_setColorGain NX1224" class="NX"></a>
<a name="pxd_SV1310_getColorGain NX1225" class="NX"></a>
<a name="pxd_SV1310_setResolutionAndTiming NX1226" class="NX"></a>
<a name="pxd_SV1310_getSubsample NX1227" class="NX"></a>
<a name="pxd_SV1310_getAoiTop NX1228" class="NX"></a>
<a name="pxd_SV1310_getAoiLeft NX1229" class="NX"></a>
<a name="pxd_SV1310_getPixelClock NX1230" class="NX"></a>
<a name="pxd_SV1310_getReadoutDirection NX1231" class="NX"></a>
<a name="pxd_SV1310_getFramePeriod NX1232" class="NX"></a>
<a name="pxd_SV1310_setVideoAndTriggerMode NX1233" class="NX"></a>
<a name="pxd_SV1310_setCtrlRate NX1234" class="NX"></a>
<a name="pxd_SV1310_getVideoMode NX1235" class="NX"></a>
<a name="pxd_SV1310_getCtrlVideoMode NX1236" class="NX"></a>
<a name="pxd_SV1310_getCtrlTriggerMode NX1237" class="NX"></a>
<a name="pxd_SV1310_getCtrlFrameRate NX1238" class="NX"></a>
<a name="pxd_SV1310_getMinMaxExposure NX1239" class="NX"></a>
</p><p>
Use of camera specific functions
<cite class="Ec">pxd_SV1310_setExposureGainOffset</cite>,
<cite class="Ec">pxd_SV1310_getExposure</cite>,
<cite class="Ec">pxd_SV1310_getGain</cite>,
<cite class="Ec">pxd_SV1310_getOffset</cite>,
<cite class="Ec">pxd_SV1310_setColorGain</cite>,
<cite class="Ec">pxd_SV1310_getColorGain</cite>,
<cite class="Ec">pxd_SV1310_setResolutionAndTiming</cite>,
<cite class="Ec">pxd_SV1310_getSubsample</cite>,
<cite class="Ec">pxd_SV1310_getAoiTop</cite>,
<cite class="Ec">pxd_SV1310_getAoiLeft</cite>,
<cite class="Ec">pxd_SV1310_getPixelClock</cite>,
<cite class="Ec">pxd_SV1310_getReadoutDirection</cite>,
<cite class="Ec">pxd_SV1310_getFramePeriod</cite>,
<cite class="Ec">pxd_SV1310_setVideoAndTriggerMode</cite>,
<cite class="Ec">pxd_SV1310_setCtrlRate</cite>,
<cite class="Ec">pxd_SV1310_getVideoMode</cite>,
<cite class="Ec">pxd_SV1310_getCtrlVideoMode</cite>,
<cite class="Ec">pxd_SV1310_getCtrlTriggerMode</cite>,
<cite class="Ec">pxd_SV1310_getCtrlFrameRate</cite>,
and
<cite class="Ec">pxd_SV1310_getMinMaxExposure</cite>
is deprecated;
new applications should use
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>,
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>,
<a href="#pxd_SILICONVIDEO_setCtrlExposureAndRate" class="Er">pxd_SILICONVIDEO_setCtrlExposureAndRate</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxExposure" class="Er">pxd_SILICONVIDEO_getMinMaxExposure</a>,
and related functions.
<a name="pxd_SV642_setExposureAndGain NX1240" class="NX"></a>
<a name="pxd_SV642_getExposure NX1241" class="NX"></a>
<a name="pxd_SV642_getGain NX1242" class="NX"></a>
<a name="pxd_SV642_getGainRange NX1243" class="NX"></a>
<a name="pxd_SV642_setResolutionAndTiming NX1244" class="NX"></a>
<a name="pxd_SV642_getAoiTop NX1245" class="NX"></a>
<a name="pxd_SV642_getAoiLeft NX1246" class="NX"></a>
<a name="pxd_SV642_getPixelClock NX1247" class="NX"></a>
<a name="pxd_SV642_setVideoAndTriggerMode NX1248" class="NX"></a>
<a name="pxd_SV642_setCtrlRate NX1249" class="NX"></a>
<a name="pxd_SV642_getVideoMode NX1250" class="NX"></a>
<a name="pxd_SV642_getCtrlVideoMode NX1251" class="NX"></a>
<a name="pxd_SV642_getCtrlTriggerMode NX1252" class="NX"></a>
<a name="pxd_SV642_getCtrlFrameRate NX1253" class="NX"></a>
<a name="pxd_SV642_getMinMaxExposure NX1254" class="NX"></a>
</p><p>
Use of camera specific functions
<cite class="Ec">pxd_SV642_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV642_getExposure</cite>,
<cite class="Ec">pxd_SV642_getGain</cite>,
<cite class="Ec">pxd_SV642_getGainRange</cite>,
<cite class="Ec">pxd_SV642_setResolutionAndTiming</cite>,
<cite class="Ec">pxd_SV642_getAoiTop</cite>,
<cite class="Ec">pxd_SV642_getAoiLeft</cite>,
<cite class="Ec">pxd_SV642_getPixelClock</cite>,
<cite class="Ec">pxd_SV642_setVideoAndTriggerMode</cite>,
<cite class="Ec">pxd_SV642_setCtrlRate</cite>,
<cite class="Ec">pxd_SV642_getVideoMode</cite>,
<cite class="Ec">pxd_SV642_getCtrlVideoMode</cite>,
<cite class="Ec">pxd_SV642_getCtrlTriggerMode</cite>,
<cite class="Ec">pxd_SV642_getCtrlFrameRate</cite>,
and
<cite class="Ec">pxd_SV642_getMinMaxExposure</cite>
is deprecated;
new applications should use
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>,
<a href="#pxd_SILICONVIDEO_setCtrlExposureAndRate" class="Er">pxd_SILICONVIDEO_setCtrlExposureAndRate</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxExposure" class="Er">pxd_SILICONVIDEO_getMinMaxExposure</a>
<a href="#pxd_SILICONVIDEO_getMinMaxCtrlExposure" class="Er">pxd_SILICONVIDEO_getMinMaxCtrlExposure</a>.
and related functions.
<a name="pxd_SV643_setExposureAndGain NX1255" class="NX"></a>
<a name="pxd_SV643_setExposureAndGainOffset NX1256" class="NX"></a>
<a name="pxd_SV643_getExposure NX1257" class="NX"></a>
<a name="pxd_SV643_getGain NX1258" class="NX"></a>
<a name="pxd_SV643_getOffset NX1259" class="NX"></a>
<a name="pxd_SV643_setResolutionAndTiming NX1260" class="NX"></a>
<a name="pxd_SV643_getAoiTop NX1261" class="NX"></a>
<a name="pxd_SV643_getAoiLeft NX1262" class="NX"></a>
<a name="pxd_SV643_getPixelClock NX1263" class="NX"></a>
<a name="pxd_SV643_setVideoAndTriggerMode NX1264" class="NX"></a>
<a name="pxd_SV643_setCtrlExposureAndRate NX1265" class="NX"></a>
<a name="pxd_SV643_getVideoMode NX1266" class="NX"></a>
<a name="pxd_SV643_getCtrlVideoMode NX1267" class="NX"></a>
<a name="pxd_SV643_getCtrlTriggerMode NX1268" class="NX"></a>
<a name="pxd_SV643_getCtrlFrameRate NX1269" class="NX"></a>
<a name="pxd_SV643_getCtrlExposure NX1270" class="NX"></a>
<a name="pxd_SV643_getMinMaxExposure NX1271" class="NX"></a>
<a name="pxd_SV643_getMinMaxCtrlExposure NX1272" class="NX"></a>
</p><p>
Use of camera specific functions
<cite class="Ec">pxd_SV643_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV643_setExposureAndGainOffset</cite>,
<cite class="Ec">pxd_SV643_getExposure</cite>,
<cite class="Ec">pxd_SV643_getGain</cite>,
<cite class="Ec">pxd_SV643_getOffset</cite>,
<cite class="Ec">pxd_SV643_setResolutionAndTiming</cite>,
<cite class="Ec">pxd_SV643_getAoiTop</cite>,
<cite class="Ec">pxd_SV643_getAoiLeft</cite>,
<cite class="Ec">pxd_SV643_getPixelClock</cite>,
<cite class="Ec">pxd_SV643_setVideoAndTriggerMode</cite>,
<cite class="Ec">pxd_SV643_setCtrlExposureAndRate</cite>,
<cite class="Ec">pxd_SV643_getVideoMode</cite>,
<cite class="Ec">pxd_SV643_getCtrlVideoMode</cite>,
<cite class="Ec">pxd_SV643_getCtrlTriggerMode</cite>,
<cite class="Ec">pxd_SV643_getCtrlFrameRate</cite>,
<cite class="Ec">pxd_SV643_getCtrlExposure</cite>,
<cite class="Ec">pxd_SV643_getMinMaxExposure</cite>,
and
<cite class="Ec">pxd_SV643_getMinMaxCtrlExposure</cite>
is deprecated;
new applications should use
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>,
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>,
<a href="#pxd_SILICONVIDEO_setCtrlExposureAndRate" class="Er">pxd_SILICONVIDEO_setCtrlExposureAndRate</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxExposure" class="Er">pxd_SILICONVIDEO_getMinMaxExposure</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxCtrlExposure" class="Er">pxd_SILICONVIDEO_getMinMaxCtrlExposure</a>,
and related functions.
<a name="pxd_SV9M001_setExposureAndGain NX1273" class="NX"></a>
<a name="pxd_SV9M001_setExposureAndDigitalGain NX1274" class="NX"></a>
<a name="pxd_SV9M001_getExposure NX1275" class="NX"></a>
<a name="pxd_SV9M001_getGain NX1276" class="NX"></a>
<a name="pxd_SV9M001_getDigitalGain NX1277" class="NX"></a>
<a name="pxd_SV9M001_setResolutionAndTiming NX1278" class="NX"></a>
<a name="pxd_SV9M001_getAoiTop NX1279" class="NX"></a>
<a name="pxd_SV9M001_getAoiLeft NX1280" class="NX"></a>
<a name="pxd_SV9M001_getScanDirection NX1281" class="NX"></a>
<a name="pxd_SV9M001_getSubsample NX1282" class="NX"></a>
<a name="pxd_SV9M001_getPixelClock NX1283" class="NX"></a>
<a name="pxd_SV9M001_setVideoAndTriggerMode NX1284" class="NX"></a>
<a name="pxd_SV9M001_setCtrlRate NX1285" class="NX"></a>
<a name="pxd_SV9M001_getVideoMode NX1286" class="NX"></a>
<a name="pxd_SV9M001_getCtrlVideoMode NX1287" class="NX"></a>
<a name="pxd_SV9M001_getCtrlTriggerMode NX1288" class="NX"></a>
<a name="pxd_SV9M001_getCtrlFrameRate NX1289" class="NX"></a>
<a name="pxd_SV9M001_getMinMaxExposure NX1290" class="NX"></a>
</p><p>
Use of camera specific functions
<cite class="Ec">pxd_SV9M001_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV9M001_setExposureAndDigitalGain</cite>,
<cite class="Ec">pxd_SV9M001_getExposure</cite>,
<cite class="Ec">pxd_SV9M001_getGain</cite>,
<cite class="Ec">pxd_SV9M001_getDigitalGain</cite>,
<cite class="Ec">pxd_SV9M001_setResolutionAndTiming</cite>,
<cite class="Ec">pxd_SV9M001_getAoiTop</cite>,
<cite class="Ec">pxd_SV9M001_getAoiLeft</cite>,
<cite class="Ec">pxd_SV9M001_getScanDirection</cite>,
<cite class="Ec">pxd_SV9M001_getSubsample</cite>,
<cite class="Ec">pxd_SV9M001_getPixelClock</cite>,
<cite class="Ec">pxd_SV9M001_setVideoAndTriggerMode</cite>,
<cite class="Ec">pxd_SV9M001_setCtrlRate</cite>,
<cite class="Ec">pxd_SV9M001_getVideoMode</cite>,
<cite class="Ec">pxd_SV9M001_getCtrlVideoMode</cite>,
<cite class="Ec">pxd_SV9M001_getCtrlTriggerMode</cite>,
<cite class="Ec">pxd_SV9M001_getCtrlFrameRate</cite>,
and
<cite class="Ec">pxd_SV9M001_getMinMaxExposure</cite>
is deprecated;
new applications should use
<a href="#pxd_SILICONVIDEO_setExposureGainOffset" class="Er">pxd_SILICONVIDEO_setExposureGainOffset</a>,
<a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets" class="Er">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>,
<a href="#pxd_SILICONVIDEO_setResolutionAndTiming" class="Er">pxd_SILICONVIDEO_setResolutionAndTiming</a>
<a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode" class="Er">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>,
<a href="#pxd_SILICONVIDEO_setCtrlExposureAndRate" class="Er">pxd_SILICONVIDEO_setCtrlExposureAndRate</a>,
<a href="#pxd_SILICONVIDEO_getMinMaxExposure" class="Er">pxd_SILICONVIDEO_getMinMaxExposure</a>.
and related functions.
</p><hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Application Notes" class="Ch"></a>
<a name="14.  Application Notes"></a>
</p><h1>14.  Application Notes</h1>
<p>&nbsp;
<a name="Conversion of Application Programs from XCOBJ" class="Ch"></a>
<a name="14.1.  Conversion of Application Programs from XCOBJ"></a>
</p><h2>14.1.  Conversion of Application Programs from XCOBJ</h2>
<p>
The following notes describe commonly used
functions in the XCOBJ Library,
and their SCF replacements in the XCLIB Library.
</p><p>
Several macros are provided to help automate the conversion.
These macros can be found in
<code class="Em">xclibsc.h</code>.
They must be explicitly enabled by using:
</p><blockquote>
<pre>    #define XCOBJ_TO_XCLIB_MACROS  1
</pre>
</blockquote>
before
<blockquote>
<pre>    #include "xcliball.h"
</pre>
</blockquote>
in the application program.
<p>
The
<cite class="Ec">pxd_xcopen</cite>
is replaced by
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
The first parameter of
<cite class="Ec">pxd_xcopen</cite>,
which could be either a reserved format name
or a path name,
is replaced by individual parameters for each of these usages.
</p><p>
The
<cite class="Ec">pxd_close</cite>
is replaced by
<a href="#pxd_PIXCIclose" class="Er">pxd_PIXCIclose</a>.
</p><p>
The
<cite class="Ec">pxd_id</cite>
and
<cite class="Ec">pxd_idstr</cite>
are replaced by
<a href="#pxd_infoDriverId" class="Er">pxd_infoDriverId</a>,
<a href="#pxd_infoLibraryId" class="Er">pxd_infoLibraryId</a>,
and
<a href="#pxd_infoIncludeId" class="Er">pxd_infoIncludeId</a>.
</p><p>
The
<cite class="Ec">pxd_xcmodel</cite>,
<cite class="Ec">pxd_xcmodelcamera</cite>,
<cite class="Ec">pxd_udim</cite>,
<cite class="Ec">pxd_imsize</cite>,
<cite class="Ec">pxd_xdim</cite>,
<cite class="Ec">pxd_ydim</cite>,
<cite class="Ec">pxd_ylace</cite>,
<cite class="Ec">pxd_cdim</cite>,
<cite class="Ec">pxd_bdim</cite>,
and
<cite class="Ec">pxd_imbufs</cite>,
are replaced by
<a href="#pxd_infoModel" class="Er">pxd_infoModel</a>,
<a href="#pxd_infoSubmodel" class="Er">pxd_infoSubmodel</a>,
<a href="#pxd_infoUnits" class="Er">pxd_infoUnits</a>,
<a href="#pxd_infoMemsize" class="Er">pxd_infoMemsize</a>
(note that the size in
<u class="U">bytes</u>
is returned) ,
<a href="#pxd_imageXdim" class="Er">pxd_imageXdim</a>,
<a href="#pxd_imageYdim" class="Er">pxd_imageYdim</a>
(note that
the number of pixels in a column including
<u class="U">all</u>
fields of the frame buffer is returned),
<a href="#pxd_imageIdim" class="Er">pxd_imageIdim</a>
(note that the
<u class="U">number</u>
of fields is returned),
<a href="#pxd_imageCdim" class="Er">pxd_imageCdim</a>,
<a href="#pxd_imageBdim" class="Er">pxd_imageBdim</a>
(note that the number of bits in a
<u class="U">single</u>
color component is returned),
and
<a href="#pxd_imageZdim" class="Er">pxd_imageZdim</a>.
</p><p>
The
<cite class="Ec">pxd_udim</cite>
is replaced by
<a href="#pxd_infoUnits" class="Er">pxd_infoUnits</a>.
The
<cite class="Ec">pxd_unit</cite>
and
<cite class="Ec">pxd_units</cite>,
which selected one or more units for
use by all following functions
until specified otherwise,
are replaced by a
<em class="Ep">unitmap</em>
parameter added to the actual functions
that provide the desired service.
For example, instead of using:
</p><blockquote>
<pre>    pxd_unit(0x2);      // select unit
    pxd_snap(...);      // operate with selection
</pre>
</blockquote>
the
<blockquote>
<pre>    pxd_doSnap(0x2, ...);
</pre>
</blockquote>
allows direct selection.
<p>
The
<cite class="Ec">pxd_iopen</cite>,
<cite class="Ec">pxd_iopencolor</cite>,
<cite class="Ec">pxd_ioc</cite>,
and
<cite class="Ec">pxd_ios</cite>,
are replaced by
<a href="#pxd_readuchar" class="Er">pxd_readuchar</a>,
<a href="#pxd_writeuchar" class="Er">pxd_writeuchar</a>,
<a href="#pxd_readushort" class="Er">pxd_readushort</a>,
and
<a href="#pxd_writeushort" class="Er">pxd_writeushort</a>.
An explicit
<cite class="Ec">pxd_iopen</cite>
or
<cite class="Ec">pxd_iopencolor</cite>
followed by a transfer request is not necessary;
each of
<a href="#pxd_readuchar" class="Er">pxd_readuchar</a>,
<a href="#pxd_writeuchar" class="Er">pxd_writeuchar</a>,
<a href="#pxd_readushort" class="Er">pxd_readushort</a>,
and
<a href="#pxd_writeushort" class="Er">pxd_writeushort</a>
transfers pixels without requiring a preceding open.
</p><p>
The
<cite class="Ec">pxd_pixread</cite>,
<cite class="Ec">pxd_pixwrite</cite>,
<cite class="Ec">pxd_pixreadRGB</cite>,
and
<cite class="Ec">pxd_pixwriteRGB</cite>
were always documented to be an inefficient convenience,
To dissuade programmers against reading or writing single pixels,
they have not been replaced.
Of course, the
<a href="#pxd_readuchar" class="Er">pxd_readuchar</a>,
<a href="#pxd_writeuchar" class="Er">pxd_writeuchar</a>,
<a href="#pxd_readushort" class="Er">pxd_readushort</a>,
and
<a href="#pxd_writeushort" class="Er">pxd_writeushort</a>
can still used upon single pixels.
</p><p>
The
<cite class="Ec">pxd_defimage</cite>
and
<cite class="Ec">pxd_defimagecolor</cite>
are replaced by
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>.
The
<cite class="Ec">pxd_defimage3</cite>
and
<cite class="Ec">pxd_defimage3color</cite>
are replaced by
<a href="#pxd_defineImage3" class="Er">pxd_defineImage3</a>.
The XCOBJ suggested against saving the
<cite class="Ec">pxd_defimage</cite>
result, such as:
</p><blockquote>
<pre>    struct pximage image;
<br>
    image = *pxd_defimage();
</pre>
</blockquote>
This practice is still prohibited.
<p>
The
<cite class="Ec">pxd_vidgenlock</cite>,
<cite class="Ec">pxd_vidparm</cite>,
<cite class="Ec">pxd_vidsize</cite>,
and
<cite class="Ec">pxd_vidfield</cite>
do not have direct replacements within the SCF style functions.
Instead, a Video Configuration Format, with suitable options set,
can be loaded by
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
</p><p>
The
<cite class="Ec">pxd_chkfault</cite>
and
<cite class="Ec">pxerrnomesg</cite>
are replaced by
<cite class="Ec">pxd_mesgFault</cite>
and
<cite class="Ec">pxd_mesgErrorCode</cite>.
The
<cite class="Ec">pxd_chkstack</cite>
is obsolete and not replaced.
</p><p>
The
<cite class="Ec">pxd_bmpsave</cite>,
<cite class="Ec">pxd_bmpload</cite>,
<cite class="Ec">pxd_tgasave</cite>,
<cite class="Ec">pxd_pcxsave</cite>,
<cite class="Ec">pxd_pcxload</cite>,
<cite class="Ec">pxd_tiffsave</cite>,
and
<cite class="Ec">pxd_tiffload</cite>
are replaced by
<a href="#pxd_saveBmp" class="Er">pxd_saveBmp</a>,
<a href="#pxd_loadBmp" class="Er">pxd_loadBmp</a>,
<a href="#pxd_saveTga" class="Er">pxd_saveTga</a>,
<a href="#pxd_savePcx" class="Er">pxd_savePcx</a>,
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>,
and
<a href="#pxd_loadTiff" class="Er">pxd_loadTiff</a>.
</p><p>
The
<cite class="Ec">pxd_StretchDIBits</cite>,
<cite class="Ec">pxd_DIBCreate</cite>,
and
<cite class="Ec">pxd_DIBFree</cite>
are replaced by
<a href="#pxd_renderStretchDIBits" class="Er">pxd_renderStretchDIBits</a>,
<a href="#pxd_renderDIBCreate" class="Er">pxd_renderDIBCreate</a>,
and
<a href="#pxd_renderDIBFree" class="Er">pxd_renderDIBFree</a>.
</p><p>
The
<cite class="Ec">pxd_DirectVideoInit</cite>
and
<cite class="Ec">pxd_DirectVideoDone</cite>
are replaced by
<a href="#pxd_renderDirectVideoInit" class="Er">pxd_renderDirectVideoInit</a>
and
<a href="#pxd_renderDirectVideoDone" class="Er">pxd_renderDirectVideoDone</a>.
The
<cite class="Ec">pxd_DirectVideo</cite>
are replaced by
<a href="#pxd_renderDirectVideoUnLive" class="Er">pxd_renderDirectVideoUnLive</a>
and
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>.
</p><p>
The
<cite class="Ec">pxd_extin</cite>,
<cite class="Ec">pxd_extinreset</cite>,
and
<cite class="Ec">pxd_extout</cite>
are replaced by
<a href="#pxd_getGPIn" class="Er">pxd_getGPIn</a>,
<a href="#pxd_setGPIn" class="Er">pxd_setGPIn</a>,
and
<a href="#pxd_setGPOut" class="Er">pxd_setGPOut</a>.
</p><p>
The
<cite class="Ec">pxd_vidmux</cite>,
<cite class="Ec">pxd_contrastbrightness</cite>,
and
<cite class="Ec">pxd_huesaturation</cite>
used with the PIXCI® SV2, SV3, and SV4
are replaced by
<a href="#pxd_setVidMux" class="Er">pxd_setVidMux</a>,
<a href="#pxd_setContrastBrightness" class="Er">pxd_setContrastBrightness</a>,
and
<a href="#pxd_setHueSaturation" class="Er">pxd_setHueSaturation</a>.
The new functions have effect immediately,
rather than waiting for the end of a frame, stopping video capture,
and restarting.
</p><p>
The
<cite class="Ec">pxd_setDalsa01</cite>,
<cite class="Ec">pxd_setKodak01</cite>,
<cite class="Ec">pxd_setHitachi01</cite>,
and
<cite class="Ec">pxd_setBasler01</cite>
used with the PIXCI® D, D24, D32, and A
are replaced by
<a href="#pxd_setExsyncPrin" class="Er">pxd_setExsyncPrin</a>.
The new function has effect immediately,
rather than waiting for the end of a frame, stopping video capture,
and restarting.
The new function provides for changing the
''exsync''
and
''prin''
values, typically integration time or line period,
but does not provide for changing camera modes;
instead, a Video Configuration Format, with suitable options set,
can be loaded by
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
Although the
<cite class="Ec">pxd_setDalsa01</cite>,
<cite class="Ec">pxd_setKodak01</cite>,
<cite class="Ec">pxd_setHitachi01</cite>,
and
<cite class="Ec">pxd_setBasler01</cite>
allowed setting bits corresponding to camera modes,
they were often misunderstood and misused; as corresponding parameters
in the video format also must be changed.
</p><p>
The
<cite class="Ec">pxd_snap</cite>
is replaced by
<cite class="Ec">pxd_doSnap</cite>.
The
<cite class="Ec">pxd_vidtime</cite>
is replaced by
<a href="#pxd_videoFieldCount" class="Er">pxd_videoFieldCount</a>.
</p><p>
The
<cite class="Ec">pxvid_snapbufa</cite>
and
<cite class="Ec">pxvid_gobufa</cite>
are replaced by
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
<a href="#pxd_goLive" class="Er">pxd_goLive</a>,
and
<a href="#pxd_goUnLive" class="Er">pxd_goUnLive</a>.
The
<cite class="Ec">pxvid_snapbufw</cite>
and
<cite class="Ec">pxvid_gobufw</cite>
are replaced by using
<a href="#pxd_capturedBuffer" class="Er">pxd_capturedBuffer</a>,
<a href="#pxd_capturedSysTicks" class="Er">pxd_capturedSysTicks</a>,
and/or
<a href="#pxd_capturedFieldCount" class="Er">pxd_capturedFieldCount</a>.
However, the
<cite class="Ec">pxvid_snapbufw</cite>
and
<cite class="Ec">pxvid_gobufw</cite>
functions were intended to be used
to wait until, or test whether, the previous
<cite class="Ec">pxvid_snapbufa</cite>
and
<cite class="Ec">pxvid_gobufa</cite>
had effect, with the intention that the application could then
''orchestrate''
''ping-pong''
or sequence capture.
In contrast
<a href="#pxd_capturedBuffer" class="Er">pxd_capturedBuffer</a>,
<a href="#pxd_capturedSysTicks" class="Er">pxd_capturedSysTicks</a>,
and/or
<a href="#pxd_capturedFieldCount" class="Er">pxd_capturedFieldCount</a>
reports whether and when a new field or frame has been captured;
with the intention to track the progress of
<a href="#pxd_goLivePair" class="Er">pxd_goLivePair</a>
or
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>
which initiate a
''ping-pong''
capture, or a sequence capture, respectively,
and proceeds without further
''orchestratation''
by the application.
</p><p>
The
<cite class="Ec">pxd_video</cite>
is replaced by
<a href="#pxd_goLive" class="Er">pxd_goLive</a>
and
<a href="#pxd_goUnLive" class="Er">pxd_goUnLive</a>;
although the latter functions always return immediately.
</p><p>&nbsp;
<a name="Using a Serial (RS-232) Configurable Camera with the PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, or SI4" class="Ch"></a>
<a name="14.2.  Using a Serial (RS-232) Configurable Camera with the PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, or SI4"></a>
</p><h2>14.2. Using a Serial (RS-232) Configurable Camera with the
PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1,
EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, or
SI4</h2>
<p>
When used with a PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1,
E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB,
ELS2, SI, SI1, SI2, or SI4 imaging board,
the XCLIB identifies the camera for which the specific model of the
PIXCI® imaging board is intended and
sets a default Video Format Configuration compatible with
that camera's default operating mode.
Typically, the camera's default operating mode is
for continuous, periodic (i.e free-running) video at maximum
resolution.
The XCLIB
does not re-configure the camera through the computer's serial RS-232
port
or through the Camera Link serial port of the PIXCI® CL1, CL2, CL3SD,
E1, E1DB, E4, E4DB, EB1, EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, or
EL1DB.<a href="#Footnote%2043" class="Ff"><sup>[43]</sup></a>
</p><p>
The SILICON VIDEO® cameras used in conjunction with a PIXCI® D2X, ELS2, SI, SI1, SI2, or SI4
imaging board use serial I<sup><small>2</small></sup>C or SPI for camera configuration instead of RS-232
or Camera Link serial, but are handled similarly by software configuration.
The SILICON VIDEO® 1281M, 1281C, 1310, 1310C, 2112, 2112C,
5C10, 5M10,
642M, 642C, 643M, 643C,
9C10,
9M001, 9M001C,
and 9T001C and are all initialized by XCLIB to the manufacturer's suggested default mode.
<br>
<a name="Initialization of RS-232 or Camera Link Serial Configured Cameras" class="Ch"></a>
<a name="14.2.1.  Initialization of RS-232 or Camera Link Serial Configured Cameras"></a>
</p><h3>14.2.1.  Initialization of RS-232 or Camera Link Serial Configured Cameras</h3>
<p>
To use the camera and PIXCI® imaging board in other modes &#8212;
such as triggered capture with asynchronous reset,
binning, or integration &#8212;
requires that both the camera and the PIXCI® imaging board
be reconfigured.
The camera's operating mode must be reconfigured
through the serial (RS-232 or Camera Link) port;
the PIXCI® imaging board must be reconfigured through
the XCLIB library.
</p><p>
For some cameras whose features are controlled by Camera Link serial commands,
XCAP's
<cite class="Ec">Capture - Adjustments</cite>
provides only basic, generic controls for configuring the PIXCI®
imaging board as per the camera's configuration, and does not automatically send
serial commands to the camera.
For these cameras, the programmer must follow
<a href="#Using%20a%20Video%20Format%20Configuration%20Exported%20by%20XCAP" class="Er">Using a Video Format Configuration Exported by XCAP</a>
to configure the PIXCI® imaging board, and must manually format and send
serial commands through the RS-232 or Camera Link serial port
as per the camera manufacturer's documentation.
</p><p>
For selected cameras whose features are controlled by RS-232,
Camera Link serial,
I<sup><small>2</small></sup>C serial,
or SPI serial
commands,
XCAP's
<cite class="Ec">Capture - Adjustments</cite>
provides convenient, integrated controls for the camera's programmable features;
automatically generating and sending appropriate serial commands as the GUI controls
are adjusted.
The remainder of this application note discusses how to utilize XCAP's
built-in integrated controls to simplify the reconfiguration of the camera under XCLIB.
</p><p>
The XCAP application is used only during program development;
it is
<u class="U">not</u>
needed when the program being developed is run.
</p><p>
First, launch a compatible version of XCAP<a href="#Footnote%2044" class="Ff"><sup>[44]</sup></a>
and use its GUI to configure the camera's operating mode
and the PIXCI® imaging board to the desired configuration.
After verifying the proper configuration (such as correct
triggering with externally provided signals, or sufficient
light sensitivity relative to binning and integration options):
</p><ol type="1">
<p>
</p><li>
Export the PIXCI® imaging board Video Format
Configuration parameters to a file with:
<blockquote>
<pre>    PIXCI®
    PIXCI® Export Video Setup
</pre>
</blockquote>
<p>
</p></li><li>
Export the camera's current operating mode's serial
(RS-232 or Camera Link) commands to a file using the:
<blockquote>
<pre>    Export Commands
</pre>
</blockquote>
button in the camera's
''Capture &amp; Adjust''
dialog box.
Each camera's
''Capture &amp; Adjust''
dialog differs, but typically:
a)&nbsp;The dialog has a left half devoted to the
PIXCI® imaging board and a right half devoted to the
camera's serial (RS-232 or Camera Link) controlled parameters,
b)&nbsp;The
''Export Commands''
button is typically found under the
''Opt''
or
''Port''
tab of the right half of the dialog.
</li></ol>
XCAP can now be closed.
<p>
Second, in the application program being developed,
open the XCLIB library, specifying the previously
saved Video Format Configuration file as the third parameter of
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
This configures the PIXCI® imaging board appropriately.
</p><p>
Third, in the application program being developed, send
the contents of the exported serial (RS-232) command file
through the appropriate serial (RS-232) port.
This configures the camera's operating mode appropriately and consistently
with the PIXCI® imaging board configuration.
An example method follows for cameras connected via an RS-232 port under Windows:<a href="#Footnote%2045" class="Ff"><sup>[45]</sup></a>:
</p><blockquote>
<pre>    #include &lt;windows.h&gt;
    #include &lt;stdio.h&gt;
<br>
    FILE    *fp;
    HANDLE  fd;
    DCB     dcb;
    char    *name = "COM1"; // or "COM2", "COM3", etc.
    int     i, n, l;
    //
    // Open access to COM port.
    //
    fd = CreateFile(name, GENERIC_READ|GENERIC_WRITE, OF_SHARE_COMPAT,
                    0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (fd == INVALID_HANDLE_VALUE)
        exit(1);    // can't open COM port - produce suitable error message
    memset(&amp;dcb, 0, sizeof(dcb));
    if (!GetCommState(fd, &amp;dcb)) {
        CloseHandle(fd);
        exit(1);    // can't get COM port state - produce suitable error message
    }
    dcb.fBinary         = TRUE;
    dcb.fDtrControl     = DTR_CONTROL_ENABLE;
    dcb.fDsrSensitivity = FALSE;
    dcb.fNull           = FALSE;
    dcb.fRtsControl     = RTS_CONTROL_ENABLE;
    dcb.BaudRate        = 9600;     // replace with camera's baud rate
    dcb.ByteSize        = 8;        // assume camera with 8 bits per word
    dcb.Parity          = 0;        // assume no parity used
    dcb.StopBits        = 2;        // camera may spec fewer stop bits, more doesn't hurt!
    dcb.fOutX = dcb.fInX = 0;       // assume camera w/out RS-232 flow control
    dcb.fOutxCtsFlow = dcb.fOutxDsrFlow = FALSE;
    SetCommState(fd, &amp;dcb);
    SetupComm(fd, 4096, 4096);
    //
    // Open exported file with camera's RS-232 data stream.
    //
    fp = fopen("camera.dat", "rb");
    if (!fp) {
        CloseHandle(fd);
        exit(1);    // can't find file - produce suitable error message
    }
    //
    // Send each command from file through COM port.
    // For most cameras, we should wait until the camera
    // has finished processing one command before sending
    // the next. A sophisticated method would be to wait for
    // the camera's response to each command - and even
    // to check whether the response indicates an error.
    // For simplicity, and because this code is used only
    // during initialization - so overall elapsed time should
    // not be critical - we simply pause after each command.
    //
    for (n = 0; (i = fgetc(fp)) != EOF; ) {
        DWORD   w = 0;
        uchar   buf[1];
<br>
        //
        // Send byte of command.
        //
        buf[0] = i;
        WriteFile(fd, buf, 1, &amp;w, NULL);
<br>
        //
        // Is the last byte sent the end of a command?
        // The test is camera specific!
        //
        #if 1                       // for DVC, older Basler, Hamamatsu, Uniq
            if (i == '\r')         // Dalsa
                Sleep(1000);
        #elif 0
            if (i == '\n')         // Imperx Lynx
                Sleep(1000);
        #elif 0                     // for Pulnix
            if (i == '\x03')
                Sleep(1000);
        #elif 0                     // for newer Basler, which ends w. 0x03
            if (n++ == 2)           // but may also have embedded 0x03,
                l = (i&amp;0x7F)+5;     // utilize the command's length count
            if (n &gt; 2 &amp;&amp; n == l) {  // to determine the end of each command
                Sleep(1000);
                n = 0;
            }
        #elif 0                     // for Hitachi using fixed length size commands
            if ((++n % 18) == 0)
                Sleep(1000);
        #elif 0                     // for Kodak/Roper MASD
            if (i == '\n')         // Some ES 4.0 commands may
                Sleep(1000);        // require delay of several seconds!
        #endif
    }
    //
    // All done. Clean up.
    //
    fclose(fp);
    CloseHandle(fd);
</pre>
</blockquote>
<p>
Alternately, for cameras connected via Camera Link, send
the contents of the exported serial (RS-232) command file
through the PIXCI® CL1, CL2, CL3SD, E1, E1DB, E4, E4DB, EB1, EB1-PoCL,
EC1, ECB1, ECB1-34, ECB2, EL1, or EL1DB Camera Link serial port:
</p><blockquote>
<pre>    FILE    *fp;
    int     i, n, l;
    //
    // Configure serial port for the Camera Link standard
    // of 9600 baud, 8 bits, 1 stop bit, no parity.
    // More recent versions of the Camera Link spec
    // allow for alternate baud rates; set the rate to match the camera!
    pxd_serialConfigure(0x01, 0, 9600, 8, 0, 1, 0, 0, 0);
    //
    // Open exported file with camera's RS-232 data stream.
    //
    fp = fopen("camera.dat", "rb");
    if (!fp)
        exit(1);    // can't find file - produce suitable error message
    //
    // Send each command from file through serial port.
    //
    for (n = 0; (i = fgetc(fp)) != EOF; ) {
        char buf[1];
        buf[0] = i;
        pxd_serialWrite(0x01, 0, buf, 1);
<br>
        //
        // Is the last byte sent the end of a command?
        // The test is camera specific!
        //
        #if 1                       // for DVC, older Basler, Hamamatsu, Uniq
            if (i == '\r')         // Dalsa
                Sleep(1000);
        #elif 0
            if (i == '\n')         // Imperx Lynx
                Sleep(1000);
        #elif 0                     // for Pulnix
            if (i == '\x03')
                Sleep(1000);
        #elif 0                     // for newer Basler, which ends w. 0x03
            if (n++ == 2)           // but may also have embedded 0x03,
                l = (i&amp;0x7F)+5;     // utilize the command's length count
            if (n &gt; 2 &amp;&amp; n == l) {  // to determine the end of each command
                Sleep(1000);
                n = 0;
            }
        #elif 0                     // for Hitachi using fixed length size commands
            if ((++n % 18) == 0)
                Sleep(1000);
        #endif
    }
    //
    // All done. Clean up.
    //
    fclose(fp);
</pre>
</blockquote>
<br>
<a name="Initialization of Camera Link Serial, I&lt;SUP&gt;&lt;SMALL&gt;2&lt;/SMALL&gt;&lt;/SUP&gt;C, or SPI Configured Cameras" class="Ch"></a>
<a name="14.2.2.  Initialization of Camera Link Serial, I&lt;SUP&gt;&lt;SMALL&gt;2&lt;/SMALL&gt;&lt;/SUP&gt;C, or SPI Configured Cameras"></a>
<h3>14.2.2.  Initialization of Camera Link Serial, I<sup><small>2</small></sup>C, or SPI Configured Cameras</h3>
<p>
For selected Camera Link cameras and for all SILICON VIDEO® cameras,
the Video Format Configuration files saved by
XCAP include the serial commands needed to restore
the camera's operating mode.
XCLIB automatically loads the serial commands contained
in the Video Format Configuration file.
</p><p>
First, launch a compatible version of XCAP<a href="#Footnote%2046" class="Ff"><sup>[46]</sup></a>
and use its GUI to configure the camera's operating mode
and the PIXCI® imaging board to the desired configuration.
After verifying the proper configuration (such as correct
triggering with externally provided signals, or sufficient
light sensitivity relative to binning and integration options):
Export the PIXCI® imaging board Video Format
Configuration parameters to a file with:
</p><blockquote>
<pre>    PIXCI®
    PIXCI® Export Video Setup
</pre>
</blockquote>
XCAP can now be closed.
<p>
Second, in the application program being developed,
open the XCLIB library, specifying the previously
saved Video Format Configuration file as the third parameter of
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>.
This configures the PIXCI® imaging board appropriately.
</p><p>
This improved support is currently provided for selected
Adimec,
Atmel,
CIS,
Basler,
CIS,
Cohu,
Dalsa,
DVC,
EG&amp;G Reticon,
E2v,
Hitachi,
Illunis,
Imperx,
Jai,
PerkinElmer,
Princeton Instruments,
Pulnix,
Rice Camera Technologies,
Redlake,
Salvador Imaging,
Sentech,
Sensors Unlimited,
Silicon Imaging,
Sony,
SVS Vistek,
Teli,
Vieworks,
and Uniq
Camera Link cameras, and may be added (or have been added)
for other Camera Link cameras post-publication
of this application note.<a href="#Footnote%2047" class="Ff"><sup>[47]</sup></a>
</p><p>
This improved support is not provided for
Camera Link cameras whose manufacturer only provides a library and API
but does not document the underlying serial commands.
</p><p>
To determine whether this integrated support is available for
a specific Camera Link camera, in XCAP:
</p><blockquote>
<pre>    PIXCI® (in Main Window)
    PIXCI® Open/Close
    Close (if open)
    Camera &amp; Format
    Open w. Default Video Setup
    OK
    Open
    PIXCI® (in Main Window)
    PIXCI® Export Video Setup
</pre>
</blockquote>
If the
<blockquote>
<pre>    Include Camera Link Serial Commands
</pre>
</blockquote>
checkbox is active (i.e. selectable), then this integrated support
for XCLIB loading of serial commands
is available for the current camera.
<p>
For SILICON VIDEO® cameras, the
</p><blockquote>
<pre>    Include I<sup><small>2</small></sup>C Commands
</pre>
</blockquote>
or
<blockquote>
<pre>    Include SPI Commands
</pre>
</blockquote>
will be active, indicating integrated support
for XCLIB loading of I<sup><small>2</small></sup>C serial, or SPI serial, commands.
<br>
<a name="Adjustments to RS-232 or Camera Link Serial Configured Cameras" class="Ch"></a>
<a name="14.2.3.  Adjustments to RS-232 or Camera Link Serial Configured Cameras"></a>
<h3>14.2.3.  Adjustments to RS-232 or Camera Link Serial Configured Cameras</h3>
<p>
In addition to the
initialization described above,
the application program may wish to adjust the camera -
such as the gain, exposure, black level -
via serial commands during program execution.
These types of adjustments do not affect the PIXCI® imaging board configuration.
In contrast, adjusting the camera's trigger mode, binning, bit-depth,
or area of interest features do reflect upon the PIXCI® imaging board's
configuration, and a new set of Video Format Configuration
parameters should be saved via
<cite class="Ec">XCAP</cite>.
</p><p>
Adjusting the camera's gain, exposure, black level, and similar parameters
could be done by using
<cite class="Ec">XCAP</cite>'s
''Export Commands''
feature for each unique combination of gain, exposure, etc.,
if the application only needs a relatively small number of
adjustment combinations.
</p><p>
Alternately, adjusting the camera's gain, exposure,
black level, and similar parameters
requires familiarity with the camera's unique serial commands,
as described in the camera's manufacturer's documentation.
<cite class="Ec">XCAP</cite>
can assist in learning about a specific camera's serial commands.
By activating the RS-232 Log (or Serial Log), typically found under the
''Port''
tab, XCAP will log and display each serial command sent as a result of
the modifying the camera's GUI controls.
The programmer can read these as examples of the necessary commands to be
sent via the computer's COM port for RS-232,
or via
<cite class="Ec">pxd_serialWrite</cite>
for Camera Link.
<br>
<a name="Adjustments to I&lt;SUP&gt;&lt;SMALL&gt;2&lt;/SMALL&gt;&lt;/SUP&gt;C or SPI Configured Cameras" class="Ch"></a>
<a name="14.2.4.  Adjustments to I&lt;SUP&gt;&lt;SMALL&gt;2&lt;/SMALL&gt;&lt;/SUP&gt;C or SPI Configured Cameras"></a>
</p><h3>14.2.4.  Adjustments to I<sup><small>2</small></sup>C or SPI Configured Cameras</h3>
<p>
The XCLIB includes SILICON VIDEO® camera specific functions for
adjustment of gain, black level, exposure, etc.;
the programmer need not be concerned with I<sup><small>2</small></sup>C or SPI commands.
Some of the more obscure settings can only be accessed via
Structured Style Interface; users of the SCF Style Interface
can utilize use of a Video Format Configuration file exported from XCAP,
as described above.
</p><p>&nbsp;
<a name="Using a Video Format Configuration Exported by XCAP" class="Ch"></a>
<a name="14.3.  Using a Video Format Configuration Exported by XCAP"></a>
</p><h2>14.3.  Using a Video Format Configuration Exported by XCAP</h2>
<p>
<a name="Video Format Configuration NX1291" class="NX"></a>
The Video Format Configuration
is a collection of dozens of parameters
that defines the video format
(i.e. whether NTSC, RS-170, PAL, or CCIR
for applicable imaging boards,
or camera manufacturer and model for other
imaging boards),
the resolution (i.e. capturing more or fewer pixels
per line or column),
and other settings related to the imaging board's hardware.
</p><p>
The XCLIB provides a suitable default Video Format Configuration
for each PIXCI(rg imaging board, model, and submodel.
</p><p>
The easiest and suggested method of creating an
alternate Video Format Configuration is to use
<cite class="Ec">XCAP</cite>.
XCAP uses an identical and compatible<a href="#Footnote%2048" class="Ff"><sup>[48]</sup></a>
Video Format Configuration,
although XCAP uses the term
''Video Setup''.
In XCAP, use:
</p><blockquote>
<pre>    PIXCI®
    PIXCI® Video Setup
    .. adjust video configuration followed by OK ..
    PIXCI®
    PIXCI® Export Video Setup
</pre>
</blockquote>
After running XCAP, simply specify the
path name of the saved video setup file
as the third parameter to
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
(with the second parameter set to NULL)
or as the fifth parameter to
<a href="#xclib_open" class="Er">xclib_open</a>
(with the fourth parameter set to NULL)
to configure XCLIB to the same Video Format Configuration.
<p>
However, for application programs which are to be distributed,
the saved video setup file must be distributed as well.
This can be advantageous - substituting a different video setup file
may allow the application to work with other cameras
or in other camera modes without recompilation - or
disadvantageous when the video setup file is lost or accidentally modified.
</p><p>
Alternatively, the Video Format Configuration
can be integrated into the application,
preventing loss of, or accidental changes to, a file required at run time,
as well as providing slightly quicker switching between different
Video Format Configurations.
The saved video setup file is readable text with the
syntax of several
''C''
structure initializers;
it can be directly compiled by simply including it
within the application's C/C++
program.
</p><p>
If using the SCF Style Interface, the
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>
macro can be used as:
</p><blockquote>
<pre>    {
        #include "format.fmt"           // a saved video setup file
        pxd_videoFormatAsIncluded(0); // configure as per the above
    }
</pre>
</blockquote>
to configure XCLIB as per the included video setup file.
Of course, the contents of the
''format.fmt''
file could instead be copied and pasted into the application
instead of being included; both methods result
in the Video Format Configuration
being integrated into the application.<a href="#Footnote%2049" class="Ff"><sup>[49]</sup></a>
<p>
The
Video Format Configuration files
are portable among the various 32 bit operating systems,
and among the various 64 bit operating systems.
The
Video Format Configuration files
are not portable between 32 and 64 bit operating systems.
</p><p>&nbsp;
<a name="Capture Directly into Memory Space of Other Devices" class="Ch"></a>
<a name="14.4.  Capture Directly into Memory Space of Other Devices"></a>
</p><h2>14.4.  Capture Directly into Memory Space of Other Devices</h2>
<p>The architecture of the
PIXCI® A, CL1, CL2, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1,
EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI4,
SV2, SV3, SV4, SV5, SV5A, SV5B, SV5L, and SV7 imaging boards
allows capturing image data by use of PCI Bus Mastering.
Typically, image data is transferred into the reserved
image frame buffer memory &#8212; a pre-allocated pool of host memory.
However, the image data can instead be transferred to
any block of consecutive addresses in PCI address space.
</p><p>
The
<em class="Ep">pxvidphys</em>
structure completely specifies the capture target address space
(see
<code class="Em">pxlibvs.h</code>).
</p><p>
When capturing into image frame buffer memory, the XCLIB
provides a simplified means of specifying the capture target address space &#8212;
the image frame buffer number.
Based on the memory size required for each image buffer
and on the total size of image frame buffer memory,
XCLIB partitions the image frame buffer memory
into one or more image frame buffers.
A function such as
<a href="#::setSnapBuf" class="Er">::setSnapBuf</a>
specifies the capture target as a single, simple, image frame buffer number;
XCLIB then translates the specified frame buffer number to a memory specification
and fills in the
<em class="Ep">pxvidphys</em>
appropriately.
</p><p>
By explicitly filling the
<em class="Ep">pxvidphys</em>
rather than using an image frame buffer number,
and by using the
<a href="#::setLivePhys" class="Er">::setLivePhys</a>
instead of the
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>
service,
images can be captured to targets in PCI address space
other than the image frame buffer memory.
</p><p>
If
<em class="Ep">pxvidphys</em>.<em class="Ep">upatita</em>=0
the addresses are interpreted as being relative to frame buffer memory.
Alternately, addresses may also be interpreted as being in user space, or
as being bus physical; the
<em class="Ep">pxvidphys</em>.<em class="Ep">upatita</em>
for these interpretations
<u class="U">must</u>
be set by using
<a href="#::signStateCopy" class="Er">::signStateCopy</a>
to
''sign''
the
<em class="Ep">pxvidphys</em>
instance after all other fields have been set.<a href="#Footnote%2050" class="Ff"><sup>[50]</sup></a>
</p><p>
When using an image frame buffer number, the
<em class="Ep">pxvidphys</em>.<em class="Ep">buffer</em>,
<em class="Ep">pxvidphys</em>.<em class="Ep">stateid</em>,
and
<em class="Ep">pxvidphys</em>.<em class="Ep">tracker</em>,
are automatically set to the buffer number, the video state id,
and an arbitrary tracker number provided by
<a href="#::setLiveBuf" class="Er">::setLiveBuf</a>.
When using
<a href="#::setLivePhys" class="Er">::setLivePhys</a>
these are arbitrary values; the values provided
are later reported by
<a href="#::getLiveStatus" class="Er">::getLiveStatus</a>.
</p><p>
The use and constraints of the
<em class="Ep">pxvidphys</em>.<em class="Ep">startadrs</em>,
<em class="Ep">pxvidphys</em>.<em class="Ep">endadrs</em>,
<em class="Ep">pxvidphys</em>.<em class="Ep">linelength</em>,
<em class="Ep">pxvidphys</em>.<em class="Ep">linestride</em>,
are dependent on the specific imaging board;
see examples below.
</p><p>
If multiple image boards are in use, the
</p><blockquote>
<pre>    xcdev.setLiveBuf(0x03, ..., 1);
</pre>
</blockquote>
which commands imaging boards one and two to both begin
capturing into frame buffer number 1,
does not cause conflict or overwriting of image data;
each board is assigned its own, unique, buffer number 1.
When using
<a href="#::setLivePhys" class="Er">::setLivePhys</a>,
each selected imaging board is provided with its own
<em class="Ep">pxvidphys</em>.
Thus,
<a href="#::setLivePhys" class="Er">::setLivePhys</a>
allows for an array of
<em class="Ep">pxvidphys</em>
specifications, one per selected imaging board.
<br>
<a name="PIXCI® SV4, SV5, SV5A, SV5B, SV5L, SV7 and DirectDraw" class="Ch"></a>
<a name="14.4.1.  PIXCI® SV4, SV5, SV5A, SV5B, SV5L, SV7 and DirectDraw"></a>
<h3>14.4.1.  PIXCI® SV4, SV5, SV5A, SV5B, SV5L, SV7 and DirectDraw</h3>
<p>
The following example is an extract of
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>,
and assumes familiarity with DirectDraw.
For the sake of brevity, the example assumes that
the PXMODE_DIGI video state has already been defined
with a pixel format compatible to the graphics display (S/VGA) secondary surface<a href="#Footnote%2051" class="Ff"><sup>[51]</sup></a>
(such as UYVY rather than RGB),
that the capture resolution has been set
to match the display window's size,
and that the capture bit depth has been set to 8 bits per color component
</p><blockquote>
<pre>    DDSURFACEDESC       surface2;   // a DirectDraw struct
    pxvidphys_s         vidphys;
    xclib_DeclareVidStateStructs(vidstate);
    //
    // Create different state, copy of PXMODE_DIGI
    //
    xclib_InitVidStateStructs(vidstate);
    xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
    //
    // Setup to send video to overlay plane.
    // We assume the 'surface2' has already been specified and
    // acquired from DirectDraw.
    //
    memset(&amp;vidphys, 0, siz(vidphys));
    vidphys.ddch.mos     = PXMOS_VIDPHYS;
    vidphys.ddch.len     = siz(pxvidphys_s);
    vidphys.bufxdim      = vidstate.vidres-&gt;x.datsamples;
    vidphys.bufydim      = vidstate.vidres-&gt;y.datsamples;
    vidphys.bufidim      = vidstate.vidres-&gt;datfields;
    vidphys.bufadrs      = (uint32)surface2.lpSurface;
    vidphys.startadrs[0][0]  = (uint32)surface2.lpSurface;
    vidphys.startadrs[1][0]  = (uint32)surface2.lpSurface;
    vidphys.linelength[0][0] = vidstate.vidres-&gt;x.datsamples*2;   // assumes YUV!
    vidphys.linelength[1][0] = vidstate.vidres-&gt;x.datsamples*2;   // assumes YUV!
    vidphys.linestride[0][0] = surface2.lPitch-vidphys.linelength[0][0];
    vidphys.linestride[1][0] = surface2.lPitch-vidphys.linelength[1][0];
    if (vidstate.vidres-&gt;datfields == 2) {
        vidphys.startadrs[0][0]  += surface2.lPitch;
        vidphys.linestride[0][0] += surface2.lPitch;
        vidphys.linestride[1][0] += surface2.lPitch;
    }
    vidphys.buffer    = 0;  // optional, so capture of this is never confused with a real buffer
    //
    // Sign the vidphys. Addresses provided by
    // DirectDraw are in user space, not physical!
    //
    vidstate.vidphys = &amp;vidphys;
    if (xclib.xclib.signStateCopy(&amp;xclib.xclib, 0, 0, &amp;vidstate, 'u', 's') &lt; 0)
        return; // error!
    //
    // If the new state changed the resolution or the pixel format, we must ..
    //
    if (xclib.xcdev.setVideoConfig(&amp;xclib.xcdev, unitmap, 0, 0, &amp;vidstate, NULL))
        return; // error!
    //
    // Start live video
    //
    if (xclib.xcdev.setLivePhys(&amp;xclib.xcdev, unitmap, 0, 0, &amp;vidstate, NULL, &amp;vidphys))
        return; // error!
</pre>
</blockquote>
This example is not intended to show
how to specify and acquire a DirectDraw surface,
how to overlay the DirectDraw
secondary surface onto the primary surface, and how to
optionally activate chroma keying; these topics are described in
the DirectDraw documentation.
<br>
<a name="PIXCI® and StreamStor" class="Ch"></a>
<a name="14.4.2.  PIXCI® and StreamStor"></a>
<h3>14.4.2.  PIXCI® and StreamStor</h3>
<p>
The following example is an extract of the XCAP
''Video to StreamStor''
feature; it assumes familiarity
with the StreamStor XLR API.
</p><blockquote>
<pre>    HANDLE      hXLR;
    xclib_DeclareVidStateStructs(vidstate);
    //
    // Get video state in use.
    //
    xclib_InitVidStateStructs(vidstate);
    xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
    //
    // Build the pxvidphys.
    //
    memset(&amp;vidphys, 0, siz(vidphys));
    vidphys.ddch.mos = PXMOS_VIDPHYS;
    vidphys.ddch.len = siz(pxvidphys_s);
    vidphys.startadrs[0][0] = XLRGetBaseAddr(hXLR);
    vidphys.startadrs[1][0] = XLRGetBaseAddr(hXLR);
    //
    // Sign the vidphys. Addresses provided
    // by XLR are physical, not user space!
    //
    vidstate.vidphys = &amp;vidphys;
    if (xclib.xclib.signStateCopy(&amp;xclib.xclib, 0, 0, &amp;vidstate, 'p', 's') &lt; 0)
        return; // error!
    //
    // Start XLR recording then start live video
    //
    XLRRecord(hXLR, FALSE, 1);
    if (xclib.xcdev.setLivePhys(&amp;xclib.xcdev, unitmap, 0, 0, &amp;vidstate, NULL, &amp;vidphys))
        return; // error!
</pre>
</blockquote>
<p>&nbsp;
<a name="Adjusting White Balance of a Bayer Output Camera with the PIXCI® Imaging Board" class="Ch"></a>
<a name="14.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI® Imaging Board"></a>
</p><h2>14.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI® Imaging Board</h2>
<p>When a Bayer output camera is used with a
PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EC1,
ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, or SI4 imaging
board,
the XCLIB performs Bayer to RGB conversion and white balancing in
software.
As for all color cameras, white balancing is subject to the
current illuminate's color spectrum, and should be adjusted
for different illumination.
A simple method of white balancing follows.
</p><p>
</p><ol type="1">
<p>
</p><li>
Capture an image of a white or grey target:
<blockquote>
<pre>    pxd_doSnap(1, 1, 0);
</pre>
</blockquote>
<p>
</p></li><li>
Obtain
<u class="U">true</u>
average red, green, and blue values of the
<u class="U">captured</u>
grey target image.
Thus, we turn off software white balancing before obtaining
average values:
<blockquote>
<pre>    unsigned int reference[3] = {0,0,0};
    unsigned int target[3]    = {0,0,0};
    pxd_setImageBrightBalance(1, reference, target, 0.00);
</pre>
</blockquote>
<p>
</p></li><li>
Obtain average pixel values.
This is slightly simpler if the
<cite class="Ec">PXIPL Image Processing Library</cite>
is available:
<blockquote>
<pre>    double  masses[] = {0, 0, 0};
    double  xcenter, ycenter;
<br>
    pxip8_masscenter(NULL,pxd_defineImage(1, 1, 0, 0, -1, -1, "RofRGB"), &amp;masses[0], &amp;xcenter, &amp;ycenter);
    pxip8_masscenter(NULL,pxd_defineImage(1, 1, 0, 0, -1, -1, "GofRGB"), &amp;masses[1], &amp;xcenter, &amp;ycenter);
    pxip8_masscenter(NULL,pxd_defineImage(1, 1, 0, 0, -1, -1, "BofRGB"), &amp;masses[2], &amp;xcenter, &amp;ycenter);
    reference[0] = masses[0]/(double)pxd_imageXdim()*pxd_imageYdim();
    reference[1] = masses[1]/(double)pxd_imageXdim()*pxd_imageYdim();
    reference[2] = masses[2]/(double)pxd_imageXdim()*pxd_imageYdim();
</pre>
</blockquote>
Or can be done by directly reading pixel values:
<blockquote>
<pre>    double  masses[] = {0, 0, 0};
    ushort  pixels[9*9];
    int     midx, midy, i;
<br>
    midx = pxd_imageXdim()/2;
    midy = pxd_imageYdim()/2;
    pxd_readushort(1,1,midx-9/2,midy-9/2,midx+1+9/2,midy+1+9/2,pixels,9*9,"RofRGB");
    for (i = 0; i &lt; 9*9; i++)
        masses[0] += pixels[i];
    pxd_readushort(1,1,midx-9/2,midy-9/2,midx+1+9/2,midy+1+9/2,pixels,9*9,"GofRGB");
    for (i = 0; i &lt; 9*9; i++)
        masses[1] += pixels[i];
    pxd_readushort(1,1,midx-9/2,midy-9/2,midx+1+9/2,midy+1+9/2,pixels,9*9,"BofRGB");
    for (i = 0; i &lt; 9*9; i++)
        masses[2] += pixels[i];
    reference[0] = masses[0]/(9*9);
    reference[1] = masses[1]/(9*9);
    reference[2] = masses[2]/(9*9);
</pre>
</blockquote>
Whether it is best to obtain the average values from the whole image or an AOI
is debatable; the former example does the entire image, the later does
a small 9×9 AOI; either method can be changed to any size AOI.
<p>
</p></li><li>
Determine suitable target pixel values.
This is often the lowest, highest, or mean of the reference
values - but should typically be the same for all three colors:
<blockquote>
<pre>    target[0] = target[1] = target[2]
                 = max(max(reference[0], reference[1]), reference[2]);
</pre>
</blockquote>
And invoke:
<blockquote>
<pre>    pxd_setImageBrightBalance(1, reference, target, 0.60);
</pre>
</blockquote>
using the preferred gamma correction coefficient
to apply the new coefficients to images accessed
via
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>.
<p>&nbsp;
<a name="Processing Images from a Bayer Output Camera with the PIXCI® CL, D, E, or SI Series" class="Ch"></a>
<a name="14.6.  Processing Images from a Bayer Output Camera with the PIXCI® CL, D, E, or SI Series"></a>
</p><h2>14.6.  Processing Images from a Bayer Output Camera with the PIXCI® CL, D, E, or SI Series</h2>
<p>When a Bayer output camera is used with a
PIXCI® CL1, CL2, CL3SD, D, D24, D32, D2X, D3X, E1, E1DB, E4, E4DB, EB1,
EB1-PoCL, EC1, ECB1, ECB1-34, ECB2, EL1, EL1DB, ELS2, SI, SI1, SI2, or
SI4 imaging board,
the XCLIB performs Bayer to RGB conversion and white balancing in
software.
The RGB conversion and white balancing is done automatically, and only
on demand.
Thus, capture may be done with any of the standard
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>,
<a href="#pxd_goSnap" class="Er">pxd_goSnap</a>,
<a href="#pxd_goLive" class="Er">pxd_goLive</a>
or similar functions, and corrected RGB (or BGR)
pixel values may be read via any of the standard
<a href="#pxd_readuchar" class="Er">pxd_readuchar</a>,
<a href="#pxd_readushort" class="Er">pxd_readushort</a>,
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>,
or similar functions.
Conversion to RGB is automatic and, for most applications,
completely transparent.
</p><p>
For the sake of overall efficiency,
the image frame buffer's contents are not converted
en masse and saved internally
as RGB values.
Rather, the frame buffer remains in Bayer format
and the Bayer values are converted only if, and when, they are requested.
A side effect is that
re-reading the same pixels from the same buffer requires
repeating the Bayer conversion.
</p><p>
Also, any pixel values written into the frame buffer, such as by
<a href="#pxd_writeuchar" class="Er">pxd_writeuchar</a>,
<a href="#pxd_writeushort" class="Er">pxd_writeushort</a>,
<a href="#pxd_defineImage" class="Er">pxd_defineImage</a>
or similar functions,
requires converting and compressing the RGB (or BGR) values
<u class="U">into</u>
Bayer format;
a process which, when inverted, may not yield
the exact, original, pixel values.
The effect is particularly noticeable when the processing algorithm
reads, processes, and writes line N before doing the same for line N+1;
the modified values written to line N will affect the values read from line N+1
(especially the green component values).
</p><p>
Applications which need to re-read the same pixel
values repeatedly can benefit from copying the RGB
values from the Bayer frame buffer into a (true) RGB buffer once,
and re-reading values from the copy.
Applications which need to perform image modifications
will also benefit from copy RGB values from the Bayer
frame buffer into a (true) RGB buffer once,
and thereafter processing the copy.
</p><p>
A true RGB buffer that can be accessed by PXIPL
functions, can be created using
<cite class="Ec">pximage_memmalloc</cite>
or
<cite class="Ec">pximage_memmalloc2</cite>.
Or, an existent array or
<cite class="Ec">malloc'ed</cite>
memory can be accessed by PXIPL
functions by creating a
<a href="#pximage" class="Er">pximage</a>
descriptor with
<cite class="Ec">pximage_memory</cite>.
These are similar, the former allocates space for
the pixels and creates the
<a href="#pximage" class="Er">pximage</a>
descriptor,
the latter assumes use of previously allocated memory
and creates the
<a href="#pximage" class="Er">pximage</a>
descriptor.
</p><p>
For example:
</p><blockquote>
<pre>    //
    // Create the RGB image buffer and pximage descriptor
    //
    void    *imagemem = NULL;
    struct  pximage image;
    struct  pxy dim;
    int     r;
<br>
    dim.x = pxd_imageXdim();
    dim.y = pxd_imageYdim();
    r = pximage_memmalloc(&amp;image, &amp;imagemem, &amp;dim,
                         pxd_imageBdim()&lt;=8?PXDATUCHAR:PXDATUSHORT,
                         pxd_imageBdim(), 3, PXHINTRGB);
    if (r &lt; 0)
        ;   // announce error
<br>
    //
    // Copy image from image frame buffer 1, converting to RGB
    // and saving in the 'true' RGB image buffer.
    //
    r = pxip8_copy(NULL, pxd_defineImage(0x1,1,0,0,-1,-1,"RGB"), &amp;image);
    //
    // We can now perform operations upon true RGB values,
    // writing RGB results.
    //
    r = pxip8_pixneg(NULL, &amp;image, &amp;image);
        ...
        ...
    //
    // When done, the memory allocated for the RGB image buffer
    // must be freed.
    //
    pximage_memfree(&amp;image, &amp;imagemem);
</pre>
</blockquote>
or the slightly simpler and easier to use from non-C/C++
environments:
<blockquote>
<pre>    //
    // Create the RGB image buffer and pximage descriptor
    //
    struct  pximage *ip;
    int     r;
<br>
    ip = pximage_memmalloc2(NULL,
                            pxd_imageBdim()&lt;=8?PXDATUCHAR:PXDATUSHORT,
                            pxd_imageBdim(), 3, PXHINTRGB,
                            pxd_imageXdim(), pxd_imageYdim(),
                            0, 0, 0);
    if (ip == NULL)
        ;   // announce error
<br>
    //
    // Copy image from frame buffer 1, converting to RGB
    // and saving in the 'true' RGB image buffer.
    //
    r = pxip8_copy(NULL, pxd_defineImage(0x1,1,0,0,-1,-1,"RGB"), ip);
    //
    // We can now perform operations upon true RGB values,
    // writing RGB results.
    //
    r = pxip8_pixneg(NULL, ip, ip);
        ...
        ...
    //
    // When done, the memory allocated for the RGB image buffer
    // must be freed.
    //
    pximage_memfree2(ip, NULL);
</pre>
</blockquote>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Release Notes" class="Ch"></a>
<a name="15.  Release Notes"></a>
</p><h1>15.  Release Notes</h1>
<br>
<br>
<b class="Hv">RELEASE NOTES: XCLIB  &#8212; Version 3.0, V3.7</b>
<ol type="1">
<p>
</p><li>
Version 3.0 released.
Adds support for Windows Vista, Windows XP(x64), and
Linux 64 Bit.
<br>
Under Linux, direct mapping of frame buffer memory into the application
memory space is now supported under 2.6 kernels.
<br>
Applications using SCF style functions need not recompile.
<br>
Applications using non-SCF functions or PXIPL functions should recompile.
Applications using
<cite class="Ec">::bufferSaveStream</cite>
or
<cite class="Ec">::bufferLoadStream</cite>
must add two parameters of 0.
A new
<cite class="Ec">::iosparse</cite>
service is added.
(28-Feb-2007)
<p>
</p></li><li>
Modified Feature:
The
'''video''time'
return value of
<cite class="Ec">pxd_videoFieldCount</cite>
has been changed from
<em class="Ep">ulong</em>
to
<em class="Ep">pxvbtime_t</em>
for consistent sizing under various 64 bit compilers.
This should not affect existing 16 or 32 bit programs,
and the old and new types are the same size integers,
albeit with a different type name.
(28-Feb-2007).
<p>
</p></li><li>
Fixed Feature:
When using more than one PIXCI®, some errors
such as PCI FIFO overflow,
on units other than the first may not be reported via
<cite class="Ec">pxd_mesgFault</cite>,
<cite class="Ec">pxd_mesgFaultText</cite>,
<cite class="Ec">::faultMessageBox</cite>,
etc.
(16-Mar-2007).
<p>
</p></li><li>
Fixed Feature:
Under Vista,
the
<cite class="Ec">pxd_eventFieldCreate</cite>,
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>,
and
<cite class="Ec">pxd_eventGPTriggerCreate</cite>,
may fail.
(??-???-2007)
<p>
</p></li><li>
Fixed Feature:
XCAP for Linux 64 bit shows a
''Usage error or fault''
when trying to open the PIXCI® imaging board.
In XCLIB for Linux 64 bit, the
<a href="#::getDevParms" class="Er">::getDevParms</a>
suffers a similar fate, but the SCF functions
are not affected as they don't use
<a href="#::getDevParms" class="Er">::getDevParms</a>.
(30-Mar-2007)
<p>
</p></li><li>
Added Feature:
Functions
<cite class="Ec">pxd_SV9M001_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV9M001_setResolutionAndTiming</cite>
and other related functions now provide camera specific controls
for the SILICON VIDEO® 5C10 and 5M10 camera.
(18-Apr-2007).
<p>
</p></li><li>
Fixed Feature:
Per-pixel offset (only) corrections/normalizations
did not work correctly under Linux, and under 64 bit Windows.
Per-pixel gain corrections did not work correctly
in configurations which did map map frame buffer memory into application space.
(27-May-2007)
<p>
</p></li><li>
Fixed Feature:
For the SILICON VIDEO® 5C10 and 5M10 cameras,
changing the exposure twice within one field may cause the
video to stop until the camera head is reset.
(31-May-2007).
<p>
</p></li><li>
Fixed Feature:
Under 64 bit Windows, with frame buffer memory mapped
''on-demand'',
when using a PIXCI® SV4, SV5 or any Camera Link compatible board,
and when using more than one imaging board (or more than one functional unit),
all but the first imaging board may fail to open
and no description of the error is provided via pxd_mesgFault().
(18-Jun-2007).
<p>
</p></li><li>
Fixed Feature:
Under Windows Vista, the
<cite class="Ec">pxd_eventFieldCreate</cite>,
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>,
and
<cite class="Ec">pxd_eventGPTriggerCreate</cite>
may fail, returning NULL.
(20-Jun-2007).
<p>
</p></li><li>
Fixed Feature:
The PIXCI® driver released approximately 11 July 2007
did not operate properly with the SV9M001, SV9M001C, SV9M001.
(24-Jul-2007)
<p>
</p></li><li>
Fixed Feature:
Depending on multi-processor configuration and speed,
the second functional half of the PIXCI® EL1DB, E1DB, E4DB
may drop, garble, or duplicate serial characters.
(02-Aug-2007)
<p>
</p></li><li>
Fixed Feature:
The PIXCI® CL3SD may intermittently report
''DMA Transfer Error''
on newer, faster computers, or where the PCI bus is inherently slow or heavily loaded.
(04-Aug-2007)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® SI4
PCI Express imaging boards (Beta).
(21-Dec-2007)
<p>
</p></li><li>
Modified Feature:
The
''Share Unit''
driver configuration parameter now defaults to
''share''
under Windows NT, 2000, XP, XP(x64), Server 2003, and Vista,
to allow easier use of the clserEPX.DLL along with
XCAP's Generic Camera Link controls.
(26-Dec-2007)
<p>
</p></li><li>
Improved Feature:
The PIXCI® SV5B is now supported distinct from
PIXCI® SV5; the default SV5B video setup is
NTSC, not the SV5's NTSC/YC.
(20-Feb-2008).
<p>
</p></li><li>
Fixed Feature:
The compilation instructions in
<code class="Em">XCLIBEXC.CPP</code>
has typo's referring to
<code class="Em">XCLIBEX2.CPP</code>
and
<code class="Em">XCLIBEX2.RC</code>
instead of
<code class="Em">XCLIBEXC.CPP</code>
and
<code class="Em">XCLIBEXC.RC</code>,
respectively.
(04-Mar-2008)
<p>
</p></li><li>
Fixed Feature:
For
SILICON VIDEO® 9T001, 5C10, and 5M10 cameras,
if XCAP is configured for
''Long Exposure''
and a format file exported to XCLIB,
the XCLIB's configuration will not be set for
''Long Exposure''.
(04-Mar-2008)
<p>
</p></li><li>
Added Feature:
Adds support for Windows Vista(x64) with Service Pack 1 or later;
use with Vista(x64) prior to SP1 is not recommended.
(13-Apr-2008)
<p>
</p></li><li>
New Feature:
The
<a href="#pxd_buffersSysTicks2" class="Er">pxd_buffersSysTicks2</a>
returns the 64 bit system time of a buffer's capture,
extending the existing
<a href="#pxd_buffersSysTicks" class="Er">pxd_buffersSysTicks</a>
which only returns the lower 32 bits.
(11-Jul-2007)
<p>
</p></li><li>
Fixed Feature:
For some PIXCI® SI cards,
after PC power up, the card must be opened twice:
the first open fails, the second (and following) opens
succeed.
(17-Jul-2007)
<p>
</p></li><li>
Modified Feature:
Controlled mode for the SILICON VIDEO® 5C10/5M10
has been modified and improved to use the chip's
''GRR Snapshot''
mode; providing common start-of-exposure for all lines
instead of rolling start-of-exposure.
(The sensor still uses a rolling shutter, thus exposure time
of lines differs.
Use of a strobe light is expected).
<p>
The SILICON VIDEO® 5C10/5M10 does not support
horizontal subsampling by a factor of 8;
software has been changed to disallow such a choice.
(29-Aug-2007)
</p><p>
</p></li><li>
Modified Feature:
The default frame buffer size under Windows NT, 2000, XP,
Server 2003, and Vista has been increased to 32 MByte.
(01-Sep-2007)
<p>
</p></li><li>
Modified Feature:
Controlled mode for the SILICON VIDEO® 9T001
has been modified and improved to use the chip's
''Global''
mode; providing common start-of-exposure for all lines
instead of rolling start-of-exposure.
(The sensor still uses a rolling shutter, thus exposure time
of lines differs.
Use of a strobe light is expected).
(07-Nov-2007)
<p>
</p></li><li>
Improved Feature:
For
PIXCI®&nbsp;E1DB, EL1DB, E4DB, and PIXCI®&nbsp;SI4 imaging boards,
under Windows 2000, XP, XP(x64), Server 2003, Vista, Linux 32 Bit and Linux 64 Bit,
it is no longer required that the first functional unit be opened
before (or together with) latter functional units of the same physical board.
(14-Jan-2008)
<p>
</p></li><li>
Modified Feature:
For Windows 95, 98, ME, 2000, XP, Server 2003, XP(x64), and Vista
the driver installation
<code class="Em">.inf</code>
file no longer sets default driver configuration parameters into the registry
(except for the PIXCI® CL3SD)
instead allowing the driver to set defaults internally.
This avoids resetting the user's altered driver configuration parameters
should a second PIXCI® card be installed later, or the
original card moved from slot to slot.
(24-Jan-2008)
<p>
</p></li><li>
Fixed Feature:
For the SILICON VIDEO® 5C10 and 5M10:
after switching from controlled mode to free-run, the frame rate
may stay at 0 until the pixel clock frequency is changed.
When switching to controlled mode and single shot, the
first trigger may not generate an exposure and image readout.
(11-Mar-2008)
<p>
</p></li><li>
Fixed Feature:
Under Windows 2000, XP, and Vista,
on some (newer?) motherboards, when using
<em class="Ep">Map Frame Buffer on demand in Sys</em>
and not using
<em class="Ep">Map Frame Buffer Direct into App</em>
after the PIXCI imaging board has been successfully
opened and used and closed several times,
an
''Unable to map image memory! (DDK MmMapIoSpace)''
may be reported;
the error is cleared by rebooting Windows.
(27-Mar-2008)
<p>
</p></li><li>
Fixed Feature:
For the SILICON VIDEO® 5C10 and 5M10:
On some camera heads
with the gain set to the default of 0&nbsp;dB,
the image is noisy and does not saturate.
(25-Apr-2008)
<p>
</p></li><li>
Improved Feature:
The SCF functions now support
use of multiple imaging boards with different resolution
and/or camera configuration (previously, multiple
imaging boards with identical configuration was supported).
The feature is activated by importing a video setup file
created by XCAP in
''Use Individual Formats &amp; Controls''
mode.
The SCF functions are still limited to use of identical imaging boards;
in some cases multiple boards of the model but different revision level
may also be allowed.
(01-Jun-2008)
<p>
</p></li><li>
Improved Feature:
The new
<code class="Em">XCLIBEXC.TXT</code>
provides a SILICON VIDEO® specific example
for use with VB.NET.
(13-Jun-2008)
<p>
</p></li><li>
Improved Feature:
For the SILICON VIDEO® 5C10 and 5M10:
Previously, the camera exposure was set in multiples of line periods;
the error (difference between exposure requested and exposure implemented)
could be up to one half a line period.
Exposure control is now improved,
and for small AOI's (less than half maximum width) the
exposure error is typically a few pixel clock periods,
but up to (approximately) one quarter of a line period for
larger AOI's.
(23-Jun-2008)
<p>
</p></li><li>
New Feature:
Now has partial
and beta-level support for new SILICON VIDEO® 9C10 camera.
(01-Jul-2008)
<p>
</p></li><li>
Improved Feature:
For 64 bit Windows and 64 bit Linux: new driver configuration
options allow specifying that frame buffer memory should be
allocated under the 4 &nbsp;GB address.
This allows using 32 bit PCI cards even on systems with more
than 4&nbsp;GB of memory.
(09-Jul-2008)
<p>
</p></li><li>
Fixed Feature:
The
<a href="#pxd_saveTiff" class="Er">pxd_saveTiff</a>
and
<a href="#::imageSaveTiff" class="Er">::imageSaveTiff</a>
may fail
when used with RGB+Pad or BGR+Pad format cameras
with forceful frame buffer allocation,
or with non-forceful allocation that isn't mapped into the
application's space.
(11-Jul-2008)
<p>
</p></li><li>
New Feature:
For PIXCI® CL2, E1 and newer imaging boards supporting Camera Link,
but not for the older PIXCI® CL1 and CL3SD,
new functions
<a href="#pxd_setCameraLinkCCOut" class="Er">pxd_setCameraLinkCCOut</a>
and
<a href="#pxd_getCameraLinkCCOut" class="Er">pxd_getCameraLinkCCOut</a>
allows setting the value of the Camera Link CC output lines,
for those CC lines which are not otherwise in use
for video control.
(16-Jul-2008)
<p>
</p></li><li>
New Feature:
XCLIB now supports the PIXCI® ECB1
ExpressCard/54 imaging board.
(18-Aug-2008)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports bit packed pixels in conjunction with
per pixel normalization.
(22-Sep-2008)
<p>
</p></li><li>
New Feature:
XCLIB now supports the PIXCI® SI4 Rev. 2
imaging board.
Use of an older XCLIB and/or driver with a PIXCI® SI4 Rev. 2
card will only work if a pixel clock frequency
of 48 MHz is chosen.
(07-Oct-2008)
<p>
</p></li><li>
Fixed Feature:
On PIXCI® CL1 imaging boards, a PCI FIFO Overflow error
causes serial communication to halt
until video capture is restarted, or the serial port disabled &amp; renabled.
(27-Oct-2008)
<p>
</p></li><li>
New Feature:
XCLIB now supports the PIXCI® EB1
imaging board.
(18-Nov-2008)
<p>
</p></li><li>
New Feature:
Now supports the SILICON VIDEO® 9C10 camera
in free-run and controlled global modes.
(03-Dec-2008)
<p>
</p></li><li>
Fixed Feature:
On some SILICON VIDEO® 5M10 or 5C10 cameras heads,
when the pixel clock frequency is changed and the gain is set to 0,
pixel values will be noisy and limited to less than 255/4095
until the gain is changed at least once.
(09-Jan-2009)
<p>
</p></li><li>
New Feature:
XCLIB now supports the PIXCI® EB1-PoCL
imaging board.
(11-Feb-2009)
<p>
</p></li><li>
Fixed Feature:
The
<a href="#pxd_doSnap" class="Er">pxd_doSnap</a>
would occasionally return 0 (success)
when capture had, in fact, been terminated due to,
for example, PCI FIFO Overflow.
The
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
or
<a href="#pxd_mesgFaultText" class="Er">pxd_mesgFaultText</a>
were not affected, and were reliable means to detect
PCI FIFO Overflow.
(13-Feb-2009)
<p>
</p></li><li>
New Feature:
Added functions
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
and
<a href="#pxd_eventFaultClose" class="Er">pxd_eventFaultClose</a>
allow notification of faults -
via events, signals, or callbacks
depending on O.S. - instead of polling via
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>.
(04-Mar-2009)
<p>
</p></li><li>
New Feature:
For Windows, NT, 2000, XP, and Vista, added functions
<a href="#pxd_eventFieldCreate2" class="Er">pxd_eventFieldCreate2</a>,
<a href="#pxd_eventCapturedFieldCreate2" class="Er">pxd_eventCapturedFieldCreate2</a>,
<a href="#pxd_eventGPTriggerCreate2" class="Er">pxd_eventGPTriggerCreate2</a>,
and
<a href="#pxd_eventFaultCreate2" class="Er">pxd_eventFaultCreate2</a>
are variations of
<a href="#pxd_eventFieldCreate" class="Er">pxd_eventFieldCreate</a>,
<a href="#pxd_eventCapturedFieldCreate" class="Er">pxd_eventCapturedFieldCreate</a>,
<a href="#pxd_eventGPTriggerCreate" class="Er">pxd_eventGPTriggerCreate</a>,
and
<a href="#pxd_eventFaultCreate" class="Er">pxd_eventFaultCreate</a>
that allow selection of a notification style event
instead of a synchronization style event.
(05-Mar-2009)
<p>
</p></li><li>
Fixed Feature:
With a PIXCI® D2X, CL1, or SI,
with versions of the V3.0 driver
with added support for PCI Express,
invoking
<a href="#::getDevInfo" class="Er">::getDevInfo</a>
while video capture is pending or in progress
may cause the video capture to be aborted.
(10-Mar-2009)
<p>
</p></li><li>
Fixed &amp; Improved Feature:
Under Linux, attempting to re-open an
already open PIXCI® imaging board
caused errors and crashes
even if -XU disallowed sharing.
Sharing is now supported.
(27-Mar-2009)
<p>
</p></li><li>
Improved Feature:
XCLIB now has preliminary support for the PIXCI® SI1.
(01-Apr-2009)
<p>
</p></li><li>
Improved Feature:
For Linux, two versions of each library is now provided,
one compiled with -fPIC and one compiled without.
Previously, the libraries were compiled without -fPIC.
14-Apr-2009
<p>
</p></li><li>
Improved Feature:
For Linux 2.6 and later kernels and Camera Link PIXCI® cards, the driver
now offers /dev/tty style access to the serial port.
Node names are /dev/ttyPIXCI0 for unit 0, /dev/ttyPIXCI1 for unit 1, etc.
Note that this mapping holds even if unit 0, for example,
is not a Camera Link card and thus doesn't have a serial port -
in which case, opening /devttyPIXCI0 will fail.
Only the Camera Link standard baud rates are supported.
(21-Apr-2009)
<p>
</p></li><li>
New Feature:
XCLIB now supports the PIXCI® ECB1-34
ExpressCard/34 imaging board.
(14-May-2009)
<p>
</p></li><li>
Improved Feature:
Under 64 bit operating systems, XCLIB now supports up to 16
PIXCI® imaging boards.
(01-Jun-2009)
<p>
</p></li><li>
New Feature:
XCLIB now supports the PIXCI® ECB2
ExpressCard/54 imaging board.
(03-Jun-2009)
<p>
</p></li><li>
Fixed Feature:
When using a SILICON VIDEO® camera,
and using pxd_SV2112, pxd_SV1310, pxd_SV1281, or pxd_SV9M001
functions, using pxd_videoFormatAsIncluded with a format
file which has I2C (i.e. camera head) configuration commands
will cause unexpected results as the camera head state which is cached
by pxd_SV2112, pxd_SV1310, pxd_SV1281, or pxd_SV9M001
is not updated with the camera state set by the format file.
(04-Jun-2009)
<p>
</p></li><li>
Clarified Feature:
The 'properties' of the PIXCI® driver for XP(x64) &amp; Vista(x64)
describe it as supporting only XP(x64).
This does not affect the driver's operation under Vista(x64).
(01-Jul-2009)
<p>
</p></li><li>
Fixed Feature:
When using a PIXCI® SI4, depending on the order in which
the 4 units are opened and the cameras initialized, an
''Eeprom contents invalid (0xffff:0xffff)''
error may occur.
This can be resolved either with a FPGA update, or with
a updated PIXCI® driver.
(24-Jul-2009)
<p>
</p></li><li>
Fixed Feature:
When using multiple PIXCI® imaging boards,
the
''struct pxdevfault''
and/or
<a href="#pxd_mesgFault" class="Er">pxd_mesgFault</a>
messages may indicate the affected units as their physical
sequential number, or as a sequential number relative to the
units actually opened.
Usage is now, consistently, the physical sequential number.
(03-Aug-2009)
<p>
</p></li><li>
New Feature:
Now has partial (can configure camera via .fmt file, but
does not yet have camera specific API)
and beta-level support for new SILICON VIDEO® 643 camera.
(24-Aug-2009)
<p>
</p></li><li>
Modified Feature:
The default pixel clock frequency for the SILICON VIDEO® 9C10
has been changed from 70 MHz (7.2 fps) to 48 MHz (4.8 fps).
(18-Sep-2009)
<p>
</p></li><li>
Version 3.7 released.
Adds support for Windows 7 and 7(x64).
(07-Nov-2009)
<p>
</p></li><li>
New Feature:
For SILICON VIDEO® cameras,
new functions
<a href="#pxd_SV2112_getMinMaxExposure" class="Er">pxd_SV2112_getMinMaxExposure</a>,
<a href="#pxd_SV2112_getMinMaxCtrlExposure" class="Er">pxd_SV2112_getMinMaxCtrlExposure</a>,
<a href="#pxd_SV1310_getMinMaxExposure" class="Er">pxd_SV1310_getMinMaxExposure</a>,
<a href="#pxd_SV1281_getMinMaxExposure" class="Er">pxd_SV1281_getMinMaxExposure</a>,
<a href="#pxd_SV9M001_getMinMaxExposure" class="Er">pxd_SV9M001_getMinMaxExposure</a>,
<a href="#pxd_SV642_getMinMaxExposure" class="Er">pxd_SV642_getMinMaxExposure</a>,
<a href="#pxd_SV643_getMinMaxExposure" class="Er">pxd_SV643_getMinMaxExposure</a>,
and
<a href="#pxd_SV643_getMinMaxCtrlExposure" class="Er">pxd_SV643_getMinMaxCtrlExposure</a>
allow obtaining the minimum and maximum allowable
exposures, which vary depending on other camera parameters
such as pixel clock frequency, area of interest, subsampling, etc.
These functions avoid having to actually set the exposure to a low or high
value and query the result, or use non-SCF functions,
to obtain the same information.
(18-Dec-2009)
<p>
</p></li><li>
Improved Feature:
Fault messages now show multiple units as a 0-based
list of units numbers, such as
''0,3,6''
instead of a hexadecimal number whose bits represent units,
such as
''0x45''.
(06-Jan-2010)
<p>
</p></li><li>
Fixed Feature:
With multiple boards, with multiple memory partitions,
depending on the relaive number of boards and partitions,
some of the memory may not have been assigned to any board.
(13-Jan-2010)
<p>
</p></li><li>
Modified Feature:
The
<a href="#::xclib_open" class="Er">::xclib_open</a>
now applied the
<em class="Ep">formatname</em>
before the
<em class="Ep">formatfile</em>,
if both are specified.
This provides a better result in the
common case of accidently using
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
with both
<em class="Ep">formatname</em>
and
<em class="Ep">formatfile</em>.
(While
<a href="#pxd_PIXCIopen" class="Er">pxd_PIXCIopen</a>
declares such as case invalid, no error is given).
(27-Jan-2010)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® SI2 imaging board.
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® SV7 imaging board.
(03-Apr-2010)
<p>
</p></li><li>
Improved Feature:
New function
<a href="#pxd_SV643_setExposureAndGainOffset" class="Er">pxd_SV643_setExposureAndGainOffset</a>
extends
<a href="#pxd_SV643_setExposureAndGain" class="Er">pxd_SV643_setExposureAndGain</a>,
allowing easy adjustment of the offset (black level).
(03-May-2010)
<p>
</p></li><li>
Fixed Feature:
Under Windows, the optional high resolution kernel timer
selectable via Driver Configuration Parameters
isn't actually enabled.
(19-May-2010)
<p>
</p></li><li>
Improved Feature:
Function names in the XCLIB 32 bit DLL's now have simple aliases,
so that Visual Basic, .NET, LabView, etc. can call, for example,
<cite class="Ec">pxd_PIXCIopen</cite>
instead of the full, decorated name
<cite class="Ec">_pxd_PIXCIopen@12</cite>.
(28-May-2010)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® ELS2
PCI Express imaging boards (Beta).
(21-Jun-2010)
<p>
</p></li><li>
Improved Feature:
New SCF+ functions, prefixed as
<a href="#pxe_" class="Er">pxe_</a>,
now allow operating multiple, non-identical
PIXCI® imaging boards without having to use
the structured functions.
The
<a href="#pxe_" class="Er">pxe_</a>
functions share the
simplicity of the
<a href="#pxd_" class="Er">pxd_</a>
functions.
(17-Aug-2010)
<p>
</p></li><li>
Fixed Feature:
For SILICON VIDEO® 9C10 cameras, the
<a href="#pxd_SV9M001_setVideoAndTriggerMode" class="Er">pxd_SV9M001_setVideoAndTriggerMode</a>
function did not allow setting controlled mode.
(14-Sep-2010)
<p>
</p></li><li>
Fixed Feature:
For PIXCI® SI2 imaging boards under a 64 bit O.S.
where the PC has more than 4 GB of memory,
image data may be black depending on whether
allocated buffers were above or below the 4 GB address.
(22-Sep-2010)
<p>
</p></li><li>
New Feature:
XCLIB now supports 32 bit applications under 64 bit Windows
(previously only 64 bit applications were supported)
using the
<code class="Em">XCLIBWNT.DLL</code>
(32 bit DLL)
and the
<code class="Em">EPIXXCW6.SYS</code>
(64 bit driver).
The 32 bit applications have the same limits as under
32 bit Windows - frame buffer memory is limited to less
than 4&nbsp;GByte.
Also, the frame buffer memory must be in the lower 4&nbsp;MByte
of PC memory.
(11-Oct-2010)
<p>
</p></li><li>
New Feature:
New
<a href="#pxd_SILICONVIDEO_" class="Er">pxd_SILICONVIDEO_</a>
functions
operate with all SILICON VIDEO®
cameras.
Use of the camera specific
<a href="#pxd_SV2112_" class="Er">pxd_SV2112_</a>,
<a href="#pxd_SV1310_" class="Er">pxd_SV1310_</a>,
<a href="#pxd_SV1281_" class="Er">pxd_SV1281_</a>,
<a href="#pxd_SV642_" class="Er">pxd_SV642_</a>,
<a href="#pxd_SV643_" class="Er">pxd_SV643_</a>,
and
<a href="#pxd_SV9M001_" class="Er">pxd_SV9M001_</a>
functions is deprecated.
(Oct-2010)
<p>
</p></li><li>
Fixed Feature:
The
<code class="Em">XCLIBWNT_VBNET.TXT</code>
declarations for use with .NET have been fixed;
declarations which involve
''passing''
of arrays were missing the
''ByRef''
adjective.
(20-Oct-2010)
<p>
</p></li><li>
Fixed Feature:
Under some conditions, following addition of the new feature
described in the 01-Jun-2008 entry, the
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>
may initiate sequence capture twice which
may cause problems in some trigger modes.
(25-Oct-2010).
<p>
</p></li><li>
Improved Feature:
For PIXCI® imaging boards with multiple functional
units (e.g. EL1DB, E4DB, SI2, SI4, ...)
and under a Windows Plug &amp; Play O.S.
(i.e. Windows 2000 and later)
the default -DM selection of which (functional)
units are to be opened is changed from the first functional unit
(i.e. -DM 0x01)
to all functional units of the first physical board
(i.e. -DM 0x03 for boards with two functional units
or -DM 0x0F for boards with four functional units).
(15-Nov-2010)
<p>
</p></li><li>
New Feature:
Now supports the SILICON VIDEO® WGA-C and WGA-M cameras.
(14-Dec-2010)
<p>
</p></li><li>
New Feature:
Now supports the PIXCI® SV5L imaging board.
(06-Jan-2011)
<p>
</p></li><li>
Fixed Feature:
With PIXCI® imaging boards with multiple
functional units (EL1DB, E4DB, SI2, SI4, ECB2),
when used with multiple processors or multi-core
processors, a BSoD may occur when the imaging board
is closed.
(01-Jan-2011)
<p>
</p></li><li>
New Feature:
Functions
<a href="#pxd_eventSerialCreate" class="Er">pxd_eventSerialCreate</a>
and
<a href="#pxd_eventSerialClose" class="Er">pxd_eventSerialClose</a>
allow signalling the application
upon activity on the serial port.
(17-Jan-2011).
<p>
</p></li><li>
Fixed Feature:
On some(?) 64 bit machines, sequence capture
may cause PCI FIFO Adrs errors, even when
live capture, or live alternate pair capture,
does not.
Reducing the number of memory partitions used
appears to eliminate the problem.
The underlying cause and alternate solutions are being investigated.
(07-Feb-2011)
<p>
</p></li><li>
Fixed Feature:
For PIXCI® imaging boards with multiple functional units
(ECB2, EL1DB, E4DB, SI2, SI4, etc.)
the default submodel (i.e. camera type) of all but the first
functional unit may rarely, randomly, be incorrect.
(09-Feb-2011)
</li></ol>
<br>
<br>
<b class="Hv">RELEASE NOTES: XCLIB  &#8212; Version 2.2</b>
<ol type="1">
<p>
</p><li>
This release adds support for Windows XP.
(03-Dec-2001).
<p>
</p></li><li>
Added Feature:
Function
<cite class="Ec">pxd_SV2112_setExposureAndGain</cite>
allows setting the current exposure and gain
for the SILICON VIDEO® 2112 and 2112C cameras.
Function
<cite class="Ec">pxd_SV2112_setResolutionAndTiming</cite>
allows setting the current decimation, AOI, scan direction,
and pixel clock frequency for the SILICON VIDEO® 2112 and 2112C cameras.
Functions
<cite class="Ec">pxd_SV2112_getExposure</cite>,
<cite class="Ec">pxd_SV2112_getGain</cite>,
<cite class="Ec">pxd_SV2112_getDecimation</cite>,
<cite class="Ec">pxd_SV2112_getAoiTop</cite>,
<cite class="Ec">pxd_SV2112_getAoiLeft</cite>,
<cite class="Ec">pxd_SV2112_getPixelClock</cite>,
and
<cite class="Ec">pxd_SV2112_getScanDirection</cite>
allow obtaining the eponymous setting
for the SILICON VIDEO® 2112 and 2112C cameras.
(03-Dec-2001).
<p>
</p></li><li>
Added Feature:
A SILICON VIDEO® 2112 and 2112C specific example program,
<code class="Em">XCLIBEXC.CPP</code>,
demonstrates capture, display, adjustment of
the camera's settings.
(03-Dec-2001).
<p>
</p></li><li>
Fixed Feature:
The new
<cite class="Ec">::goingBufStatus</cite>
service may cause system termination
when used with multiple boards,
and when used on any but the first board.
(13-Dec-2001).
<p>
</p></li><li>
Added Feature:
For SILICON IMAGING 3170 cameras, video setup files
saved by XCAP now contain the necessary serial
commands to (re)configure the camera.
Upon open, XCLIB now reconfigures the camera
with these serial commands.
(18-Jan-2002).
<p>
</p></li><li>
Added Feature:
New functions
<cite class="Ec">pxd_getGPTrigger</cite>,
<cite class="Ec">pxd_eventGPTriggerCreate</cite>,
and
<cite class="Ec">pxd_eventGPTriggerClose</cite>
provide SCF level access to the software detectable
trigger provided on PIXCI® D, D24, D32, D2X, and D3X
image boards.
These functions are not needed
when using a camera which itself is in trigger mode.
Rather, they can be used to detect a trigger with cameras in continuous mode
where the PIXCI® trigger input
has no direct effect on camera or PIXCI® imaging board.
(01-Feb-2002).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">pxd_defineImage3</cite>
with some combinations of imaging boards and cameras
would produce a program fault.
(08-Feb-2002).
<p>
</p></li><li>
Fixed Feature:
On PIXCI® and cameras which produce
more than one pixel per clock, the
''vidres.x.vidoffset''
was interpreted in units of pixel clocks, instead of pixels.
(13-Feb-2002).
<p>
</p></li><li>
Fixed Feature:
The PIXCI® Windows VXD and SYS files, the XCLIB DLL files,
and the PXIPL DLL files did not have correct, or did not have any,
version information shown with the files' properties
(such as via the Windows Explorer).
(20-Feb-2002).
<p>
</p></li><li>
Fixed/Added Feature:
The
<cite class="Ec">pxd_getFieldCount</cite>
function mentioned in the
<cite class="Ec">Conversion of Application Programs from XCOBJ</cite>
was not documented.
It has been renamed to
<cite class="Ec">pxd_videoFieldCount</cite>
(a function under the old name persists for compatibility)
and documented.
The
<cite class="Ec">pxd_getFieldsPerFrame</cite>,
never mentioned or documented,
has been renamed to
<cite class="Ec">pxd_videoFieldsPerFrame</cite>
and documented.
(27-Feb-2002).
<p>
</p></li><li>
Improved/Fixed Feature:
The maximum number of bits per pixel value component
was limited to 14, and has been changed to 16.
(09-Apr-2002).
<p>
</p></li><li>
Fixed Feature:
When switching the SV2112 camera from controlled back to continuous
video mode, the
<cite class="Ec">pxd_SV2112_setVideoAndTriggerMode</cite>
had to be called twice (with the same parameters).
(02-May-2002).
<p>
</p></li><li>
Improved Feature:
The
<code class="Em">XCLIBEXC.CPP</code>
example program for use with SV2112 and SV2112C
cameras now also demonstrates the implementation
of automatic gain control (AGC).
(05-Jul-2002)
<p>
</p></li><li>
Fixed Feature:
Using Forceful Memory allocation under Windows NT/2000/XP,
and selecting the wrong boot.ini selection when prompted
during Windows' boot, may prevent Windows from starting.
(09-Aug-2002).
<p>
</p></li><li>
Fixed Feature:
Using multiple PIXCI® D2X, D3X, CL1 under Windows 2000/XP,
where the cameras are tightly synchronized may cause
the PC to lockup until rebooted or the cameras powered down.
(12-Aug-2002).
<p>
</p></li><li>
Added Feature:
XCLIB now supports additional features of newer PIXCI® D2X, D3X
imaging boards for line scan cameras, increasing the maximum
number of lines per image from 65535 to 16777216.
(15-Aug-2002).
<p>
</p></li><li>
Fixed Feature:
When using multiple PIXCI® CL1 imaging boards with certain cameras,
the
<cite class="Ec">pxd_videoFieldCount</cite>
<cite class="Ec">pxd_getFieldCount</cite>
<cite class="Ec">pxd_getGPTrigger</cite>
functions always returned the status of unit 1, not the
selected
<em class="Ep">unitmap</em>,
and the events created by
<cite class="Ec">pxd_eventFieldCreate</cite>
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
<cite class="Ec">pxd_eventGPTriggerCreate</cite>
were signalled by activity on either unit.
(22-Aug-2002).
<p>
</p></li><li>
Fixed Feature:
On newer machines under Windows XP, the
<cite class="Ec">pxd_eventFieldCreate</cite>
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
<cite class="Ec">pxd_eventGPTriggerCreate</cite>
may cause system death (i.e.
''blue-screen'').
(23-Aug-2002).
<p>
</p></li><li>
New Feature:
XCLIB and XCLIB-IPL for Windows now includes static link libraries,
as an alternative to using the dynamic link library (DLL).
For OEM application programs that are to be redistributed,
using the static link libraries minimizes the number of
files that must be redistributed.
(09-Sep-2002).
<p>
</p></li><li>
Improved Feature:
The
<cite class="Ec">::setLiveTrigBuf</cite>
and
<cite class="Ec">pxd_goLiveTrig</cite>
now allow selecting rising, falling, or either
edge of the general purpose input, when
used with PIXCI® SV4, SV5, D2X, D3X, and CL1
imaging boards.
Previously, those features always used either edge.
(09-Sep-2002).
<p>
</p></li><li>
Improved Feature:
For
PIXCI® D2X, D3X, or CL1
and line scan cameras running in
''vertical mastered''
mode (i.e. no external VDRIVE signal),
XCLIB now allows snapping an image starting
at the next line, in contrast to snapping when
the internal line counters
''roll over''.
(25-Sep-2002).
<p>
</p></li><li>
Fixed Feature:
In the current release of XCLIB, the
''controlled''
mode parameters of
<cite class="Ec">pxd_SV2112_setVideoAndTriggerMode</cite>
and
<cite class="Ec">pxd_SV2112_setCtrlExposureAndRate</cite>
may not work as intended.
(04-Oct-2002).
<p>
</p></li><li>
Added Feature:
A new example,
<code class="Em">XCLIBEX4.CPP</code>,
demonstrates
sequence capture and display with any PIXCI®
imaging board.
(11-Oct-2002)
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">pxd_readuchar</cite>,
<cite class="Ec">pxd_writeuchar</cite>,
<cite class="Ec">pxd_readushort</cite>,
and
<cite class="Ec">pxd_writeushort</cite>
as well as the similar
<cite class="Ec">::imageWriteUShort</cite>,
<cite class="Ec">::imageReadUShort</cite>,
<cite class="Ec">::imageWriteUChar</cite>,
and
<cite class="Ec">::imageReadUChar</cite>
functions would return 0 and read/write nothing
if the specified AOI were invalid, such as larger
than the frame buffer.
(15-Oct-2002).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">::bufferSaveStream</cite>
and
<cite class="Ec">::bufferLoadStream</cite>
functions may cause program death when the
<em class="Ep">alignsector</em>
parameter is non-zero in conjunction with certain combinations
of cameras, imaging boards, and operating systems.
(16-Oct-2002).
<p>
</p></li><li>
Improved Feature:
The
<cite class="Ec">pxd_defineImage</cite>,
<cite class="Ec">pxd_defineImage3</cite>,
<cite class="Ec">pxd_readuchar</cite>,
<cite class="Ec">pxd_writeuchar</cite>,
<cite class="Ec">pxd_readushort</cite>,
and
<cite class="Ec">pxd_writeushort</cite>
now accept a
<em class="Ep">colorspace</em>
of
''CbYCrY''
to access pixel data in UYVY format, supported
only with  a PIXCI® SV2, SV3, SV4, or SV5
which has been set to capture in that format.
(28-Oct-2002).
<p>
</p></li><li>
New Feature:
A beta version of XCLIB for the Linux 2.4.8 kernel is released.
(01-Nov-2002)
<p>
</p></li><li>
Modified Feature:
The default frame buffer memory size under Windows NT, 2000, and XP
has been increased from 4 MByte to 16 MByte.
(05-Nov-2002).
<p>
</p></li><li>
Fixed Feature:
For some combinations of PIXCI® imaging boards and cameras,
use of
<cite class="Ec">pxd_defineImage3</cite>
selecting fewer than all frame buffers,
combined with
<cite class="Ec">pxio8_binreadseq</cite>,
<cite class="Ec">pxio8_binwriteseq</cite>,
<cite class="Ec">pxio8_bin1writeseq</cite>,
and
<cite class="Ec">pxio8_bin1readseq</cite>
would result saving or loading more frame buffers than specified.
(13-Nov-2002).
<p>
</p></li><li>
Improved Feature:
Under Windows NT, 2000, or XP the
''-WT''
driver configuration parameter now allows selecting
a high resolution kernel timer for time stamping
events.
(28-Nov-2002)
<p>
</p></li><li>
Fixed Feature:
On some machines and cameras under Windows 2000 and XP, the
<cite class="Ec">pxd_eventFieldCreate</cite>
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
<cite class="Ec">pxd_eventGPTriggerCreate</cite>
may cause system death.
(16-Dec-2002).
<p>
</p></li><li>
Added Feature:
The Camera Link serial API has been added to XCLIB, with functions
<cite class="Ec">clSerialInit</cite>,
<cite class="Ec">clSerialClose</cite>,
<cite class="Ec">clSerialRead</cite>,
and
<cite class="Ec">clSerialWrite</cite>.
These allow access to a PIXCI® imaging board
which was already opened by XCLIB.
A separate DLL,
<code class="Em">clSerPIXCI.dll</code>
which has only the Camera Link Serial API,
and can be distributed w/out XCLIB's licensing
restrictions, can be used to access the serial port
PIXCI® imaging boards w/out XCLIB.
(24-Dec-2002)
<p>
</p></li><li>
Fixed Feature:
When using 3 or more PIXCI® imaging boards
that are combinations of at least 2 different models
(such as D vs SV4 vs D2X),
certain combinations of selected boards (via -DM)
when installed in certain order on the PCI bus may cause errors upon open.
(13-Jan-2003)
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">pxd_setExsyncPrin</cite>,
<cite class="Ec">pxd_setExsyncPrincMode</cite>
and related functions were not enabled for use with the
PIXCI® CL3SD.
(31-Jan-2003)
<p>
</p></li><li>
Fixed Feature:
For the SILICON VIDEO® 2112(C) when used in Controlled mode,
the maximum frame rate allowed such as via
<cite class="Ec">pxd_SV2112_setCtrlExposureAndRate</cite>
has been corrected (increased).
(04-Feb-2003).
<p>
</p></li><li>
Fixed Feature:
Driver installation under Windows XP has been improved,
eliminating the problem under some PC configurations
whereby the initial Plug&amp;Play installation run's
''forever'',
requiring a reboot and a second installation.
(20-Feb-2003).
<p>
</p></li><li>
Added Feature:
Functions
<cite class="Ec">pxd_SV1310_setExposureGainOffset</cite>,
<cite class="Ec">pxd_SV1310_setResolutionAndTiming</cite>
and other related functions provide camera specific controls
for the SILICON VIDEO® 1310 and 1310C cameras.
(28-Feb-2003)
<p>
</p></li><li>
Improved Feature:
The
<cite class="Ec">pxd_SV2112</cite>
functions, and especially the
<cite class="Ec">pxd_SV2112_get</cite>
functions,
have been improved and are now faster
by virtue of caching the camera's state rather than
having to re-read the information from the camera.
(05-Mar-2003).
<p>
</p></li><li>
Fixed Feature:
When the PIXCI® D2X, D3X, or CL1 is used in (video) triggered
mode combined with pxd_goLive, the first triggered image is
now captured, rather than capture starting with the second
triggered image.
(05-Apr-2003).
<p>
</p></li><li>
Fixed Feature:
The
<em class="Ep">subsample</em>
parameter to the new
<cite class="Ec">pxd_SV1310_setResolutionAndTiming</cite>
function had the horizontal and vertical subsampling components exchanged.
Thus
<em class="Ep">subsample</em>=0x0402
would have implemented horizontal subsampling by a factor of two
and vertical subsampling by a factor of four, rather than the documented
horizontal subsampling by a factor of four
and vertical subsampling by a factor of two.
(11-Apr-2003).
<p>
</p></li><li>
Improved Feature:
For the SILICON VIDEO® 1310 camera,
the frame rate can now be increased by using subsampling
and/or using a smaller AOI.
Previously, only a smaller AOI would increase the frame rate.
(11-Apr-2003)
<p>
</p></li><li>
Fixed Feature:
Using a
''struct pximage3''
with operations that read or write across
image boundaries with a single read or write,
the result may be incorrect.
The only known library function that this affected
is
<cite class="Ec">pxio8_binreadseq</cite>.
(11-Jun-2003)
<p>
</p></li><li>
Added Feature:
A new example program,
<code class="Em">xclibex5.cpp</code>,
demonstrates use of non pxd_
functions to operate two
imaging boards at different resolutions.
(06-Jun-2003)
<p>
</p></li><li>
Fixed Feature:
For the PIXCI® CL3SD, under Windows 2000, XP,
the improved driver installation file,
<code class="Em">epixxcw2.inf</code>,
set
<blockquote>
<pre>    PIXCI= ... -WT -0x20
</pre>
</blockquote>
to activate high resolution timestamps.
The superfluous
''-''
causes software to believe the board has 4 GBytes
of memory, regardless of the amount of memory actually installed.
(27-Jun-2003).
<p>
</p></li><li>
Fixed Feature:
The
<em class="Ep">pximage</em>'s
optional PXUNIT* constants
(which describe the image's real-world dimensional units)
have been corrected;
the old values did not fit within the
<em class="Ep">uchar</em>
fields provided, namely
<em class="Ep">widthunits</em>,
<em class="Ep">heightunits</em>,
and
<em class="Ep">depthunits</em>.
(13-Jul-2003)
<p>
</p></li><li>
Added Feature:
The
<cite class="Ec">pxd_goSnapPair</cite>
has been added as an SCF version of
<cite class="Ec">::setSnapPairBuf</cite>;
both intended for use with cameras that
output two images with a single trigger.
(29-Jul-2003)
<p>
</p></li><li>
Added Feature:
The
<cite class="Ec">pxd_goLiveSeqTrig</cite>
allows initiating or terminating sequence capture in
response to a general purpose input or trigger,
with less latency than possible with previously available techniques.
(03-Aug-2003)
<p>
</p></li><li>
Fixed Feature:
For
PIXCI® D, D24, D32, D2X, and D3X imaging boards, the
<cite class="Ec">pxd_goLiveTrig</cite>
and
<cite class="Ec">::setLiveTrigBuf</cite>
optional parameters
<em class="Ep">delay60</em>
and
<em class="Ep">delay70</em>
would implement the stated delay plus 1, rather than
the stated delay.
These functions are rarely used with those imaging
boards, as they are only used with cameras
that don't implement triggering within the camera.
(07-Aug-2003).
<p>
</p></li><li>
Modified Feature:
Due to lack of apparent interest, the
static link libraries for Windows
are no longer distributed with XCLIB and
XCLIB-IPL.
(19-Aug-2003).
<p>
</p></li><li>
Improved Feature:
XCLIB now performs a power-up initialization
for SILICON VIDEO® 2112 and 1310 cameras
upon calling pxd_PIXCIopen.
Previously, the cameras were initialized only by PC power-up.
(12-Sep-2003)
<p>
</p></li><li>
Fixed Feature:
Under Windows NT, 2000, and XP,
when using multiple instances of XCLIB
(via multiple calls to
<cite class="Ec">xclib_open</cite>),
the
<cite class="Ec">pxd_eventFieldCreate</cite>,
<cite class="Ec">pxd_eventFieldClose</cite>,
and
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
could not be used in more than one instance.
(13-Sep-2003).
<p>
</p></li><li>
Added Feature:
Functions
<cite class="Ec">pxd_SV1281_setExposureGainOffset</cite>,
<cite class="Ec">pxd_SV1281_setResolutionAndTiming</cite>
and other related functions provide camera specific controls
for the SILICON VIDEO® 1281 and 1281C cameras.
(16-Sep-2003).
<p>
</p></li><li>
Fixed Feature:
On some PC's, the SILICON VIDEO® 1310(C)
would not initialize properly after power up,
outputting a grey image, unless either
(a)&nbsp;XCAP was run, or
(b)&nbsp;The XCLIB application was run twice.
(29-Sep-2003).
<p>
</p></li><li>
Improved Feature:
The PIXCI® SV5A is now supported distinct from
PIXCI® SV5; the default SV5A video setup is
NTSC, not the SV5's NTSC/YC.
(30-Sep-2003).
<p>
</p></li><li>
Improved Feature:
For all currently supported Uniq, Basler, Hitachi, and Cohu
CameraLink cameras and the Jai CV-M4+CL/CV-M7+CL CameraLink cameras
video setup files saved by
XCAP now include the serial commands needed to restore
the camera to the operating mode as set in XCAP.
XCLIB now loads those serial commands during
<cite class="Ec">pxd_PIXCIopen</cite>,
eliminating having to follow the instructions in the
<cite class="Ec">Using a Serial (RS-232) Configurable Camera with the PIXCI(R) D, D24, D32, D2X, D3X, CL1, or CL3SD</cite>
application note.
The same improvement has always been provided for
Silicon Imaging and Redlake ES-1020 cameras, but not explicitly noted.
(27-Oct-2003).
<p>
</p></li><li>
Improved Feature:
Under Linux, the
''Use Polling Rather than Interrupts (-QU)''
option is now available.
(12-Nov-2003).
<p>
</p></li><li>
Fixed Feature:
Under Linux, closing the library may cause the
wrong (library internal) file
''handle''
to the driver to be closed, adversely affecting any file or device opened after XCLIB.
Under Linux, the
<cite class="Ec">pxd_loadBmp</cite>
does not work properly.
(09-Dec-2003).
<p>
</p></li><li>
Added Feature:
Functions
<cite class="Ec">pxd_definePximage</cite>
and
<cite class="Ec">pxd_definePximage3</cite>
and similar to the existing
<cite class="Ec">pxd_defineImage</cite>
and
<cite class="Ec">pxd_defineImage3</cite>,
but more convenient in multi-threaded
and a few other, rare, applications.
(06-Jan-2004)
<p>
</p></li><li>
Fixed Feature:
Under Linux, on some motherboards,
interrupts, and thus notification about end-of-capture,
may not work properly.
(14-Jan-2004)
<p>
</p></li><li>
Added Feature:
A new example program,
<code class="Em">XCLIBEX6.TXT</code>,
illustrates use of XCLIB with VB.NET.
(16-Jan-2004).
<p>
</p></li><li>
Added Feature:
New functions
<cite class="Ec">pxd_saveRawBuffers</cite>
and
<cite class="Ec">pxd_loadRawBuffers</cite>
have been added as an SCF version of
<cite class="Ec">::bufferLoadStream</cite>
and
<cite class="Ec">::bufferSaveStream</cite>.
(02-Feb-2004)
<p>
</p></li><li>
Fixed Feature:
When using
<code class="Em">XCLIBEXC.CPP</code>and<code class="Em">a</code>SILICON<code class="Em">VIDEO®</code>1310(C)<code class="Em">with</code>
a video setup file saved by XCAP which sets a small
capture AOI, the captured image is garbled
as the camera is set to one resolution while the
SILICON VIDEO® 1310(C) specific functions invoked by
<code class="Em">XCLIBEXC.CPP</code>
set the PIXCI® imaging board to a different resolution.
(The same video setup file works correctly in
<code class="Em">XCLIBEX2.CPP</code>
which does not make use of SILICON VIDEO® 1310(C) specific functions).
(31-Mar-2004).
<p>
</p></li><li>
Improved Feature:
New function
<cite class="Ec">pxd_mesgFaultText</cite>
allows obtaining the text describing a fault
from a SCF style function, avoiding
<cite class="Ec">pxd_mesgFault</cite>'s
implied creation of a message box.
(12-Apr-2004).
<p>
</p></li><li>
Fixed Feature:
For Camera Link cameras where a previously saved video setup
file contains serial commands with which to initialize the camera, XCLIB's
<cite class="Ec">pxd_PIXCIopen</cite>
may fail with a
''timeout''
error.
The problem is most likely to occur under Linux, but might occur under
other operating systems.
(30-Apr-2004).
<p>
</p></li><li>
Improved Feature:
The XCLIB release now includes the full XCLIB C/C++ Reference Manual
in HTML format.
(07-May-2004).
<p>
</p></li><li>
Fixed Feature:
For rare combinations of frame buffer sizes versus frame buffer memory
allocation parameters, the per-buffer capture information
reported by
<cite class="Ec">pxd_buffersFieldCount</cite>,
<cite class="Ec">pxd_buffersSysTicks</cite>,
and
<cite class="Ec">pxd_buffersGPIn</cite>
may be destroyed by capturing into the last, or last few, frame buffers.
(11-May-2004).
<p>
</p></li><li>
Fixed Feature:
For the SILICON VIDEO® 1281 and 1281C cameras, in some combinations
of AOI, pixel clock and other parameters, too large a value of
exposure is allowed, causing the captured image to be extremely dark
or extremely bright.
Also, under Visual Basic or Delphi a divide by zero error may occur
when the camera was not previously used by a
''C''
application or XCAP.
(27-May-2004).
<p>
</p></li><li>
Fixed Feature:
For SILICON VIDEO® 1281 and 1281C cameras, the maximum exposure
as a function of other parameters, and some internal
''tweaks''
governing timing was not consistent with XCAP.
(17-Jun-2004).
<p>
</p></li><li>
Improved Feature:
For all currently supported DVC CameraLink cameras
video setup files saved by
XCAP now include the serial commands needed to restore
the camera to the operating mode as set in XCAP.
See entry for 27-Oct-2003 for additional information.
(11-Aug-2004).
<p>
</p></li><li>
Added Feature:
Supports the SILICON VIDEO® 9M001 and 9M001C
cameras, including utilizing video setup files saved by
XCAP to restore the camera state.
But does not yet have camera specific API functions.
(19-Sep-2004).
<p>
</p></li><li>
Added Feature:
Access to color pixel values now supports CMY (cyan, magenta, yellow)
color space.
(21-Sep-2004).
<p>
</p></li><li>
Corrected.
Documentation for
<cite class="Ec">pxd_loadBmp</cite>
and
<cite class="Ec">pxd_loadTiff</cite>
has been corrected to describe the existing 0x100 option to
<em class="Ep">loadmode</em>.
(25-Oct-2004).
<p>
</p></li><li>
Added Feature:
Functions
<cite class="Ec">pxd_SV9M001_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV9M001_setResolutionAndTiming</cite>
and other related functions provide camera specific controls
for the SILICON VIDEO® 9M001 and 9M001C cameras.
(25-Oct-2004).
<p>
</p></li><li>
Improved Feature:
XCLIB now recognizes and supports Windows Server 2003, a variant of XP.
(29-Nov-2004)
<p>
</p></li><li>
Fixed Feature:
For the SILICON VIDEO® 1281 and 1281C cameras and when using a
video setup file in non-free run mode.
The call to the first
<cite class="Ec">pxd_SV1281_*()</cite>
function may change the video setup.
Previous workaround was to call
<cite class="Ec">pxd_videoFormatAsIncluded</cite>
after the
<cite class="Ec">pxd_SV1281_*()</cite>
function.
(09-Dec-2004)
<p>
</p></li><li>
Fixed Feature:
For SILICON VIDEO® and other cameras configured for
per-pixel offset and gain corrections, when
a)&nbsp;Using forceful memory allocation,
b)&nbsp;Driver configuration parameter -MB non-zero,
and
c)&nbsp;Frame buffer memory mapped into application space,
the per-pixel corrections may not be applied correctly.
(22-Dec-2004)
<p>
</p></li><li>
Improved Documentation:
For the
<cite class="Ec">pxd_SV2112_</cite>,
<cite class="Ec">pxd_SV1310_</cite>,
<cite class="Ec">pxd_SV1281_</cite>,
and
<cite class="Ec">pxd_SV9M001_</cite>
functions, documentation now notes that
<cite class="Ec">pxd_PIXCIopen</cite>
performs partial, quick initialization of XCLIB;
initialization for these camera
functions is delayed until the first such function is called.
Time sensitive applications should call
any of these camera functions once
before entering the application's time critical phase.
(23-Dec-2004)
<p>
</p></li><li>
Fixed Feature:
Use of clserPIXCI.DLL (the stand-alone Camera Link API) failed under Windows 95, 98
if the PIXCI® was not previously opened by XCLIB or XCAP.
(06-Jan-2005)
<p>
</p></li><li>
Added Feature:
Functions
<cite class="Ec">pxd_SV9M001_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV9M001_setResolutionAndTiming</cite>
and other related functions provide camera specific controls
for the SILICON VIDEO® 9T001C camera.
(27-Feb-2005).
<p>
</p></li><li>
Improved Feature:
The clserPIXCI.DLL (the stand-alone Camera Link API) has been renamed to
clserEPX.dll, and is now compliant with the Camera Link V1.1 specification.
(12-May-2005).
<p>
</p></li><li>
Improved Feature:
The
<cite class="Ec">pxd_xclibEscape</cite>
now returns NULL if the library is not open.
(12-May-2005)
<p>
</p></li><li>
Fixed Feature:
The Linux version of the PIXCI® driver did not work
with the (very) old PIXCI® SV2 and SV3 imaging boards.
(25-Jun-2005)
<p>
</p></li><li>
Fixed Feature:
In beta releases of XCLIB w. support for the PIXCI® CL2,
the
<cite class="Ec">pxd_serialConfigure</cite>
would ONLY work with the CL2, not the older CL1, CL3SD, etc.
(27-Jun-2005).
<p>
</p></li><li>
Improved Feature:
The data rate of the I<sup><small>2</small></sup>C or two wire serial bus
used to control SILICON VIDEO® camera heads can now be
increased via the
''-I2C''
<cite class="Ec">Device Configuration Parameters</cite>
so as to allow faster control of gain and other camera head features
when used with shorter cables.
This feature is particularly useful with 9T001C cameras,
whose camera head's control involves more I<sup><small>2</small></sup>C or two wire serial bus
activity than other SILICON VIDEO® camera heads.
(04-Aug-2005).
<p>
</p></li><li>
Added Feature:
Now supports Linux 2.6.x kernels.
(03-Oct-2005).
<p>
</p></li><li>
Added Feature:
Supports the SILICON VIDEO® 642M and 642C
cameras, including utilizing video setup files saved by
XCAP to restore the camera state.
Functions
<cite class="Ec">pxd_SV640_setExposureAndGain</cite>,
<cite class="Ec">pxd_SV640_setResolutionAndTiming</cite>
and other related functions provide camera specific controls
for the SILICON VIDEO® 642M and 642C cameras.
(23-Nov-2005).
<p>
</p></li><li>
Fixed Feature:
The pxd_readuchar and pxd_readushort functions,
when used to read an AOI of the image
with one function call,
under some memory configurations
may return incorrect pixel data.
(22-Dec-2005).
<p>
</p></li><li>
API Tweak:
The
''cnt''
parameter of
<cite class="Ec">::imageReadUChar</cite>,
<cite class="Ec">::imageWriteUChar</cite>,
<cite class="Ec">::imageReadUShort</cite>,
<cite class="Ec">::imageWriteUShort</cite>,
<cite class="Ec">::imageReadUInt</cite>,
and
<cite class="Ec">::imageWriteUInt</cite>
has been tweaked from
''int''
to
''size_t''.
This has no effect on (current) 32 bit applications.
(18-Jan-2006).
<p>
</p></li><li>
Modified Feature:
The file name of 32 bit Linux drivers has been changed from
<code class="Em">pixcii86.o</code>
or
<code class="Em">pixcii86.ko</code>
to
<code class="Em">pixci_i386.o</code>
or
<code class="Em">pixci_i386.ko</code>.
This will avoid confusion with new 64 bit Linux drivers, to be named
<code class="Em">pixci_x86_64.ko</code>.
Similarly, the file names of 32 bit Linux drivers has changed from
<code class="Em">xclibi86.a</code>
and
<code class="Em">pxipli86.a</code>
to
<code class="Em">xclib_i386.a</code>
and
<code class="Em">pxipl_i386.a</code>
(The
<code class="Em">i386</code>
or
<code class="Em">x86_64</code>
file name components are consistent with
''uname -i'').
(30-Jan-2006).
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® CL1 Rev. 3.
An older XCLIB used with a PIXCI® CL1 Rev. 3
is not able to correctly program the Camera Link
serial baud rate.
(07-Feb-2006)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® E1,
PCI Express imaging board.
Note that Microsoft does not support PCI Express
under Windows 95, 98, ME, or NT; neither does XCLIB.
(20-Feb-2006)
<p>
</p></li><li>
Modified Feature:
High resolution time stamping for Windows NT, 2000, XP
is now the default for all PIXCI® imaging boards.
Previously it was the default only for the PIXCI® CL3SD.
(07-Apr-2006)
<p>
</p></li><li>
API Tweak:
The type of the
<em class="Ep">offset</em>
parameter of
<cite class="Ec">::getVidStatusValue</cite>
has been changed from
<cite class="Ec">uint</cite>
to
<cite class="Ec">size_t</cite>
to better accommodate 64 bit environments.
Ditto the
<em class="Ep">cnt</em>
parameters of
<cite class="Ec">::io</cite>,
<cite class="Ec">::ioctl</cite>,
<cite class="Ec">pxd_readuchar</cite>,
<cite class="Ec">pxd_writeuchar</cite>,
<cite class="Ec">pxd_readushort</cite>,
and
<cite class="Ec">pxd_writeushort</cite>
have been changed from
<cite class="Ec">uint</cite>
or
<cite class="Ec">int</cite>
to
<cite class="Ec">size_t</cite>.
This change does not affect 32 bit environments,
under which the two types are the same size.
(12-May-2006)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® E4, E1DB, and EL1,
PCI Express imaging boards.
(20-Feb-2006)
<p>
</p></li><li>
Improved Feature:
XCLIB now supports the PIXCI® E4DB,
PCI Express imaging board.
(30-Jun-2006)
<p>
</p></li><li>
Modified Feature:
The
<code class="Em">ctobas.exe</code>
utility, to generate VB and VB.NET declarations, is no longer distributed.
The XCLIB distribution not includes VB and VB.NET declarations in
<code class="Em">XCLIB_VB.TXT</code>
and
<code class="Em">XCLIB_VBNET.TXT</code>.
(02-Sep-2006)
<p>
</p></li><li>
Improved Feature:
For Linux, the
the
''-LX''
<cite class="Ec">Driver Configuration Parameter</cite>
allows requesting a higher resolution timer
for time stamping video events.
(06-Nov-2006)
<p>
</p></li><li>
Fixed Feature:
For SILICON VIDEO® 9M001 and 9M001C cameras,
the actual frame period was one line longer than the program's requested
frame period.
(07-Dec-2006)
<p>
</p></li><li>
Improved Feature:
XCLIB now has preliminary support for the PIXCI® EC1,
Express Card imaging boards; the number of general purpose inputs,
outputs, and triggers is not yet finalized.
(18-Dec-2006)
<p>
</p></li><li>
Fixed Feature:
On some computers with hyperthreading or multiple processors,
under Windows NT, 2000, or XP, infrequent errors in Camera Link serial
transmit or receive data may occur.
(26-Dec-2006)
<p>
</p></li><li>
Fixed Feature:
Using XCLIB-Lite, the various file load/save functions
returned PXERMALLOC.
(09-Jan-2007)
<p>
</p></li><li>
Improved Feature:
Drivers for Windows 2000 and XP, as well all Windows DLL's and executables,
are now digitally signed.
(17-Jan-2007)
<p>
</p></li><li>
Improved Feature:
XCLIB now has support for the PIXCI® EL1DB,
Express Card imaging boards.
(18-Dec-2006)
<p>
</p></li><li>
Fixed Feature:
Under Linux, the
<cite class="Ec">pxd_doSnap()</cite>
does not work as documented.
It sometimes takes longer than necessary to complete,
and in case of a timeout returns PXERDEVFAULT instead of PXERTIMEOUT.
(30-Jan-2007)
<p>
</p></li><li>
Fixed Feature:
When using a PIXCI® SI, versions of XCLIB on or after Oct. 2006
may incorrectly report
''Camera head disconnected'',
depending on cable length.
(31-Jan-2007)
<p>
</p></li><li>
Improved Feature:
For SILICON VIDEO® 9T001 cameras,
the (analog) gain and digital gains have been combined into a single,
integrated gain.
The integrated gain is easier to use, and prevents use of less than optimal
settings (such as applying digital gain before the analog gain is maximized).
(09-Feb-2007)
</li></ol>
<br>
<br>
<b class="Hv">RELEASE NOTES: XCLIB  &#8212; Version 2.1</b>
<ol type="1">
<p>
</p><li>
This release supports the PIXCI®&nbsp;SV2, SV3, SV4, D, D24, D32, and A models,
in Watcom+Tenberry extended 32 bit DOS, and Windows 95/98/NT/2000 environments.
Though not documented, the 95/98 driver and library also works in Windows ME.
(28-Aug-2000).
<p>
</p></li><li>
Added feature:
An additional forceful memory allocation method added for Windows ME
using the -IA driver configuration parameter in similar manner as for Windows NT.
(01-Sep-2000).
<p>
</p></li><li>
Fixed feature:
The default format (pixels per clock) for the Pulnix TMC-9700 is incorrect.
(04-Sep-2000)
<p>
</p></li><li>
Fixed feature:
Using
<cite class="Ec">pxd_getGPOut</cite>
or its non-SCF counterpart
with a PIXCI®&nbsp;D, D24, D32, or A
and certain Kodak 10 bit cameras may cause
loss of the 2 least significant bits.
(7-Sep-2000).
<p>
</p></li><li>
Fixed documentation:
Documentation for
<cite class="Ec">pxd_renderDirectVideoInit</cite>,
<cite class="Ec">pxd_renderDirectVideoDone</cite>,
<cite class="Ec">pxd_renderDirectVideoLive</cite>,
and
<cite class="Ec">pxd_renderDirectVideoUnLive</cite>
showed these functions as being named
<cite class="Ec">pxd_DirectVideoInit</cite>,
<cite class="Ec">pxd_DirectVideoDone</cite>,
<cite class="Ec">pxd_DirectVideoLive</cite>,
and
<cite class="Ec">pxd_DirectVideoUnLive</cite>.
The library and .h files are not affected.
(15-Sep-2000).
<p>
</p></li><li>
Fixed feature:
The default format for the Dalsa CA-D4
was incorrectly set as if for a line scan camera.
(19-Sep-2000).
<p>
</p></li><li>
Fixed documentation:
The documentation for
<cite class="Ec">pxd_goLiveSeq</cite>
also referred to a
''pxd_goSnapSeq''
function; the
''pxd_goSnapSeq''
was a typographical error
and should have been
<cite class="Ec">pxd_goLiveSeq</cite>.
(28-Sep-2000).
<p>
</p></li><li>
Added feature:
Support for using interlace cameras with the
PIXCI®&nbsp;D, D24, D32 added with support
for snap, live, and sequence capture.
The
<cite class="Ec">::setLiveTrigBuf</cite>
does not yet support interlace modes.
(29-Sep-2000)
<p>
</p></li><li>
Fixed release:
Versions of XCLIB for Windows NT w/out PXIPL
did not included the EPIXXCWT.SYS driver
and related files.
These files can be obtained from the XCAP release.
(03-Nov-2000)
<p>
</p></li><li>
Added feature:
XCLIB now supports the PIXCI®&nbsp;D2X
series of imaging boards.
(06-Nov-2000)
<p>
</p></li><li>
Fixed documentation:
The documentation for the reserved
<em class="Ep">period</em>
parameter of
<cite class="Ec">::setLivePairBuf</cite>
specified that its value should be 0.
The value should be 1.
(09-Nov-2000).
<p>
</p></li><li>
Added feature:
The
<cite class="Ec">pxd_defineImage</cite>,
<cite class="Ec">pxd_defineImage3</cite>,
<cite class="Ec">pxd_readuchar</cite>,
<cite class="Ec">pxd_readushort</cite>,
<cite class="Ec">pxd_writeuchar</cite>,
and
<cite class="Ec">pxd_writeushort</cite>
now accept
''GRAY''
and
''Gray''
as a synonyms for
''Grey'',
and now accept
''Bayer''
for use in conjunction with cameras
that actually output raw Bayer pattern values, and where the
library would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
(22-Dec-2000).
<p>
</p></li><li>
Modified feature:
For Bayer output cameras, the
''Default''
pixel format is now BGR rather than RGB,
for better display performance when
''Default''
is requested.
(Does not affect code that explicitly requested
BGR format).
(01-Jan-2001).
<p>
</p></li><li>
Fixed feature:
A Driver Configuration Parameter of
''-XM''=0
(a non-default value)
did not work properly with multiple boards installed.
<br>
With multiple boards, one of which having a configuration error
while others are selected for actual use, may result in a spurious
''Can't allocate frame buffer memory''
error.
(02-Jan-2001).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">pxd_defineImage3</cite>
did not accept a
<em class="Ep">colorspace</em>
of
''Default''
(the
<cite class="Ec">pxd_defineImage</cite>
was not affected).
(13-Jan-2001).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">pxd_defineImage</cite>
and
<cite class="Ec">pxd_defineImage3</cite>
area of interest selection may or may not
have the correct effect, depending upon the function
with which the
<cite class="Ec">pxd_defineImage</cite>
or
<cite class="Ec">pxd_defineImage3</cite>
result is used (a new bug only in previous release).
(13-Jan-2001).
<p>
</p></li><li>
Added Feature:
The
<cite class="Ec">pxd_defineImage</cite>
and
<cite class="Ec">pxd_defineImage3</cite>
now accept a
<em class="Ep">colorspace</em>
of
''Display'',
which provides the most efficient color space
for display of the frame buffer through
<cite class="Ec">pxio8_GDIDisplay</cite>
or similar functions.
(13-Jan-2001).
<p>
</p></li><li>
Fixed Feature:
Using forceful memory allocation under Windows NT, Windows 2000, or DOS
with a PIXCI® SV4 would result in unpredictable
behavior the second time (since booting) that the board is opened.
(16-Jan-2001).
<p>
</p></li><li>
Fixed Feature:
Calling
<cite class="Ec">pxd_goLiveSeq</cite>
or
<cite class="Ec">::setLiveSeqBuf</cite>
while a previous
<cite class="Ec">pxd_goLiveSeq</cite>
or
<cite class="Ec">::setLiveSeqBuf</cite>
was in operation did not alter the
<em class="Ep">numbuf</em>
setting .
(17-Jan-2001)
<p>
</p></li><li>
Added Feature:
XCLIB now supports the two G.P In and two G.P Out bits
for the PIXCI®&nbsp;D2X
series of imaging boards.
(24-Jan-2001).
<p>
</p></li><li>
Fixed Feature:
For PIXCI® SV4 imaging boards in
<cite class="Ec">::setLiveSeqBuf</cite>
mode, a
<cite class="Ec">::getLiveStatus</cite>
using
<em class="Ep">PXVIST_RUNNING</em>
always returned 0.
(31-Jan-2001).
<p>
</p></li><li>
Added Feature:
The
<cite class="Ec">pxd_eventFieldCreate</cite>
and
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
allow the application to be signalled
via a Windows event at the start of each field,
and/or at the end of each captured field.
Under Tenberry+DOS,
<cite class="Ec">pxd_eventFieldCreate</cite>
and
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
allow specifying a
''callback''
function to be invoked
at the start of each field,
and/or at the end of each captured field.
(06-Feb-2001).
<p>
</p></li><li>
Improved Feature:
A new EPIXXCW2.SYS driver for Windows 2000
provides better compatibility with newer motherboards.
In particular, it resolves a problem with motherboards
using early 800 series chipsets, which would not provide
interrupts.
The older EPIXXCWT.SYS driver for Windows NT
may still be used under Windows 2000 on all previously supported
motherboards.
(20-Feb-2001).
<p>
</p></li><li>
Fixed feature:
The default format for the SMD 4M15 was incorrect.
(27-Mar-2001).
<p>
</p></li><li>
Added Feature:
New function
<cite class="Ec">pxd_setExsyncPrincMode</cite>,
<cite class="Ec">pxd_getExsyncMode</cite>,
and
<cite class="Ec">pxd_getPrincMode</cite>
allow setting camera configuration bits,
but not suggested for
use in favor of loading a new video configuration format.
<br>
New service
<cite class="Ec">pxd_videoFormatAsIncluded</cite>
allows configuring XCLIB as per a
video configuration format
that has been compiled into the application, and
without re-opening XCLIB.
(01-Apr-2001).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">::setLiveTrigBuf</cite>
used with a PIXCI® SV4 imaging board
did not always set the
''gpout60value''
or
''gpout80value''
correctly.
(08-May-2001)
<p>
</p></li><li>
Added Feature:
The
<cite class="Ec">::setLiveTrigBuf</cite>
is now supported for the
PIXCI® D2X imaging boards.
(09-May-2001).
<p>
</p></li><li>
Added feature:
XCLIB now supports the PIXCI®&nbsp;CL1
series of imaging boards for Camera Link cameras.
New functions
<cite class="Ec">pxd_serialConfigure</cite>,
<cite class="Ec">pxd_serialRead</cite>,
and
<cite class="Ec">pxd_serialWrite</cite>
support reading and writing data through the
PIXCI®&nbsp;CL1.
(15-May-2001).
<p>
</p></li><li>
Fixed feature:
Under Windows NT and 2000, the event created by
<cite class="Ec">pxd_eventFieldCreate</cite>
and
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
is initially signalled; thus the first
<cite class="Ec">WaitForSingleObject</cite>
would always return immediately.
For PIXCI® D2X imaging boards, the event created by
<cite class="Ec">pxd_eventCapturedFieldCreate</cite>
behaved the same as an event created by
<cite class="Ec">pxd_eventFieldCreate</cite>.
(18-May-2001).
<p>
</p></li><li>
Added Feature:
The XCLIB now supports the PIXCI®&nbsp;SV5 imaging board.
(29-May-2001).
<p>
</p></li><li>
Fixed Feature:
Under Windows 2000, the PIXCI®&nbsp;SV5 would appear
as two devices, (1)&nbsp;The SV5, and (2)&nbsp;A
''can't identify imaging board model''.
(18-Jun-2001).
<p>
</p></li><li>
Added Feature:
The XCLIB now support opening multiple, simultaneous, instances of the library;
allowing use of multiple, non-identical, PIXCI® imaging boards.
The multiple instances must be opened from the same process,
with multi-thread synchronization provided by the application program.
(01-Jul-2001).
<p>
</p></li><li>
Fixed Feature:
The new
<cite class="Ec">pxd_serialWrite</cite>
did not function correctly.
(03-Jul-2001).
<p>
</p></li><li>
Modified feature:
For PIXCI® SV2, SV3, SV4, and SV5, for PAL and CCIR,
the default video setup has been changed to avoid capturing black
lines at the top of the image.
(06-Jul-2001).
<p>
</p></li><li>
Fixed Feature:
When using Forceful Memory allocation under Windows NT or 2000,
the frame buffer memory would not be cleared when Windows booted.
Rather, the memory, or a portion of the memory,
would be cleared each time the library/driver was opened.
(18-Jul-2001).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">::setLiveTrigBuf</cite>
did not work with the PIXCI® D2X,
causing program or PC hang-ups.
(20-Jul-2001).
<p>
</p></li><li>
Modified feature:
The size of the serial data buffers for
<cite class="Ec">pxd_serialRead</cite>
and
<cite class="Ec">pxd_serialWrite</cite>
have been increased from 32 bytes to 1024 bytes.
(28-Jul-2001).
<p>
</p></li><li>
Fixed Feature:
For PIXCI® D, D24, D32, D2X, or CL1,
specifying video resolution
''setmaxdatsamples''
or
''setmaxvidsamples''
with insufficient frame buffer memory to achieve maximum resolution
would (correctly) cause the
''setmax...samples''
to be overridden and a less than maximum resolution to be used.
However, the X &amp; Y resolution used, trading X resolution for Y resolution,
would not be consistent.
(05-Aug-2001).
<p>
</p></li><li>
Fixed Feature:
Trying to open a imaging board while already in use
by an earlier application
correctly produced an error, but incorrectly
closed the imaging board and deprived the earlier application
of its use.
(13-Aug-2001).
<p>
</p></li><li>
Fixed Feature:
Support for opening multiple, non-identical, PIXCI® imaging boards
was not fully included in Windows NT/2000 versions.
(17-Aug-2001).
<p>
</p></li><li>
Added Feature:
New functions
<cite class="Ec">pxd_buffersFieldCount</cite>
<cite class="Ec">pxd_buffersGPIn</cite>
<cite class="Ec">pxd_buffersSysTicks</cite>
provide the time and value of the general purpose
inputs for each captured buffer.
(16-Sep-2001).
<p>
</p></li><li>
Added Feature:
New function
<cite class="Ec">pxd_goLiveTrig</cite>
allows using
<cite class="Ec">::setLiveTrigBuf</cite>
within the SCF functions.
(25-Sep-2001).
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">::setLiveTrigBuf</cite>
did not work with the PIXCI® D2X,
causing the
''wait for g.p. input''
to never be satisfied.
(05-Oct-2001).
<p>
</p></li><li>
Fixed Feature:
The
<em class="Ep">colorspace</em>
parameter of
<cite class="Ec">pxd_readuchar</cite>,
<cite class="Ec">pxd_writeuchar</cite>
and similar functions is documented as allowing
a selection of
''YCrCb'',
''YofYCrCb'',
''RofYCrCb'',
and
''BofYCrCb'',
but the library instead required
''YCRCB'',
''YofYCRCB'',
''RofYCRCB'',
and
''BofYCRCB''.
Either
''YCRCB''
or
''YCrCb'',
and their variants,
are now allowed.
(05-Oct-2001)
<p>
</p></li><li>
Fixed Feature:
The
<cite class="Ec">::importStateCopy</cite>
and
<cite class="Ec">::exportStateCopy</cite>,
and the third parameter of
<cite class="Ec">pxd_PIXCIopen</cite>
did not always work properly under Watcom+Tenberry.
(24-Oct-2001).
<p>
</p></li><li>
Modified Feature:
A twelfth parameter,
<em class="Ep">trackers</em>
has been added to
<cite class="Ec">::setLiveSeqBuf</cite>;
existing code should simply add a final parameter of 0.
(28-Oct-2001).
<p>
</p></li><li>
Added feature:
XCLIB now supports the PIXCI®&nbsp;D3X
series of imaging boards.
(Oct-2001)
<p>
</p></li><li>
Added Feature:
XCLIB now supports the G.P. In and G.P. Out bits
that have been added to newer released of PIXCI® CL1 boards.
(12-Nov-2001).
</li></ol>
<br>
<br>
<b class="Hv">RELEASE NOTES: XCLIB  &#8212; Version 0.0 Beta</b>
<ol type="1">
<p>
</p><li>
Fixed Feature.
The
<em class="Ep">pxd_readuchar</em>,
<em class="Ep">pxd_writeuchar</em>,
<em class="Ep">pxd_readushort</em>,
<em class="Ep">pxd_writeushort</em>,
as well as their
<cite class="Ec">::imageReadUChar</cite>,
<cite class="Ec">::imageWriteUChar</cite>
<cite class="Ec">::imageReadUShort</cite>,
<cite class="Ec">::imageWriteUShort</cite>
equivalents do not work properly on an image AOI.
(27-Jun-2000).
</li></ol>
<hr size="3">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;
<a name="Distribution Contents" class="Ch"></a>
<a name="16.  Distribution Contents"></a>
</p><h1>16.  Distribution Contents</h1>
<pre>DISTRIBUTION KIT:
<br>
        C/C++ Library for the PIXCI® Imaging Boards
        XCLIB &amp; XCLIB-Lite - Version 3.7
<br>
The XCLIB or XCLIB-Lite distribution contains one or more of:
<br>
1a) EPIXXCW5.VXD        Windows 95/98/ME 32 bit driver.
    EPIXXCW5.INF        Windows 95/98/ME 32 bit driver installer.
    EPIXXC.SYS          Large image memory reservoir driver for Windows 95/98.
<br>
1b) EPIXXCWT.SYS        Windows NT 32 bit driver (formerly also for Windows 2000).
    EPIXXCWT.INF        Windows NT 32 bit driver installer.
<br>
1c) EPIXXCW2.SYS        Windows 2000/XP/Vista/7 32 bit driver.
    EPIXXCW2.INF        Windows 2000/XP/Vista/7 32 bit driver installer.
    EPIXXCW2.CAT        Windows 2000/XP/Vista/7 32 bit driver catalog.
<br>
1d) pixci_i386.o        Loadable device driver for Linux w. 2.4 32 bit kernel
                        and Intel i386 and newer processors.
<br>
1e) pixci_i386.ko       Loadable device driver for Linux w. 2.6 32 bit kernel
                        and Intel i386 and newer processors.
<br>
1f) EPIXXCW6.SYS        Windows XP(x64)/Vista(x64)/7(x64) 64 bit driver.
    EPIXXCW6.INF        Windows XP(x64)/Vista(x64)/7(x64) 64 bit driver installer.
    EPIXXCW6.CAT        Windows XP(x64)/Vista(x64)/7(x64) 64 bit driver catalog.
<br>
1g) pixci_x86_64.ko     Loadable device driver for Linux w. 2.6 64 bit kernel
                        and Intel 86_x64 and newer processors.
<br>
<br>
2a) XCLIBW95.DLL        XCLIB DLL and Import library for Windows 95/98/ME.
    XCLIBW95.LIB        (Compiler independent).
    XCLIBW95.EXP
<br>
2b) XCLIBWNT.DLL        XCLIB DLL and Import library for Windows NT V4.0,
    XCLIBWNT.LIB        2000, XP, Vista, and 7 (Compiler independent).
    XCLIBWNT.EXP
<br>
2c) XCLIBW64.DLL        XCLIB DLL and Import library for Windows XP(x64),
    XCLIBW64.LIB        Vista(x64), and 7(x64) (Compiler independent).
    XCLIBW64.EXP
<br>
2d) XCLYBW95.DLL        XCLIB-Lite DLL and Import library for Windows 95/98/ME.
    XCLYBW95.LIB        (Compiler independent).
    XCLYBW95.EXP
<br>
2e) XCLYBWNT.DLL        XCLIB-Lite DLL and Import library for Windows NT V4.0,
    XCLYBWNT.LIB        2000, XP, Vista, and 7 (Compiler independent).
    XCLYBWNT.EXP
<br>
<br>
2f) XCLBW1DF.LIB        XCLIB Library, F model, for Tenberry+DOS,
                        Watcom 32 Bit C/C++ V11.0.
<br>
2g) xclib_i386.a        XCLIB Library, static link, for Linux,
                        Intel i386, and GNU 'C'.
<br>
2h) xclib_x86_64.a      XCLIB Library, static link, for Linux,
                        Intel x86_64, and GNU 'C'.
<br>
3a) xcliball.h          Master C include file for programs using XCLIB.
<br>
3b) pxlibsv.h   cext.h             Various C include files for XCLIB.
    pxlibvs.h   cext_hp1.h         Included by inclusion of XCLIBALL.H
    xclibsc.h   cext_hp2.h
    xclibsv.h   cext_hp4.h
    xclibvs.h   cext_hps.h
    xclibver.h  cext_hpe.h
    pximage.h
    pxerrno.h
    pxlibcam.h
<br>
4a) XCLIBEX1.C          Source of example program demonstrating capture
                        and video display on S/VGA and other features
                        under Tenberry+DOS and Windows command line.
<br>
4b) XCLIBEX2.CPP        Source of example programs demonstrating capture
    XCLIBEX2.RC         and video display on S/VGA and other features
    XCLIBEX2.H          under Windows.
    XCLIBEX4.CPP        See comments in file(s) for compilation instructions.
    XCLIBEX4.RC
    XCLIBEX5.CPP
    XCLIBEXP.CPP
<br>
4c) XCLIBEXD.CPP        Source of example program demonstrating
    XCLIBEXD.RC         capture, video display, and control of the
                        SILICON VIDEO® 1281, 1281C, 1310, 1310C,
                        2112, 2112C, 5C10, 5M10, 642M, 642C,
                        643M, 643C, 9M001, 9M001C, 9T001C, 9C10 cameras under Windows.
<br>
4d) XCLIBEX3.TXT        Source of example program for Visual Basic, VB.NET,
    XCLIBEX6.TXT        and C#.NET, respectively.
    XCLIBEX7.TXT        Comments in file provide usage instructions.
    XCLIBEXD.TXT
<br>
4e) xclibel1.c          Source of example programs demonstrating capture,
    xclibel3.c          access to pixel data and other features
                        under Linux. See comments in file(s) for compilation
                        instructions.
<br>
 5) XCLIBW95_VB.TXT     Declarations for Visual Basic, VB.NET, Matlab, &amp; LabView
    XCLIBW95_VBNET.TXT  for Windows 95/98/ME.
    XCLIBW95_IMPORT.H
    XCLIBWNT_VB.TXT     Declarations for Visual Basic, VB.NET, Matlab &amp; LabView
    XCLIBWNT_VBNET.TXT  for Windows NT/2000/XP/Vista/7.
    XCLIBWNT_IMPORT.H
    XCLIBW64_VBNET64.TXT    Declarations for VB.NET, Matlab &amp; LabView for Windows XP, Vista, 7 (x64).
    XCLIBW64_IMPORT.H
<br>
 6) *.txt               One or more ASCII text files containing distribution
                        information, release notes, manual updates, etc.
<br>
 7) xclib.htm           Complete XCLIB C/C++ Library Reference Manual, in HTML format.
<br>
 A) XCLIB C/C++ Library Reference Manual.
                        Not included with XCLIB-Lite.
<br>
Items 1 through 7 distributed on diskettes or CD.
Item A distributed on paper.
</pre>
<hr size="3">
<a name="Footnotes"></a>
<h1>17.  Footnotes</h1>
<dl>
<dt>
<a name="Footnote 1"></a>
[1]
</dt><dd>
The XCLIB-Lite supports only a single imaging board
with a single functional unit.

</dd><dt>
<a name="Footnote 2"></a>
[2]
</dt><dd>
Under Watcom V10.0, there is a well known bug in the ``C'' library's
<cite class="Ec">realloc</cite>;
the
<cite class="Ec">pxrealloc</cite>
is defined differently, and avoids calling
<cite class="Ec">realloc</cite>.

</dd><dt>
<a name="Footnote 3"></a>
[3]
</dt><dd>
The include file(s) attempt to automatically identify
C++ environments and thereby eliminate the need
of using
''extern'',
but the automatic detection may not work with all compilers
or all compiler options.
Inclusion of the explicit
''extern''
is recommended.

</dd><dt>
<a name="Footnote 4"></a>
[4]
</dt><dd>
The XCLIB-Lite does not provide a pointer into the actual image frame buffer.

</dd><dt>
<a name="Footnote 5"></a>
[5]
</dt><dd>
While the XCLIB-Lite allows opening only a single imaging board,
or one half of a PIXCI®&nbsp;E1DB, E4DB, ECB2, EL1DB, ELS2, SI2, or SV7 imaging board,
or one quarter of a PIXCI®&nbsp;SI4,
XCLIB-Lite does allow selecting which of several imaging boards,
or functional half or quarter of an imaging board, is
to be opened.

</dd><dt>
<a name="Footnote 6"></a>
[6]
</dt><dd>
Compatibility requires that the XCAP and XCLIB
be using the same version libraries.

</dd><dt>
<a name="Footnote 7"></a>
[7]
</dt><dd>
The XCLIB-Lite does not support the Structured Style Interface.

</dd><dt>
<a name="Footnote 8"></a>
[8]
</dt><dd>
The XCLIB-Lite does not support the
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>.

</dd><dt>
<a name="Footnote 9"></a>
[9]
</dt><dd>
Aficionados of C++ will recognize this description as a
''virtual class'',
and may think of it as such.
However, for compatibility with
''C''
programs, the
<em class="Ep">pximage</em>
is implemented as a
structure from which member functions are called via function pointers.
Unlike typical class objects, the
<em class="Ep">pximage</em>
may be freely copied and destroyed;
there are no class destructors.

</dd><dt>
<a name="Footnote 10"></a>
[10]
</dt><dd>
E.g. must be
''constructed'',
for C++ aficionados.

</dd><dt>
<a name="Footnote 11"></a>
[11]
</dt><dd>
See the
''Intel Chipset 4 GB System Memory Support''
white paper by Intel Corp.

</dd><dt>
<a name="Footnote 12"></a>
[12]
</dt><dd>
Also referred to as a video setup file.

</dd><dt>
<a name="Footnote 13"></a>
[13]
</dt><dd>
The XCLIB-Lite supports only a single imaging board
with a single functional unit.

</dd><dt>
<a name="Footnote 14"></a>
[14]
</dt><dd>
The XCLIB-Lite does not provide
<a href="#pxd_xclibEscape" class="Er">pxd_xclibEscape</a>
and
<a href="#pxd_xclibEscaped" class="Er">pxd_xclibEscaped</a>.

</dd><dt>
<a name="Footnote 15"></a>
[15]
</dt><dd>
The time provided by the operating system is recorded
by software after the frame is captured, and provided on request.
No claim is made regarding the operating system clock's
accuracy, repeatability, or resolution,
nor the latency between the end of frame capture
and software's recording of the time.

</dd><dt>
<a name="Footnote 16"></a>
[16]
</dt><dd>
The time provided by the operating system is recorded
by software after the frame is captured, and provided on request.
No claim is made regarding the operating system clock's
accuracy, repeatability, or resolution,
nor the latency between the end of frame capture
and software's recording of the time.

</dd><dt>
<a name="Footnote 17"></a>
[17]
</dt><dd>
Obviously these functions take some non-zero
amount of time to execute.
The term
''immediately''
is used relative to video timing and events;
these functions return without waiting
for video events.

</dd><dt>
<a name="Footnote 18"></a>
[18]
</dt><dd>
For all imaging boards, triggered sequence capture
can also be implemented by the application:
Record current value of the General Purpose Input or Trigger,
wait for the value to change, and invoke
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>.
Or, record current value of the General Purpose Input or Trigger, invoke
<a href="#pxd_goLiveSeq" class="Er">pxd_goLiveSeq</a>,
wait for the value to change and invoke
<a href="#pxd_goUnLive" class="Er">pxd_goUnLive</a>.
<p>
The integrated
<a href="#pxd_goLiveSeqTrig" class="Er">pxd_goLiveSeqTrig</a>
function is particularly beneficial when used with very high speed
cameras so as to eliminate the application's
latency in responding to the General Purpose Input or Trigger.

</p></dd><dt>
<a name="Footnote 19"></a>
[19]
</dt><dd>
Unlike the similar
<cite class="Ec">pxd_bdim()</cite>
function of the XCOBJ library,
the number of bits in a
<u class="U">single</u>
color component is returned.

</dd><dt>
<a name="Footnote 20"></a>
[20]
</dt><dd>
Unlike the similar
<cite class="Ec">pxd_ylace()</cite>
function of the XCOBJ library,
the number of fields is returned, not a boolean
as to whether the image frame buffer provides
storage for both fields.

</dd><dt>
<a name="Footnote 21"></a>
[21]
</dt><dd>
Unlike the similar
<cite class="Ec">pxd_ydim()</cite>
function of the XCOBJ library,
the number of pixels in a column including
<u class="U">all</u>
fields of the frame buffer is returned.

</dd><dt>
<a name="Footnote 22"></a>
[22]
</dt><dd>
A reminder regarding file names under DOS and Windows:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<cite class="Ec">The C Programming Language</cite>
by Kernighan &amp; Ritchie or
<cite class="Ec">The C++ Programming Language</cite>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which DOS and Windows accept in liu of a backslash.

</dd><dt>
<a name="Footnote 23"></a>
[23]
</dt><dd>
A reminder regarding file names under DOS and Windows:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<cite class="Ec">The C Programming Language</cite>
by Kernighan &amp; Ritchie or
<cite class="Ec">The C++ Programming Language</cite>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which DOS and Windows accept in liu of a backslash.

</dd><dt>
<a name="Footnote 24"></a>
[24]
</dt><dd>
A reminder regarding file names under DOS and Windows:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<cite class="Ec">The C Programming Language</cite>
by Kernighan &amp; Ritchie or
<cite class="Ec">The C++ Programming Language</cite>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which DOS and Windows accept in liu of a backslash.

</dd><dt>
<a name="Footnote 25"></a>
[25]
</dt><dd>
The
<a href="#pxd_renderDirectVideoInit" class="Er">pxd_renderDirectVideoInit</a>
and related functions currently support only
a single imaging board.

</dd><dt>
<a name="Footnote 26"></a>
[26]
</dt><dd>
The
<a href="#pxd_renderDirectVideoLive" class="Er">pxd_renderDirectVideoLive</a>
and related functions currently supports only
a single imaging board.

</dd><dt>
<a name="Footnote 27"></a>
[27]
</dt><dd>
The stated use of
<em class="Ep">lrx</em>-<em class="Ep">ulx</em>
and
<em class="Ep">lry</em>-<em class="Ep">uly</em>
is not complete and precise, as it doesn't take into account the
<em class="Ep">lrx</em>=-1
or
<em class="Ep">lry</em>=-1
option.

</dd><dt>
<a name="Footnote 28"></a>
[28]
</dt><dd>
For monochrome images and S/VGA adapters providing 8 bits per pixel and a palette,
the rendering could be improved by using the Windows
<cite class="Ec">CreatePalette</cite>,
<cite class="Ec">SelectPalette</cite>,
and
<cite class="Ec">RealizePalette</cite>
functions to define more
grey levels, at the expense of colors used elsewhere on the desktop.

</dd><dt>
<a name="Footnote 29"></a>
[29]
</dt><dd>
See the Camera Link V1.1 specification for a detailed description
of these functions' parameters.

</dd><dt>
<a name="Footnote 30"></a>
[30]
</dt><dd>
The XCLIB-Lite does not support the SCF+ Style Interface.

</dd><dt>
<a name="Footnote 31"></a>
[31]
</dt><dd>
The XCLIB-Lite does not support the Structured Style Interface.

</dd><dt>
<a name="Footnote 32"></a>
[32]
</dt><dd>
A reminder regarding file names under DOS and Windows:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<cite class="Ec">The C Programming Language</cite>
by Kernighan &amp; Ritchie or
<cite class="Ec">The C++ Programming Language</cite>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which DOS and Windows accept in liu of a backslash.

</dd><dt>
<a name="Footnote 33"></a>
[33]
</dt><dd>
A reminder regarding file names under DOS and Windows:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<cite class="Ec">The C Programming Language</cite>
by Kernighan &amp; Ritchie or
<cite class="Ec">The C++ Programming Language</cite>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which DOS and Windows accept in liu of a backslash.

</dd><dt>
<a name="Footnote 34"></a>
[34]
</dt><dd>
The
''CCCC''
is a common Windows macro.
For other environments use:
<blockquote>
<pre>#define CCCC(a,b,c,d)   (((uint32)(a)&lt;&lt;24) | ((uint32)(b)&lt;&lt;16) | ((c)&lt;&lt;8) | (d))
</pre>
</blockquote>
''#define CCCC(a,b,c,d) (((uint32)(a)&lt;&lt;24) | ((uint32)(b)&lt;&lt;16) | ((c)&lt;&lt;8) | (d))''

</dd><dt>
<a name="Footnote 35"></a>
[35]
</dt><dd>
A reminder regarding file names under DOS and Windows:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<cite class="Ec">The C Programming Language</cite>
by Kernighan &amp; Ritchie or
<cite class="Ec">The C++ Programming Language</cite>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which DOS and Windows accept in liu of a backslash.

</dd><dt>
<a name="Footnote 36"></a>
[36]
</dt><dd>
The XCLIB-Lite does not support the
<cite class="Ec">PXIPL Image Processing Library</cite>
or the
<em class="Ep">pximage</em>
and
<em class="Ep">pximage3</em>
interfaces.

</dd><dt>
<a name="Footnote 37"></a>
[37]
</dt><dd>
The
<cite class="Ec">pximage_file</cite>,
and
<cite class="Ec">pximage_memory</cite>
are provided with the
<cite class="Ec">PXIPL Image Processing Library</cite>.

</dd><dt>
<a name="Footnote 38"></a>
[38]
</dt><dd>
These allowed variations do not complicate the typical application program.
When reading and writing pixie values, it typically isn't necessary
to worry about left or right justification, or the following topic
of dirty and clean bits; for most
<em class="Ep">pximage</em>
device drivers,
pixel reads/writes can produce/accept data in the form that the
application program requests/generates.
These detailed specifications allow
an application program to optionally improve
efficiency by using the data in its natural format,
rather than having the data converted.

</dd><dt>
<a name="Footnote 39"></a>
[39]
</dt><dd>
This particular
<em class="Ep">d.pixelhint</em>
begs for an explanation.
When used with
''uchar''
pixie types, and multiple pixels read into a
''uchar''
buffer, on Intel machines with little-endian architecture
(least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, the resulting pixels are compatible with Windows' RGB() data type,
as well as many SVGA cards operating in RGB 32 bit per pixel mode.

</dd><dt>
<a name="Footnote 40"></a>
[40]
</dt><dd>
For
<a href="#::imap" class="Er">::imap</a>,
the information provided is not about the execution time of
<a href="#::imap" class="Er">::imap</a>
itself,
but rather information regarding use of the
pointer returned by
<a href="#::imap" class="Er">::imap</a>.

</dd><dt>
<a name="Footnote 41"></a>
[41]
</dt><dd>
For example, a
<em class="Ep">pximage</em>
(or
<em class="Ep">pximage3</em>)
which references image buffers on a SILICON VIDEO®
or a 4MEG VIDEO imaging board might provide
access only when the board is not capturing or displaying video.

</dd><dt>
<a name="Footnote 42"></a>
[42]
</dt><dd>
For example, on a
<em class="Ep">pximage</em>
(or
<em class="Ep">pximage3</em>)
which references image buffers on a SILICON VIDEO®
or a 4MEG VIDEO imaging board, where video was off during
<em class="Ep">::imapset</em>
and then activated before
<em class="Ep">::imap</em>.
The direct access pointer provided by
<em class="Ep">::imap</em>
could even be invalidated after receipt from
<em class="Ep">::imap</em>,
such as by activating video.
The
<em class="Ep">pximage</em>
(or
<em class="Ep">pximage3</em>)
provides no method of handling invalidation;
during use of the
<em class="Ep">::imap</em>
direct access pointer,
the user must avoid using services beyond the
<em class="Ep">pximage</em>'s
(or
<em class="Ep">pximage3</em>'s)
domain which adversely affect the state of the underlying device.

</dd><dt>
<a name="Footnote 43"></a>
[43]
</dt><dd>
With the exception of the Silicon Imaging 3170 and 3171 cameras,
which are initialized to the manufacturer's suggested default mode
via the Camera Link serial port.

</dd><dt>
<a name="Footnote 44"></a>
[44]
</dt><dd>
Compatibility requires that the XCAP and XCLIB
are using the same version libraries.

</dd><dt>
<a name="Footnote 45"></a>
[45]
</dt><dd>
This example of programming a non-EPIX® imaging product
is provided without warranties of any kind.

</dd><dt>
<a name="Footnote 46"></a>
[46]
</dt><dd>
Compatibility requires that the XCAP and XCLIB
are using the same version libraries.

</dd><dt>
<a name="Footnote 47"></a>
[47]
</dt><dd>
A newer release of XCLIB and XCAP may be required.

</dd><dt>
<a name="Footnote 48"></a>
[48]
</dt><dd>
Compatibility requires that the XCAP and XCLIB
be using the same version libraries.

</dd><dt>
<a name="Footnote 49"></a>
[49]
</dt><dd>
The XCLIB-Lite does not support the
<a href="#pxd_videoFormatAsIncluded" class="Er">pxd_videoFormatAsIncluded</a>.

</dd><dt>
<a name="Footnote 50"></a>
[50]
</dt><dd>
The requirement for a signature is intended to prevent
an imported Video Format Configuration, which contains a
<em class="Ep">pxvidphys</em>,
from accidentally being re-used to specify a user space
or bus physical target.
Closing and re-opening the XCLIB, even within the same
application or process requires new signatures!

</dd><dt>
<a name="Footnote 51"></a>
[51]
</dt><dd>
A
''secondary surface''
is a DirectDraw term.

</dd></dl>
<hr>
<a name="Index" class="Ch"></a>
<h1>Index</h1>
</li><li><a href="#::aeiou%20NX1141" class="NX">::aeiou</a>
</li><li><a href="#::bxta%20NX1171" class="NX">::bxta</a>
</li><li><a href="#::bxtp%20NX1170" class="NX">::bxtp</a>
</li><li><a href="#::bxts%20NX1169" class="NX">::bxts</a>
</li><li><a href="#::bxtw%20NX1172" class="NX">::bxtw</a>
</li><li><a href="#::imap%20NX1183" class="NX">::imap</a>
</li><li><a href="#::imapr%20NX1184" class="NX">::imapr</a>
</li><li><a href="#::imapset%20NX1182" class="NX">::imapset</a>
</li><li><a href="#::iolen%20NX1158" class="NX">::iolen</a>
</li><li><a href="#::ioread%20NX1155" class="NX">::ioread</a>
</li><li><a href="#::iorite%20NX1156" class="NX">::iorite</a>
</li><li><a href="#::ioset%20NX1154" class="NX">::ioset</a>
</li><li><a href="#::iowait%20NX1157" class="NX">::iowait</a>
</li><li><a href="#::pxaux.bufferLoadStream%20NX1014" class="NX">::pxaux.bufferLoadStream</a>
</li><li><a href="#::pxaux.bufferSaveStream%20NX1016" class="NX">::pxaux.bufferSaveStream</a>
</li><li><a href="#::pxaux.errorCodeString%20NX1018" class="NX">::pxaux.errorCodeString</a>
</li><li><a href="#::pxaux.faultMessageBox%20NX1020" class="NX">::pxaux.faultMessageBox</a>
</li><li><a href="#::pxaux.faultPrintf%20NX1022" class="NX">::pxaux.faultPrintf</a>
</li><li><a href="#::pxaux.freeDIB%20NX1054" class="NX">::pxaux.freeDIB</a>
</li><li><a href="#::pxaux.imageLoadBmp%20NX1024" class="NX">::pxaux.imageLoadBmp</a>
</li><li><a href="#::pxaux.imageLoadTiff%20NX1026" class="NX">::pxaux.imageLoadTiff</a>
</li><li><a href="#::pxaux.imageReadUChar%20NX1040" class="NX">::pxaux.imageReadUChar</a>
</li><li><a href="#::pxaux.imageReadUInt%20NX1044" class="NX">::pxaux.imageReadUInt</a>
</li><li><a href="#::pxaux.imageReadUShort%20NX1042" class="NX">::pxaux.imageReadUShort</a>
</li><li><a href="#::pxaux.imageSaveBmp%20NX1028" class="NX">::pxaux.imageSaveBmp</a>
</li><li><a href="#::pxaux.imageSavePcx%20NX1030" class="NX">::pxaux.imageSavePcx</a>
</li><li><a href="#::pxaux.imageSaveTga%20NX1032" class="NX">::pxaux.imageSaveTga</a>
</li><li><a href="#::pxaux.imageSaveTiff%20NX1034" class="NX">::pxaux.imageSaveTiff</a>
</li><li><a href="#::pxaux.imageWriteUChar%20NX1046" class="NX">::pxaux.imageWriteUChar</a>
</li><li><a href="#::pxaux.imageWriteUInt%20NX1050" class="NX">::pxaux.imageWriteUInt</a>
</li><li><a href="#::pxaux.imageWriteUShort%20NX1048" class="NX">::pxaux.imageWriteUShort</a>
</li><li><a href="#::pxaux.makeDIB%20NX1052" class="NX">::pxaux.makeDIB</a>
</li><li><a href="#::pxaux.StretchDIBits%20NX1056" class="NX">::pxaux.StretchDIBits</a>
</li><li><a href="#::pxdev.freeImap%20NX956" class="NX">::pxdev.freeImap</a>
</li><li><a href="#::pxdev.getDevInfo%20NX916" class="NX">::pxdev.getDevInfo</a>
</li><li><a href="#::pxdev.getFault%20NX920" class="NX">::pxdev.getFault</a>
</li><li><a href="#::pxdev.getImap%20NX954" class="NX">::pxdev.getImap</a>
</li><li><a href="#::pxdev.getVidStatus%20NX972" class="NX">::pxdev.getVidStatus</a>
</li><li><a href="#::pxdev.getVidStatusValue%20NX976" class="NX">::pxdev.getVidStatusValue</a>
</li><li><a href="#::pxdev.io%20NX966" class="NX">::pxdev.io</a>
</li><li><a href="#::pxdev.ioctl%20NX1012" class="NX">::pxdev.ioctl</a>
</li><li><a href="#::pxdev.iosparse%20NX968" class="NX">::pxdev.iosparse</a>
</li><li><a href="#::pxlib.allocStateCopy%20NX926" class="NX">::pxlib.allocStateCopy</a>
</li><li><a href="#::pxlib.compareStateCopy%20NX930" class="NX">::pxlib.compareStateCopy</a>
</li><li><a href="#::pxlib.defineState%20NX932" class="NX">::pxlib.defineState</a>
</li><li><a href="#::pxlib.deleteState%20NX934" class="NX">::pxlib.deleteState</a>
</li><li><a href="#::pxlib.exportStateCopy%20NX938" class="NX">::pxlib.exportStateCopy</a>
</li><li><a href="#::pxlib.freeStateCopy%20NX928" class="NX">::pxlib.freeStateCopy</a>
</li><li><a href="#::pxlib.getState%20NX936" class="NX">::pxlib.getState</a>
</li><li><a href="#::pxlib.goingBufStatus%20NX978" class="NX">::pxlib.goingBufStatus</a>
</li><li><a href="#::pxlib.importStateCopy%20NX940" class="NX">::pxlib.importStateCopy</a>
</li><li><a href="#::pxlib.initFilteredPximage%20NX962" class="NX">::pxlib.initFilteredPximage</a>
</li><li><a href="#::pxlib.initFilteredPximage3%20NX964" class="NX">::pxlib.initFilteredPximage3</a>
</li><li><a href="#::pxlib.initPximage%20NX958" class="NX">::pxlib.initPximage</a>
</li><li><a href="#::pxlib.initPximage3%20NX960" class="NX">::pxlib.initPximage3</a>
</li><li><a href="#::pxlib.initStateCopy%20NX948" class="NX">::pxlib.initStateCopy</a>
</li><li><a href="#::setLivePhys%20NX988" class="NX">::setLivePhys</a>
</li><li><a href="#::setLiveSeqBuf%20NX990" class="NX">::setLiveSeqBuf</a>
</li><li><a href="#::setLiveTrigBuf%20NX992" class="NX">::setLiveTrigBuf</a>
</li><li><a href="#::xcdev.getDevInfo%20NX918" class="NX">::xcdev.getDevInfo</a>
</li><li><a href="#::xcdev.getDevParms%20NX922" class="NX">::xcdev.getDevParms</a>
</li><li><a href="#::xcdev.getGpin%20NX1004" class="NX">::xcdev.getGpin</a>
</li><li><a href="#::xcdev.getGpout%20NX1010" class="NX">::xcdev.getGpout</a>
</li><li><a href="#::xcdev.getLiveStatus%20NX970" class="NX">::xcdev.getLiveStatus</a>
</li><li><a href="#::xcdev.getVidStatus%20NX974" class="NX">::xcdev.getVidStatus</a>
</li><li><a href="#::xcdev.setAbortLive%20NX996" class="NX">::xcdev.setAbortLive</a>
</li><li><a href="#::xcdev.setCameraConfig%20NX998" class="NX">::xcdev.setCameraConfig</a>
</li><li><a href="#::xcdev.setDevParms%20NX924" class="NX">::xcdev.setDevParms</a>
</li><li><a href="#::xcdev.setGpin%20NX1006" class="NX">::xcdev.setGpin</a>
</li><li><a href="#::xcdev.setGpout%20NX1008" class="NX">::xcdev.setGpout</a>
</li><li><a href="#::xcdev.setLiveBuf%20NX984" class="NX">::xcdev.setLiveBuf</a>
</li><li><a href="#::xcdev.setLivePairBuf%20NX986" class="NX">::xcdev.setLivePairBuf</a>
</li><li><a href="#::xcdev.setSnapBuf%20NX980" class="NX">::xcdev.setSnapBuf</a>
</li><li><a href="#::xcdev.setSnapPairBuf%20NX982" class="NX">::xcdev.setSnapPairBuf</a>
</li><li><a href="#::xcdev.setUnLive%20NX994" class="NX">::xcdev.setUnLive</a>
</li><li><a href="#::xcdev.setVideoAdjust%20NX1002" class="NX">::xcdev.setVideoAdjust</a>
</li><li><a href="#::xcdev.setVideoConfig%20NX1000" class="NX">::xcdev.setVideoConfig</a>
</li><li><a href="#::xclib.fillStateCopy%20NX944" class="NX">::xclib.fillStateCopy</a>
</li><li><a href="#::xclib.fixxStateCopy%20NX942" class="NX">::xclib.fixxStateCopy</a>
</li><li><a href="#::xclib.signStateCopy%20NX946" class="NX">::xclib.signStateCopy</a>
</li><li><a href="#::xwind%20NX1138" class="NX">::xwind</a>
</li><li><a href="#_cfunacc%20NX42" class="NX">_cfunacc</a>
</li><li><a href="#_cfunfcc%20NX40" class="NX">_cfunfcc</a>
</li><li><a href="#_cfunvcc%20NX41" class="NX">_cfunvcc</a>
</li><li><a href="#_farimap%20NX21" class="NX">_farimap</a>
</li><li><a href="#Abort%20Live/Snap%20into%20Frame%20Buffer%20NX997" class="NX">Abort Live/Snap into Frame Buffer</a>
</li><li><a href="#Adjust%20Video%20Configuration%20NX1003" class="NX">Adjust Video Configuration</a>
</li><li><a href="#AEC%20NX533" class="NX">AEC</a>
</li><li><a href="#AGC%20NX532" class="NX">AGC</a>
</li><li><a href="#Allocate%20Copy%20of%20Video%20State%20NX927" class="NX">Allocate Copy of Video State</a>
</li><li><a href="#BMP%20Format%20NX1037" class="NX">BMP Format</a>
</li><li><a href="#BMP%20Format%20NX356" class="NX">BMP Format</a>
</li><li><a href="#Buffer%27s%20Capture%20Field%20Count%20NX169" class="NX">Buffer's Capture Field Count</a>
</li><li><a href="#Buffer%27s%20Capture%20Field%20Count%20NX565" class="NX">Buffer's Capture Field Count</a>
</li><li><a href="#Buffer%27s%20Capture%20General%20Purpose%20Input%20NX171" class="NX">Buffer's Capture General Purpose Input</a>
</li><li><a href="#Buffer%27s%20Capture%20General%20Purpose%20Input%20NX567" class="NX">Buffer's Capture General Purpose Input</a>
</li><li><a href="#Buffer%27s%20Capture%20System%20Time%20NX173" class="NX">Buffer's Capture System Time</a>
</li><li><a href="#Buffer%27s%20Capture%20System%20Time%20NX175" class="NX">Buffer's Capture System Time</a>
</li><li><a href="#Buffer%27s%20Capture%20System%20Time%20NX569" class="NX">Buffer's Capture System Time</a>
</li><li><a href="#Buffer%27s%20Capture%20System%20Time%20NX571" class="NX">Buffer's Capture System Time</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+1281+NX1074" class="NX">Camera Control: SILICON VIDEO® 1281</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+1310+NX1067" class="NX">Camera Control: SILICON VIDEO® 1310</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+2112+NX1060" class="NX">Camera Control: SILICON VIDEO® 2112</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+5M10/5C10+NX1085" class="NX">Camera Control: SILICON VIDEO® 5M10/5C10</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+642+NX1098" class="NX">Camera Control: SILICON VIDEO® 642</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+643+NX1105" class="NX">Camera Control: SILICON VIDEO® 643</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+9C10+NX1087" class="NX">Camera Control: SILICON VIDEO® 9C10</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+9M001+NX1081" class="NX">Camera Control: SILICON VIDEO® 9M001</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+9T001+NX1083" class="NX">Camera Control: SILICON VIDEO® 9T001</a>
</li><li><a href="#Camera%20Control:+SILICON+VIDEO%AE+WGA+NX1112" class="NX">Camera Control: SILICON VIDEO® WGA</a>
</li><li><a href="#Camera%20Link%20CC%20Output%20Signal:%20Get%20NX185" class="NX">Camera Link CC Output Signal: Get</a>
</li><li><a href="#Camera%20Link%20CC%20Output%20Signal:%20Get%20NX581" class="NX">Camera Link CC Output Signal: Get</a>
</li><li><a href="#Camera%20Link%20CC%20Output%20Signal:%20Set%20NX183" class="NX">Camera Link CC Output Signal: Set</a>
</li><li><a href="#Camera%20Link%20CC%20Output%20Signal:%20Set%20NX579" class="NX">Camera Link CC Output Signal: Set</a>
</li><li><a href="#Camera%20Link%20Serial:%20Close%20NX410" class="NX">Camera Link Serial: Close</a>
</li><li><a href="#Camera%20Link%20Serial:%20Error%20Text%20NX420" class="NX">Camera Link Serial: Error Text</a>
</li><li><a href="#Camera%20Link%20Serial:%20Get%20Baud%20Rates%20NX428" class="NX">Camera Link Serial: Get Baud Rates</a>
</li><li><a href="#Camera%20Link%20Serial:%20Initialize%20NX408" class="NX">Camera Link Serial: Initialize</a>
</li><li><a href="#Camera%20Link%20Serial:%20Manufacturer%20ID%20NX426" class="NX">Camera Link Serial: Manufacturer ID</a>
</li><li><a href="#Camera%20Link%20Serial:%20Ports%20ID%20NX424" class="NX">Camera Link Serial: Ports ID</a>
</li><li><a href="#Camera%20Link%20Serial:%20Ports%20NX422" class="NX">Camera Link Serial: Ports</a>
</li><li><a href="#Camera%20Link%20Serial:%20Read%20Available%20NX416" class="NX">Camera Link Serial: Read Available</a>
</li><li><a href="#Camera%20Link%20Serial:%20Read%20Flush%20NX418" class="NX">Camera Link Serial: Read Flush</a>
</li><li><a href="#Camera%20Link%20Serial:%20Read%20NX412" class="NX">Camera Link Serial: Read</a>
</li><li><a href="#Camera%20Link%20Serial:%20Set%20Baud%20Rate%20NX430" class="NX">Camera Link Serial: Set Baud Rate</a>
</li><li><a href="#Camera%20Link%20Serial:%20Write%20NX414" class="NX">Camera Link Serial: Write</a>
</li><li><a href="#clFlushPort%20NX417" class="NX">clFlushPort</a>
</li><li><a href="#clGetErrorText%20NX419" class="NX">clGetErrorText</a>
</li><li><a href="#clGetManufacturerInfo%20NX425" class="NX">clGetManufacturerInfo</a>
</li><li><a href="#clGetNumBytesAvail%20NX415" class="NX">clGetNumBytesAvail</a>
</li><li><a href="#clGetNumSerialPorts%20NX421" class="NX">clGetNumSerialPorts</a>
</li><li><a href="#clGetSerialPortIdentifier%20NX423" class="NX">clGetSerialPortIdentifier</a>
</li><li><a href="#clGetSupportedBaudRates%20NX427" class="NX">clGetSupportedBaudRates</a>
</li><li><a href="#clSerialClose%20NX409" class="NX">clSerialClose</a>
</li><li><a href="#clSerialInit%20NX407" class="NX">clSerialInit</a>
</li><li><a href="#clSerialRead%20NX411" class="NX">clSerialRead</a>
</li><li><a href="#clSerialWrite%20NX413" class="NX">clSerialWrite</a>
</li><li><a href="#clSetBaudRate%20NX429" class="NX">clSetBaudRate</a>
</li><li><a href="#Compare%20Pair%20of%20Video%20State%20Copies%20NX931" class="NX">Compare Pair of Video State Copies</a>
</li><li><a href="#Compilation%20NX1" class="NX">Compilation</a>
</li><li><a href="#ddch.cnt%20NX52" class="NX">ddch.cnt</a>
</li><li><a href="#ddch.len%20NX51" class="NX">ddch.len</a>
</li><li><a href="#Declare%20Instance%20of%20Video%20Format%20Configuration%20Structures%20NX951" class="NX">Declare Instance of Video Format Configuration Structures</a>
</li><li><a href="#Define%20Video%20State%20NX933" class="NX">Define Video State</a>
</li><li><a href="#Delete%20Video%20State%20NX935" class="NX">Delete Video State</a>
</li><li><a href="#Device%20Control%20NX1013" class="NX">Device Control</a>
</li><li><a href="#DOS%20NX249" class="NX">DOS</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Captured%20Video%20Field%20NX234" class="NX">DOS: Register Callback upon Captured Video Field</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Captured%20Video%20Field%20NX629" class="NX">DOS: Register Callback upon Captured Video Field</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Fault%20NX242" class="NX">DOS: Register Callback upon Fault</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Fault%20NX637" class="NX">DOS: Register Callback upon Fault</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20General%20Purpose%20Trigger%20NX238" class="NX">DOS: Register Callback upon General Purpose Trigger</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20General%20Purpose%20Trigger%20NX633" class="NX">DOS: Register Callback upon General Purpose Trigger</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Serial%20NX246" class="NX">DOS: Register Callback upon Serial</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Serial%20NX641" class="NX">DOS: Register Callback upon Serial</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Video%20Field%20NX230" class="NX">DOS: Register Callback upon Video Field</a>
</li><li><a href="#DOS:%20Register%20Callback%20upon%20Video%20Field%20NX625" class="NX">DOS: Register Callback upon Video Field</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Captured%20Video%20Field%20NX236" class="NX">DOS: Unregister Callback upon Captured Video Field</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Captured%20Video%20Field%20NX631" class="NX">DOS: Unregister Callback upon Captured Video Field</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Fault%20NX244" class="NX">DOS: Unregister Callback upon Fault</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Fault%20NX639" class="NX">DOS: Unregister Callback upon Fault</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20General%20Purpose%20Trigger%20NX240" class="NX">DOS: Unregister Callback upon General Purpose Trigger</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20General%20Purpose%20Trigger%20NX635" class="NX">DOS: Unregister Callback upon General Purpose Trigger</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Serial%20NX248" class="NX">DOS: Unregister Callback upon Serial</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Serial%20NX643" class="NX">DOS: Unregister Callback upon Serial</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Video%20Field%20NX232" class="NX">DOS: Unregister Callback upon Video Field</a>
</li><li><a href="#DOS:%20Unregister%20Callback%20upon%20Video%20Field%20NX627" class="NX">DOS: Unregister Callback upon Video Field</a>
</li><li><a href="#Driver%20Configuration%20Parameters%20NX166" class="NX">Driver Configuration Parameters</a>
</li><li><a href="#EMM386%20NX167" class="NX">EMM386</a>
</li><li><a href="#Errors:%20Check%20&amp;%20Report%20Faults%20NX1021" class="NX">Errors: Check &amp; Report Faults</a>
</li><li><a href="#Errors:%20Check%20&amp;%20Report%20Faults%20NX1023" class="NX">Errors: Check &amp; Report Faults</a>
</li><li><a href="#Errors:%20Check%20&amp;%20Report%20Faults%20NX366" class="NX">Errors: Check &amp; Report Faults</a>
</li><li><a href="#Errors:%20Check%20&amp;%20Report%20Faults%20NX368" class="NX">Errors: Check &amp; Report Faults</a>
</li><li><a href="#Errors:%20Check%20&amp;%20Report%20Faults%20NX763" class="NX">Errors: Check &amp; Report Faults</a>
</li><li><a href="#Errors:%20Check%20&amp;%20Report%20Faults%20NX765" class="NX">Errors: Check &amp; Report Faults</a>
</li><li><a href="#Errors:%20Translate%20Error%20Code%20to%20String%20NX1019" class="NX">Errors: Translate Error Code to String</a>
</li><li><a href="#Errors:%20Translate%20Error%20Code%20to%20String%20NX364" class="NX">Errors: Translate Error Code to String</a>
</li><li><a href="#Export%20Copy%20of%20Video%20State%20NX939" class="NX">Export Copy of Video State</a>
</li><li><a href="#Fill%20Video%20State%20NX945" class="NX">Fill Video State</a>
</li><li><a href="#Fixup%20Video%20State%20NX943" class="NX">Fixup Video State</a>
</li><li><a href="#Free%20Copy%20of%20Video%20State%20NX929" class="NX">Free Copy of Video State</a>
</li><li><a href="#Free%20Pointer%20into%20Imaging%20Board%20Memory%20NX957" class="NX">Free Pointer into Imaging Board Memory</a>
</li><li><a href="#Functional%20Units%20NX48" class="NX">Functional Units</a>
</li><li><a href="#General%20Purpose%20Input%20Signal:%20Reset%20NX1007" class="NX">General Purpose Input Signal: Reset</a>
</li><li><a href="#General%20Purpose%20Input%20Signal:%20Reset%20NX274" class="NX">General Purpose Input Signal: Reset</a>
</li><li><a href="#General%20Purpose%20Input%20Signal:%20Reset%20NX667" class="NX">General Purpose Input Signal: Reset</a>
</li><li><a href="#General%20Purpose%20Input%20Signal:%20Sense%20NX1005" class="NX">General Purpose Input Signal: Sense</a>
</li><li><a href="#General%20Purpose%20Input%20Signal:%20Sense%20NX272" class="NX">General Purpose Input Signal: Sense</a>
</li><li><a href="#General%20Purpose%20Input%20Signal:%20Sense%20NX665" class="NX">General Purpose Input Signal: Sense</a>
</li><li><a href="#General%20Purpose%20Output%20Signal:%20Get%20NX1011" class="NX">General Purpose Output Signal: Get</a>
</li><li><a href="#General%20Purpose%20Output%20Signal:%20Get%20NX278" class="NX">General Purpose Output Signal: Get</a>
</li><li><a href="#General%20Purpose%20Output%20Signal:%20Get%20NX671" class="NX">General Purpose Output Signal: Get</a>
</li><li><a href="#General%20Purpose%20Output%20Signal:%20Set%20NX1009" class="NX">General Purpose Output Signal: Set</a>
</li><li><a href="#General%20Purpose%20Output%20Signal:%20Set%20NX276" class="NX">General Purpose Output Signal: Set</a>
</li><li><a href="#General%20Purpose%20Output%20Signal:%20Set%20NX669" class="NX">General Purpose Output Signal: Set</a>
</li><li><a href="#General%20Purpose%20Trigger%20Count:%20Sense%20NX280" class="NX">General Purpose Trigger Count: Sense</a>
</li><li><a href="#General%20Purpose%20Trigger%20Count:%20Sense%20NX673" class="NX">General Purpose Trigger Count: Sense</a>
</li><li><a href="#Get%20Current%20Buffer%20Status%20NX979" class="NX">Get Current Buffer Status</a>
</li><li><a href="#Get%20Current%20Video%20Status%20NX973" class="NX">Get Current Video Status</a>
</li><li><a href="#Get%20Current%20Video%20Status%20Value%20NX977" class="NX">Get Current Video Status Value</a>
</li><li><a href="#Get%20Driver%20Parameters%20NX923" class="NX">Get Driver Parameters</a>
</li><li><a href="#Get%20EXSYNC%20Counter%20Value%20NX434" class="NX">Get EXSYNC Counter Value</a>
</li><li><a href="#Get%20EXSYNC%20Counter%20Value%20NX801" class="NX">Get EXSYNC Counter Value</a>
</li><li><a href="#Get%20EXSYNC%20Mode%20Bits%20NX440" class="NX">Get EXSYNC Mode Bits</a>
</li><li><a href="#Get%20EXSYNC%20Mode%20Bits%20NX807" class="NX">Get EXSYNC Mode Bits</a>
</li><li><a href="#Get%20Extended%20Imaging%20Board%20and%20Driver%20Information%20NX919" class="NX">Get Extended Imaging Board and Driver Information</a>
</li><li><a href="#Get%20Extended%20Video%20Status%20NX975" class="NX">Get Extended Video Status</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20NX302" class="NX">Get Frame Buffer Image Aspect Ratio</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20NX304" class="NX">Get Frame Buffer Image Aspect Ratio</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20NX707" class="NX">Get Frame Buffer Image Aspect Ratio</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Aspect%20Ratio%20NX709" class="NX">Get Frame Buffer Image Aspect Ratio</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20NX306" class="NX">Get Frame Buffer Image Bit Depth</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20NX308" class="NX">Get Frame Buffer Image Bit Depth</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20NX711" class="NX">Get Frame Buffer Image Bit Depth</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Bit%20Depth%20NX713" class="NX">Get Frame Buffer Image Bit Depth</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20NX310" class="NX">Get Frame Buffer Image Color Components</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20NX312" class="NX">Get Frame Buffer Image Color Components</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20NX715" class="NX">Get Frame Buffer Image Color Components</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Color%20Components%20NX717" class="NX">Get Frame Buffer Image Color Components</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Count%20NX326" class="NX">Get Frame Buffer Image Count</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Count%20NX328" class="NX">Get Frame Buffer Image Count</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Count%20NX731" class="NX">Get Frame Buffer Image Count</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Count%20NX733" class="NX">Get Frame Buffer Image Count</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20NX314" class="NX">Get Frame Buffer Image Field Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20NX316" class="NX">Get Frame Buffer Image Field Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20NX719" class="NX">Get Frame Buffer Image Field Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Field%20Dimension%20NX721" class="NX">Get Frame Buffer Image Field Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20NX318" class="NX">Get Frame Buffer Image Horizontal Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20NX320" class="NX">Get Frame Buffer Image Horizontal Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20NX723" class="NX">Get Frame Buffer Image Horizontal Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Horizontal%20Dimension%20NX725" class="NX">Get Frame Buffer Image Horizontal Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20NX322" class="NX">Get Frame Buffer Image Vertical Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20NX324" class="NX">Get Frame Buffer Image Vertical Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20NX727" class="NX">Get Frame Buffer Image Vertical Dimension</a>
</li><li><a href="#Get%20Frame%20Buffer%20Image%20Vertical%20Dimension%20NX729" class="NX">Get Frame Buffer Image Vertical Dimension</a>
</li><li><a href="#Get%20Imaging%20Board%27s%20Frame%20Buffer%20Size%20NX336" class="NX">Get Imaging Board's Frame Buffer Size</a>
</li><li><a href="#Get%20Imaging%20Board%27s%20Frame%20Buffer%20Size%20NX739" class="NX">Get Imaging Board's Frame Buffer Size</a>
</li><li><a href="#Get%20Imaging%20Board%27s%20Model%20NX338" class="NX">Get Imaging Board's Model</a>
</li><li><a href="#Get%20Imaging%20Board%27s%20Model%20NX741" class="NX">Get Imaging Board's Model</a>
</li><li><a href="#Get%20Imaging%20Board%27s%20Submodel%20NX340" class="NX">Get Imaging Board's Submodel</a>
</li><li><a href="#Get%20Imaging%20Board%27s%20Submodel%20NX743" class="NX">Get Imaging Board's Submodel</a>
</li><li><a href="#Get%20Imaging%20Board%20and%20Driver%20Information%20NX917" class="NX">Get Imaging Board and Driver Information</a>
</li><li><a href="#Get%20Imaging%20Board%20Driver%20ID%20NX330" class="NX">Get Imaging Board Driver ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Driver%20ID%20NX735" class="NX">Get Imaging Board Driver ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Include%20Files%20ID%20NX332" class="NX">Get Imaging Board Include Files ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Include%20Files%20ID%20NX909" class="NX">Get Imaging Board Include Files ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Library%20ID%20NX334" class="NX">Get Imaging Board Library ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Library%20ID%20NX737" class="NX">Get Imaging Board Library ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Library%20ID%20NX911" class="NX">Get Imaging Board Library ID</a>
</li><li><a href="#Get%20Imaging%20Board%20Unit%20Count%20NX342" class="NX">Get Imaging Board Unit Count</a>
</li><li><a href="#Get%20Imaging%20Board%20Unit%20Count%20NX745" class="NX">Get Imaging Board Unit Count</a>
</li><li><a href="#Get%20Live/Snap%20Status%20NX971" class="NX">Get Live/Snap Status</a>
</li><li><a href="#Get%20PRIN%20Counter%20Value%20NX436" class="NX">Get PRIN Counter Value</a>
</li><li><a href="#Get%20PRIN%20Counter%20Value%20NX803" class="NX">Get PRIN Counter Value</a>
</li><li><a href="#Get%20PRINC%20Mode%20Bits%20NX442" class="NX">Get PRINC Mode Bits</a>
</li><li><a href="#Get%20PRINC%20Mode%20Bits%20NX809" class="NX">Get PRINC Mode Bits</a>
</li><li><a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20NX187" class="NX">Get PXIMAGE: Access Imaging Board Frame Buffer</a>
</li><li><a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20NX191" class="NX">Get PXIMAGE: Access Imaging Board Frame Buffer</a>
</li><li><a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20NX583" class="NX">Get PXIMAGE: Access Imaging Board Frame Buffer</a>
</li><li><a href="#Get%20PXIMAGE:%20Access%20Imaging%20Board%20Frame%20Buffer%20NX587" class="NX">Get PXIMAGE: Access Imaging Board Frame Buffer</a>
</li><li><a href="#Get%20PXIMAGE:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20NX195" class="NX">Get PXIMAGE: Release Access to Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20NX591" class="NX">Get PXIMAGE: Release Access to Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20NX189" class="NX">Get PXIMAGE3: Access Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20NX193" class="NX">Get PXIMAGE3: Access Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20NX585" class="NX">Get PXIMAGE3: Access Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE3:%20Access%20Imaging%20Board%20Frame%20Buffers%20NX589" class="NX">Get PXIMAGE3: Access Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE3:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20NX197" class="NX">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20PXIMAGE3:%20Release%20Access%20to%20Imaging%20Board%20Frame%20Buffers%20NX593" class="NX">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20AEC%20Exposure%20NX530" class="NX">Get SILICON VIDEO AEC Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20AEC%20Exposure%20NX881" class="NX">Get SILICON VIDEO AEC Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20AGC%20A%20Gain%20NX526" class="NX">Get SILICON VIDEO AGC A Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20AGC%20A%20Gain%20NX877" class="NX">Get SILICON VIDEO AGC A Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20AGC%20B%20Gain%20NX528" class="NX">Get SILICON VIDEO AGC B Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20AGC%20B%20Gain%20NX879" class="NX">Get SILICON VIDEO AGC B Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Height%20NX505" class="NX">Get SILICON VIDEO Aoi Height</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Height%20NX857" class="NX">Get SILICON VIDEO Aoi Height</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Left%20Edge%20NX499" class="NX">Get SILICON VIDEO Aoi Left Edge</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Left%20Edge%20NX851" class="NX">Get SILICON VIDEO Aoi Left Edge</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Top%20Edge%20NX501" class="NX">Get SILICON VIDEO Aoi Top Edge</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Top%20Edge%20NX853" class="NX">Get SILICON VIDEO Aoi Top Edge</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Width%20NX503" class="NX">Get SILICON VIDEO Aoi Width</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Aoi%20Width%20NX855" class="NX">Get SILICON VIDEO Aoi Width</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20A%20NX486" class="NX">Get SILICON VIDEO Color Gains A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20A%20NX839" class="NX">Get SILICON VIDEO Color Gains A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20B%20NX488" class="NX">Get SILICON VIDEO Color Gains B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Gains%20B%20NX841" class="NX">Get SILICON VIDEO Color Gains B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20A%20NX490" class="NX">Get SILICON VIDEO Color Offsets A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20A%20NX843" class="NX">Get SILICON VIDEO Color Offsets A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20B%20NX492" class="NX">Get SILICON VIDEO Color Offsets B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Color%20Offsets%20B%20NX845" class="NX">Get SILICON VIDEO Color Offsets B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Controlled%20Trigger%20Mode%20NX522" class="NX">Get SILICON VIDEO Controlled Trigger Mode</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Controlled%20Trigger%20Mode%20NX873" class="NX">Get SILICON VIDEO Controlled Trigger Mode</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Controlled%20Video%20Mode%20NX520" class="NX">Get SILICON VIDEO Controlled Video Mode</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Controlled%20Video%20Mode%20NX871" class="NX">Get SILICON VIDEO Controlled Video Mode</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Exposure%20NX480" class="NX">Get SILICON VIDEO Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Exposure%20NX833" class="NX">Get SILICON VIDEO Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Frame%20Period%20NX511" class="NX">Get SILICON VIDEO Frame Period</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Frame%20Period%20NX863" class="NX">Get SILICON VIDEO Frame Period</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Gain%20A%20NX482" class="NX">Get SILICON VIDEO Gain A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Gain%20A%20NX835" class="NX">Get SILICON VIDEO Gain A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Gain%20B%20NX484" class="NX">Get SILICON VIDEO Gain B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Gain%20B%20NX837" class="NX">Get SILICON VIDEO Gain B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AEC%20Exposure%20NX559" class="NX">Get SILICON VIDEO Min/Max AEC Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AEC%20Exposure%20NX907" class="NX">Get SILICON VIDEO Min/Max AEC Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20A%20Gain%20NX555" class="NX">Get SILICON VIDEO Min/Max AGC A Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20A%20Gain%20NX903" class="NX">Get SILICON VIDEO Min/Max AGC A Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20B%20Gain%20NX557" class="NX">Get SILICON VIDEO Min/Max AGC B Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AGC%20B%20Gain%20NX905" class="NX">Get SILICON VIDEO Min/Max AGC B Gain</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Height%20NX553" class="NX">Get SILICON VIDEO Min/Max AOI Height</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Height%20NX901" class="NX">Get SILICON VIDEO Min/Max AOI Height</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Width%20NX551" class="NX">Get SILICON VIDEO Min/Max AOI Width</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20AOI%20Width%20NX899" class="NX">Get SILICON VIDEO Min/Max AOI Width</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Controlled%20Frame%20Rate%20NX539" class="NX">Get SILICON VIDEO Min/Max Controlled Frame Rate</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Controlled%20Frame%20Rate%20NX887" class="NX">Get SILICON VIDEO Min/Max Controlled Frame Rate</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Exposure%20NX535" class="NX">Get SILICON VIDEO Min/Max Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Exposure%20NX883" class="NX">Get SILICON VIDEO Min/Max Exposure</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Frame%20Period%20NX537" class="NX">Get SILICON VIDEO Min/Max Frame Period</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Frame%20Period%20NX885" class="NX">Get SILICON VIDEO Min/Max Frame Period</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20A%20NX543" class="NX">Get SILICON VIDEO Min/Max Gain A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20A%20NX891" class="NX">Get SILICON VIDEO Min/Max Gain A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20B%20NX545" class="NX">Get SILICON VIDEO Min/Max Gain B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Gain%20B%20NX893" class="NX">Get SILICON VIDEO Min/Max Gain B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20A%20NX547" class="NX">Get SILICON VIDEO Min/Max Offset A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20A%20NX895" class="NX">Get SILICON VIDEO Min/Max Offset A</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20B%20NX549" class="NX">Get SILICON VIDEO Min/Max Offset B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Offset%20B%20NX897" class="NX">Get SILICON VIDEO Min/Max Offset B</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Pixel%20Clock%20Frequency%20NX541" class="NX">Get SILICON VIDEO Min/Max Pixel Clock Frequency</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Min/Max%20Pixel%20Clock%20Frequency%20NX889" class="NX">Get SILICON VIDEO Min/Max Pixel Clock Frequency</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Pixel%20Clock%20Frequency%20NX509" class="NX">Get SILICON VIDEO Pixel Clock Frequency</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Pixel%20Clock%20Frequency%20NX861" class="NX">Get SILICON VIDEO Pixel Clock Frequency</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Scan%20Direction%20NX507" class="NX">Get SILICON VIDEO Scan Direction</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Scan%20Direction%20NX859" class="NX">Get SILICON VIDEO Scan Direction</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Subsample%20NX497" class="NX">Get SILICON VIDEO Subsample</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Subsample%20NX849" class="NX">Get SILICON VIDEO Subsample</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Video%20Mode%20NX518" class="NX">Get SILICON VIDEO Video Mode</a>
</li><li><a href="#Get%20SILICON%20VIDEO%20Video%20Mode%20NX869" class="NX">Get SILICON VIDEO Video Mode</a>
</li><li><a href="#Get%20Video%20Brightness%20NX454" class="NX">Get Video Brightness</a>
</li><li><a href="#Get%20Video%20Brightness%20NX675" class="NX">Get Video Brightness</a>
</li><li><a href="#Get%20Video%20Contrast%20NX452" class="NX">Get Video Contrast</a>
</li><li><a href="#Get%20Video%20Contrast%20NX677" class="NX">Get Video Contrast</a>
</li><li><a href="#Get%20Video%20Field%20Characteristic%20NX468" class="NX">Get Video Field Characteristic</a>
</li><li><a href="#Get%20Video%20Field%20Characteristic%20NX470" class="NX">Get Video Field Characteristic</a>
</li><li><a href="#Get%20Video%20Field%20Characteristic%20NX823" class="NX">Get Video Field Characteristic</a>
</li><li><a href="#Get%20Video%20Field%20Characteristic%20NX825" class="NX">Get Video Field Characteristic</a>
</li><li><a href="#Get%20Video%20Field%20Count%20NX466" class="NX">Get Video Field Count</a>
</li><li><a href="#Get%20Video%20Field%20Count%20NX821" class="NX">Get Video Field Count</a>
</li><li><a href="#Get%20Video%20Hue%20NX456" class="NX">Get Video Hue</a>
</li><li><a href="#Get%20Video%20Hue%20NX679" class="NX">Get Video Hue</a>
</li><li><a href="#Get%20Video%20Input%20Multiplexer%20NX450" class="NX">Get Video Input Multiplexer</a>
</li><li><a href="#Get%20Video%20Input%20Multiplexer%20NX685" class="NX">Get Video Input Multiplexer</a>
</li><li><a href="#Get%20Video%20State%20NX937" class="NX">Get Video State</a>
</li><li><a href="#Get%20Video%20U%20Saturation%20NX458" class="NX">Get Video U Saturation</a>
</li><li><a href="#Get%20Video%20U%20Saturation%20NX681" class="NX">Get Video U Saturation</a>
</li><li><a href="#Get%20Video%20V%20Saturation%20NX460" class="NX">Get Video V Saturation</a>
</li><li><a href="#Get%20Video%20V%20Saturation%20NX683" class="NX">Get Video V Saturation</a>
</li><li><a href="#Graphics%20Display%20System%20NX399" class="NX">Graphics Display System</a>
</li><li><a href="#Import%20Copy%20of%20Video%20State%20NX941" class="NX">Import Copy of Video State</a>
</li><li><a href="#Inclusions%20NX3" class="NX">Inclusions</a>
</li><li><a href="#Initialize%20Instance%20of%20Video%20Format%20Configuration%20Structures%20NX953" class="NX">Initialize Instance of Video Format Configuration Structures</a>
</li><li><a href="#Initiate%20Continuous%20Alternate%20Capture%20into%20Frame%20Buffers%20NX987" class="NX">Initiate Continuous Alternate Capture into Frame Buffers</a>
</li><li><a href="#Initiate%20Continuous%20Capture%20into%20Frame%20Buffer%20NX985" class="NX">Initiate Continuous Capture into Frame Buffer</a>
</li><li><a href="#Initiate%20Continuous%20Capture%20into%20Memory%20Space%20NX989" class="NX">Initiate Continuous Capture into Memory Space</a>
</li><li><a href="#Initiate%20Sequence%20Capture%20into%20Frame%20Buffers%20NX991" class="NX">Initiate Sequence Capture into Frame Buffers</a>
</li><li><a href="#Initiate%20Snap%20into%20Frame%20Buffer%20NX981" class="NX">Initiate Snap into Frame Buffer</a>
</li><li><a href="#Initiate%20Snap%20Pair%20into%20Frame%20Buffers%20NX983" class="NX">Initiate Snap Pair into Frame Buffers</a>
</li><li><a href="#Initiate%20Triggered%20Capture%20into%20Frame%20Buffer%20NX993" class="NX">Initiate Triggered Capture into Frame Buffer</a>
</li><li><a href="#Last%20Captured%20Buffer:%20Buffer%20Number%20NX177" class="NX">Last Captured Buffer: Buffer Number</a>
</li><li><a href="#Last%20Captured%20Buffer:%20Buffer%20Number%20NX573" class="NX">Last Captured Buffer: Buffer Number</a>
</li><li><a href="#Last%20Captured%20Buffer:%20Field%20Count%20NX179" class="NX">Last Captured Buffer: Field Count</a>
</li><li><a href="#Last%20Captured%20Buffer:%20Field%20Count%20NX575" class="NX">Last Captured Buffer: Field Count</a>
</li><li><a href="#Last%20Captured%20Buffer:%20System%20Time%20NX181" class="NX">Last Captured Buffer: System Time</a>
</li><li><a href="#Last%20Captured%20Buffer:%20System%20Time%20NX577" class="NX">Last Captured Buffer: System Time</a>
</li><li><a href="#Libraries%20NX0" class="NX">Libraries</a>
</li><li><a href="#Linux%20NX270" class="NX">Linux</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Captured%20Video%20Field%20NX255" class="NX">Linux: Register Signal upon Captured Video Field</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Captured%20Video%20Field%20NX649" class="NX">Linux: Register Signal upon Captured Video Field</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Fault%20NX263" class="NX">Linux: Register Signal upon Fault</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Fault%20NX657" class="NX">Linux: Register Signal upon Fault</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20General%20Purpose%20Trigger%20NX259" class="NX">Linux: Register Signal upon General Purpose Trigger</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20General%20Purpose%20Trigger%20NX653" class="NX">Linux: Register Signal upon General Purpose Trigger</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Serial%20NX267" class="NX">Linux: Register Signal upon Serial</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Serial%20NX661" class="NX">Linux: Register Signal upon Serial</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Video%20Field%20NX251" class="NX">Linux: Register Signal upon Video Field</a>
</li><li><a href="#Linux:%20Register%20Signal%20upon%20Video%20Field%20NX645" class="NX">Linux: Register Signal upon Video Field</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Captured%20Video%20Field%20NX257" class="NX">Linux: Unregister Signal upon Captured Video Field</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Captured%20Video%20Field%20NX651" class="NX">Linux: Unregister Signal upon Captured Video Field</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Fault%20NX265" class="NX">Linux: Unregister Signal upon Fault</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Fault%20NX659" class="NX">Linux: Unregister Signal upon Fault</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20General%20Purpose%20Trigger%20NX261" class="NX">Linux: Unregister Signal upon General Purpose Trigger</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20General%20Purpose%20Trigger%20NX655" class="NX">Linux: Unregister Signal upon General Purpose Trigger</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Serial%20NX269" class="NX">Linux: Unregister Signal upon Serial</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Serial%20NX663" class="NX">Linux: Unregister Signal upon Serial</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Video%20Field%20NX253" class="NX">Linux: Unregister Signal upon Video Field</a>
</li><li><a href="#Linux:%20Unregister%20Signal%20upon%20Video%20Field%20NX647" class="NX">Linux: Unregister Signal upon Video Field</a>
</li><li><a href="#Load%20Frame%20Buffers%20as%20Stream%20NX1015" class="NX">Load Frame Buffers as Stream</a>
</li><li><a href="#Load%20Frame%20Buffers%20NX360" class="NX">Load Frame Buffers</a>
</li><li><a href="#Load%20Frame%20Buffers%20NX759" class="NX">Load Frame Buffers</a>
</li><li><a href="#Load%20Image:%20BMP%20Format%20NX1025" class="NX">Load Image: BMP Format</a>
</li><li><a href="#Load%20Image:%20BMP%20Format%20NX344" class="NX">Load Image: BMP Format</a>
</li><li><a href="#Load%20Image:%20BMP%20Format%20NX747" class="NX">Load Image: BMP Format</a>
</li><li><a href="#Load%20Image:%20TIFF%20Format%20NX1027" class="NX">Load Image: TIFF Format</a>
</li><li><a href="#Load%20Image:%20TIFF%20Format%20NX346" class="NX">Load Image: TIFF Format</a>
</li><li><a href="#Load%20Image:%20TIFF%20Format%20NX749" class="NX">Load Image: TIFF Format</a>
</li><li><a href="#Obtain%20Filtered%20pximage%20Access%20into%20Imaging%20Board%20Memory%20NX963" class="NX">Obtain Filtered pximage Access into Imaging Board Memory</a>
</li><li><a href="#Obtain%20Filtered%20pximage3%20Access%20into%20Imaging%20Board%20Memory%20NX965" class="NX">Obtain Filtered pximage3 Access into Imaging Board Memory</a>
</li><li><a href="#Obtain%20Last%20Logged%20Fault%20NX921" class="NX">Obtain Last Logged Fault</a>
</li><li><a href="#Obtain%20Pointer%20into%20Imaging%20Board%20Memory%20NX955" class="NX">Obtain Pointer into Imaging Board Memory</a>
</li><li><a href="#Obtain%20pximage%20Access%20into%20Imaging%20Board%20Memory%20NX959" class="NX">Obtain pximage Access into Imaging Board Memory</a>
</li><li><a href="#Obtain%20pximage3%20Access%20into%20Imaging%20Board%20Memory%20NX961" class="NX">Obtain pximage3 Access into Imaging Board Memory</a>
</li><li><a href="#PCX%20Format%20NX1039" class="NX">PCX Format</a>
</li><li><a href="#PCX%20Format%20NX358" class="NX">PCX Format</a>
</li><li><a href="#PIXCI%AE+Imaging+Board+Library:+Create+Instance+NX561" class="NX">PIXCI® Imaging Board Library: Create Instance</a>
</li><li><a href="#PIXCI%AE+Imaging+Board+Library:+Uncreate+Instance+NX563" class="NX">PIXCI® Imaging Board Library: Uncreate Instance</a>
</li><li><a href="#PIXCI%AE+Imaging+Board:+Close+NX372" class="NX">PIXCI® Imaging Board: Close</a>
</li><li><a href="#PIXCI%AE+Imaging+Board:+Close+NX769" class="NX">PIXCI® Imaging Board: Close</a>
</li><li><a href="#PIXCI%AE+Imaging+Board:+Open+and+Set+Video+Format+Configuration+NX370" class="NX">PIXCI® Imaging Board: Open and Set Video Format Configuration</a>
</li><li><a href="#PIXCI%AE+Imaging+Board:+Open+and+Set+Video+Format+Configuration+NX767" class="NX">PIXCI® Imaging Board: Open and Set Video Format Configuration</a>
</li><li><a href="#PIXCI%AE+Imaging+Board:+Structured+Close+NX915" class="NX">PIXCI® Imaging Board: Structured Close</a>
</li><li><a href="#PIXCI%AE+Imaging+Board:+Structured+Open+NX913" class="NX">PIXCI® Imaging Board: Structured Open</a>
</li><li><a href="#Printing%20NX400" class="NX">Printing</a>
</li><li><a href="#pxabortfunc_t%20NX46" class="NX">pxabortfunc_t</a>
</li><li><a href="#pxauxservice,%20struct%20NX130" class="NX">pxauxservice, struct</a>
</li><li><a href="#pxauxservice_s%20NX161" class="NX">pxauxservice_s</a>
</li><li><a href="#pxbuffer_t%20NX19" class="NX">pxbuffer_t</a>
</li><li><a href="#pxbufstatus,%20struct%20NX133" class="NX">pxbufstatus, struct</a>
</li><li><a href="#pxbufstatus_s%20NX164" class="NX">pxbufstatus_s</a>
</li><li><a href="#pxbufstatusfile,%20struct%20NX134" class="NX">pxbufstatusfile, struct</a>
</li><li><a href="#pxbufstatusfile_s%20NX165" class="NX">pxbufstatusfile_s</a>
</li><li><a href="#PXCam_SILICONVIDEO032%20NX1111" class="NX">PXCam_SILICONVIDEO032</a>
</li><li><a href="#PXCam_SILICONVIDEO1281%20NX1073" class="NX">PXCam_SILICONVIDEO1281</a>
</li><li><a href="#PXCam_SILICONVIDEO1310%20NX1066" class="NX">PXCam_SILICONVIDEO1310</a>
</li><li><a href="#PXCam_SILICONVIDEO2112%20NX1059" class="NX">PXCam_SILICONVIDEO2112</a>
</li><li><a href="#PXCam_SILICONVIDEO642%20NX1097" class="NX">PXCam_SILICONVIDEO642</a>
</li><li><a href="#PXCam_SILICONVIDEO643%20NX1104" class="NX">PXCam_SILICONVIDEO643</a>
</li><li><a href="#PXCam_SILICONVIDEO9M001%20NX1080" class="NX">PXCam_SILICONVIDEO9M001</a>
</li><li><a href="#PXCam_SILICONVIDEO9M001%20NX1082" class="NX">PXCam_SILICONVIDEO9M001</a>
</li><li><a href="#PXCam_SILICONVIDEO9M001%20NX1084" class="NX">PXCam_SILICONVIDEO9M001</a>
</li><li><a href="#PXCam_SILICONVIDEO9M001%20NX1086" class="NX">PXCam_SILICONVIDEO9M001</a>
</li><li><a href="#PXCam_SV032State,%20struct%20NX1114" class="NX">PXCam_SV032State, struct</a>
</li><li><a href="#PXCam_SV032State_s%20NX1115" class="NX">PXCam_SV032State_s</a>
</li><li><a href="#PXCam_SV1281State,%20struct%20NX1076" class="NX">PXCam_SV1281State, struct</a>
</li><li><a href="#PXCam_SV1281State_s%20NX1077" class="NX">PXCam_SV1281State_s</a>
</li><li><a href="#PXCam_SV1310State,%20struct%20NX1069" class="NX">PXCam_SV1310State, struct</a>
</li><li><a href="#PXCam_SV1310State_s%20NX1070" class="NX">PXCam_SV1310State_s</a>
</li><li><a href="#PXCam_SV2112State,%20struct%20NX1062" class="NX">PXCam_SV2112State, struct</a>
</li><li><a href="#PXCam_SV2112State_s%20NX1063" class="NX">PXCam_SV2112State_s</a>
</li><li><a href="#PXCam_SV642State,%20struct%20NX1100" class="NX">PXCam_SV642State, struct</a>
</li><li><a href="#PXCam_SV642State_s%20NX1101" class="NX">PXCam_SV642State_s</a>
</li><li><a href="#PXCam_SV643State,%20struct%20NX1107" class="NX">PXCam_SV643State, struct</a>
</li><li><a href="#PXCam_SV643State_s%20NX1108" class="NX">PXCam_SV643State_s</a>
</li><li><a href="#PXCam_SV9M001State,%20struct%20NX1089" class="NX">PXCam_SV9M001State, struct</a>
</li><li><a href="#PXCam_SV9M001State_s%20NX1090" class="NX">PXCam_SV9M001State_s</a>
</li><li><a href="#pxcamcntl,%20struct%20NX114" class="NX">pxcamcntl, struct</a>
</li><li><a href="#pxcamcntl_s%20NX145" class="NX">pxcamcntl_s</a>
</li><li><a href="#pxcoord_t%20NX1121" class="NX">pxcoord_t</a>
</li><li><a href="#pxcoord_t%20NX14" class="NX">pxcoord_t</a>
</li><li><a href="#pxd_buffersFieldCount%20NX168" class="NX">pxd_buffersFieldCount</a>
</li><li><a href="#pxd_buffersGPIn%20NX170" class="NX">pxd_buffersGPIn</a>
</li><li><a href="#pxd_buffersSysTicks%20NX172" class="NX">pxd_buffersSysTicks</a>
</li><li><a href="#pxd_buffersSysTicks2%20NX174" class="NX">pxd_buffersSysTicks2</a>
</li><li><a href="#pxd_capturedBuffer%20NX176" class="NX">pxd_capturedBuffer</a>
</li><li><a href="#pxd_capturedFieldCount%20NX178" class="NX">pxd_capturedFieldCount</a>
</li><li><a href="#pxd_capturedSysTicks%20NX180" class="NX">pxd_capturedSysTicks</a>
</li><li><a href="#pxd_defineImage%20NX186" class="NX">pxd_defineImage</a>
</li><li><a href="#pxd_defineImage3%20NX188" class="NX">pxd_defineImage3</a>
</li><li><a href="#pxd_definePximage%20NX190" class="NX">pxd_definePximage</a>
</li><li><a href="#pxd_definePximage3%20NX192" class="NX">pxd_definePximage3</a>
</li><li><a href="#pxd_definePximage3Free%20NX196" class="NX">pxd_definePximage3Free</a>
</li><li><a href="#pxd_definePximageFree%20NX194" class="NX">pxd_definePximageFree</a>
</li><li><a href="#pxd_doSnap%20NX198" class="NX">pxd_doSnap</a>
</li><li><a href="#pxd_eventCapturedFieldClose%20NX210" class="NX">pxd_eventCapturedFieldClose</a>
</li><li><a href="#pxd_eventCapturedFieldClose%20NX235" class="NX">pxd_eventCapturedFieldClose</a>
</li><li><a href="#pxd_eventCapturedFieldClose%20NX256" class="NX">pxd_eventCapturedFieldClose</a>
</li><li><a href="#pxd_eventCapturedFieldCreate%20NX206" class="NX">pxd_eventCapturedFieldCreate</a>
</li><li><a href="#pxd_eventCapturedFieldCreate%20NX233" class="NX">pxd_eventCapturedFieldCreate</a>
</li><li><a href="#pxd_eventCapturedFieldCreate%20NX254" class="NX">pxd_eventCapturedFieldCreate</a>
</li><li><a href="#pxd_eventCapturedFieldCreate2%20NX208" class="NX">pxd_eventCapturedFieldCreate2</a>
</li><li><a href="#pxd_eventFaultClose%20NX222" class="NX">pxd_eventFaultClose</a>
</li><li><a href="#pxd_eventFaultClose%20NX243" class="NX">pxd_eventFaultClose</a>
</li><li><a href="#pxd_eventFaultClose%20NX264" class="NX">pxd_eventFaultClose</a>
</li><li><a href="#pxd_eventFaultCreate%20NX218" class="NX">pxd_eventFaultCreate</a>
</li><li><a href="#pxd_eventFaultCreate%20NX241" class="NX">pxd_eventFaultCreate</a>
</li><li><a href="#pxd_eventFaultCreate%20NX262" class="NX">pxd_eventFaultCreate</a>
</li><li><a href="#pxd_eventFaultCreate2%20NX220" class="NX">pxd_eventFaultCreate2</a>
</li><li><a href="#pxd_eventFieldClose%20NX204" class="NX">pxd_eventFieldClose</a>
</li><li><a href="#pxd_eventFieldClose%20NX231" class="NX">pxd_eventFieldClose</a>
</li><li><a href="#pxd_eventFieldClose%20NX252" class="NX">pxd_eventFieldClose</a>
</li><li><a href="#pxd_eventFieldCreate%20NX200" class="NX">pxd_eventFieldCreate</a>
</li><li><a href="#pxd_eventFieldCreate%20NX229" class="NX">pxd_eventFieldCreate</a>
</li><li><a href="#pxd_eventFieldCreate%20NX250" class="NX">pxd_eventFieldCreate</a>
</li><li><a href="#pxd_eventFieldCreate2%20NX202" class="NX">pxd_eventFieldCreate2</a>
</li><li><a href="#pxd_eventGPTriggerClose%20NX216" class="NX">pxd_eventGPTriggerClose</a>
</li><li><a href="#pxd_eventGPTriggerClose%20NX239" class="NX">pxd_eventGPTriggerClose</a>
</li><li><a href="#pxd_eventGPTriggerClose%20NX260" class="NX">pxd_eventGPTriggerClose</a>
</li><li><a href="#pxd_eventGPTriggerCreate%20NX212" class="NX">pxd_eventGPTriggerCreate</a>
</li><li><a href="#pxd_eventGPTriggerCreate%20NX237" class="NX">pxd_eventGPTriggerCreate</a>
</li><li><a href="#pxd_eventGPTriggerCreate%20NX258" class="NX">pxd_eventGPTriggerCreate</a>
</li><li><a href="#pxd_eventGPTriggerCreate2%20NX214" class="NX">pxd_eventGPTriggerCreate2</a>
</li><li><a href="#pxd_eventSerialClose%20NX226" class="NX">pxd_eventSerialClose</a>
</li><li><a href="#pxd_eventSerialClose%20NX247" class="NX">pxd_eventSerialClose</a>
</li><li><a href="#pxd_eventSerialClose%20NX268" class="NX">pxd_eventSerialClose</a>
</li><li><a href="#pxd_eventSerialCreate%20NX224" class="NX">pxd_eventSerialCreate</a>
</li><li><a href="#pxd_eventSerialCreate%20NX245" class="NX">pxd_eventSerialCreate</a>
</li><li><a href="#pxd_eventSerialCreate%20NX266" class="NX">pxd_eventSerialCreate</a>
</li><li><a href="#pxd_getBrightness%20NX453" class="NX">pxd_getBrightness</a>
</li><li><a href="#pxd_getCameraLinkCCOut%20NX184" class="NX">pxd_getCameraLinkCCOut</a>
</li><li><a href="#pxd_getContrast%20NX451" class="NX">pxd_getContrast</a>
</li><li><a href="#pxd_getExsync%20NX433" class="NX">pxd_getExsync</a>
</li><li><a href="#pxd_getExsyncMode%20NX439" class="NX">pxd_getExsyncMode</a>
</li><li><a href="#pxd_getGPIn%20NX271" class="NX">pxd_getGPIn</a>
</li><li><a href="#pxd_getGPOut%20NX277" class="NX">pxd_getGPOut</a>
</li><li><a href="#pxd_getGPTrigger%20NX279" class="NX">pxd_getGPTrigger</a>
</li><li><a href="#pxd_getHue%20NX455" class="NX">pxd_getHue</a>
</li><li><a href="#pxd_getPrin%20NX435" class="NX">pxd_getPrin</a>
</li><li><a href="#pxd_getPrincMode%20NX441" class="NX">pxd_getPrincMode</a>
</li><li><a href="#pxd_getUGain%20NX457" class="NX">pxd_getUGain</a>
</li><li><a href="#pxd_getVGain%20NX459" class="NX">pxd_getVGain</a>
</li><li><a href="#pxd_getVidMux%20NX449" class="NX">pxd_getVidMux</a>
</li><li><a href="#pxd_goAbortLive%20NX293" class="NX">pxd_goAbortLive</a>
</li><li><a href="#pxd_goLive%20NX285" class="NX">pxd_goLive</a>
</li><li><a href="#pxd_goLivePair%20NX287" class="NX">pxd_goLivePair</a>
</li><li><a href="#pxd_goLiveSeq%20NX289" class="NX">pxd_goLiveSeq</a>
</li><li><a href="#pxd_goLiveSeqTrig%20NX297" class="NX">pxd_goLiveSeqTrig</a>
</li><li><a href="#pxd_goLiveTrig%20NX295" class="NX">pxd_goLiveTrig</a>
</li><li><a href="#pxd_goneLive%20NX299" class="NX">pxd_goneLive</a>
</li><li><a href="#pxd_goSnap%20NX281" class="NX">pxd_goSnap</a>
</li><li><a href="#pxd_goSnapPair%20NX283" class="NX">pxd_goSnapPair</a>
</li><li><a href="#pxd_goUnLive%20NX291" class="NX">pxd_goUnLive</a>
</li><li><a href="#pxd_imageAspectRatio%20NX301" class="NX">pxd_imageAspectRatio</a>
</li><li><a href="#pxd_imageAspectRatio2%20NX303" class="NX">pxd_imageAspectRatio2</a>
</li><li><a href="#pxd_imageBdim%20NX305" class="NX">pxd_imageBdim</a>
</li><li><a href="#pxd_imageBdims%20NX307" class="NX">pxd_imageBdims</a>
</li><li><a href="#pxd_imageCdim%20NX309" class="NX">pxd_imageCdim</a>
</li><li><a href="#pxd_imageCdims%20NX311" class="NX">pxd_imageCdims</a>
</li><li><a href="#pxd_imageIdim%20NX313" class="NX">pxd_imageIdim</a>
</li><li><a href="#pxd_imageIdims%20NX315" class="NX">pxd_imageIdims</a>
</li><li><a href="#pxd_imageXdim%20NX317" class="NX">pxd_imageXdim</a>
</li><li><a href="#pxd_imageXdims%20NX319" class="NX">pxd_imageXdims</a>
</li><li><a href="#pxd_imageYdim%20NX321" class="NX">pxd_imageYdim</a>
</li><li><a href="#pxd_imageYdims%20NX323" class="NX">pxd_imageYdims</a>
</li><li><a href="#pxd_imageZdim%20NX325" class="NX">pxd_imageZdim</a>
</li><li><a href="#pxd_imageZdims%20NX327" class="NX">pxd_imageZdims</a>
</li><li><a href="#pxd_infoDriverId%20NX329" class="NX">pxd_infoDriverId</a>
</li><li><a href="#pxd_infoIncludeId%20NX331" class="NX">pxd_infoIncludeId</a>
</li><li><a href="#pxd_infoLibraryId%20NX333" class="NX">pxd_infoLibraryId</a>
</li><li><a href="#pxd_infoMemsize%20NX335" class="NX">pxd_infoMemsize</a>
</li><li><a href="#pxd_infoModel%20NX337" class="NX">pxd_infoModel</a>
</li><li><a href="#pxd_infoSubmodel%20NX339" class="NX">pxd_infoSubmodel</a>
</li><li><a href="#pxd_infoUnits%20NX341" class="NX">pxd_infoUnits</a>
</li><li><a href="#pxd_loadBmp%20NX343" class="NX">pxd_loadBmp</a>
</li><li><a href="#pxd_loadRawBuffers%20NX359" class="NX">pxd_loadRawBuffers</a>
</li><li><a href="#pxd_loadTiff%20NX345" class="NX">pxd_loadTiff</a>
</li><li><a href="#pxd_mesgErrorCode%20NX363" class="NX">pxd_mesgErrorCode</a>
</li><li><a href="#pxd_mesgFault%20NX365" class="NX">pxd_mesgFault</a>
</li><li><a href="#pxd_mesgFaultText%20NX367" class="NX">pxd_mesgFaultText</a>
</li><li><a href="#pxd_PIXCIclose%20NX371" class="NX">pxd_PIXCIclose</a>
</li><li><a href="#pxd_PIXCIopen%20NX369" class="NX">pxd_PIXCIopen</a>
</li><li><a href="#pxd_readuchar%20NX373" class="NX">pxd_readuchar</a>
</li><li><a href="#pxd_readushort%20NX375" class="NX">pxd_readushort</a>
</li><li><a href="#pxd_renderDIBCreate%20NX381" class="NX">pxd_renderDIBCreate</a>
</li><li><a href="#pxd_renderDIBFree%20NX383" class="NX">pxd_renderDIBFree</a>
</li><li><a href="#pxd_renderDirectVideoDone%20NX387" class="NX">pxd_renderDirectVideoDone</a>
</li><li><a href="#pxd_renderDirectVideoInit%20NX385" class="NX">pxd_renderDirectVideoInit</a>
</li><li><a href="#pxd_renderDirectVideoLive%20NX390" class="NX">pxd_renderDirectVideoLive</a>
</li><li><a href="#pxd_renderDirectVideoUnLive%20NX392" class="NX">pxd_renderDirectVideoUnLive</a>
</li><li><a href="#pxd_renderStretchDIBits%20NX395" class="NX">pxd_renderStretchDIBits</a>
</li><li><a href="#pxd_saveBmp%20NX347" class="NX">pxd_saveBmp</a>
</li><li><a href="#pxd_savePcx%20NX349" class="NX">pxd_savePcx</a>
</li><li><a href="#pxd_saveRawBuffers%20NX361" class="NX">pxd_saveRawBuffers</a>
</li><li><a href="#pxd_saveTga%20NX351" class="NX">pxd_saveTga</a>
</li><li><a href="#pxd_saveTiff%20NX353" class="NX">pxd_saveTiff</a>
</li><li><a href="#pxd_serialConfigure%20NX401" class="NX">pxd_serialConfigure</a>
</li><li><a href="#pxd_serialRead%20NX403" class="NX">pxd_serialRead</a>
</li><li><a href="#pxd_serialWrite%20NX405" class="NX">pxd_serialWrite</a>
</li><li><a href="#pxd_setCameraLinkCCOut%20NX182" class="NX">pxd_setCameraLinkCCOut</a>
</li><li><a href="#pxd_setContrastBrightness%20NX445" class="NX">pxd_setContrastBrightness</a>
</li><li><a href="#pxd_setExsyncPrin%20NX431" class="NX">pxd_setExsyncPrin</a>
</li><li><a href="#pxd_setExsyncPrincMode%20NX437" class="NX">pxd_setExsyncPrincMode</a>
</li><li><a href="#pxd_setGPIn%20NX273" class="NX">pxd_setGPIn</a>
</li><li><a href="#pxd_setGPOut%20NX275" class="NX">pxd_setGPOut</a>
</li><li><a href="#pxd_setHueSaturation%20NX447" class="NX">pxd_setHueSaturation</a>
</li><li><a href="#pxd_setImageBrightBalance%20NX461" class="NX">pxd_setImageBrightBalance</a>
</li><li><a href="#pxd_setImageDarkBalance%20NX463" class="NX">pxd_setImageDarkBalance</a>
</li><li><a href="#pxd_setVidMux%20NX443" class="NX">pxd_setVidMux</a>
</li><li><a href="#pxd_SILICONVIDEO_getAec%20NX529" class="NX">pxd_SILICONVIDEO_getAec</a>
</li><li><a href="#pxd_SILICONVIDEO_getAgcA%20NX525" class="NX">pxd_SILICONVIDEO_getAgcA</a>
</li><li><a href="#pxd_SILICONVIDEO_getAgcB%20NX527" class="NX">pxd_SILICONVIDEO_getAgcB</a>
</li><li><a href="#pxd_SILICONVIDEO_getAoiLeft%20NX498" class="NX">pxd_SILICONVIDEO_getAoiLeft</a>
</li><li><a href="#pxd_SILICONVIDEO_getAoiTop%20NX500" class="NX">pxd_SILICONVIDEO_getAoiTop</a>
</li><li><a href="#pxd_SILICONVIDEO_getAoiTop%20NX502" class="NX">pxd_SILICONVIDEO_getAoiTop</a>
</li><li><a href="#pxd_SILICONVIDEO_getAoiTop%20NX504" class="NX">pxd_SILICONVIDEO_getAoiTop</a>
</li><li><a href="#pxd_SILICONVIDEO_getCtrlTriggerMode%20NX521" class="NX">pxd_SILICONVIDEO_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SILICONVIDEO_getCtrlVideoMode%20NX519" class="NX">pxd_SILICONVIDEO_getCtrlVideoMode</a>
</li><li><a href="#pxd_SILICONVIDEO_getExposure%20NX479" class="NX">pxd_SILICONVIDEO_getExposure</a>
</li><li><a href="#pxd_SILICONVIDEO_getFramePeriod%20NX510" class="NX">pxd_SILICONVIDEO_getFramePeriod</a>
</li><li><a href="#pxd_SILICONVIDEO_getGainA%20NX481" class="NX">pxd_SILICONVIDEO_getGainA</a>
</li><li><a href="#pxd_SILICONVIDEO_getGainB%20NX483" class="NX">pxd_SILICONVIDEO_getGainB</a>
</li><li><a href="#pxd_SILICONVIDEO_getGainsA%20NX485" class="NX">pxd_SILICONVIDEO_getGainsA</a>
</li><li><a href="#pxd_SILICONVIDEO_getGainsB%20NX487" class="NX">pxd_SILICONVIDEO_getGainsB</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxAec%20NX558" class="NX">pxd_SILICONVIDEO_getMinMaxAec</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxAgcA%20NX554" class="NX">pxd_SILICONVIDEO_getMinMaxAgcA</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxAgcB%20NX556" class="NX">pxd_SILICONVIDEO_getMinMaxAgcB</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxAoiHeight%20NX552" class="NX">pxd_SILICONVIDEO_getMinMaxAoiHeight</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxAoiWidth%20NX550" class="NX">pxd_SILICONVIDEO_getMinMaxAoiWidth</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxCtrlFrameRate%20NX538" class="NX">pxd_SILICONVIDEO_getMinMaxCtrlFrameRate</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxExposure%20NX534" class="NX">pxd_SILICONVIDEO_getMinMaxExposure</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxFramePeriod%20NX536" class="NX">pxd_SILICONVIDEO_getMinMaxFramePeriod</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxGainA%20NX542" class="NX">pxd_SILICONVIDEO_getMinMaxGainA</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxGainB%20NX544" class="NX">pxd_SILICONVIDEO_getMinMaxGainB</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxOffsetA%20NX546" class="NX">pxd_SILICONVIDEO_getMinMaxOffsetA</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxOffsetB%20NX548" class="NX">pxd_SILICONVIDEO_getMinMaxOffsetB</a>
</li><li><a href="#pxd_SILICONVIDEO_getMinMaxPixelClock%20NX540" class="NX">pxd_SILICONVIDEO_getMinMaxPixelClock</a>
</li><li><a href="#pxd_SILICONVIDEO_getOffsetsA%20NX489" class="NX">pxd_SILICONVIDEO_getOffsetsA</a>
</li><li><a href="#pxd_SILICONVIDEO_getOffsetsB%20NX491" class="NX">pxd_SILICONVIDEO_getOffsetsB</a>
</li><li><a href="#pxd_SILICONVIDEO_getPixelClock%20NX508" class="NX">pxd_SILICONVIDEO_getPixelClock</a>
</li><li><a href="#pxd_SILICONVIDEO_getScanDirection%20NX506" class="NX">pxd_SILICONVIDEO_getScanDirection</a>
</li><li><a href="#pxd_SILICONVIDEO_getSubsample%20NX496" class="NX">pxd_SILICONVIDEO_getSubsample</a>
</li><li><a href="#pxd_SILICONVIDEO_getVideoMode%20NX517" class="NX">pxd_SILICONVIDEO_getVideoMode</a>
</li><li><a href="#pxd_SILICONVIDEO_setAxC%20NX523" class="NX">pxd_SILICONVIDEO_setAxC</a>
</li><li><a href="#pxd_SILICONVIDEO_setCtrlRates%20NX515" class="NX">pxd_SILICONVIDEO_setCtrlRates</a>
</li><li><a href="#pxd_SILICONVIDEO_setExposure%20NX477" class="NX">pxd_SILICONVIDEO_setExposure</a>
</li><li><a href="#pxd_SILICONVIDEO_setExposureColorGainOffsets%20NX475" class="NX">pxd_SILICONVIDEO_setExposureColorGainOffsets</a>
</li><li><a href="#pxd_SILICONVIDEO_setExposureGainOffset%20NX473" class="NX">pxd_SILICONVIDEO_setExposureGainOffset</a>
</li><li><a href="#pxd_SILICONVIDEO_setResolutionAndTiming%20NX494" class="NX">pxd_SILICONVIDEO_setResolutionAndTiming</a>
</li><li><a href="#pxd_SILICONVIDEO_setVideoAndTriggerMode%20NX513" class="NX">pxd_SILICONVIDEO_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_SV1281_getAoiLeft%20NX1211" class="NX">pxd_SV1281_getAoiLeft</a>
</li><li><a href="#pxd_SV1281_getAoiTop%20NX1210" class="NX">pxd_SV1281_getAoiTop</a>
</li><li><a href="#pxd_SV1281_getCtrlFrameRate%20NX1218" class="NX">pxd_SV1281_getCtrlFrameRate</a>
</li><li><a href="#pxd_SV1281_getCtrlTriggerMode%20NX1217" class="NX">pxd_SV1281_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SV1281_getCtrlVideoMode%20NX1216" class="NX">pxd_SV1281_getCtrlVideoMode</a>
</li><li><a href="#pxd_SV1281_getExposure%20NX1206" class="NX">pxd_SV1281_getExposure</a>
</li><li><a href="#pxd_SV1281_getGain%20NX1207" class="NX">pxd_SV1281_getGain</a>
</li><li><a href="#pxd_SV1281_getMinMaxExposure%20NX1219" class="NX">pxd_SV1281_getMinMaxExposure</a>
</li><li><a href="#pxd_SV1281_getOffset%20NX1208" class="NX">pxd_SV1281_getOffset</a>
</li><li><a href="#pxd_SV1281_getPixelClock%20NX1212" class="NX">pxd_SV1281_getPixelClock</a>
</li><li><a href="#pxd_SV1281_getVideoMode%20NX1215" class="NX">pxd_SV1281_getVideoMode</a>
</li><li><a href="#pxd_SV1281_setCtrlRate%20NX1214" class="NX">pxd_SV1281_setCtrlRate</a>
</li><li><a href="#pxd_SV1281_setExposureGainOffset%20NX1205" class="NX">pxd_SV1281_setExposureGainOffset</a>
</li><li><a href="#pxd_SV1281_setResolutionAndTiming%20NX1209" class="NX">pxd_SV1281_setResolutionAndTiming</a>
</li><li><a href="#pxd_SV1281_setVideoAndTriggerMode%20NX1213" class="NX">pxd_SV1281_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_SV1310_getAoiLeft%20NX1229" class="NX">pxd_SV1310_getAoiLeft</a>
</li><li><a href="#pxd_SV1310_getAoiTop%20NX1228" class="NX">pxd_SV1310_getAoiTop</a>
</li><li><a href="#pxd_SV1310_getColorGain%20NX1225" class="NX">pxd_SV1310_getColorGain</a>
</li><li><a href="#pxd_SV1310_getCtrlFrameRate%20NX1238" class="NX">pxd_SV1310_getCtrlFrameRate</a>
</li><li><a href="#pxd_SV1310_getCtrlTriggerMode%20NX1237" class="NX">pxd_SV1310_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SV1310_getCtrlVideoMode%20NX1236" class="NX">pxd_SV1310_getCtrlVideoMode</a>
</li><li><a href="#pxd_SV1310_getExposure%20NX1221" class="NX">pxd_SV1310_getExposure</a>
</li><li><a href="#pxd_SV1310_getFramePeriod%20NX1232" class="NX">pxd_SV1310_getFramePeriod</a>
</li><li><a href="#pxd_SV1310_getGain%20NX1222" class="NX">pxd_SV1310_getGain</a>
</li><li><a href="#pxd_SV1310_getMinMaxExposure%20NX1239" class="NX">pxd_SV1310_getMinMaxExposure</a>
</li><li><a href="#pxd_SV1310_getOffset%20NX1223" class="NX">pxd_SV1310_getOffset</a>
</li><li><a href="#pxd_SV1310_getPixelClock%20NX1230" class="NX">pxd_SV1310_getPixelClock</a>
</li><li><a href="#pxd_SV1310_getReadoutDirection%20NX1231" class="NX">pxd_SV1310_getReadoutDirection</a>
</li><li><a href="#pxd_SV1310_getSubsample%20NX1227" class="NX">pxd_SV1310_getSubsample</a>
</li><li><a href="#pxd_SV1310_getVideoMode%20NX1235" class="NX">pxd_SV1310_getVideoMode</a>
</li><li><a href="#pxd_SV1310_setColorGain%20NX1224" class="NX">pxd_SV1310_setColorGain</a>
</li><li><a href="#pxd_SV1310_setCtrlRate%20NX1234" class="NX">pxd_SV1310_setCtrlRate</a>
</li><li><a href="#pxd_SV1310_setExposureGainOffset%20NX1220" class="NX">pxd_SV1310_setExposureGainOffset</a>
</li><li><a href="#pxd_SV1310_setResolutionAndTiming%20NX1226" class="NX">pxd_SV1310_setResolutionAndTiming</a>
</li><li><a href="#pxd_SV1310_setVideoAndTriggerMode%20NX1233" class="NX">pxd_SV1310_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_SV2112_getAoiLeft%20NX1193" class="NX">pxd_SV2112_getAoiLeft</a>
</li><li><a href="#pxd_SV2112_getAoiTop%20NX1192" class="NX">pxd_SV2112_getAoiTop</a>
</li><li><a href="#pxd_SV2112_getCtrlExposure%20NX1202" class="NX">pxd_SV2112_getCtrlExposure</a>
</li><li><a href="#pxd_SV2112_getCtrlFrameRate%20NX1201" class="NX">pxd_SV2112_getCtrlFrameRate</a>
</li><li><a href="#pxd_SV2112_getCtrlTriggerMode%20NX1200" class="NX">pxd_SV2112_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SV2112_getCtrlVideoMode%20NX1199" class="NX">pxd_SV2112_getCtrlVideoMode</a>
</li><li><a href="#pxd_SV2112_getDecimation%20NX1191" class="NX">pxd_SV2112_getDecimation</a>
</li><li><a href="#pxd_SV2112_getExposure%20NX1188" class="NX">pxd_SV2112_getExposure</a>
</li><li><a href="#pxd_SV2112_getGain%20NX1189" class="NX">pxd_SV2112_getGain</a>
</li><li><a href="#pxd_SV2112_getMinMaxCtrlExposure%20NX1204" class="NX">pxd_SV2112_getMinMaxCtrlExposure</a>
</li><li><a href="#pxd_SV2112_getMinMaxExposure%20NX1203" class="NX">pxd_SV2112_getMinMaxExposure</a>
</li><li><a href="#pxd_SV2112_getPixelClock%20NX1194" class="NX">pxd_SV2112_getPixelClock</a>
</li><li><a href="#pxd_SV2112_getScanDirection%20NX1195" class="NX">pxd_SV2112_getScanDirection</a>
</li><li><a href="#pxd_SV2112_getVideoMode%20NX1198" class="NX">pxd_SV2112_getVideoMode</a>
</li><li><a href="#pxd_SV2112_setCtrlExposureAndRate%20NX1197" class="NX">pxd_SV2112_setCtrlExposureAndRate</a>
</li><li><a href="#pxd_SV2112_setExposureAndGain%20NX1187" class="NX">pxd_SV2112_setExposureAndGain</a>
</li><li><a href="#pxd_SV2112_setResolutionAndTiming%20NX1190" class="NX">pxd_SV2112_setResolutionAndTiming</a>
</li><li><a href="#pxd_SV2112_setVideoAndTriggerMode%20NX1196" class="NX">pxd_SV2112_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_SV642_getAoiLeft%20NX1246" class="NX">pxd_SV642_getAoiLeft</a>
</li><li><a href="#pxd_SV642_getAoiTop%20NX1245" class="NX">pxd_SV642_getAoiTop</a>
</li><li><a href="#pxd_SV642_getCtrlFrameRate%20NX1253" class="NX">pxd_SV642_getCtrlFrameRate</a>
</li><li><a href="#pxd_SV642_getCtrlTriggerMode%20NX1252" class="NX">pxd_SV642_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SV642_getCtrlVideoMode%20NX1251" class="NX">pxd_SV642_getCtrlVideoMode</a>
</li><li><a href="#pxd_SV642_getExposure%20NX1241" class="NX">pxd_SV642_getExposure</a>
</li><li><a href="#pxd_SV642_getGain%20NX1242" class="NX">pxd_SV642_getGain</a>
</li><li><a href="#pxd_SV642_getGainRange%20NX1243" class="NX">pxd_SV642_getGainRange</a>
</li><li><a href="#pxd_SV642_getMinMaxExposure%20NX1254" class="NX">pxd_SV642_getMinMaxExposure</a>
</li><li><a href="#pxd_SV642_getPixelClock%20NX1247" class="NX">pxd_SV642_getPixelClock</a>
</li><li><a href="#pxd_SV642_getVideoMode%20NX1250" class="NX">pxd_SV642_getVideoMode</a>
</li><li><a href="#pxd_SV642_setCtrlRate%20NX1249" class="NX">pxd_SV642_setCtrlRate</a>
</li><li><a href="#pxd_SV642_setExposureAndGain%20NX1240" class="NX">pxd_SV642_setExposureAndGain</a>
</li><li><a href="#pxd_SV642_setResolutionAndTiming%20NX1244" class="NX">pxd_SV642_setResolutionAndTiming</a>
</li><li><a href="#pxd_SV642_setVideoAndTriggerMode%20NX1248" class="NX">pxd_SV642_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_SV643_getAoiLeft%20NX1262" class="NX">pxd_SV643_getAoiLeft</a>
</li><li><a href="#pxd_SV643_getAoiTop%20NX1261" class="NX">pxd_SV643_getAoiTop</a>
</li><li><a href="#pxd_SV643_getCtrlExposure%20NX1270" class="NX">pxd_SV643_getCtrlExposure</a>
</li><li><a href="#pxd_SV643_getCtrlFrameRate%20NX1269" class="NX">pxd_SV643_getCtrlFrameRate</a>
</li><li><a href="#pxd_SV643_getCtrlTriggerMode%20NX1268" class="NX">pxd_SV643_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SV643_getCtrlVideoMode%20NX1267" class="NX">pxd_SV643_getCtrlVideoMode</a>
</li><li><a href="#pxd_SV643_getExposure%20NX1257" class="NX">pxd_SV643_getExposure</a>
</li><li><a href="#pxd_SV643_getGain%20NX1258" class="NX">pxd_SV643_getGain</a>
</li><li><a href="#pxd_SV643_getMinMaxCtrlExposure%20NX1272" class="NX">pxd_SV643_getMinMaxCtrlExposure</a>
</li><li><a href="#pxd_SV643_getMinMaxExposure%20NX1271" class="NX">pxd_SV643_getMinMaxExposure</a>
</li><li><a href="#pxd_SV643_getOffset%20NX1259" class="NX">pxd_SV643_getOffset</a>
</li><li><a href="#pxd_SV643_getPixelClock%20NX1263" class="NX">pxd_SV643_getPixelClock</a>
</li><li><a href="#pxd_SV643_getVideoMode%20NX1266" class="NX">pxd_SV643_getVideoMode</a>
</li><li><a href="#pxd_SV643_setCtrlExposureAndRate%20NX1265" class="NX">pxd_SV643_setCtrlExposureAndRate</a>
</li><li><a href="#pxd_SV643_setExposureAndGain%20NX1255" class="NX">pxd_SV643_setExposureAndGain</a>
</li><li><a href="#pxd_SV643_setExposureAndGainOffset%20NX1256" class="NX">pxd_SV643_setExposureAndGainOffset</a>
</li><li><a href="#pxd_SV643_setResolutionAndTiming%20NX1260" class="NX">pxd_SV643_setResolutionAndTiming</a>
</li><li><a href="#pxd_SV643_setVideoAndTriggerMode%20NX1264" class="NX">pxd_SV643_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_SV9M001_getAoiLeft%20NX1280" class="NX">pxd_SV9M001_getAoiLeft</a>
</li><li><a href="#pxd_SV9M001_getAoiTop%20NX1279" class="NX">pxd_SV9M001_getAoiTop</a>
</li><li><a href="#pxd_SV9M001_getCtrlFrameRate%20NX1289" class="NX">pxd_SV9M001_getCtrlFrameRate</a>
</li><li><a href="#pxd_SV9M001_getCtrlTriggerMode%20NX1288" class="NX">pxd_SV9M001_getCtrlTriggerMode</a>
</li><li><a href="#pxd_SV9M001_getCtrlVideoMode%20NX1287" class="NX">pxd_SV9M001_getCtrlVideoMode</a>
</li><li><a href="#pxd_SV9M001_getDigitalGain%20NX1277" class="NX">pxd_SV9M001_getDigitalGain</a>
</li><li><a href="#pxd_SV9M001_getExposure%20NX1275" class="NX">pxd_SV9M001_getExposure</a>
</li><li><a href="#pxd_SV9M001_getGain%20NX1276" class="NX">pxd_SV9M001_getGain</a>
</li><li><a href="#pxd_SV9M001_getMinMaxExposure%20NX1290" class="NX">pxd_SV9M001_getMinMaxExposure</a>
</li><li><a href="#pxd_SV9M001_getPixelClock%20NX1283" class="NX">pxd_SV9M001_getPixelClock</a>
</li><li><a href="#pxd_SV9M001_getScanDirection%20NX1281" class="NX">pxd_SV9M001_getScanDirection</a>
</li><li><a href="#pxd_SV9M001_getSubsample%20NX1282" class="NX">pxd_SV9M001_getSubsample</a>
</li><li><a href="#pxd_SV9M001_getVideoMode%20NX1286" class="NX">pxd_SV9M001_getVideoMode</a>
</li><li><a href="#pxd_SV9M001_setCtrlRate%20NX1285" class="NX">pxd_SV9M001_setCtrlRate</a>
</li><li><a href="#pxd_SV9M001_setExposureAndDigitalGain%20NX1274" class="NX">pxd_SV9M001_setExposureAndDigitalGain</a>
</li><li><a href="#pxd_SV9M001_setExposureAndGain%20NX1273" class="NX">pxd_SV9M001_setExposureAndGain</a>
</li><li><a href="#pxd_SV9M001_setResolutionAndTiming%20NX1278" class="NX">pxd_SV9M001_setResolutionAndTiming</a>
</li><li><a href="#pxd_SV9M001_setVideoAndTriggerMode%20NX1284" class="NX">pxd_SV9M001_setVideoAndTriggerMode</a>
</li><li><a href="#pxd_videoFieldCount%20NX465" class="NX">pxd_videoFieldCount</a>
</li><li><a href="#pxd_videoFieldsPerFrame%20NX467" class="NX">pxd_videoFieldsPerFrame</a>
</li><li><a href="#pxd_videoFieldsPerFrames%20NX469" class="NX">pxd_videoFieldsPerFrames</a>
</li><li><a href="#pxd_videoFormatAsIncluded%20NX471" class="NX">pxd_videoFormatAsIncluded</a>
</li><li><a href="#pxd_writeuchar%20NX377" class="NX">pxd_writeuchar</a>
</li><li><a href="#pxd_writeushort%20NX379" class="NX">pxd_writeushort</a>
</li><li><a href="#pxddch,%20struct%20NX104" class="NX">pxddch, struct</a>
</li><li><a href="#pxddch_s%20NX135" class="NX">pxddch_s</a>
</li><li><a href="#pxdevfault,%20struct%20NX124" class="NX">pxdevfault, struct</a>
</li><li><a href="#pxdevfault_s%20NX155" class="NX">pxdevfault_s</a>
</li><li><a href="#pxdevinfo,%20struct%20NX118" class="NX">pxdevinfo, struct</a>
</li><li><a href="#pxdevinfo_s%20NX149" class="NX">pxdevinfo_s</a>
</li><li><a href="#pxdevservice,%20struct%20NX129" class="NX">pxdevservice, struct</a>
</li><li><a href="#pxdevservice_s%20NX160" class="NX">pxdevservice_s</a>
</li><li><a href="#pxe_buffersFieldCount%20NX564" class="NX">pxe_buffersFieldCount</a>
</li><li><a href="#pxe_buffersGPIn%20NX566" class="NX">pxe_buffersGPIn</a>
</li><li><a href="#pxe_buffersSysTicks%20NX568" class="NX">pxe_buffersSysTicks</a>
</li><li><a href="#pxe_buffersSysTicks2%20NX570" class="NX">pxe_buffersSysTicks2</a>
</li><li><a href="#pxe_capturedBuffer%20NX572" class="NX">pxe_capturedBuffer</a>
</li><li><a href="#pxe_capturedFieldCount%20NX574" class="NX">pxe_capturedFieldCount</a>
</li><li><a href="#pxe_capturedSysTicks%20NX576" class="NX">pxe_capturedSysTicks</a>
</li><li><a href="#pxe_defineImage%20NX582" class="NX">pxe_defineImage</a>
</li><li><a href="#pxe_defineImage3%20NX584" class="NX">pxe_defineImage3</a>
</li><li><a href="#pxe_definePximage%20NX586" class="NX">pxe_definePximage</a>
</li><li><a href="#pxe_definePximage3%20NX588" class="NX">pxe_definePximage3</a>
</li><li><a href="#pxe_definePximage3Free%20NX592" class="NX">pxe_definePximage3Free</a>
</li><li><a href="#pxe_definePximageFree%20NX590" class="NX">pxe_definePximageFree</a>
</li><li><a href="#pxe_doSnap%20NX594" class="NX">pxe_doSnap</a>
</li><li><a href="#pxe_eventCapturedFieldClose%20NX606" class="NX">pxe_eventCapturedFieldClose</a>
</li><li><a href="#pxe_eventCapturedFieldClose%20NX630" class="NX">pxe_eventCapturedFieldClose</a>
</li><li><a href="#pxe_eventCapturedFieldClose%20NX650" class="NX">pxe_eventCapturedFieldClose</a>
</li><li><a href="#pxe_eventCapturedFieldCreate%20NX602" class="NX">pxe_eventCapturedFieldCreate</a>
</li><li><a href="#pxe_eventCapturedFieldCreate%20NX628" class="NX">pxe_eventCapturedFieldCreate</a>
</li><li><a href="#pxe_eventCapturedFieldCreate%20NX648" class="NX">pxe_eventCapturedFieldCreate</a>
</li><li><a href="#pxe_eventCapturedFieldCreate2%20NX604" class="NX">pxe_eventCapturedFieldCreate2</a>
</li><li><a href="#pxe_eventFaultClose%20NX618" class="NX">pxe_eventFaultClose</a>
</li><li><a href="#pxe_eventFaultClose%20NX638" class="NX">pxe_eventFaultClose</a>
</li><li><a href="#pxe_eventFaultClose%20NX658" class="NX">pxe_eventFaultClose</a>
</li><li><a href="#pxe_eventFaultCreate%20NX614" class="NX">pxe_eventFaultCreate</a>
</li><li><a href="#pxe_eventFaultCreate%20NX636" class="NX">pxe_eventFaultCreate</a>
</li><li><a href="#pxe_eventFaultCreate%20NX656" class="NX">pxe_eventFaultCreate</a>
</li><li><a href="#pxe_eventFaultCreate2%20NX616" class="NX">pxe_eventFaultCreate2</a>
</li><li><a href="#pxe_eventFieldClose%20NX600" class="NX">pxe_eventFieldClose</a>
</li><li><a href="#pxe_eventFieldClose%20NX626" class="NX">pxe_eventFieldClose</a>
</li><li><a href="#pxe_eventFieldClose%20NX646" class="NX">pxe_eventFieldClose</a>
</li><li><a href="#pxe_eventFieldCreate%20NX596" class="NX">pxe_eventFieldCreate</a>
</li><li><a href="#pxe_eventFieldCreate%20NX624" class="NX">pxe_eventFieldCreate</a>
</li><li><a href="#pxe_eventFieldCreate%20NX644" class="NX">pxe_eventFieldCreate</a>
</li><li><a href="#pxe_eventFieldCreate2%20NX598" class="NX">pxe_eventFieldCreate2</a>
</li><li><a href="#pxe_eventGPTriggerClose%20NX612" class="NX">pxe_eventGPTriggerClose</a>
</li><li><a href="#pxe_eventGPTriggerClose%20NX634" class="NX">pxe_eventGPTriggerClose</a>
</li><li><a href="#pxe_eventGPTriggerClose%20NX654" class="NX">pxe_eventGPTriggerClose</a>
</li><li><a href="#pxe_eventGPTriggerCreate%20NX608" class="NX">pxe_eventGPTriggerCreate</a>
</li><li><a href="#pxe_eventGPTriggerCreate%20NX632" class="NX">pxe_eventGPTriggerCreate</a>
</li><li><a href="#pxe_eventGPTriggerCreate%20NX652" class="NX">pxe_eventGPTriggerCreate</a>
</li><li><a href="#pxe_eventGPTriggerCreate2%20NX610" class="NX">pxe_eventGPTriggerCreate2</a>
</li><li><a href="#pxe_eventSerialClose%20NX622" class="NX">pxe_eventSerialClose</a>
</li><li><a href="#pxe_eventSerialClose%20NX642" class="NX">pxe_eventSerialClose</a>
</li><li><a href="#pxe_eventSerialClose%20NX662" class="NX">pxe_eventSerialClose</a>
</li><li><a href="#pxe_eventSerialCreate%20NX620" class="NX">pxe_eventSerialCreate</a>
</li><li><a href="#pxe_eventSerialCreate%20NX640" class="NX">pxe_eventSerialCreate</a>
</li><li><a href="#pxe_eventSerialCreate%20NX660" class="NX">pxe_eventSerialCreate</a>
</li><li><a href="#pxe_getBrightness%20NX674" class="NX">pxe_getBrightness</a>
</li><li><a href="#pxe_getCameraLinkCCOut%20NX580" class="NX">pxe_getCameraLinkCCOut</a>
</li><li><a href="#pxe_getContrast%20NX676" class="NX">pxe_getContrast</a>
</li><li><a href="#pxe_getExsync%20NX800" class="NX">pxe_getExsync</a>
</li><li><a href="#pxe_getExsyncMode%20NX806" class="NX">pxe_getExsyncMode</a>
</li><li><a href="#pxe_getGPIn%20NX664" class="NX">pxe_getGPIn</a>
</li><li><a href="#pxe_getGPOut%20NX670" class="NX">pxe_getGPOut</a>
</li><li><a href="#pxe_getGPTrigger%20NX672" class="NX">pxe_getGPTrigger</a>
</li><li><a href="#pxe_getHue%20NX678" class="NX">pxe_getHue</a>
</li><li><a href="#pxe_getPrin%20NX802" class="NX">pxe_getPrin</a>
</li><li><a href="#pxe_getPrincMode%20NX808" class="NX">pxe_getPrincMode</a>
</li><li><a href="#pxe_getUGain%20NX680" class="NX">pxe_getUGain</a>
</li><li><a href="#pxe_getVGain%20NX682" class="NX">pxe_getVGain</a>
</li><li><a href="#pxe_getVidMux%20NX684" class="NX">pxe_getVidMux</a>
</li><li><a href="#pxe_goAbortLive%20NX698" class="NX">pxe_goAbortLive</a>
</li><li><a href="#pxe_goLive%20NX690" class="NX">pxe_goLive</a>
</li><li><a href="#pxe_goLivePair%20NX692" class="NX">pxe_goLivePair</a>
</li><li><a href="#pxe_goLiveSeq%20NX694" class="NX">pxe_goLiveSeq</a>
</li><li><a href="#pxe_goLiveSeqTrig%20NX702" class="NX">pxe_goLiveSeqTrig</a>
</li><li><a href="#pxe_goLiveTrig%20NX700" class="NX">pxe_goLiveTrig</a>
</li><li><a href="#pxe_goneLive%20NX704" class="NX">pxe_goneLive</a>
</li><li><a href="#pxe_goSnap%20NX686" class="NX">pxe_goSnap</a>
</li><li><a href="#pxe_goSnapPair%20NX688" class="NX">pxe_goSnapPair</a>
</li><li><a href="#pxe_goUnLive%20NX696" class="NX">pxe_goUnLive</a>
</li><li><a href="#pxe_imageAspectRatio%20NX706" class="NX">pxe_imageAspectRatio</a>
</li><li><a href="#pxe_imageAspectRatio2%20NX708" class="NX">pxe_imageAspectRatio2</a>
</li><li><a href="#pxe_imageBdim%20NX710" class="NX">pxe_imageBdim</a>
</li><li><a href="#pxe_imageBdims%20NX712" class="NX">pxe_imageBdims</a>
</li><li><a href="#pxe_imageCdim%20NX714" class="NX">pxe_imageCdim</a>
</li><li><a href="#pxe_imageCdims%20NX716" class="NX">pxe_imageCdims</a>
</li><li><a href="#pxe_imageIdim%20NX718" class="NX">pxe_imageIdim</a>
</li><li><a href="#pxe_imageIdims%20NX720" class="NX">pxe_imageIdims</a>
</li><li><a href="#pxe_imageXdim%20NX722" class="NX">pxe_imageXdim</a>
</li><li><a href="#pxe_imageXdims%20NX724" class="NX">pxe_imageXdims</a>
</li><li><a href="#pxe_imageYdim%20NX726" class="NX">pxe_imageYdim</a>
</li><li><a href="#pxe_imageYdims%20NX728" class="NX">pxe_imageYdims</a>
</li><li><a href="#pxe_imageZdim%20NX730" class="NX">pxe_imageZdim</a>
</li><li><a href="#pxe_imageZdims%20NX732" class="NX">pxe_imageZdims</a>
</li><li><a href="#pxe_infoDriverId%20NX734" class="NX">pxe_infoDriverId</a>
</li><li><a href="#pxe_infoLibraryId%20NX736" class="NX">pxe_infoLibraryId</a>
</li><li><a href="#pxe_infoMemsize%20NX738" class="NX">pxe_infoMemsize</a>
</li><li><a href="#pxe_infoModel%20NX740" class="NX">pxe_infoModel</a>
</li><li><a href="#pxe_infoSubmodel%20NX742" class="NX">pxe_infoSubmodel</a>
</li><li><a href="#pxe_infoUnits%20NX744" class="NX">pxe_infoUnits</a>
</li><li><a href="#pxe_loadBmp%20NX746" class="NX">pxe_loadBmp</a>
</li><li><a href="#pxe_loadRawBuffers%20NX758" class="NX">pxe_loadRawBuffers</a>
</li><li><a href="#pxe_loadTiff%20NX748" class="NX">pxe_loadTiff</a>
</li><li><a href="#pxe_mesgFault%20NX762" class="NX">pxe_mesgFault</a>
</li><li><a href="#pxe_mesgFaultText%20NX764" class="NX">pxe_mesgFaultText</a>
</li><li><a href="#pxe_PIXCIclose%20NX768" class="NX">pxe_PIXCIclose</a>
</li><li><a href="#pxe_PIXCIopen%20NX766" class="NX">pxe_PIXCIopen</a>
</li><li><a href="#pxe_readuchar%20NX770" class="NX">pxe_readuchar</a>
</li><li><a href="#pxe_readushort%20NX772" class="NX">pxe_readushort</a>
</li><li><a href="#pxe_renderDIBCreate%20NX778" class="NX">pxe_renderDIBCreate</a>
</li><li><a href="#pxe_renderDIBFree%20NX780" class="NX">pxe_renderDIBFree</a>
</li><li><a href="#pxe_renderDirectVideoDone%20NX784" class="NX">pxe_renderDirectVideoDone</a>
</li><li><a href="#pxe_renderDirectVideoInit%20NX782" class="NX">pxe_renderDirectVideoInit</a>
</li><li><a href="#pxe_renderDirectVideoLive%20NX786" class="NX">pxe_renderDirectVideoLive</a>
</li><li><a href="#pxe_renderDirectVideoUnLive%20NX788" class="NX">pxe_renderDirectVideoUnLive</a>
</li><li><a href="#pxe_renderStretchDIBits%20NX790" class="NX">pxe_renderStretchDIBits</a>
</li><li><a href="#pxe_saveBmp%20NX750" class="NX">pxe_saveBmp</a>
</li><li><a href="#pxe_savePcx%20NX752" class="NX">pxe_savePcx</a>
</li><li><a href="#pxe_saveRawBuffers%20NX760" class="NX">pxe_saveRawBuffers</a>
</li><li><a href="#pxe_saveTga%20NX754" class="NX">pxe_saveTga</a>
</li><li><a href="#pxe_saveTiff%20NX756" class="NX">pxe_saveTiff</a>
</li><li><a href="#pxe_serialConfigure%20NX792" class="NX">pxe_serialConfigure</a>
</li><li><a href="#pxe_serialRead%20NX794" class="NX">pxe_serialRead</a>
</li><li><a href="#pxe_serialWrite%20NX796" class="NX">pxe_serialWrite</a>
</li><li><a href="#pxe_setCameraLinkCCOut%20NX578" class="NX">pxe_setCameraLinkCCOut</a>
</li><li><a href="#pxe_setContrastBrightness%20NX812" class="NX">pxe_setContrastBrightness</a>
</li><li><a href="#pxe_setExsyncPrin%20NX798" class="NX">pxe_setExsyncPrin</a>
</li><li><a href="#pxe_setExsyncPrincMode%20NX804" class="NX">pxe_setExsyncPrincMode</a>
</li><li><a href="#pxe_setGPIn%20NX666" class="NX">pxe_setGPIn</a>
</li><li><a href="#pxe_setGPOut%20NX668" class="NX">pxe_setGPOut</a>
</li><li><a href="#pxe_setHueSaturation%20NX814" class="NX">pxe_setHueSaturation</a>
</li><li><a href="#pxe_setImageBrightBalance%20NX816" class="NX">pxe_setImageBrightBalance</a>
</li><li><a href="#pxe_setImageDarkBalance%20NX818" class="NX">pxe_setImageDarkBalance</a>
</li><li><a href="#pxe_setVidMux%20NX810" class="NX">pxe_setVidMux</a>
</li><li><a href="#pxe_SILICONVIDEO_getAec%20NX880" class="NX">pxe_SILICONVIDEO_getAec</a>
</li><li><a href="#pxe_SILICONVIDEO_getAgcA%20NX876" class="NX">pxe_SILICONVIDEO_getAgcA</a>
</li><li><a href="#pxe_SILICONVIDEO_getAgcB%20NX878" class="NX">pxe_SILICONVIDEO_getAgcB</a>
</li><li><a href="#pxe_SILICONVIDEO_getAoiLeft%20NX850" class="NX">pxe_SILICONVIDEO_getAoiLeft</a>
</li><li><a href="#pxe_SILICONVIDEO_getAoiTop%20NX852" class="NX">pxe_SILICONVIDEO_getAoiTop</a>
</li><li><a href="#pxe_SILICONVIDEO_getAoiTop%20NX854" class="NX">pxe_SILICONVIDEO_getAoiTop</a>
</li><li><a href="#pxe_SILICONVIDEO_getAoiTop%20NX856" class="NX">pxe_SILICONVIDEO_getAoiTop</a>
</li><li><a href="#pxe_SILICONVIDEO_getCtrlTriggerMode%20NX872" class="NX">pxe_SILICONVIDEO_getCtrlTriggerMode</a>
</li><li><a href="#pxe_SILICONVIDEO_getCtrlVideoMode%20NX870" class="NX">pxe_SILICONVIDEO_getCtrlVideoMode</a>
</li><li><a href="#pxe_SILICONVIDEO_getExposure%20NX832" class="NX">pxe_SILICONVIDEO_getExposure</a>
</li><li><a href="#pxe_SILICONVIDEO_getFramePeriod%20NX862" class="NX">pxe_SILICONVIDEO_getFramePeriod</a>
</li><li><a href="#pxe_SILICONVIDEO_getGainA%20NX834" class="NX">pxe_SILICONVIDEO_getGainA</a>
</li><li><a href="#pxe_SILICONVIDEO_getGainB%20NX836" class="NX">pxe_SILICONVIDEO_getGainB</a>
</li><li><a href="#pxe_SILICONVIDEO_getGainsA%20NX838" class="NX">pxe_SILICONVIDEO_getGainsA</a>
</li><li><a href="#pxe_SILICONVIDEO_getGainsB%20NX840" class="NX">pxe_SILICONVIDEO_getGainsB</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxAec%20NX906" class="NX">pxe_SILICONVIDEO_getMinMaxAec</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxAgcA%20NX902" class="NX">pxe_SILICONVIDEO_getMinMaxAgcA</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxAgcB%20NX904" class="NX">pxe_SILICONVIDEO_getMinMaxAgcB</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxAoiHeight%20NX900" class="NX">pxe_SILICONVIDEO_getMinMaxAoiHeight</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxAoiWidth%20NX898" class="NX">pxe_SILICONVIDEO_getMinMaxAoiWidth</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxCtrlFrameRate%20NX886" class="NX">pxe_SILICONVIDEO_getMinMaxCtrlFrameRate</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxExposure%20NX882" class="NX">pxe_SILICONVIDEO_getMinMaxExposure</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxFramePeriod%20NX884" class="NX">pxe_SILICONVIDEO_getMinMaxFramePeriod</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxGainA%20NX890" class="NX">pxe_SILICONVIDEO_getMinMaxGainA</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxGainB%20NX892" class="NX">pxe_SILICONVIDEO_getMinMaxGainB</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxOffsetA%20NX894" class="NX">pxe_SILICONVIDEO_getMinMaxOffsetA</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxOffsetB%20NX896" class="NX">pxe_SILICONVIDEO_getMinMaxOffsetB</a>
</li><li><a href="#pxe_SILICONVIDEO_getMinMaxPixelClock%20NX888" class="NX">pxe_SILICONVIDEO_getMinMaxPixelClock</a>
</li><li><a href="#pxe_SILICONVIDEO_getOffsetsA%20NX842" class="NX">pxe_SILICONVIDEO_getOffsetsA</a>
</li><li><a href="#pxe_SILICONVIDEO_getOffsetsB%20NX844" class="NX">pxe_SILICONVIDEO_getOffsetsB</a>
</li><li><a href="#pxe_SILICONVIDEO_getPixelClock%20NX860" class="NX">pxe_SILICONVIDEO_getPixelClock</a>
</li><li><a href="#pxe_SILICONVIDEO_getScanDirection%20NX858" class="NX">pxe_SILICONVIDEO_getScanDirection</a>
</li><li><a href="#pxe_SILICONVIDEO_getSubsample%20NX848" class="NX">pxe_SILICONVIDEO_getSubsample</a>
</li><li><a href="#pxe_SILICONVIDEO_getVideoMode%20NX868" class="NX">pxe_SILICONVIDEO_getVideoMode</a>
</li><li><a href="#pxe_SILICONVIDEO_setAxC%20NX874" class="NX">pxe_SILICONVIDEO_setAxC</a>
</li><li><a href="#pxe_SILICONVIDEO_setCtrlRates%20NX866" class="NX">pxe_SILICONVIDEO_setCtrlRates</a>
</li><li><a href="#pxe_SILICONVIDEO_setExposure%20NX830" class="NX">pxe_SILICONVIDEO_setExposure</a>
</li><li><a href="#pxe_SILICONVIDEO_setExposureColorGainOffsets%20NX828" class="NX">pxe_SILICONVIDEO_setExposureColorGainOffsets</a>
</li><li><a href="#pxe_SILICONVIDEO_setExposureGainOffset%20NX826" class="NX">pxe_SILICONVIDEO_setExposureGainOffset</a>
</li><li><a href="#pxe_SILICONVIDEO_setResolutionAndTiming%20NX846" class="NX">pxe_SILICONVIDEO_setResolutionAndTiming</a>
</li><li><a href="#pxe_SILICONVIDEO_setVideoAndTriggerMode%20NX864" class="NX">pxe_SILICONVIDEO_setVideoAndTriggerMode</a>
</li><li><a href="#pxe_videoFieldCount%20NX820" class="NX">pxe_videoFieldCount</a>
</li><li><a href="#pxe_videoFieldsPerFrame%20NX822" class="NX">pxe_videoFieldsPerFrame</a>
</li><li><a href="#pxe_videoFieldsPerFrames%20NX824" class="NX">pxe_videoFieldsPerFrames</a>
</li><li><a href="#pxe_writeuchar%20NX774" class="NX">pxe_writeuchar</a>
</li><li><a href="#pxe_writeushort%20NX776" class="NX">pxe_writeushort</a>
</li><li><a href="#pxe_XCLIBinstantiate%20NX560" class="NX">pxe_XCLIBinstantiate</a>
</li><li><a href="#pxe_XCLIBuninstantiate%20NX562" class="NX">pxe_XCLIBuninstantiate</a>
</li><li><a href="#pxim1size_t%20NX16" class="NX">pxim1size_t</a>
</li><li><a href="#pxim2size_t%20NX17" class="NX">pxim2size_t</a>
</li><li><a href="#pxim3size_t%20NX18" class="NX">pxim3size_t</a>
</li><li><a href="#pximadrs,%20struct%20NX1174" class="NX">pximadrs, struct</a>
</li><li><a href="#pximadrs_s%20NX1175" class="NX">pximadrs_s</a>
</li><li><a href="#pximaeiou_t%20NX1143" class="NX">pximaeiou_t</a>
</li><li><a href="#pximage,%20struct%20NX68" class="NX">pximage, struct</a>
</li><li><a href="#PXIMAGE:%20Access%20Non-Sequential%20Pixels%20NX1166" class="NX">PXIMAGE: Access Non-Sequential Pixels</a>
</li><li><a href="#PXIMAGE:%20Get%20Advice,%20Errors,%20Info%20&amp;%20Options%20NX1140" class="NX">PXIMAGE: Get Advice, Errors, Info &amp; Options</a>
</li><li><a href="#PXIMAGE:%20Image%20and%20Pixel%20Specifications%20NX1119" class="NX">PXIMAGE: Image and Pixel Specifications</a>
</li><li><a href="#PXIMAGE:%20Obtain%20Pointer%20to%20Pixels%20NX1179" class="NX">PXIMAGE: Obtain Pointer to Pixels</a>
</li><li><a href="#PXIMAGE:%20Obtain%20Sequential%20Access%20Pixel%20Count%20NX1153" class="NX">PXIMAGE: Obtain Sequential Access Pixel Count</a>
</li><li><a href="#PXIMAGE:%20Prepare%20for%20Non-Sequential%20Pixel%20Access%20NX1164" class="NX">PXIMAGE: Prepare for Non-Sequential Pixel Access</a>
</li><li><a href="#PXIMAGE:%20Read%20Sequential%20Pixels%20NX1147" class="NX">PXIMAGE: Read Sequential Pixels</a>
</li><li><a href="#PXIMAGE:%20Release%20Pointer%20to%20Pixels%20NX1181" class="NX">PXIMAGE: Release Pointer to Pixels</a>
</li><li><a href="#PXIMAGE:%20Set%20&amp;%20Get%20Area%20of%20Interest%20Window%20NX1137" class="NX">PXIMAGE: Set &amp; Get Area of Interest Window</a>
</li><li><a href="#PXIMAGE:%20Set%20to%20Access%20Non-Sequential%20Pixels%20NX1162" class="NX">PXIMAGE: Set to Access Non-Sequential Pixels</a>
</li><li><a href="#PXIMAGE:%20Set%20to%20Access%20Sequential%20Pixels%20NX1145" class="NX">PXIMAGE: Set to Access Sequential Pixels</a>
</li><li><a href="#PXIMAGE:%20Set%20to%20Obtain%20Pointer%20to%20Pixels%20NX1177" class="NX">PXIMAGE: Set to Obtain Pointer to Pixels</a>
</li><li><a href="#PXIMAGE:%20Wait%20for%20Non-Sequential%20Access%20Completion%20NX1168" class="NX">PXIMAGE: Wait for Non-Sequential Access Completion</a>
</li><li><a href="#PXIMAGE:%20Wait%20for%20Sequential%20Access%20Completion%20NX1151" class="NX">PXIMAGE: Wait for Sequential Access Completion</a>
</li><li><a href="#PXIMAGE:%20Write%20Sequential%20Pixels%20NX1149" class="NX">PXIMAGE: Write Sequential Pixels</a>
</li><li><a href="#pximage::aeiou%20NX1139" class="NX">pximage::aeiou</a>
</li><li><a href="#pximage::bxta%20NX1165" class="NX">pximage::bxta</a>
</li><li><a href="#pximage::bxtp%20NX1163" class="NX">pximage::bxtp</a>
</li><li><a href="#pximage::bxts%20NX1161" class="NX">pximage::bxts</a>
</li><li><a href="#pximage::bxtw%20NX1167" class="NX">pximage::bxtw</a>
</li><li><a href="#pximage::imap%20NX1178" class="NX">pximage::imap</a>
</li><li><a href="#pximage::imapr%20NX1180" class="NX">pximage::imapr</a>
</li><li><a href="#pximage::imapset%20NX1176" class="NX">pximage::imapset</a>
</li><li><a href="#pximage::iolen%20NX1152" class="NX">pximage::iolen</a>
</li><li><a href="#pximage::ioread%20NX1146" class="NX">pximage::ioread</a>
</li><li><a href="#pximage::iorite%20NX1148" class="NX">pximage::iorite</a>
</li><li><a href="#pximage::ioset%20NX1144" class="NX">pximage::ioset</a>
</li><li><a href="#pximage::iowait%20NX1150" class="NX">pximage::iowait</a>
</li><li><a href="#pximage::xwind%20NX1136" class="NX">pximage::xwind</a>
</li><li><a href="#pximage_s%20NX69" class="NX">pximage_s</a>
</li><li><a href="#pximage3,%20struct%20NX71" class="NX">pximage3, struct</a>
</li><li><a href="#pximage3_s%20NX72" class="NX">pximage3_s</a>
</li><li><a href="#pximage3buf,%20struct%20NX126" class="NX">pximage3buf, struct</a>
</li><li><a href="#pximage3buf_s%20NX157" class="NX">pximage3buf_s</a>
</li><li><a href="#pximagebuf,%20struct%20NX125" class="NX">pximagebuf, struct</a>
</li><li><a href="#pximagebuf_s%20NX156" class="NX">pximagebuf_s</a>
</li><li><a href="#pximap,%20struct%20NX1186" class="NX">pximap, struct</a>
</li><li><a href="#pximcnt_t%20NX1160" class="NX">pximcnt_t</a>
</li><li><a href="#pximcnt_t%20NX15" class="NX">pximcnt_t</a>
</li><li><a href="#pxtimestamp,%20struct%20NX121" class="NX">pxtimestamp, struct</a>
</li><li><a href="#pxtimestamp_s%20NX152" class="NX">pxtimestamp_s</a>
</li><li><a href="#pxtrigspec,%20struct%20NX127" class="NX">pxtrigspec, struct</a>
</li><li><a href="#pxtrigspec_s%20NX158" class="NX">pxtrigspec_s</a>
</li><li><a href="#pxvbtime_t%20NX20" class="NX">pxvbtime_t</a>
</li><li><a href="#pxviddim,%20struct%20NX108" class="NX">pxviddim, struct</a>
</li><li><a href="#pxviddim_s%20NX139" class="NX">pxviddim_s</a>
</li><li><a href="#pxvidformat,%20struct%20NX106" class="NX">pxvidformat, struct</a>
</li><li><a href="#pxvidformat_s%20NX137" class="NX">pxvidformat_s</a>
</li><li><a href="#pxvidimage,%20struct%20NX107" class="NX">pxvidimage, struct</a>
</li><li><a href="#pxvidimage_s%20NX138" class="NX">pxvidimage_s</a>
</li><li><a href="#pxvidmem,%20struct%20NX113" class="NX">pxvidmem, struct</a>
</li><li><a href="#pxvidmem_s%20NX144" class="NX">pxvidmem_s</a>
</li><li><a href="#pxvidmode,%20struct%20NX111" class="NX">pxvidmode, struct</a>
</li><li><a href="#pxvidmode_s%20NX142" class="NX">pxvidmode_s</a>
</li><li><a href="#pxvidopt,%20struct%20NX112" class="NX">pxvidopt, struct</a>
</li><li><a href="#pxvidopt_s%20NX143" class="NX">pxvidopt_s</a>
</li><li><a href="#pxvidphys,%20struct%20NX110" class="NX">pxvidphys, struct</a>
</li><li><a href="#pxvidphys_s%20NX141" class="NX">pxvidphys_s</a>
</li><li><a href="#pxvidres,%20struct%20NX109" class="NX">pxvidres, struct</a>
</li><li><a href="#pxvidres_s%20NX140" class="NX">pxvidres_s</a>
</li><li><a href="#pxvidstate,%20struct%20NX105" class="NX">pxvidstate, struct</a>
</li><li><a href="#pxvidstate_s%20NX136" class="NX">pxvidstate_s</a>
</li><li><a href="#pxvidstatus,%20struct%20NX122" class="NX">pxvidstatus, struct</a>
</li><li><a href="#pxvidstatus_s%20NX153" class="NX">pxvidstatus_s</a>
</li><li><a href="#pxy,%20struct%20NX1123" class="NX">pxy, struct</a>
</li><li><a href="#pxy,%20struct%20NX54" class="NX">pxy, struct</a>
</li><li><a href="#pxy_s%20NX1124" class="NX">pxy_s</a>
</li><li><a href="#pxy_s%20NX55" class="NX">pxy_s</a>
</li><li><a href="#pxypoint_s%20NX1125" class="NX">pxypoint_s</a>
</li><li><a href="#pxypoint_s%20NX56" class="NX">pxypoint_s</a>
</li><li><a href="#pxypointz_s%20NX60" class="NX">pxypointz_s</a>
</li><li><a href="#pxywindow,%20struct%20NX1127" class="NX">pxywindow, struct</a>
</li><li><a href="#pxywindow,%20struct%20NX62" class="NX">pxywindow, struct</a>
</li><li><a href="#pxywindow_s%20NX1128" class="NX">pxywindow_s</a>
</li><li><a href="#pxywindow_s%20NX63" class="NX">pxywindow_s</a>
</li><li><a href="#pxyz,%20struct%20NX1130" class="NX">pxyz, struct</a>
</li><li><a href="#pxyz,%20struct%20NX58" class="NX">pxyz, struct</a>
</li><li><a href="#pxyz_s%20NX1131" class="NX">pxyz_s</a>
</li><li><a href="#pxyz_s%20NX59" class="NX">pxyz_s</a>
</li><li><a href="#pxyzpoint_s%20NX1132" class="NX">pxyzpoint_s</a>
</li><li><a href="#pxyzwindow,%20struct%20NX1134" class="NX">pxyzwindow, struct</a>
</li><li><a href="#pxyzwindow,%20struct%20NX65" class="NX">pxyzwindow, struct</a>
</li><li><a href="#pxyzwindow_s%20NX1135" class="NX">pxyzwindow_s</a>
</li><li><a href="#pxyzwindow_s%20NX66" class="NX">pxyzwindow_s</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Char%20NX1041" class="NX">Read Pixel Values as Unsigned Char</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Char%20NX374" class="NX">Read Pixel Values as Unsigned Char</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Char%20NX771" class="NX">Read Pixel Values as Unsigned Char</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Int%20NX1045" class="NX">Read Pixel Values as Unsigned Int</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Short%20NX1043" class="NX">Read Pixel Values as Unsigned Short</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Short%20NX376" class="NX">Read Pixel Values as Unsigned Short</a>
</li><li><a href="#Read%20Pixel%20Values%20as%20Unsigned%20Short%20NX773" class="NX">Read Pixel Values as Unsigned Short</a>
</li><li><a href="#Read/Write%20Imaging%20Board%20Memory%20NX967" class="NX">Read/Write Imaging Board Memory</a>
</li><li><a href="#Read/Write%20Imaging%20Board%20Memory,%20Sparsely%20NX969" class="NX">Read/Write Imaging Board Memory, Sparsely</a>
</li><li><a href="#S/VGA%20Adapter%20NX398" class="NX">S/VGA Adapter</a>
</li><li><a href="#Save%20Frame%20Buffers%20as%20Stream%20NX1017" class="NX">Save Frame Buffers as Stream</a>
</li><li><a href="#Save%20Frame%20Buffers%20NX362" class="NX">Save Frame Buffers</a>
</li><li><a href="#Save%20Frame%20Buffers%20NX761" class="NX">Save Frame Buffers</a>
</li><li><a href="#Save%20Image:%20BMP%20Format%20NX1029" class="NX">Save Image: BMP Format</a>
</li><li><a href="#Save%20Image:%20BMP%20Format%20NX348" class="NX">Save Image: BMP Format</a>
</li><li><a href="#Save%20Image:%20BMP%20Format%20NX751" class="NX">Save Image: BMP Format</a>
</li><li><a href="#Save%20Image:%20PCX%20Format%20NX1031" class="NX">Save Image: PCX Format</a>
</li><li><a href="#Save%20Image:%20PCX%20Format%20NX350" class="NX">Save Image: PCX Format</a>
</li><li><a href="#Save%20Image:%20PCX%20Format%20NX753" class="NX">Save Image: PCX Format</a>
</li><li><a href="#Save%20Image:%20TARGA%20Format%20NX1033" class="NX">Save Image: TARGA Format</a>
</li><li><a href="#Save%20Image:%20TARGA%20Format%20NX352" class="NX">Save Image: TARGA Format</a>
</li><li><a href="#Save%20Image:%20TARGA%20Format%20NX755" class="NX">Save Image: TARGA Format</a>
</li><li><a href="#Save%20Image:%20TIFF%20Format%20NX1035" class="NX">Save Image: TIFF Format</a>
</li><li><a href="#Save%20Image:%20TIFF%20Format%20NX354" class="NX">Save Image: TIFF Format</a>
</li><li><a href="#Save%20Image:%20TIFF%20Format%20NX757" class="NX">Save Image: TIFF Format</a>
</li><li><a href="#schar%20NX10" class="NX">schar</a>
</li><li><a href="#Serial%20Port:%20Read%20NX404" class="NX">Serial Port: Read</a>
</li><li><a href="#Serial%20Port:%20Read%20NX795" class="NX">Serial Port: Read</a>
</li><li><a href="#Serial%20Port:%20Set%20Configuration%20NX402" class="NX">Serial Port: Set Configuration</a>
</li><li><a href="#Serial%20Port:%20Set%20Configuration%20NX793" class="NX">Serial Port: Set Configuration</a>
</li><li><a href="#Serial%20Port:%20Write%20NX406" class="NX">Serial Port: Write</a>
</li><li><a href="#Serial%20Port:%20Write%20NX797" class="NX">Serial Port: Write</a>
</li><li><a href="#Set%20Bright%20White%20Balance%20NX462" class="NX">Set Bright White Balance</a>
</li><li><a href="#Set%20Bright%20White%20Balance%20NX817" class="NX">Set Bright White Balance</a>
</li><li><a href="#Set%20Camera%20Configuration%20NX999" class="NX">Set Camera Configuration</a>
</li><li><a href="#Set%20Dark%20White%20Balance%20NX464" class="NX">Set Dark White Balance</a>
</li><li><a href="#Set%20Dark%20White%20Balance%20NX819" class="NX">Set Dark White Balance</a>
</li><li><a href="#Set%20Default%20Configuration%20Copy%20of%20Video%20State%20NX949" class="NX">Set Default Configuration Copy of Video State</a>
</li><li><a href="#Set%20Driver%20Parameters%20NX925" class="NX">Set Driver Parameters</a>
</li><li><a href="#Set%20EXSYNC%20and%20PRIN%20Counter%20Values%20NX432" class="NX">Set EXSYNC and PRIN Counter Values</a>
</li><li><a href="#Set%20EXSYNC%20and%20PRIN%20Counter%20Values%20NX799" class="NX">Set EXSYNC and PRIN Counter Values</a>
</li><li><a href="#Set%20EXSYNC%20and%20PRINC%20Mode%20Bits%20NX438" class="NX">Set EXSYNC and PRINC Mode Bits</a>
</li><li><a href="#Set%20EXSYNC%20and%20PRINC%20Mode%20Bits%20NX805" class="NX">Set EXSYNC and PRINC Mode Bits</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20AGC%20and%20AEC%20NX524" class="NX">Set SILICON VIDEO AGC and AEC</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20AGC%20and%20AEC%20NX875" class="NX">Set SILICON VIDEO AGC and AEC</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Controlled%20Rates%20NX516" class="NX">Set SILICON VIDEO Controlled Rates</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Controlled%20Rates%20NX867" class="NX">Set SILICON VIDEO Controlled Rates</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Exposure%20NX478" class="NX">Set SILICON VIDEO Exposure</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Exposure%20NX831" class="NX">Set SILICON VIDEO Exposure</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gain,%20and%20Offset%20NX474" class="NX">Set SILICON VIDEO Exposure, Gain, and Offset</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gain,%20and%20Offset%20NX827" class="NX">Set SILICON VIDEO Exposure, Gain, and Offset</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gains,%20and%20Offsets%20NX476" class="NX">Set SILICON VIDEO Exposure, Gains, and Offsets</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Exposure,%20Gains,%20and%20Offsets%20NX829" class="NX">Set SILICON VIDEO Exposure, Gains, and Offsets</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Resolution%20and%20Timing%20NX495" class="NX">Set SILICON VIDEO Resolution and Timing</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Resolution%20and%20Timing%20NX847" class="NX">Set SILICON VIDEO Resolution and Timing</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Video%20And%20Trigger%20Modes%20NX514" class="NX">Set SILICON VIDEO Video And Trigger Modes</a>
</li><li><a href="#Set%20SILICON%20VIDEO%20Video%20And%20Trigger%20Modes%20NX865" class="NX">Set SILICON VIDEO Video And Trigger Modes</a>
</li><li><a href="#Set%20Video%20Configuration%20as%20per%20Compiled%20Include%20NX472" class="NX">Set Video Configuration as per Compiled Include</a>
</li><li><a href="#Set%20Video%20Configuration%20NX1001" class="NX">Set Video Configuration</a>
</li><li><a href="#Set%20Video%20Contrast%20and%20Brightness%20NX446" class="NX">Set Video Contrast and Brightness</a>
</li><li><a href="#Set%20Video%20Contrast%20and%20Brightness%20NX813" class="NX">Set Video Contrast and Brightness</a>
</li><li><a href="#Set%20Video%20Hue%20and%20Saturation%20NX448" class="NX">Set Video Hue and Saturation</a>
</li><li><a href="#Set%20Video%20Hue%20and%20Saturation%20NX815" class="NX">Set Video Hue and Saturation</a>
</li><li><a href="#Set%20Video%20Input%20Multiplexer%20NX444" class="NX">Set Video Input Multiplexer</a>
</li><li><a href="#Set%20Video%20Input%20Multiplexer%20NX811" class="NX">Set Video Input Multiplexer</a>
</li><li><a href="#Sign%20Video%20State%20NX947" class="NX">Sign Video State</a>
</li><li><a href="#SILICON%20VIDEO%201281C%20NX1079" class="NX">SILICON VIDEO 1281C</a>
</li><li><a href="#SILICON%20VIDEO%201281M%20NX1078" class="NX">SILICON VIDEO 1281M</a>
</li><li><a href="#SILICON%20VIDEO%201310%20NX1071" class="NX">SILICON VIDEO 1310</a>
</li><li><a href="#SILICON%20VIDEO%201310C%20NX1072" class="NX">SILICON VIDEO 1310C</a>
</li><li><a href="#SILICON%20VIDEO%202112%20NX1064" class="NX">SILICON VIDEO 2112</a>
</li><li><a href="#SILICON%20VIDEO%202112C%20NX1065" class="NX">SILICON VIDEO 2112C</a>
</li><li><a href="#SILICON%20VIDEO%205C10%20NX1094" class="NX">SILICON VIDEO 5C10</a>
</li><li><a href="#SILICON%20VIDEO%205M10%20NX1095" class="NX">SILICON VIDEO 5M10</a>
</li><li><a href="#SILICON%20VIDEO%20642C%20NX1103" class="NX">SILICON VIDEO 642C</a>
</li><li><a href="#SILICON%20VIDEO%20642M%20NX1102" class="NX">SILICON VIDEO 642M</a>
</li><li><a href="#SILICON%20VIDEO%20643C%20NX1110" class="NX">SILICON VIDEO 643C</a>
</li><li><a href="#SILICON%20VIDEO%20643M%20NX1109" class="NX">SILICON VIDEO 643M</a>
</li><li><a href="#SILICON%20VIDEO%209C10%20NX1096" class="NX">SILICON VIDEO 9C10</a>
</li><li><a href="#SILICON%20VIDEO%209M001%20NX1091" class="NX">SILICON VIDEO 9M001</a>
</li><li><a href="#SILICON%20VIDEO%209M001C%20NX1092" class="NX">SILICON VIDEO 9M001C</a>
</li><li><a href="#SILICON%20VIDEO%209T001C%20NX1093" class="NX">SILICON VIDEO 9T001C</a>
</li><li><a href="#SILICON%20VIDEO%20WGA-C%20NX1117" class="NX">SILICON VIDEO WGA-C</a>
</li><li><a href="#SILICON%20VIDEO%20WGA-M%20NX1116" class="NX">SILICON VIDEO WGA-M</a>
</li><li><a href="#SILICON+VIDEO%AE+NX493" class="NX">SILICON VIDEO®</a>
</li><li><a href="#SILICON+VIDEO%AE+NX512" class="NX">SILICON VIDEO®</a>
</li><li><a href="#SILICON+VIDEO%AE+NX531" class="NX">SILICON VIDEO®</a>
</li><li><a href="#sint%20NX11" class="NX">sint</a>
</li><li><a href="#size_t%20NX4" class="NX">size_t</a>
</li><li><a href="#slong%20NX13" class="NX">slong</a>
</li><li><a href="#sshort%20NX12" class="NX">sshort</a>
</li><li><a href="#Stack%20Overflow%20NX2" class="NX">Stack Overflow</a>
</li><li><a href="#Struct%20pxauxservice%20NX99" class="NX">Struct pxauxservice</a>
</li><li><a href="#Struct%20pxbufstatus%20NX102" class="NX">Struct pxbufstatus</a>
</li><li><a href="#Struct%20pxbufstatusfile%20NX103" class="NX">Struct pxbufstatusfile</a>
</li><li><a href="#Struct%20PXCam_SV032State%20NX1113" class="NX">Struct PXCam_SV032State</a>
</li><li><a href="#Struct%20PXCam_SV1281State%20NX1075" class="NX">Struct PXCam_SV1281State</a>
</li><li><a href="#Struct%20PXCam_SV1310State%20NX1068" class="NX">Struct PXCam_SV1310State</a>
</li><li><a href="#Struct%20PXCam_SV2112State%20NX1061" class="NX">Struct PXCam_SV2112State</a>
</li><li><a href="#Struct%20PXCam_SV642State%20NX1099" class="NX">Struct PXCam_SV642State</a>
</li><li><a href="#Struct%20PXCam_SV643State%20NX1106" class="NX">Struct PXCam_SV643State</a>
</li><li><a href="#Struct%20PXCam_SV9M001State%20NX1088" class="NX">Struct PXCam_SV9M001State</a>
</li><li><a href="#Struct%20pxcamcntl%20NX83" class="NX">Struct pxcamcntl</a>
</li><li><a href="#Struct%20pxddch%20NX73" class="NX">Struct pxddch</a>
</li><li><a href="#Struct%20pxdevfault%20NX93" class="NX">Struct pxdevfault</a>
</li><li><a href="#Struct%20pxdevinfo%20NX87" class="NX">Struct pxdevinfo</a>
</li><li><a href="#Struct%20pxdevservice%20NX98" class="NX">Struct pxdevservice</a>
</li><li><a href="#Struct%20pximadrs%20NX1173" class="NX">Struct pximadrs</a>
</li><li><a href="#Struct%20pximage%20NX1118" class="NX">Struct pximage</a>
</li><li><a href="#Struct%20pximage%20NX67" class="NX">Struct pximage</a>
</li><li><a href="#Struct%20pximage3%20NX70" class="NX">Struct pximage3</a>
</li><li><a href="#Struct%20pximage3buf%20NX95" class="NX">Struct pximage3buf</a>
</li><li><a href="#Struct%20pximagebuf%20NX94" class="NX">Struct pximagebuf</a>
</li><li><a href="#Struct%20pximap%20NX1185" class="NX">Struct pximap</a>
</li><li><a href="#Struct%20pxtimestamp%20NX90" class="NX">Struct pxtimestamp</a>
</li><li><a href="#Struct%20pxtrigspec%20NX96" class="NX">Struct pxtrigspec</a>
</li><li><a href="#Struct%20pxviddim%20NX77" class="NX">Struct pxviddim</a>
</li><li><a href="#Struct%20pxvidformat%20NX75" class="NX">Struct pxvidformat</a>
</li><li><a href="#Struct%20pxvidimage%20NX76" class="NX">Struct pxvidimage</a>
</li><li><a href="#Struct%20pxvidmem%20NX82" class="NX">Struct pxvidmem</a>
</li><li><a href="#Struct%20pxvidmode%20NX80" class="NX">Struct pxvidmode</a>
</li><li><a href="#Struct%20pxvidopt%20NX81" class="NX">Struct pxvidopt</a>
</li><li><a href="#Struct%20pxvidphys%20NX79" class="NX">Struct pxvidphys</a>
</li><li><a href="#Struct%20pxvidres%20NX78" class="NX">Struct pxvidres</a>
</li><li><a href="#Struct%20pxvidstate%20NX74" class="NX">Struct pxvidstate</a>
</li><li><a href="#Struct%20pxvidstatus%20NX91" class="NX">Struct pxvidstatus</a>
</li><li><a href="#Struct%20pxy%20NX1122" class="NX">Struct pxy</a>
</li><li><a href="#Struct%20pxy%20NX53" class="NX">Struct pxy</a>
</li><li><a href="#Struct%20pxywindow%20NX1126" class="NX">Struct pxywindow</a>
</li><li><a href="#Struct%20pxywindow%20NX61" class="NX">Struct pxywindow</a>
</li><li><a href="#Struct%20pxyz%20NX1129" class="NX">Struct pxyz</a>
</li><li><a href="#Struct%20pxyz%20NX57" class="NX">Struct pxyz</a>
</li><li><a href="#Struct%20pxyzwindow%20NX1133" class="NX">Struct pxyzwindow</a>
</li><li><a href="#Struct%20pxyzwindow%20NX64" class="NX">Struct pxyzwindow</a>
</li><li><a href="#Struct%20xcdevinfo%20NX88" class="NX">Struct xcdevinfo</a>
</li><li><a href="#Struct%20xcdevparms%20NX89" class="NX">Struct xcdevparms</a>
</li><li><a href="#Struct%20xcdevservice%20NX100" class="NX">Struct xcdevservice</a>
</li><li><a href="#Struct%20xcdxxformat%20NX86" class="NX">Struct xcdxxformat</a>
</li><li><a href="#Struct%20xclibs%20NX97" class="NX">Struct xclibs</a>
</li><li><a href="#Struct%20xclibservice%20NX101" class="NX">Struct xclibservice</a>
</li><li><a href="#Struct%20xcsv2format%20NX84" class="NX">Struct xcsv2format</a>
</li><li><a href="#Struct%20xcsv2mode%20NX85" class="NX">Struct xcsv2mode</a>
</li><li><a href="#Struct%20xcvidstatus%20NX92" class="NX">Struct xcvidstatus</a>
</li><li><a href="#TARGA%20Format%20NX1038" class="NX">TARGA Format</a>
</li><li><a href="#TARGA%20Format%20NX357" class="NX">TARGA Format</a>
</li><li><a href="#Terminate%20Live/Snap%20into%20Frame%20Buffer%20NX995" class="NX">Terminate Live/Snap into Frame Buffer</a>
</li><li><a href="#TIFF%20Format%20NX1036" class="NX">TIFF Format</a>
</li><li><a href="#TIFF%20Format%20NX355" class="NX">TIFF Format</a>
</li><li><a href="#Type%20_cfunacc%20NX45" class="NX">Type _cfunacc</a>
</li><li><a href="#Type%20_cfunfcc%20NX43" class="NX">Type _cfunfcc</a>
</li><li><a href="#Type%20_cfunvcc%20NX44" class="NX">Type _cfunvcc</a>
</li><li><a href="#Type%20_farimap%20NX39" class="NX">Type _farimap</a>
</li><li><a href="#Type%20pxabortfunc_t%20NX47" class="NX">Type pxabortfunc_t</a>
</li><li><a href="#Type%20pxapiadrs_t%20NX38" class="NX">Type pxapiadrs_t</a>
</li><li><a href="#Type%20pxbuffer_t%20NX35" class="NX">Type pxbuffer_t</a>
</li><li><a href="#Type%20pxcoord_t%20NX1120" class="NX">Type pxcoord_t</a>
</li><li><a href="#Type%20pxcoord_t%20NX30" class="NX">Type pxcoord_t</a>
</li><li><a href="#Type%20pxim1size_t%20NX32" class="NX">Type pxim1size_t</a>
</li><li><a href="#Type%20pxim2size_t%20NX33" class="NX">Type pxim2size_t</a>
</li><li><a href="#Type%20pxim3size_t%20NX34" class="NX">Type pxim3size_t</a>
</li><li><a href="#Type%20pximaeiou_t%20NX1142" class="NX">Type pximaeiou_t</a>
</li><li><a href="#Type%20pximaplen_t%20NX37" class="NX">Type pximaplen_t</a>
</li><li><a href="#Type%20pximcnt_t%20NX1159" class="NX">Type pximcnt_t</a>
</li><li><a href="#Type%20pximcnt_t%20NX31" class="NX">Type pximcnt_t</a>
</li><li><a href="#Type%20pxvbtime_t%20NX36" class="NX">Type pxvbtime_t</a>
</li><li><a href="#Type%20schar%20NX26" class="NX">Type schar</a>
</li><li><a href="#Type%20sint%20NX27" class="NX">Type sint</a>
</li><li><a href="#Type%20size_t%20NX5" class="NX">Type size_t</a>
</li><li><a href="#Type%20slong%20NX29" class="NX">Type slong</a>
</li><li><a href="#Type%20sshort%20NX28" class="NX">Type sshort</a>
</li><li><a href="#Type%20uchar%20NX22" class="NX">Type uchar</a>
</li><li><a href="#Type%20uint%20NX23" class="NX">Type uint</a>
</li><li><a href="#Type%20ulong%20NX25" class="NX">Type ulong</a>
</li><li><a href="#Type%20ushort%20NX24" class="NX">Type ushort</a>
</li><li><a href="#uchar%20NX6" class="NX">uchar</a>
</li><li><a href="#uint%20NX7" class="NX">uint</a>
</li><li><a href="#ulong%20NX9" class="NX">ulong</a>
</li><li><a href="#ushort%20NX8" class="NX">ushort</a>
</li><li><a href="#Video%20Abort%20NX294" class="NX">Video Abort</a>
</li><li><a href="#Video%20Abort%20NX699" class="NX">Video Abort</a>
</li><li><a href="#Video%20Format%20Configuration%20NX1291" class="NX">Video Format Configuration</a>
</li><li><a href="#Video%20Format%20Configuration%20NX49" class="NX">Video Format Configuration</a>
</li><li><a href="#Video%20Initiated%20Status%20Check%20NX300" class="NX">Video Initiated Status Check</a>
</li><li><a href="#Video%20Initiated%20Status%20Check%20NX705" class="NX">Video Initiated Status Check</a>
</li><li><a href="#Video%20Live%20NX286" class="NX">Video Live</a>
</li><li><a href="#Video%20Live%20NX691" class="NX">Video Live</a>
</li><li><a href="#Video%20Live%20Pair%20Alternate%20NX288" class="NX">Video Live Pair Alternate</a>
</li><li><a href="#Video%20Live%20Pair%20Alternate%20NX693" class="NX">Video Live Pair Alternate</a>
</li><li><a href="#Video%20Live%20Sequence%20NX290" class="NX">Video Live Sequence</a>
</li><li><a href="#Video%20Live%20Sequence%20NX695" class="NX">Video Live Sequence</a>
</li><li><a href="#Video%20Live%20Sequence%20Trigger%20NX298" class="NX">Video Live Sequence Trigger</a>
</li><li><a href="#Video%20Live%20Sequence%20Trigger%20NX703" class="NX">Video Live Sequence Trigger</a>
</li><li><a href="#Video%20Live%20Trigger%20NX296" class="NX">Video Live Trigger</a>
</li><li><a href="#Video%20Live%20Trigger%20NX701" class="NX">Video Live Trigger</a>
</li><li><a href="#Video%20Snap%20and%20Wait%20NX199" class="NX">Video Snap and Wait</a>
</li><li><a href="#Video%20Snap%20and%20Wait%20NX595" class="NX">Video Snap and Wait</a>
</li><li><a href="#Video%20Snap%20NX282" class="NX">Video Snap</a>
</li><li><a href="#Video%20Snap%20NX687" class="NX">Video Snap</a>
</li><li><a href="#Video%20Snap%20Pair%20NX284" class="NX">Video Snap Pair</a>
</li><li><a href="#Video%20Snap%20Pair%20NX689" class="NX">Video Snap Pair</a>
</li><li><a href="#Video%20State%20ID%20NX50" class="NX">Video State ID</a>
</li><li><a href="#Video%20UnLive%20NX292" class="NX">Video UnLive</a>
</li><li><a href="#Video%20UnLive%20NX697" class="NX">Video UnLive</a>
</li><li><a href="#Windows%20NX1058" class="NX">Windows</a>
</li><li><a href="#Windows%20NX228" class="NX">Windows</a>
</li><li><a href="#Windows%20NX389" class="NX">Windows</a>
</li><li><a href="#Windows%20NX394" class="NX">Windows</a>
</li><li><a href="#Windows%20NX397" class="NX">Windows</a>
</li><li><a href="#Windows:%20Create%20Device%20Independent%20Bitmap%20%28DIB%29%20NX382" class="NX">Windows: Create Device Independent Bitmap (DIB)</a>
</li><li><a href="#Windows:%20Create%20Device%20Independent%20Bitmap%20%28DIB%29%20NX779" class="NX">Windows: Create Device Independent Bitmap (DIB)</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Done%20NX388" class="NX">Windows: Direct Video Display, Done</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Done%20NX785" class="NX">Windows: Direct Video Display, Done</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Init%20NX386" class="NX">Windows: Direct Video Display, Init</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Init%20NX783" class="NX">Windows: Direct Video Display, Init</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Start%20NX391" class="NX">Windows: Direct Video Display, Start</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Start%20NX787" class="NX">Windows: Direct Video Display, Start</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Stop%20NX393" class="NX">Windows: Direct Video Display, Stop</a>
</li><li><a href="#Windows:%20Direct%20Video%20Display,%20Stop%20NX789" class="NX">Windows: Direct Video Display, Stop</a>
</li><li><a href="#Windows:%20Display%20Image%20Frame%20Buffer%20On%20Device%20Context%20NX1057" class="NX">Windows: Display Image Frame Buffer On Device Context</a>
</li><li><a href="#Windows:%20Display%20Image%20Frame%20Buffer%20On%20Device%20Context%20NX396" class="NX">Windows: Display Image Frame Buffer On Device Context</a>
</li><li><a href="#Windows:%20Display%20Image%20Frame%20Buffer%20On%20Device%20Context%20NX791" class="NX">Windows: Display Image Frame Buffer On Device Context</a>
</li><li><a href="#Windows:%20Free%20Device%20Independent%20Bitmap%20NX1055" class="NX">Windows: Free Device Independent Bitmap</a>
</li><li><a href="#Windows:%20Make%20Device%20Independent%20Bitmap%20NX1053" class="NX">Windows: Make Device Independent Bitmap</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20NX207" class="NX">Windows: Register Event upon Captured Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20NX209" class="NX">Windows: Register Event upon Captured Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20NX603" class="NX">Windows: Register Event upon Captured Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Captured%20Video%20Field%20NX605" class="NX">Windows: Register Event upon Captured Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Fault%20NX219" class="NX">Windows: Register Event upon Fault</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Fault%20NX221" class="NX">Windows: Register Event upon Fault</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Fault%20NX615" class="NX">Windows: Register Event upon Fault</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Fault%20NX617" class="NX">Windows: Register Event upon Fault</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20NX213" class="NX">Windows: Register Event upon General Purpose Trigger</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20NX215" class="NX">Windows: Register Event upon General Purpose Trigger</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20NX609" class="NX">Windows: Register Event upon General Purpose Trigger</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20General%20Purpose%20Trigger%20NX611" class="NX">Windows: Register Event upon General Purpose Trigger</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Serial%20NX225" class="NX">Windows: Register Event upon Serial</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Serial%20NX621" class="NX">Windows: Register Event upon Serial</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20NX201" class="NX">Windows: Register Event upon Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20NX203" class="NX">Windows: Register Event upon Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20NX597" class="NX">Windows: Register Event upon Video Field</a>
</li><li><a href="#Windows:%20Register%20Event%20upon%20Video%20Field%20NX599" class="NX">Windows: Register Event upon Video Field</a>
</li><li><a href="#Windows:%20Release%20Device%20Independent%20Bitmap%20%28DIB%29%20NX384" class="NX">Windows: Release Device Independent Bitmap (DIB)</a>
</li><li><a href="#Windows:%20Release%20Device%20Independent%20Bitmap%20%28DIB%29%20NX781" class="NX">Windows: Release Device Independent Bitmap (DIB)</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Captured%20Video%20Field%20NX211" class="NX">Windows: Unregister Event upon Captured Video Field</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Captured%20Video%20Field%20NX607" class="NX">Windows: Unregister Event upon Captured Video Field</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Fault%20NX223" class="NX">Windows: Unregister Event upon Fault</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Fault%20NX619" class="NX">Windows: Unregister Event upon Fault</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20General%20Purpose%20Trigger%20NX217" class="NX">Windows: Unregister Event upon General Purpose Trigger</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20General%20Purpose%20Trigger%20NX613" class="NX">Windows: Unregister Event upon General Purpose Trigger</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Serial%20NX227" class="NX">Windows: Unregister Event upon Serial</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Serial%20NX623" class="NX">Windows: Unregister Event upon Serial</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Video%20Field%20NX205" class="NX">Windows: Unregister Event upon Video Field</a>
</li><li><a href="#Windows:%20Unregister%20Event%20upon%20Video%20Field%20NX601" class="NX">Windows: Unregister Event upon Video Field</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Char%20NX1047" class="NX">Write Pixel Values as Unsigned Char</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Char%20NX378" class="NX">Write Pixel Values as Unsigned Char</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Char%20NX775" class="NX">Write Pixel Values as Unsigned Char</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Int%20NX1051" class="NX">Write Pixel Values as Unsigned Int</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Short%20NX1049" class="NX">Write Pixel Values as Unsigned Short</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Short%20NX380" class="NX">Write Pixel Values as Unsigned Short</a>
</li><li><a href="#Write%20Pixel%20Values%20as%20Unsigned%20Short%20NX777" class="NX">Write Pixel Values as Unsigned Short</a>
</li><li><a href="#xcdevinfo,%20struct%20NX119" class="NX">xcdevinfo, struct</a>
</li><li><a href="#xcdevinfo_s%20NX150" class="NX">xcdevinfo_s</a>
</li><li><a href="#xcdevparms,%20struct%20NX120" class="NX">xcdevparms, struct</a>
</li><li><a href="#xcdevparms_s%20NX151" class="NX">xcdevparms_s</a>
</li><li><a href="#xcdevservice,%20struct%20NX131" class="NX">xcdevservice, struct</a>
</li><li><a href="#xcdevservice_s%20NX162" class="NX">xcdevservice_s</a>
</li><li><a href="#xcdxxformat,%20struct%20NX117" class="NX">xcdxxformat, struct</a>
</li><li><a href="#xcdxxformat_s%20NX148" class="NX">xcdxxformat_s</a>
</li><li><a href="#xclib_close%20NX914" class="NX">xclib_close</a>
</li><li><a href="#xclib_DeclareVidStateStructs%20NX950" class="NX">xclib_DeclareVidStateStructs</a>
</li><li><a href="#xclib_InitVidStateStructs%20NX952" class="NX">xclib_InitVidStateStructs</a>
</li><li><a href="#xclib_libincid%20NX908" class="NX">xclib_libincid</a>
</li><li><a href="#xclib_liblibid%20NX910" class="NX">xclib_liblibid</a>
</li><li><a href="#xclib_open%20NX912" class="NX">xclib_open</a>
</li><li><a href="#xclibs,%20struct%20NX128" class="NX">xclibs, struct</a>
</li><li><a href="#xclibs_s%20NX159" class="NX">xclibs_s</a>
</li><li><a href="#xclibservice,%20struct%20NX132" class="NX">xclibservice, struct</a>
</li><li><a href="#xclibservice_s%20NX163" class="NX">xclibservice_s</a>
</li><li><a href="#xcsv2format,%20struct%20NX115" class="NX">xcsv2format, struct</a>
</li><li><a href="#xcsv2format_s%20NX146" class="NX">xcsv2format_s</a>
</li><li><a href="#xcsv2mode,%20struct%20NX116" class="NX">xcsv2mode, struct</a>
</li><li><a href="#xcsv2mode_s%20NX147" class="NX">xcsv2mode_s</a>
</li><li><a href="#xcvidstatus,%20struct%20NX123" class="NX">xcvidstatus, struct</a>
</li><li><a href="#xcvidstatus_s%20NX154" class="NX">xcvidstatus_s</a>
</li></ol></div>
</body></html>