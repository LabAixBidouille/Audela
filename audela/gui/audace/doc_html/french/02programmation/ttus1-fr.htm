<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>


  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" /><title>Librairie TT : Manuel Utilisateur</title></head><body>
<p class="date">Date de mise &#224; jour : 30 mai 2011</p>
<h1>LIB TT - Librairie de pr&#233;traitement d'images
astronomiques</h1>
<h1>Manuel Utilisateur</h1>
<p>Ce guide de l'utilisateur s'adresse aux astronomes qui veulent
&#233;crire des scripts de traitement d'image utilisant la
librairie TT. Rappelons que seul le format d'images FITS est
reconnu et que seules les images monochromes (naxis=2) peuvent
&#234;tre trait&#233;es.</p>
<p style="color: rgb(0, 0, 0);">On distingue deux types de
fonctions de traitement d'images. Les fonctions qui traitent une
pile d'images en entr&#233;e et sortent une seule image sont
r&#233;unies au sein de IMA/STACK. Les fonctions qui traitement
les images les unes apr&#232;s les autres ind&#233;pendamment de
la pr&#233;c&#233;dente sont r&#233;unies dans IMA/SERIES.</p>
<h1>1. Guide de r&#233;f&#233;rence du mode script de TT</h1>
<p>L'int&#233;r&#234;t principal de la librairie TT est de
pouvoir ex&#233;cuter des commandes entr&#233;es sous la forme de
scripts. Un script TT est compos&#233; d'une seule cha&#238;ne de
caract&#232;res contenant des lignes (s&#233;parateurs \n du
langage C). Chaque ligne est analys&#233;e s&#233;quentiellement.
Au sein d'une ligne, la premi&#232;re cha&#238;ne de
caract&#232;res rencontr&#233;e doit contenir le mot cl&#233; de
d&#233;finition.</p>
<p>Si le mot cl&#233; n'est pas reconnu, le restant de la ligne
est interpr&#233;t&#233; comme une simple remarque. Le
s&#233;parateur blanc est utilis&#233; pour les param&#232;tres
suivants de la ligne.</p>
<p>Il existe actuellement quatre mots cl&#233;s de
d&#233;finition :</p>
<p>SET/VAR : initialise la valeur d'une variable de substitution.
Cette d&#233;finition comporte deux arguments : le mot &#224;
substituer et le mot substitu&#233;.</p>
<p>Les lignes suivantes se verront ainsi remplacer les mots
&#224; substituer par le mot substitu&#233;.</p>
<p>IMA/SERIES : traitement d'une s&#233;rie d'images et
cr&#233;ation d'autant d'images en sortie qu'en entr&#233;e.</p>
<p>IMA/STACK : traitement d'une pile d'images et cr&#233;ation
d'une seule image en sortie.</p>
<p>TMPFILE/EXT : assignation d'un mot qui sera ajout&#233; au nom
des fichiers temporaires (extensions .lst).</p>
<h2>1.1. Param&#233;trages des d&#233;finitions IMA/</h2>
<p>La forme g&#233;n&#233;rale d'une ligne d&#233;finie par un
mot cl&#233; de type IMA/ est la suivante :d&#233;finition rep_in
nom_in ext_in indice_deb indice_fin rep_out nom_out ext_out
indice_out fonction param&#232;tres ...</p>
<p>d&#233;finition : IMA/SERIES ou IMA/STACK</p>
<p>rep_in : chemin d'acc&#232;s aux fichiers d'image
d'entr&#233;e (mettre un point si c'est le r&#233;pertoire
courant de libtt).</p>
<p>nom_in : nom g&#233;n&#233;rique (ou liste de noms
d&#233;pareill&#233;s) des images d'entr&#233;e</p>
<p>indice_deb : nombre correspondant &#224; l'indice de la
premi&#232;re image (mettre un point s'il n'y a pas d'indice, ou
une &#233;toile si c'est une liste de noms
d&#233;pareill&#233;s)</p>
<p>indice_fin : nombre correspondant &#224; l'indice de la
derni&#232;re image (mettre un point s'il n'y a pas d'indice, ou
une &#233;toile si c'est une liste de noms
d&#233;pareill&#233;s)</p>
<p>ext_in : nom de l'extension (suffixe) des fichiers images
d'entr&#233;e</p>
<p>rep_out : chemin d'acc&#232;s aux fichiers d'images de sortie
(mettre un point si c'est le r&#233;pertoire courant de
libtt).</p>
<p>nom_out : nom g&#233;n&#233;rique des images de sortie.</p>
<p>indice_out : nombre correspondant &#224; l'indice de la
premi&#232;re image de sortie (mettre un point s'il n'y a pas
d'indice)</p>
<p>ext_out : nom de l'extension (suffixe) des fichiers images de
sortie.</p>
<p>fonction : nom de la fonction (voir ci-apr&#232;s).</p>
<p>param&#232;tres ... : liste de param&#232;tres propres &#224;
chaque fonction. Ces param&#232;tres peuvent appara&#238;tre dans
n'importe quel ordre.</p>
<p>Exemple d'une ligne de script :IMA/STACK . i 1 5 .fit c:\toto
j . .fit SK bitpix=32 kappa=1.5 nullpixel=-1000 jpegfile</p>
<p>Ce script demande d'effectuer un pile kappa-sigma (fonction
SK) des images i1.fit &#224; i5.fit du r&#233;pertoire courant en
une image j.fit dans le r&#233;pertoire c:\toto. L'image j.fit
sera enregistr&#233;e en entiers de 4 octets (bitpix=32), le
coefficient kappa vaut 1.5 et les pixels de valeur
inf&#233;rieure ou &#233;gale &#224; -1000 ADU ne seront pas pris
en compte dans calcul des kappa-sigma.</p>
<p>A noter : dans ce propos, le terme de nom complet signifie le
nom du fichier incluant le r&#233;pertoire et le suffixe. Ainsi :
c:\toto\j.fit est un nom complet alors que le nom de l'image est
j.</p>
<p>Si un param&#232;tre doit contenir des caract&#232;res blancs,
encadrer le param&#232;tre par des doubles quotes. Par exemple
:</p>
<p>IMA/SERIES . i 1 5 .fit c:\toto j 1 .fit RESAMPLE
"paramresample=1.5 0 0 0 1.5 0 0"</p>
<p>les double quotes doivent encadrer aussi le mot d&#233;signant
le param&#232;tre.</p>
<p>Noter que l'extension .mt pour le format FITS g&#232;re le
syst&#232;me d'indexation des images diff&#233;remment des autres
extensions. Des z&#233;ros sont ajout&#233;s automatiquement
devant les indices pour que l'indice contienne 4 chiffres. Par
exemple IMA/SERIES . i 1 5 .mt c:\toto j 1 .fit COPY, va chercher
les fichiers i0001.mt &#224; i0005.mt en lecture.</p>
<h2>1.2. Liste g&#233;n&#233;rale des fonctions disponibles</h2>
<table border="2" cellpadding="5">
  <tbody>
    <tr>
      <td>Mot cl&#233; de d&#233;finition [et param&#232;tres
disponibles]</td>
      <td>Mot cl&#233; de la fonction [et param&#232;tres
disponibles]</td>
    </tr>
    <tr>
      <td>IMA/STACK [bitpix jpegfile skylevel nullpixel<br />
jpeg_quality]</td>
      <td><a href="#stackADD">ADD</a><br />
      <a href="#MEAN">MEAN</a><br />
      <a href="#MED">MED</a><br />
      <a href="#stackPROD">PROD</a> [powernorm]<br />
      <a href="#PYTHAGORE">PYTHAGORE</a><br />
      <a href="#SHUTTER">SHUTTER</a><br />
      <a href="#SIG">SIG</a><br />
      <a href="#SK">SK</a> [kappa]<br />
      <a href="#SORT">SORT</a> [percent]</td>
    </tr>
    <tr>
      <td>IMA/SERIES [bitpix jpegfile skylevel nullpixel<br />
jpeg_quality]</td>
      <td><a href="#seriesADD">ADD</a> [file offset]<br />
      <a href="#ASTROMETRY">ASTROMETRY</a> [file_ascii]<br />
      <a href="#BACK">BACK</a> [back_kernel] [back_threshold] [sub]
[div]<br />
      <a href="#CATCHART">CATCHART</a> [path_astromcatalog]
[astromcatalog] [catafile] [jpegfile_chart] [jpegfile_chart2]
[magrlim] [magblim] [simulimage] [exposure] [fwhmx] [fwhmy] [teldiam]
[colfilter] [sky_brightness] [qe] [gain] [readout_noise] [shutter_mode]
[bias_level] [thermic_response] [flat_type]<br />
      <a href="#CONV">CONV</a> [kernel_type] [sigma]<br />
      <a href="#COPY">COPY</a> [nbsubseries]<br />
      <a href="#CUTS">CUTS</a> [hicut] [locut] [keytype]
[cutscontrast]<br />
      <a href="#DELETE">DELETE</a><br />
      <a href="#DIV">DIV</a> [file] [constant]<br />
      <a href="#FILTER">FILTER</a> [threshold] [type_threshold]
[kernel_width] [kernel_type] [kernel_coef]<br />
      <a href="#FITELLIP">FITELLIP</a> [x1] [x2] [y1] [y2] [xcenter]
[ycenter] [backgound] [fitorder6543] [file_ascii]
[threshold]<br />
      <a href="#HEADERFITS">HEADERFITS</a> [file]<br />
      <a href="#HOUGH">HOUGH</a> [threshold] [binary]<br />
      <a href="#INVERT">INVERT</a> [mirror] [flip] [xy]
[normaflux]<br />
      <a href="#MULT">MULT</a> [constant]<br />
      <a href="#NORMOFFSET">NORMOFFSET</a> [normoffset_value]<br />
      <a href="ttus1-fr.htm#NORMGAIN">NORMGAIN</a> [normgain_value]<br />
      <a href="#OFFSET">OFFSET</a> [offset]<br />
      <a href="#OPT">OPT</a> [dark] [bias] [therm_kappa]
[unsmearing]<br />
      <a href="#seriesPROD">PROD</a> [file] [constant]<br />
      <a href="#RADIAL">RADIAL</a> [radius] [sigma] [power] [xcenter]
[ycenter]<br />
      <a href="#REGISTER">REGISTER</a> [translate] [normaflux]
[matchwcs]<br />
      <a href="#REGISTERFINE">REGISTERFINE</a> [oversampling] [delta]
[file]<br />
      <a href="#RESAMPLE">RESAMPLE</a> [paramresample]
[normaflux]<br />
      <a href="#RGRADIENT">RGRADIENT</a> [xcenter] [ycenter] [radius]
[angle]<br />
      <a href="#SMILEX">SMILEX</a> [ycenter] [coef_smile2]
[coef_smile4]<br />
      <a href="#SMILEY">SMILEY</a> [xcenter] [coef_smile2]
[coef_smile4]<br />
      <a href="#SUB">SUB</a> [file] [offset] [hot_pixel_list]
[cosmic_threshold]<br />
      <a href="#STAT">STAT</a> [pixelsat_value] [fwhm] [objefile]
[pixefile] [border] [detect_kappa] [pixint]<br />
      <a href="#UNSMEARING">UNSMEARING</a> [unsmearing]<br />
      <a href="#SUBDARK">SUBDARK</a> [dark] [bias] [exptime] [dexptime]
[unsmearing] [hot_pixel_list] [cosmic_threshold]<br />
      <a href="#SORTX">SORTX</a> [percent] [x1] [x2] [width]<br />
      <a href="#SORTY">SORTY</a> [percent] [y1] [y2] [height]<br />
      <a href="#TILT">TILT</a> [trans_x] [trans_y]<br />
      <a href="#TRANS">TRANS</a> [trans_x] [trans_y]<br />
      <p><br />
Fonctions &#233;crites par tt_user2</p>
      <a href="#LOPT">LOPT</a> [y1] [y2] [height]<br />
      <a href="#PROFILE2">PROFILE2</a> [offset] [direction]
[filename]<br />
      <p><br />
Fonctions &#233;crites par tt_user3</p>
      <a href="#BINX">BINX</a> [x1] [x2] [width]<br />
      <a href="#BINY">BINY</a> [y1] [y2] [height]<br />
      <a href="#LOG">LOG</a> [offsetlog] [coeff]<br />
      <a href="#MATRIX">MATRIX</a> [x1] [x2] [y1] [y2]
[filematrix]<br />
      <a href="#MEDIANX">MEDIANX</a> [x1] [x2] [width]<br />
      <a href="#MEDIANY">MEDIANY</a> [y1] [y2] [height]<br />
      <a href="#POL2REC">POL2REC</a> [y0] [x0] [scale_theta]
[scale_rho] [width] [height]<br />
      <a href="#PROFILE">PROFILE</a> [offset] [direction]
[filename]<br />
      <a href="#REC2POL">REC2POL</a> [y0] [x0] [scale_theta]
[scale_rho]<br />
      <a href="#ROT">ROT</a> [y0] [x0] [angle]<br />
      <a href="ttus1-fr.htm#ROTENTIERE">ROTENTIERE</a> [y0] [x0] [angle]<br />
      <a href="#WINDOW">WINDOW</a> [x1] [x2] [y1] [y2]<br />
      <p><br />
Fonctions &#233;crites par tt_user4</p>
      <a href="#ASTROMETRY2">ASTROMETRY2</a><br />
      <p><br />
Fonctions &#233;crites par tt_user6</p>
      <a href="#HOTPIXEL">HOTPIXEL</a> [hot_pixel_list]<br />
      <a href="#COSMIC">COSMIC</a> [cosmic_threshold]</td>
    </tr>
  </tbody>
</table>
<br />
<h2 style="color: rgb(0, 0, 0);">1.3. Param&#232;tres optionnels
communs &#224; IMA/STACK et IMA/SERIES</h2>
<p>Les param&#232;tres optionnels sont du type cl&#233; ou
cl&#233;=valeur. La cl&#233; est un mot (majuscules ou minuscules
indiff&#233;renci&#233;es). Certaines cl&#233;s exigent une
valeur qui doit &#234;tre &#233;crite apr&#232;s le symbole
&#233;gal. La valeur est soit un mot, soit un nombre, soit une
s&#233;rie de nombres selon les cas. On prendra garde &#224; ne
pas introduire de caract&#232;re blanc avant et apr&#232;s le
symbole &#233;gal. Un certain nombre de cl&#233;s peuvent
&#234;tre utilis&#233;es dans les d&#233;finitions de IMA/STACK
ou IMA/SERIES. Elles sont pr&#233;sent&#233;es dans ce paragraphe
:</p>
<p>[bitpix] permet de choisir le format des donn&#233;es
enregistr&#233;es dans le fichier FITS.<br />
</p>
<p><span style="font-weight: bold;">Par d&#233;faut, les images de sortie
prennent le m&#234;me
type de donn&#233;es que les images d'entr&#233;e. </span><br />
</p>
<p>On distingue les cas
suivants :</p>
<p>bitpix=8 (byte) : entiers &#224; 1 octet non sign&#233; (0 &#224; 255).</p>
<p>bitpix=16 (short) : entiers &#224; 2 octets sign&#233;s (-32768 &#224; 32767).</p>
<p>bitpix=+16 (ushort) : entiers &#224; 2 octets non sign&#233;s (0 &#224; 65535)
(Note 1).<br />
</p>
<p>bitpix=32 (long) : entiers &#224; 4 octets sign&#233;s (-2 147 483 648 &#224; 2 147
483
647).</p>
<p>bitpix=+32 (ulong) : entiers &#224; 4 octets non sign&#233;s (0 &#224; 4 294 967
295) (Note 1).<br />
</p>
<p>bitpix=-32 (float) : flottants &#224; 4 octets (-3,4*10<sup>+38</sup> &#224;
3,4*10<sup>+38</sup>) (Note 2).<br />
</p>
<p>bitpix=-64 (double) : flottants &#224; 8 octets (-1,7*10<sup>+308</sup>
&#224; 1,7*10<sup>+308</sup>) (Note3).<br />
</p>
<p><span style="text-decoration: underline;">Note 1 :</span> Les
valeurs +16 et +32 ne sont pas des valeurs normalis&#233;es du standard
FITS. Elles sont sp&#233;cifiques &#224; AudeLA et ne sont utilisables qu'en tant
que param&#232;tres de certaines commandes de libaudela et de libtt.<big><span style="font-size: 9pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;" /></big><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><br />
</span></p>
<p><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;" /><span style="text-decoration: underline;">Note 2 :</span> Cette notation
pr&#233;sente 2 discontinuit&#233;s, en effet il est impossible d'affecter une
valeur d'ADU dans les intervalles suivants :</p>
<ul>
  <li>0 &#224; +3,4*10<sup class="moz-txt-sup">-38</sup><sup class="moz-txt-sup" /></li>
  <li>-3,4*10<sup class="moz-txt-sup">-38</sup>&nbsp; &#224; 0<sup class="moz-txt-sup" /></li>
</ul>
<p><span style="text-decoration: underline;">Note 3 :</span> Cette
notation pr&#233;sente 2 discontinuit&#233;s, en effet il est impossible
d'affecter une valeur d'ADU dans les intervalles suivants :</p>
<ul>
  <li>0 &#224; +1,7*10<sup class="moz-txt-sup">-308</sup></li>
  <li>-1,7*10<sup class="moz-txt-sup">-308</sup>&nbsp; &#224; 0</li>
</ul>
<p>[jpegfile] (pas d'arguments) permet de sauver une ou plusieurs
images au format JPEG apr&#232;s traitement. Les seuils sont pris
&#233;gaux &#224; ceux trouv&#233;s dans l'en-t&#234;te de
l'image (cf. fonction IMA/SERIES STAT pour les calculer). Il y
aura autant d'images JPEG g&#233;n&#233;r&#233;es que d'images
finales FITS g&#233;n&#233;r&#233;es. Chaque fichier JPEG porte
le m&#234;me nom que le fichier FITS correspondant dont le
suffixe est remplac&#233; par .jpg. Les fichiers JPEG sont
enregistr&#233;s dans le m&#234;me r&#233;pertoire que les images
FITS de sortie.</p>
<p>[jpeg_quality] (= valeur enti&#232;re entre 5 et 100) permet
de fixer la valeur du crit&#232;re de qualit&#233; de l'image
JPEG (cf. utilisation de [jpegfile]). Ce crit&#232;re peut varier
entre 5 (image tr&#232;s d&#233;grad&#233;e) &#224; 100 (image
compress&#233;e sans perte). Par d&#233;faut, cette valeur est
fix&#233;e &#224; 75.</p>
<p>[skylevel] (pas d'argument) permet de sauver la valeur du fond
de ciel, avant traitement, dans l'en-t&#234;te de l'image
trait&#233;e (mot cl&#233; SKYLEVEL dans l'en-t&#234;te
FITS).</p>
<p>[nullpixel] (= valeur en ADU). Permet d'indiquer &#224; la
fonction de ne pas prendre en compte les pixels dont les valeurs
sont inf&#233;rieures ou &#233;gales &#224; la valeur seuil de
nullpixel. Nullpixel employ&#233; sans argument signifie que la
valeur seuil vaut z&#233;ro.</p>
<h1>2. Fonctions de la d&#233;finition IMA/STACK</h1>
<p style="color: rgb(0, 0, 0);">Ces fonctions produisent une
seule image en sortie &#224; partir d'une pile d'images en
entr&#233;e.</p>
<p>Chacune des fonctions de IMA/STACK peut &#234;tre
associ&#233;e aux param&#232;tres optionnels g&#233;n&#233;raux
d&#233;crits au paragraphe 1.3</p>
<ol>
  <li>
    <h3><a name="stackADD" id="stackADD" />Fonction ADD</h3>
    <p>Addition pixel &#224; pixel des images de la pile.<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la somme des
(EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="MEAN" id="MEAN" />Fonction MEAN</h3>
    <p>Moyenne pixel &#224; pixel des images de la pile.<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la valeur
moyenne des (EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="MED" id="MED" />Fonction MED</h3>
    <p>M&#233;diane pixel &#224; pixel des images de la
pile.<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la valeur
m&#233;diane des (EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="stackPROD" id="stackPROD" />Fonction PROD</h3>
    <p>Produit pixel &#224; pixel des images de la pile. L'option
[powernorm], si elle est indiqu&#233;e (sans valeur) impose une
normalisation en puissance 1/n pour n images constituant chaque
point.</p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la somme des
(EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="PYTHAGORE" id="PYTHAGORE" />Fonction
PYTHAGORE</h3>
    <p>Racine carr&#233;e de la somme des carr&#233;s de pixel &#224;
pixel des images de la pile.<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la somme des
(EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="SIG" id="SIG" />Fonction SIG</h3>
    <p>Ecart type, pixel &#224; pixel, des images de la
pile.<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la valeur
moyenne des (EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="SK" id="SK" />Fonction SK</h3>
    <p>Moyenne kappa-sigma, pixel &#224; pixel, des images de la
pile. Le param&#232;tre optionnel [kappa] permet de choisir le
seuil de r&#233;jection des valeurs hors de la plage
[moyenne-kappa*&#233;cart-type ; moyenne+kappa*&#233;cart-type].
Par d&#233;faut [kappa=3].<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; la valeur
moyenne des (EXPOSURE) des images de la pile.</p>
  </li>
  <li>
    <h3><a name="SORT" id="SORT" />Fonction SORT</h3>
    <p>Valeur tri&#233;e, pixel &#224; pixel, des images de la pile.
Le calcul de la valeur tri&#233;e est le suivant. La valeur de
chaque pixel (x,y) de toutes les images de la pile sont
tri&#233;es dans l'ordre croissant. Le param&#232;tre optionnel
[percent] permet de choisir la valeur tri&#233;e. La valeur
tri&#233;e est prise &#233;gale au minimum si [percent=0], &#224;
la valeur m&#233;diane si [percent=50] et au maximum si
[percent=100]. percent peut prendre n'importe quelle valeur entre
0 et 100. Par d&#233;faut [percent=50].</p>
    <p>Exemple avec 8 valeurs class&#233;es par ordre croissant : 0,
1, 2, 2, 4, 4, 6, 1000<br />
0% ---&gt; 0 ; 30%---&gt; 2 ; 50% ---&gt; 4 ; 100% ---&gt;
1000</p>
    <p>La date (DATE-OBS) est chang&#233;e en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale varie en fonction de la valeur de
[percent].</p>
  </li>
  <li>
    <h3><a name="SHUTTER" id="SHUTTER" />Fonction SHUTTER</h3>
    <p>Synth&#233;tise l'image des d&#233;lais de ouverture/fermeture
d'un obturateur m&#233;canique &#224; partir d'un lot d'images
prises avec des dur&#233;es de pose diff&#233;rentes. La valeur
des pixels de l'image finale est &#233;gale au retard par rapport
au d&#233;but d'ouverture de l'obturateur.<br />
    </p>
    <p>La date (DATE-OBS) est chang&#233; en fonction des poids de
chacune des images entrant dans la pile. Le temps de pose
(EXPOSURE) de l'image finale est &#233;gal &#224; 0.</p>
  </li>
</ol>
<h1>3. Fonctions de la d&#233;finition IMA/SERIES</h1>
<p>Chacune des fonctions de IMA/SERIES peut &#234;tre
associ&#233;e aux param&#232;tres optionnels g&#233;n&#233;raux
d&#233;crits au paragraphe 1.3. Les param&#232;tres optionnels
(et leur argument) sp&#233;cifiques &#224; chaque fonction sont
d&#233;crits maintenant :</p>
<h2>3.1. Les fonctions destin&#233;es &#224; 'Adapter la
g&#233;om&#233;trie' des images</h2>
<p style="color: rgb(0, 0, 0);">Ces fonctions transforment la
g&#233;om&#233;trie des images et/ou l'intensit&#233; des pixels
et produisent autant d'images en sortie qu'il y en a en
entr&#233;e.</p>
<ol>
  <li>
    <h3><a name="INVERT" id="INVERT" />Fonction INVERT</h3>
    <p>Echange les pixels de l'image en fonction de l'option
pr&#233;cis&#233;e :</p>
    <p>MIRROR : L'image est invers&#233;e gauche droite.</p>
    <p>FLIP : L'image est invers&#233;e haut bas.</p>
    <p>XY : L'image est transpos&#233;e (&#233;change des lignes et
des colonnes).</p>
    <p>Les mots cl&#233;s d'astrom&#233;trie (WCS),
&#233;ventuellement pr&#233;sents dans l'en-t&#234;te FITS, sont
modifi&#233;s en cons&#233;quence.</p>
  </li>
  <li>
    <h3><a name="WINDOW" id="WINDOW" />Fonction WINDOW</h3>
    <p>Extrait une image de sortie dans la fen&#234;tre [x1] [x2]
[y1] [y2] de l'image d'entr&#233;e.</p>
    <p>Exemple de script pour fen&#234;trer trois images de nom
g&#233;n&#233;rique $img, indic&#233;es de 1 &#224; 3 et
d'extension $ext, $x1,$y1 et $x2,$y2 repr&#233;sentant les
coordonn&#233;es d'un rectangle de s&#233;lection, on peut
ex&#233;cuter dans un script Tcl :</p>
    <pre>ttscript2 "IMA/SERIES . $img 1 3 $ext . $img 1 $ext WINDOW x1=$x1 x2=$x2 y1=$y1 y2=$y2 bitpix=16"<br />   <br /></pre>
Pour des plans couleurs portant le nom ${img}r ${img}g ${img}b il
faudra traiter les images comme une liste d&#233;pareill&#233;e :
    <pre>set liste_images [ list ${img}r ${img}g ${img}b ]<br />
ttscript2 "IMA/SERIES . \"$liste_images\" * * $ext . $img 1 $ext WINDOW x1=$x1 x2=$x2 y1=$y1 y2=$y2 bitpix=16"<br />   <br /></pre>
    <p>Les images produites porteront le nom ${img}1 ${img}2
${img}3</p>
  </li>
  <li>
    <h3><a name="RESAMPLE" id="RESAMPLE" />Fonction RESAMPLE</h3>
    <p>Effectue une transformation lin&#233;aire de type :</p>
    <p>x_out = a[0]*x_in + a[1]*y_in + a[2]<br />
y_out = a[3]*x_in + a[4]*y_in + a[5]</p>
    <p>La valeur des coefficients a[0] &#224; a[5] est cod&#233;e
dans le param&#232;tre [paramresample] sous la forme de la suite
des coefficients 0 &#224; 5. Par exemple, pour effectuer une
r&#233;duction homog&#232;ne de l'image d'un facteur 2, on
&#233;crira :</p>
    <p>IMA/SERIES ... RESAMPLE "paramresample=0.5 0 0 0 0.5 0"</p>
    <p>Par d&#233;faut, l'int&#233;grale du flux est conserv&#233;e
(par exemple, si l'image est dilat&#233;e d'un facteur deux sur
les deux axes, sa dynamique sera r&#233;duite d'un facteur
quatre). Pour imposer une normalisation autre du flux, utiliser
le param&#232;tre [normaflux]. Par exemple, pour garder la
dynamique originelle, utiliser normaflux=1.</p>
    <p>Les mots cl&#233;s d'astrom&#233;trie (WCS),
&#233;ventuellement pr&#233;sents dans l'en-t&#234;te FITS, sont
modifi&#233;s en cons&#233;quence de la transformation
g&#233;om&#233;trique.</p>
  </li>
  <li>
    <h3><a name="TRANS" id="TRANS" />Fonction TRANS</h3>
    <p>Effectue une translation constante de [trans_x] [trans_y]
pixels de toutes les images. Les mots cl&#233;s d'astrom&#233;trie
(WCS), &#233;ventuellement pr&#233;sents dans l'en-t&#234;te
FITS, sont modifi&#233;s en cons&#233;quence.<br />
    </p>
    <p>Par exemple, pour effectuer une translation sur l'image
$img.$ext</p>
    <pre>ttscript2 "IMA/SERIES . $img . . $ext . $img . $ext TRANS trans_x=12 trans_y=34 nullpixel=0<br />   <br /></pre>
    <p>L'option nullpixel=0 peut s'av&#233;rer importante pour le
compositage ult&#233;rieur des images. En effet, le mot cl&#233;
NULLPIXEL pourra &#234;tre &#224; nouveau utilis&#233; par les
fonctions d'empilage (IMA/STACK) pour &#233;viter de tenir compte
des "bords noirs" des images.</p>
  </li>
  <li>
    <h3><a name="ROT" id="ROT" />Fonction ROT</h3>
    <p>Effectue une rotation d'un [angle] (en degr&#233;s) autour du
point d&#233;fini par les coordonn&#233;es [x0] [y0]. Les mots
cl&#233;s d'astrom&#233;trie (WCS), &#233;ventuellement
pr&#233;sents dans l'en-t&#234;te FITS, sont modifi&#233;s en
cons&#233;quence.</p>
    <p>Exemple de script pour tourner une image de 15&#176; autour de
son centre x0,y0 :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . rot$file . $ext ROT x0=$x0 y0=$y0 angle=15.0"<br />   <br /></pre>
    <p>L'image produite garde les m&#234;mes dimensions naxis1 et
naxis2 que l'image originale. Une partie des coins de l'image
originale est perdue. La perte est d'autant plus importante que
l'angle de rotation est grand.</p>
  </li>
  <li>
    <h3><a name="ROTENTIERE" id="ROTENTIERE" />Fonction
ROTENTIERE</h3>
    <p>A la diff&#233;rence de ROT, les dimensions de l'image finale
sont modifi&#233;es pour contenir toute l'image originale
tourn&#233;e d'un [angle] (en degr&#233;s) autour du centre de l'image de coordonn&#233;es [x0] (= naxis1 / 2) et [y0] (= naxis2 / 2).</p>
  </li>
</ol>
<h2>3.2. Les fonctions pour 'Retoucher' les images</h2>
<p style="color: rgb(0, 0, 0);">Ces fonctions corrigent des
d&#233;fauts sur les images. Elles produisent autant d 'images en
sortie qu'il y en a en entr&#233;e.</p>
<ol>
  <li>
    <h3><a name="UNSMEARING" id="UNSMEARING" />Fonction
UNSMEARING</h3>
    <p>Effectue une correction de tra&#238;n&#233;e (deconvflat) dans
le cas d'une image effectu&#233;e avec une cam&#233;ra sans
obturateur. Pour ce faire, indiquer la valeur du rapport de
lecture (en g&#233;n&#233;ral proche de 0.0005) dans le
param&#232;tre [unsmearing]. Le coefficient
UNSMEARING=[unsmearing] correspond au rapport du temps de lecture
d'une ligne par rapport a l'image enti&#232;re.</p>
    <p>Cette correction doit &#234;tre effectu&#233;e apr&#232;s
correction du bias et du dark.</p>
    <p>Remarque : Le smearing peut supprim&#233; aussi avec les
commandes <a href="#OPT">OPT</a> et <a href="#SUBDARK">SUBDARK</a> .</p>
    <p>Exemple : Supprimer le smearing de 3 images ugc192-1.fit ,
ugc192-2.fit , ugc192-3.fit acquises avec une Audine Kaf400 avec
512 lignes en binning 2x2 . Le coefficient vaut environ 1 /
(binningx * binningy * nb lignes) = 0.0005 . On suppose que les
images sont dans le r&#233;pertoire par d&#233;faut d&#233;fini
dans la variable ::audace(rep_images).</p>
    <pre>set in "ugc192-"<br />
set first 1<br />
set ni 3<br />
set ext ".fit"<br />
set out "ugc192unsmear-"<br />
set coefficientUnsmear 0.0005<br />
ttscript2 "IMA/SERIES \"$::audace(rep_images)\" \"$in\" $first $ni \"$ext\" \"$::audace(rep_images)\" \"$out\" 1 \"$ext\" UNSMEARING UNSMEARING=$coefficientUnsmear"
    </pre>
    <p>La commande cr&#233;e les 3 images trait&#233;es :
ugc192unsmear-1.fits , ugc192unsmear-2.fits ,
ugc192unsmear-3.fits</p>
  </li>
  <li>
    <h3><a name="HOTPIXEL" id="HOTPIXEL" />Fonction HOTPIXEL</h3>
    <p>Corrige les pixels chauds, les colonnes d&#233;fectueuses et
les lignes d&#233;fectueuses en rempla&#231;ant les valeurs
d&#233;fectueuses par la moyenne des pixels voisins.</p>
    <p>La fonction re&#231;oit en param&#232;tre la liste des pixels
&#224; corriger sous la forme d'une cha&#238;ne de
caract&#232;res contenant les &#233;l&#233;ments suivants :</p>
    <blockquote>
      <p>"P x y" repr&#233;sente les coordonn&#233;es d'un pixel
chaud<br />
"C x" repr&#233;sente l'abscisse d'une colonne
d&#233;fectueuse<br />
"L y" repr&#233;sente l'ordonn&#233;e d'une ligne
d&#233;fectueuse<br />
      </p>
    </blockquote>
    <p>L'exemple suivant corrige le pixel (232,133), le pixel (456
198), la colonne 400 et la ligne 200 :</p>
    <pre>IMA/SERIES ./images/ i- 1 9 .fit ./images/ j . .fit HOTPIXEL HOT_PIXEL_LIST="P 232 133 P 456 198 C 400 L 200"<br /> <br /></pre>
    <p>Remarque : Pour optimiser les traitements, il est possible de
corriger aussi les pixels chauds avec les fonctions de
soustraction des images ou de soustraction des darks (voir les
commandes SUB et SUBDARK)<br />
    </p>
  </li>
  <li>
    <h3><a name="COSMIC" id="COSMIC" />Fonction COSMIC</h3>
    <p>Corrige les cosmiques en rempla&#231;ant les valeurs
alt&#233;r&#233;es par un cosmique par la moyenne des pixels
voisins.</p>
    <p>La fonction re&#231;oit en param&#232;tre un seuil qui permet
d'adapter le niveau de d&#233;tection des cosmiques dans l'image.
La valeur par d&#233;faut est 400. Il est conseill&#233;
d'utiliser une valeur entre 100 et 500.</p>
    <p>Exemple :</p>
    <pre>IMA/SERIES ./images/ i- 1 9 .fit ./images/ j . .fit COSMIC COSMIC_THRESHOLD=350<br />
    </pre>
    <p>Remarque : Pour optimiser les traitements, il est possible de
corriger aussi les cosmiques avec les fonctions de soustraction
des images ou de soustraction des darks (voir les commandes SUB
et SUBDARK<br />
    </p>
  </li>
  <li>
    <h3><a name="OPT" id="OPT" />Fonction OPT</h3>
    <p>Correction du dark avec optimisation. Les images sont
corrig&#233;es des images [bias] et [dark] (noms complets).
L'image [dark] est optimis&#233;e avant d'&#234;tre soustraite.
L'optimisation se fait sur les pixels dont la valeur est
sup&#233;rieure &#224; un certain seuil dans l'image dark. Ce
seuil est calcul&#233; comme la moyenne + [therm_kappa] sigma.
Par d&#233;faut, [therm_kappa]=0.25.</p>
    <p>A la suite des corrections pr&#233;c&#233;dentes, il est
possible d'effectuer une correction de tra&#238;n&#233;e
(deconvflat) dans le cas d'une image effectu&#233;e avec une
cam&#233;ra sans obturateur. Pour ce faire, indiquer la valeur du
rapport de lecture (en g&#233;n&#233;ral proche de 0.0005) dans
le param&#232;tre [unsmearing].</p>
  </li>
  <li>
    <h3><a name="BACK" id="BACK" />Fonction BACK</h3>
    <p>Synth&#233;tise une image du fond de ciel. L'image est d'abord
d&#233;coup&#233;e en pav&#233;s carr&#233;s de c&#244;t&#233;
[back_kernel] (=8 par d&#233;faut) pixels. Dans chaque carr&#233;
est calcul&#233;e la valeur du fond de ciel en prenant la
fraction [back_threshold] (=0.1 par d&#233;faut) des valeurs de
pixels tri&#233;s dans l'ordre d'intensit&#233; croissante
(back_threshold=0 pour ne prendre que les valeurs minimales et =1
pour les valeurs maximales).</p>
    <p>Ajouter [sub] sans argument si l'on souhaite obtenir
directement le r&#233;sultat de la soustraction du fond &#224;
l'image initiale (une valeur constante &#233;gale &#224; la
moyenne du fond synth&#233;tique est ajout&#233;e au
r&#233;sultat de fa&#231;on &#224; retrouver la dynamique
initiale).</p>
    <p>Ajouter [div] sans argument si l'on souhaite obtenir
directement le r&#233;sultat de la division du fond &#224;
l'image initiale (une valeur constante &#233;gale &#224; la
moyenne du fond synth&#233;tique est multipli&#233;e au
r&#233;sultat de fa&#231;on &#224; retrouver la dynamique
initiale).</p>
    <p>Pour soustraire le fond de ciel &#224; une image dont les
&#233;toiles sont &#233;tal&#233;es d'environ 3 pixels, on
essaiera par exemple :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext BACK back_kernel=12 back_threshold=0.2 sub"<br />  <br /></pre>
  </li>
  <li>
    <h3><a name="SUBDARK" id="SUBDARK" />Fonction SUBDARK</h3>
    <p>Soustraction d'un dark de temps de pose diff&#233;rent des
images brutes. Le nom du dark est [dark] et celui du bias est
[bias]. Si [exptime] est le temps d'int&#233;gration des images
et [dexptime] le temps d'exposition du dark, le dark est
corrig&#233; du rapport de ces valeurs. Si [exptime] et
[dexptime] sont des cha&#238;nes de caract&#232;res, alors la
valeur des temps d'int&#233;gration sera recherch&#233;e comme la
valeur de ces mots cl&#233;s.</p>
    <p>Par d&#233;faut, [exptime]="EXPTIME" et
[dexptime]="EXPTIME".</p>
    <p>Si l'argument UNSMEARING=[unsmearing] est pr&#233;sent, il est
possible d'effectuer une correction de tra&#238;n&#233;e
(deconvflat) dans le cas d'une image effectu&#233;e avec une
cam&#233;ra sans obturateur. Pour ce faire, indiquer la valeur du
rapport de lecture (en g&#233;n&#233;ral proche de 0.0005) dans
le param&#232;tre [unsmearing].</p>
    <p>Si l'argument HOT_PIXEL_LIST="P x1 y1 P x2 y2 ..." est
pr&#233;sent, les pixels chauds sont retir&#233;s de chaque image
avant la soustraction du dark (la syntaxe est identique &#224; la
fonction <a href="#HOTPIXEL">HOTPIXEL</a> ).</p>
    <p>Si l'argument COSMIC_THRESHOLD=400 est pr&#233;sent, les
cosmiques sont retir&#233;s de chaque image avant la soustraction
du dark (la syntaxe est identique &#224; la fonction <a href="#COSMIC">COSMIC</a>
)</p>
  </li>
</ol>
<h2>3.3. Les fonctions pour effectuer des op&#233;ration
'arithm&#233;tiques'</h2>
<p style="color: rgb(0, 0, 0);">Ces fonctions modifient
l'intensit&#233; des pixels trait&#233;s et produisent autant
d'images en sortie qu'il y en a en entr&#233;e.</p>
<ol>
  <li>
    <h3><a name="seriesADD" id="ADD" />Fonction ADD</h3>
    <p>Addition pixel &#224; pixel avec une image dont le nom complet
est d&#233;fini par l'argument de [file]. Une valeur d'offset
peut &#234;tre ajout&#233;e et vaut l'argument de [offset].</p>
  </li>
  <li>
    <h3><a name="SUB" id="SUB" />Fonction SUB</h3>
    <p>Soustraction pixel &#224; pixel avec une image dont le nom
complet est d&#233;fini par l'argument de [file]. Une valeur
d'offset peut &#234;tre ajout&#233;e et vaut l'argument de
[offset].</p>
    <p>Si l'argument HOT_PIXEL_LIST="P x1 y1 P x2 y2 ..." est
pr&#233;sent, les pixels chauds sont retir&#233;s de chaque image
avant la soustraction (la syntaxe est identique &#224; la
fonction <a href="#HOTPIXEL">HOTPIXEL</a> ).</p>
    <p>Si l'argument COSMIC_THRESHOLD=400 est pr&#233;sent, les
cosmiques sont retir&#233;s de chaque image avant la soustraction
(la syntaxe est identique &#224; la fonction <a href="#COSMIC">COSMIC</a> )</p>
  </li>
  <li>
    <h3><a name="DIV" id="DIV" />Fonction DIV</h3>
    <p>Division pixel &#224; pixel avec une image dont le nom complet
est d&#233;fini par l'argument de [file]. Une valeur constante
peut &#234;tre multipli&#233;e et vaut l'argument de
[constant].</p>
  </li>
  <li>
    <h3><a name="seriesPROD" id="seriesPROD" />Fonction PROD</h3>
    <p>Produit pixel &#224; pixel avec une image dont le nom complet
est d&#233;fini par l'argument de [file]. Une valeur constante
peut &#234;tre divis&#233;e et vaut l'argument de [constant].</p>
  </li>
  <li>
    <h3><a name="OFFSET" id="OFFSET" />Fonction OFFSET</h3>
    <p>Ajoute, &#224; tous les pixels, une valeur constante qui vaut
l'argument de [offset].</p>
  </li>
  <li>
    <h3><a name="MULT" id="MULT" />Fonction MULT</h3>
    <p>Multiplication de la valeur de tous les pixels par une
constante d&#233;finie par l'argument de [constant].</p>
  </li>
  <li>
    <h3><a name="LOG" id="LOG" />Fonction LOG</h3>
    <p>Effectue une op&#233;ration math&#233;matique de logarithme
selon la formule :</p>
    <p>[coeff] *log10(value-[offsetlog])</p>
    <p>La valeur [nullpixel] (z&#233;ro par d&#233;faut)
appara&#238;t lorsque (value-[offsetlog]) est n&#233;gatif (log
non d&#233;fini).</p>
  </li>
  <li>
    <h3><a name="NORMOFFSET" id="NORMOFFSET" />Fonction
NORMOFFSET</h3>
    <p>Normalise, par un offset, la valeur du fond de ciel &#224; la
valeur sp&#233;cifi&#233;e par [normoffset_value]. Par
d&#233;faut, la valeur de [normoffset_value] vaut z&#233;ro.</p>
  </li>
  <li>
    <h3><a name="NORMGAIN" id="NORMGAIN" />Fonction NORMGAIN</h3>
    <p>Normalise, par une multiplication, la valeur du fond de ciel
&#224; la valeur sp&#233;cifi&#233;e par [normgain_value]. Par
d&#233;faut, la valeur de [normgain_value] vaut la valeur de fond
de ciel de la premi&#232;re image.</p>
  </li>
</ol>
<h2>3.4. Les fonctions 'filtres'</h2>
<p style="color: rgb(0, 0, 0);">Ces fonctions&nbsp;appliquent des
filtres aux images. Elles produisent autant d 'images en sortie
qu'il y en a en entr&#233;e.</p>
<ol>
  <li>
    <h3><a name="FILTER" id="FILTER" />Fonction FILTER</h3>
    <p>Filtrage spatial d'image avec un filtre kernel. Le masque de
kernel est carr&#233; est comporte [kernel_width] pixels. Les
valeurs du kernel sont pr&#233;d&#233;finies en fonction du
[kernel_type]</p>
    <p>kernel_type=fb : Filtre passe-bas</p>
    <p>kernel_type=fh : Filtre passe-haut</p>
    <p>kernel_type=med : Filtre m&#233;dian</p>
    <p>kernel_type=mean : Filtre moyen<br />
    </p>
    <p>kernel_type=min : Filtre minimum</p>
    <p>kernel_type=max : Filtre maximum</p>
    <p>kernel_type=gradup : Filtre gradient &#233;clair&#233; par
le haut</p>
    <p>kernel_type=gradleft : Filtre gradient &#233;clair&#233; par
la gauche</p>
    <p>kernel_type=graddown : Filtre gradient &#233;clair&#233; par le bas</p>
    <p>kernel_type=gradright : Filtre gradient &#233;clair&#233; par
la droite</p>
    <p>L'argument de [kernel_coef] permet de r&#233;gler
l'efficacit&#233; d'action du filtre. Cette efficacit&#233; est
nulle (le filtre n'a aucun effet) si la valeur vaut 1.
L'efficacit&#233; est maximale si la valeur vaut 0. En pratique
l'efficacit&#233; est calcul&#233;e de la fa&#231;on suivante :
value est la valeur initiale du pixel central du kernel, val0 est
la valeur filtr&#233;e par le kernel, valmax est l'avant
derni&#232;re valeur maximale des pixels sous le kernel et valmin
est la deuxi&#232;me valeur minimale des pixels sous le kernel.
On calcule val1 et val2 de la fa&#231;on suivante :</p>
    <p>val1=fabs((double)(val0-value));</p>
    <p>val2=kernel_coef*(valmax-valmin);</p>
    <p>La valeur initiale est remplac&#233;e par la valeur
filtr&#233;e si val1&lt;val2.</p>
    <p>Le param&#232;tre [threshold] permet d'assigner un seuil de
limite du calcul du filtre et [type_threshold] permet de
distinguer la condition du calcul par rapport &#224; ce
seuil.</p>
    <p>type_threshold=-1 : le filtre est appliqu&#233; si le pixel
central initial a une valeur inf&#233;rieure ou &#233;gale au
seuil [threshold]</p>
    <p>type_threshold=0 : le filtre est appliqu&#233; &#224; tous les
pixels de l'image (valeur par d&#233;faut).</p>
    <p>type_threshold=+1 : le filtre est appliqu&#233; si le pixel
central initial a une valeur sup&#233;rieure ou &#233;gale au
seuil [threshold]</p>
  </li>
  <li>
    <h3><a name="CONV" id="CONV" />Fonction CONV</h3>
    <p>Convolution d'image par un filtre de type d&#233;termin&#233;
par [kernel_type] :</p>
    <p>GAUSSIAN : pour un filtre gaussien.</p>
    <p>MORLET : pour une ondelette de type Morlet.</p>
    <p>MEXICAN : pour une ondelette de type chapeau mexicain.</p>
    <p>La largeur des filtres est d&#233;termin&#233;e par la valeur
de l'option [sigma]. Si ce param&#232;tre n'est pas
pr&#233;cis&#233;, sigma sera d&#233;termin&#233;e &#224; partir
de la valeur associ&#233;e au mot cl&#233; FWHM de l'en-t&#234;te
de l'image (sigma = fwhm * 0.601). Si le mot cl&#233; FWHM n'est
pas trouv&#233; dans l'en-t&#234;te, la valeur de sigma, par
d&#233;faut, vaut 2 pixels.</p>
  </li>
  <li>
    <h3><a name="RGRADIENT" id="RGRADIENT" />Fonction
RGRADIENT</h3>
    <p>Effectue un gradient rotationnel, centr&#233; sur la position
pixel d&#233;finie par [xcenter] [ycenter]. Le gradient a pour
param&#232;tre radial [radius] (en pixel) et pour param&#232;tre
angulaire [angle] (en degr&#233;s).</p>
  </li>
  <li>
    <h3><a name="RADIAL" id="RADIAL" />Fonction RADIAL</h3>
    <p>Applique le poids (1-1/(1+(r/[sigma])^[power]))) &#224; chaque
pixel distant de r au centre d&#233;fini par [xcenter],
[ycenter]. Tous les pixels inf&#233;rieurs &#224; la distance
[radius] du centre ne sont pas affect&#233;s. Noter qu'il s'agit
d'un masque utile pour mettre en &#233;vidence les jets coronnaux
lors d'&#233;clipses de Soleils.</p>
  </li>
</ol>
<h2>3.5. Les fonctions pour 'Transformer' les images</h2>
<ol>
  <li>
    <h3><a name="REC2POL" id="REC2POL" />Fonction REC2POL</h3>
    <p>Projection polaire centr&#233;e en [y0] [x0] de l'image
d'entr&#233;e. Par d&#233;faut, les axes polaires ont
1degr&#233;/pix pour l'angle et 1 pix/pix pour
l'&#233;loignement. Il est possible de modifier ces valeurs en
utilisant les facteurs d'&#233;chelle [scale_theta]
[scale_rho].</p>
    <p>Exemple de script pour passer l'image en coordonn&#233;es
polaires centr&#233;es sur x0 et y0, l'image de sortie ayant pour
nom pol$file :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . pol$file . $ext REC2POL x0=$x0 y0=$y0 scale_theta=1. scale_rho=1."<br />   <br /></pre>
  </li>
  <li>
    <h3><a name="POL2REC" id="POL2REC" />Fonction POL2REC</h3>
    <p>Projection cart&#233;sienne centr&#233;e en [y0] [x0] &#224;
partir de l'image d'une projection polaire. Il est possible de
modifier les valeurs des facteurs d'&#233;chelle [scale_theta]
[scale_rho]. Enfin, [width] et [height] sont les largeur et
hauteur de l'image finale.</p>
    <p>Exemple de script pour repasser en coordonn&#233;es
cart&#233;siennes en retrouvant la taille (naxis1 et naxis2) de
l'image d'origine :</p>
    <pre>ttscript2 "IMA/SERIES . pol$file . . $ext . $file . $ext POL2REC x0=$x0 y0=$y0 scale_theta=1. scale_rho=1. width=$naxis1 height=$naxis2"<br />  <br /></pre>
  </li>
  <li>
    <h3><a name="HOUGH" id="HOUGH" />Fonction HOUGH</h3>
    <p>Transform&#233;e de Hough. Chaque point de l'image,
sup&#233;rieur &#224; [threshold] (=0 par d&#233;faut), est
repr&#233;sent&#233;, dans l'espace de Hough (T, R) par une
sinuso&#239;de d'intensit&#233; I, d'&#233;quation R = y*sin(T) -
x*cos(T) avec -90&lt;=T&lt;90. La valeur R=0 est situ&#233;e
&#224; la ligne telle que y=naxis2/2 et la valeur T=0 est
situ&#233;e &#224; la colonne x=naxis1/2 (T=0, R=0 est donc au
milieu de l'image). L'&#233;chelle de T vaut 1 degr&#233; par
pixel (R est en pixel de l'image initiale). I vaut 1 si on a
pr&#233;cis&#233; [binary] sinon il vaut la valeur
d'intensit&#233; du pixel de l'image initiale. La
transform&#233;e de Hough permet de rep&#233;rer la position de
pixels align&#233;s (tra&#238;n&#233;e de smearing, satellite,
avion, etc.).</p>
  </li>
</ol>
<h2>3.6. Les fonctions pour 'Extraire des informations'</h2>
<ol>
  <li>
    <h3><a name="PROFILE" id="PROFILE" />Fonction PROFILE</h3>
    <p>Extrait la valeur num&#233;rique des pixels d'une ligne ou
d'une colonne dans un fichier texte [filename]. [direction]=x ou
y respectivement pour effectuer le profil selon les lignes ou les
colonnes. [offset] repr&#233;sente le num&#233;ro de ligne ou de
colonne sur lequel sera effectu&#233; le profil. Si
[direction]=x, alors [offset] peut &#234;tre compris entre 1 et
le nombre de colonnes. Si [direction]=y, alors [offset] peut
&#234;tre compris entre 1 et le nombre de lignes. Le fichier
[filename] contient une ent&#234;te de 1 ligne sur 2
colonnes.</p>
    <p>Exemple de script pour extraire la colonne (direction=y) de
coordonn&#233;e x (offset) vers un fichier profile.txt :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext PROFILE direction=y offset=1 filename=profile.txt"<br /></pre>
    <p>Le fichier profile.txt se pr&#233;sente ainsi :<br />
pixel value of the pixel<br />
1 13.000000<br />
2 9.275490<br />
3 9.827091</p>
    <p>Le fichier est directement copiable dans Excel ou peut
&#234;tre lu pour recopier les valeurs dans un vecteur (liste de
3474 valeurs pour un .CR2 !)</p>
    <p>Dans l'exemple ci-dessus on a extrait les valeurs d'un fichier
binn&#233; n'ayant qu'une seule colonne. Pour extraire une ligne
particuli&#232;re d'une image :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext PROFILE direction=x offset=$y filename=profile.txt"<br /></pre>
Pour extraire une seule colonne particuli&#232;re :
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext PROFILE direction=y offset=$x filename=profile.txt"<br /></pre>
  </li>
  <li>
    <h3><a name="PROFILE2" id="PROFILE2" />Fonction PROFILE2</h3>
    <p>Extrait la valeur num&#233;rique des pixels d'une ligne ou
d'une colonne dans un fichier texte [filename]. [direction]=x ou
y respectivement pour effectuer le profil selon les lignes ou les
colonnes. [offset] repr&#233;sente le num&#233;ro de ligne ou de
colonne sur lequel sera effectu&#233; le profil. Si
[direction]=x, alors [offset] peut &#234;tre compris entre 1 et
le nombre de colonnes. Si [direction]=y, alors [offset] peut
&#234;tre compris entre 1 et le nombre de lignes. A la
diff&#233;rence de PROFIL le fichier [filename] ne contient pas
d'ent&#234;te.</p>
  </li>
  <li>
    <h3><a name="BINY" id="BINY" />Fonction BINY</h3>
    <p>Attribue, &#224; chaque colonne, une valeur constante
&#233;gale &#224; la somme de tous les pixels de cette colonne
entre les pixels [y1] et [y2]. L'image finale comporte [height]
colonnes (20 par d&#233;faut).</p>
    <p>Exemple de script pour additionner tous les pixels de chaque
colonne. L'image finale ne contient qu'une seule ligne ; comme on
additionne tous les valeurs, on passe en 32 bits pour garder une
grande amplitude de valeur ; $in est le nom de l'image
d'entr&#233;e , $ext l'extension, bin_y$in le nom de l'image de
sortie :</p>
    <pre>ttscript2 "IMA/SERIES . $in . . $ext . biny_$in . $ext BINY y1=1 y2=$naxis2 height=1 bitpix=32"<br />    <br /></pre>
    <p>L'image finale contient une seule ligne (height=1).</p>
  </li>
  <li>
    <h3><a name="MEDIANY" id="MEDIANY" />Fonction MEDIANY</h3>
    <p>Attribue, &#224; chaque colonne, une valeur constante
&#233;gale &#224; la m&#233;diane de tous les pixels de cette
colonne entre les pixels [y1] et [y2]. L'image finale comporte
[height] colonnes (20 par d&#233;faut).</p>
    <p>C'est le parall&#232;le de BINY : la somme est remplac&#233;e
par la m&#233;diane.</p>
  </li>
  <li>
    <h3><a name="SORTY" id="SORTY" />Fonction SORTY</h3>
    <p>Attribue, &#224; chaque colonne, une valeur constante
&#233;gale &#224; la valeur tri&#233;e &#224; [percent] (=50 pour
la m&#233;diane, =100 pour le maximum) de tous les pixels de
cette colonne entre les pixels [y1] et [y2]. L'image finale
comporte [height] colonnes (20 par d&#233;faut).</p>
    <p>C'est le parall&#232;le de BINY : la somme est remplac&#233;e
par la valeur tri&#233;e (CF <a href="ttus1-fr.htm#SORT">IMA/STACK
SORT</a>).</p>
  </li>
  <li style="list-style-type: none; list-style-image: none; list-style-position: outside;">
    <p style="color: rgb(0, 0, 0);">Ces fonctions permettent
d'extraire les valeurs d'intensit&#233; dans un fichier .txt.
Elles ne peuvent traiter qu'une seule image &#224; la fois : si
on traitait une s&#233;rie ou une liste d&#233;pareill&#233;e,
les fichiers produits seraient &#233;cras&#233;s &#224;
l'exception du dernier. Le nom de l'image de sortie est identique
&#224; celui de l'image d'entr&#233;e.<br />
    </p>
  </li>
  <li>
    <h3><a name="BINX" id="BINX" />Fonction BINX</h3>
    <p>Attribue, &#224; chaque ligne, une valeur constante &#233;gale
&#224; la somme de tous les pixels de cette ligne entre les
pixels [x1] et [x2]. L'image finale comporte [width] colonnes (20
par d&#233;faut).</p>
    <p>Exemple de script pour additionner tous les pixels de chaque
ligne entre les pixels 1 et naxis1, $file est le nom de l'image
d'entr&#233;e , $ext l'extension et binx_$file le nom de l'image
de sortie :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . binx_$file . $ext BINX x1=1 x2=$naxis1 width=1 bitpix=32"<br />  <br /></pre>
    <p>L'image finale contient une seule colonne (width=1), d'o&#249;
un petit fichier. Comme on additionne tous les valeurs, on passe
en 32 bits pour garder une grande amplitude de valeurs.</p>
  </li>
  <li>
    <h3><a name="MEDIANX" id="MEDIANX" />Fonction MEDIANX</h3>
    <p>Attribue, &#224; chaque ligne, une valeur constante &#233;gale
&#224; la m&#233;diane de tous les pixels de cette ligne entre
les pixels [x1] et [x2]. L'image finale comporte [width] colonnes
(20 par d&#233;faut).</p>
    <p>C'est le parall&#232;le de BINX : la somme est remplac&#233;e
par la m&#233;diane.</p>
  </li>
  <li>
    <h3><a name="SORTX" id="SORTX" />Fonction SORTX</h3>
    <p>Attribue, &#224; chaque ligne, une valeur constante &#233;gale
&#224; la valeur tri&#233;e &#224; [percent] (=50 pour la
m&#233;diane, =100 pour le maximum) de tous les pixels de cette
ligne entre les pixels [x1] et [x2]. L'image finale comporte
[width] colonnes (20 par d&#233;faut).</p>
    <p>C'est le parall&#232;le de BINX : la somme est remplac&#233;e
par la valeur tri&#233;e (CF <a href="#SORT">IMA/STACK
SORT</a>).</p>
  </li>
  <li>
    <h3><a name="MATRIX" id="MATRIX" />Fonction MATRIX</h3>
  </li>
</ol>
<p style="text-align: left; margin-left: 40px;">Extrait une fen&#234;tre
[x1] [x2] [y1] [y2] de l'image et
&#233;crit les valeurs de ces pixels dans un fichier texte
[filematrix]. L'image de sortie est la m&#234;me que celle
d'entr&#233;e.</p>
<h2>3.7. Les fonctions 'r&#233;gistration'</h2>
<ol>
  <li>
    <h3><a name="REGISTER" id="REGISTER" />Fonction REGISTER</h3>
    <p>Effectue la r&#233;gistration des images par rapport &#224; la
premi&#232;re. Il faut pr&#233;alablement que toutes les images
aient un liste d'objets associ&#233;e (cf. fonction STAT).
[translate] permet de contraindre le mode de calcul de la
r&#233;gistration :</p>
    <p>translate=only : on contraint le passage d'une image &#224;
l'autre par une translation.</p>
    <p>translate=before : on effectue d'abord le calcul de
r&#233;gistration par une translation, puis si aucun accord n'est
trouv&#233;, on effectue une transformation lin&#233;aire
quelconque.</p>
    <p>translate=after : on effectue d'abord le calcul de
r&#233;gistration par une transformation lin&#233;aire
quelconque. puis si aucun accord n'est trouv&#233;, on effectue
une translation.</p>
    <p>translate=never : on effectue le calcul de r&#233;gistration
uniquement par une transformation lin&#233;aire quelconque.</p>
    <p>Le mot d'option [matchwcs] indique que le recentrage ne sera
fait qu'avec les mots cl&#233;s WCS de l'image. A noter que dans
ce cas on peut effectuer une r&#233;gistration sur des images
d'entr&#233;e de dimensions diff&#233;rentes. Cela est tr&#232;s
utile pour combiner des images effectu&#233;es avec des
t&#233;lescopes diff&#233;rents.</p>
    <p>Par d&#233;faut, l'int&#233;grale du flux est conserv&#233;e
(par exemple, si l'image est dilat&#233;e d'un facteur deux, sa
dynamique sera r&#233;duite d'un facteur 2). Pour imposer une
normalisation autre du flux, utiliser le param&#232;tre
[normaflux]. Par exemple, pour garder la dynamique originelle,
utiliser normaflux=1.</p>
    <p>Les mots cl&#233;s d'astrom&#233;trie (WCS),
&#233;ventuellement pr&#233;sents dans l'en-t&#234;te FITS, sont
modifi&#233;s en cons&#233;quence.</p>
  </li>
  <li>
    <h3><a name="REGISTERFINE" id="REGISTERFINE" />Fonction
REGISTERFINE</h3>
    <p>Effectue une translation de fa&#231;on &#224; minimiser la
somme des carr&#233;s des r&#233;sidus avec une image de
r&#233;f&#233;rence [file]. La translation sera recherch&#233;e
entre les bornes en pixels d&#233;limit&#233;s par [delta] avec
un sur&#233;chantillonnage [oversampling].</p>
  </li>
  <li>
    <h3><a name="FITELLIP" id="FITELLIP" />Fonction FITELLIP</h3>
    <p>Synth&#233;tise une image par ajustement d'ellipses. Cette
fonction permet de synth&#233;tiser l'image non bruit&#233; d'une
galaxie elliptique (pour &#233;ventuellement la soustraire &#224;
l'image originale). Avant d'utiliser Fitellip, il est
n&#233;cessaire d'enlever les &#233;toiles les plus brillantes de
l'image. On peut travailler uniquement sur une partie de l'image
d&#233;limit&#233;e par [x1] [x2] [y1] [y2]. Il faut d&#233;finir
un centre approximatif (&#224; quelques pixels pr&#232;s) avec
[xcenter] et [ycenter]. Il faut d&#233;finir le niveau (en ADU)
du fond de ciel avec [backgound]. Il est possible de raffiner
l'ajustement en introduisant un d&#233;veloppement de Fourier par
dessus les ellipses afin de tenir compte des effets boxy ou lemon
en utilisant [fitorder6543]. Ce param&#232;tre comprend quatre
entiers: par exemple 0000 signifie qu'il ne faut faire aucun
d&#233;veloppement d'ordre sup&#233;rieur &#224; 2. Pour un
d&#233;veloppement d'ordre 4 uniquement, [fitorder6543]=0010. Les
param&#232;tres du profil final sont dans le fichier d&#233;finit
par [file_ascii]. Le format de sortie est le suivant:: indice,
rayon^1/4 (arcmin), magnitude surfacique (mag/arcsec^2), xce et
yce les centres de l'ellipse, csa (?), l'angle au nord, et les
coefficients de Fourier: a3 b3 a4 b4 a5 b5 a6 b6. Le
param&#232;tre [threshold] s'il n'est pas =0, permet de
synth&#233;tiser une image &#224; partir de l'image originale (o)
&#224; qui l'on remplace les pixels par l'image de l'ajustement
d'ellipses (c) si o-c&gt;[threshold].</p>
    <p>Pour mod&#233;liser l'image d'une galaxie centr&#233;e au
pixel (32,99) avec un fond de ciel de 150 A.D.U. :</p>
    <pre>ttscript2 "IMA/SERIES . $file . . $ext . $file . $ext FITELLIP xcenter=32 ycenter=99 background=150 "<br />
    </pre>
  </li>
</ol>
<h2>3.8. Les fonctions 'en-t&#234;tes'</h2>
<p style="color: rgb(0, 0, 0);">Elles compl&#232;tent ou
modifient les mots cl&#233;s des images. Elles produisent autant
d 'images en sortie qu'il y en a en entr&#233;e.</p>
<ol>
  <li>
    <h3><a name="STAT" id="STAT" />Fonction STAT</h3>
    <p>Effectue le calcul des param&#232;tres statistiques de l'image
(moyenne, &#233;cart type, minimum, maximum, moyenne du fond,
&#233;cart type du fond, seuil haut, seuil bas, contraste).
Calcule le nombre de pixels satur&#233;s si on d&#233;finit la
valeur de [pixelsat_value]. Calcule la largeur &#224; mi-hauteur
moyenne des &#233;toiles du champ si le param&#232;tre optionnel
[fwhm] est pr&#233;sent.</p>
    <p>Si l'option [objefile] est pr&#233;sente, g&#233;n&#232;re une
liste d'objets dont le nom complet du fichier FITS est l'argument
de [objefile]. De m&#234;me, on peut g&#233;n&#233;rer une liste
de pixels dont le nom complet du fichier FITS est l'argument de
[pixefile]. [pixefile] et [objefile] peuvent avoir le m&#234;me
nom. Il est possible de r&#233;duire la fen&#234;tre de recherche
pour [objefile] et [pixefile]. Pour cela, on utilise le mot
[border] suivit d'un pourcentage. Ce pourcentage vaut 0 pour
calculer sur toute l'image (valeur par d&#233;faut), et vaut au
maximum 90 pour effectuer le calcul sur une petite zone au centre
de l'image. [border] n'affecte pas le calcul des param&#232;tres
statistiques moyenne, etc. Enfin, il est possible de r&#233;gler
le seuil de d&#233;tection en agissant sur la valeur de
[detect_kappa]. Par d&#233;faut, [detect_kappa] vaut 3 (en
unit&#233;s d'&#233;cart type du fond).</p>
    <p>Si le mot cl&#233; [pixint] est pr&#233;sent alors le calcul
de la liste d'objet est effectu&#233; avec des coordonn&#233;es
(x,y) en pixels entier et non pas fractionnaires (option par
d&#233;faut).</p>
  </li>
  <li>
    <h3><a name="CUTS" id="CUTS" />Fonction CUTS</h3>
    <p>Calcule les seuils de visualisation de l'image par analyse de
l'histogramme. La valeur des seuils est compl&#233;t&#233;e dans
l'en-t&#234;te FITS. Le mot cl&#233; correspondant au seuil haut
est d&#233;finit par [hicut] (MIPS-HI par d&#233;faut) et celui
du seuil bas est d&#233;finit par [locut] (MIPS-LO par
d&#233;faut). Le type de valeur pour l'en-t&#234;te FITS est
donn&#233;e par [keytype] et peut valoir INT, FLOAT ou STRING
(INT par d&#233;faut). Par exemple :</p>
    <p>IMA/SERIES ... CUTS hicut=SH locut=SB keytype=FLOAT</p>
    <p>Les param&#232;tres [lofrac] et [hifrac] servent &#224; fixer
la fraction de l'histogramme o&#249; seront calcul&#233;s les
seuils. [lofrac] (=0.05 par d&#233;faut) est la fraction pour le
seuil bas et [lofrac] (=0.05 par d&#233;faut) est la fraction
pour le seuil haut. ces valeurs peuvent varier de 0 &#224; 1.</p>
    <p>Le param&#232;tre [cutscontrast] (=1 par d&#233;faut) sert
&#224; adoucir le contraste. Plus sa valeur est grande, plus doux
sera le contraste. La valeur doit &#234;tre une quantit&#233;
r&#233;elle positive ou nulle.</p>
    <p>La m&#233;thode de calcul de la fonction CUTS fourni un
r&#233;sultat bien plus rapide que le calcul des seuils par la
fonction STAT. Cependant, la qualit&#233; du calcul est un peu
meilleure pour la fonction STAT que l'on pr&#233;f&#233;rera pour
des petites images (inf&#233;rieures &#224; 500x500 typiquement).
La fonction CUTS pr&#233;sente un grand int&#233;r&#234;t sur les
grandes images car seuls 100 000 points servent au calcul. Le
temps de calcul est donc le m&#234;me quelque soit la taille de
l'image (alors qu'il peu devenir long pour la fonction STAT).</p>
  </li>
  <li>
    <h3><a name="HEADERFITS" id="HEADERFITS" />Fonction
HEADERFITS</h3>
    <p>Ajoute des mots cl&#233;s &#224; l'en-t&#234;te FITS. Les mots
cl&#233;s sont d&#233;finis dans un fichier texte ASCII dont le
nom complet est l'argument de [file]. Chaque mot cl&#233; est
d&#233;fini par 5 lignes dans le fichier texte :</p>
    <p>ligne 1 : nom du mot cl&#233; (en majuscules &lt;= 8
lettres)</p>
    <p>ligne 2 : valeur associ&#233;e au mot cl&#233;.</p>
    <p>ligne 3 : type de la valeur (short, int, float, double,
string)</p>
    <p>ligne 4 : commentaire</p>
    <p>ligne 5 : unit&#233;s</p>
    <p>S'il n'y a pas de commentaire, laisser la ligne blanche. De
m&#234;me pour l'unit&#233;. On peut ajouter autant de
mots cl&#233;s que l'on veut.</p>
    <p>Exemple de script pour modifier l'en-t&#234;te FITS des images
avec les donn&#233;es du kwdfile.txt contenu dans le
r&#233;pertoire de travail :</p>
    <pre>ttscript2 "IMA/SERIES . $img 1 3 $ext . $img 1 $ext HEADERFITS file=kwdfile.txt"<br /> <br /></pre>
  </li>
  <li>
    <h3><a name="CATCHART" id="CATCHART" />Fonction CATCHART</h3>
    <p>Dresse un liste d'objets d'un catalogue correspondant au champ
&#224; l'image d'entr&#233;. La liste est enregistr&#233;e dans
le fichier FITS de nom complet l'argument de [catafile]. Par
d&#233;faut (catafile employ&#233; sans argument) le fichier FITS
est celui de l'image de sortie. Ainsi, la liste du catalogue est
ajout&#233;e derri&#232;re l'image. Si l'on souhaite
g&#233;n&#233;rer une liste catalogue &#224; part de l'image, il
suffit de sp&#233;cifier son nom comme argument de [catafile].
Dans ce cas, ce fichier FITS contiendra toutes les listes
catalogues de la s&#233;rie d'image.</p>
    <p>[path_astromcatalog] est le chemin d'acc&#232;s au catalogue.
[astromcatalog] est le nom du catalogue choisit :</p>
    <p>astromcatalog=USNO : pour utiliser l'USNO A ou SA</p>
    <p>astromcatalog=MICROCAT : pour utiliser le catalogue
astrom&#233;trique compact&#233; Microcat.</p>
    <p>Sinon, il s'agit d'un nom de fichier ASCII d'un catalogue
personnel contenant des lignes de type "ra dec mag" o&#249; ra et
dec sont exprim&#233;s en degr&#233;s d&#233;cimaux et mag est la
magnitude.</p>
    <p>[jpegfile_chart] est le nom du fichier jpeg qui simule l'image
du champ des &#233;toiles du catalogue.</p>
    <p>[jpegfile_chart2] est le nom du fichier jpeg qui simule
l'image du champ des &#233;toiles du catalogue qui se superposent
en rouge sur le champ observ&#233;.</p>
    <p>Il est possible de r&#233;duire la fen&#234;tre de la carte
des &#233;toiles du catalogue. Pour cela, on utilise le mot
[border] suivit d'un pourcentage. Ce pourcentage vaut 0 pour
calculer sur toute l'image (valeur par d&#233;faut), et vaut au
maximum 90 pour effectuer le calcul sur une petite zone au centre
de l'image (cf. fonction STAT de IMA/SERIES).</p>
    <p>On peut fixer une limite de magnitude au-del&#224; de laquelle
on ne lit pas les donn&#233;es dans le catalogue. Les arguments
de [magrlim] [magblim] fixent ces limites (99 par d&#233;faut).
Dans le cas d'un catalogue personnel, seul [magrlim] est
actif.</p>

    <p>Si le mot [simulimage] est sp&#233;cifi&#233; alors l'image de
sortie sera une image synth&#233;tique compos&#233;e &#224;
partir des &#233;toiles trouv&#233;es dans le catalogue. Les
param&#232;tres physiques optionnels sont : [exposure] (= 1 seconde
par d&#233;faut), [fwhmx] (= 2.5 pixels par d&#233;faut), [ fwhmy]
(= 2.5 pixels par d&#233;faut), [teldiam] (= 1 m&#232;tre par
d&#233;faut), [colfilter] (= R par d&#233;faut), [sky_brightness]
(= 20.9 mag/arcsec2 par d&#233;faut), [qe] (= 1 par d&#233;faut),
[gain] (= 2.5 e/ADU par d&#233;faut), [readout_noise] (= 0
&#233;lectron par d&#233;faut), [shutter_mode] (= 0 si obturateur
ferm&#233;, = 1 si obturateur synchro (valeur par d&#233;faut), = 2
si obturateur toujours ouvert ou inexistant, = 3 si obturateur synchro
mais sans synth&#232;se d'&#233;toiles (simule un &#233;cran de
flat)), [bias_level] (= 0 ADU par d&#233;faut, d&#233;finit un
niveau constant du bias), [thermic_response] (= 0 par d&#233;faut,
exprime la r&#233;ponse thermique moyenne en e/pix/sec), [flat_type]
(= 0 pour ne pas tenir compte d'une r&#233;ponse de flat (par
d&#233;faut), = 1 pour tenir compte d'un vignettage parabolique).</p>
  </li>
  <li>
    <h3><a name="ASTROMETRY" id="ASTROMETRY" />Fonction
ASTROMETRY</h3>
    <p>Calcule les param&#232;tres astrom&#233;triques de l'image
(mots cl&#233;s CRVAL1, CRVAL2, CD1_1, CD1_2, CD2_1, CD2_2 de
l'en-t&#234;te FITS dans le cas d'une transformation
lin&#233;aire). Il faut pr&#233;alablement que les images soient
associ&#233;es &#224; des listes d'objets (voir fonction STAT) et
des listes de catalogue (voir fonction CATCHART). De plus, pour
initialiser le calcul des coefficients astrom&#233;triques, il
faut pr&#233;d&#233;finir la valeur de RA, DEC, PIXSIZE1,
PIXSIZE2 et FOCLEN dans l'en-t&#234;te FITS (cf. fonction
HEADERFITS) :</p>
    <p>RA : coordonn&#233;e approximative d'ascension droite du
centre de l'image (en degr&#233;s)</p>
    <p>DEC : coordonn&#233;e approximative de d&#233;clinaison du
centre de l'image (en degr&#233;s)</p>
    <p>PIXSIZE1 : taille du pixel sur l'axe x (en microns)</p>
    <p>PIXSIZE2 : taille du pixel sur l'axe y (en microns)</p>
    <p>FOCLEN : longueur focale approximative (en m&#232;tres).</p>
    <p>Le param&#232;tre [epsilon] permet de r&#233;gler le rayon
d'appariement de la m&#233;thode des triangles (=0.002 par
d&#233;faut). [delta] permet de r&#233;gler le nombre de pixels
d'appariement final (=1 par d&#233;faut).</p>
    <p>Si le param&#232;tre [objefile] est pr&#233;sent, il indique
le nom du catalogue g&#233;n&#233;r&#233; par Sextractor &#224;
utiliser comme liste d'objets. Le catalogue est de la forme
suivante :</p>
    <p>Indice</p>
    <p>Flux ErrFlux Mag ErrMag</p>
    <p>Backgnd X Y X2</p>
    <p>Y2 XY a b</p>
    <p>theta fwhm flag</p>
    <p>avec</p>
    <p>X2 : moment d'ordre 2 selon X</p>
    <p>Y2 : moment d'ordre 2 selon Y</p>
    <p>XY : moment d'ordre 2 selon X-Y</p>
    <p>a : grand axe de l'ellipse repr&#233;sentant au mieux
l'objet</p>
    <p>b : petit axe de l'ellipse repr&#233;sentant au mieux
l'objet</p>
    <p>theta : angle de l'ellipse repr&#233;sentant au mieux
l'objet</p>
    <p>flag : flag sextractor</p>
  </li>
  <li>
    <h3><a name="ASTROMETRY2" id="ASTROMETRY2" />Fonction
ASTROMETRY2</h3>
    <p>Effectue l'astrom&#233;trie de la m&#234;me mani&#232;re que
ASTROMETRY mais calcule les coefficients de d&#233;formation du
second ordre. ces coefficients sont cod&#233;s par les mots
cl&#233;s FITS standards PV* dans l'en-t&#234;te de l'image de
sortie.</p>
  </li>
</ol>
<h2>3.9. Les fonctions 'spectres'</h2>
<p style="color: rgb(0, 0, 0);">Ces fonctions sont utiles pour
traiter des images spectrales. Elles produisent autant d 'images
en sortie qu'il y en a en entr&#233;e.</p>
<ol>
  <li>
    <h3><a name="TILT" id="TILT" />Fonction TILT</h3>
    <p>Effectue une translation de colonnes
Dy=(x-0.5*NAXIS1/2)*[trans_y] puis une translation de lignes
Dx=(y-0.5*NAXIS2)*[trans_x] afin de corriger les effets
d'inclinaison des raies dans un spectre.</p>
  </li>
  <li>
    <h3><a name="SMILEX" id="SMILEX" />Fonction SMILEX</h3>
    <p>Effectue une translation de lignes
Dx=[coef_smile2]*(y-[ycenter])^2+[coef_smile4]*(y-[ycenter])^4
pour corriger les effets de distorsions de type smile des raies
dans un spectre.</p>
  </li>
  <li>
    <h3><a name="SMILEY" id="SMILEY" />Fonction SMILEY</h3>
    <p>Effectue une translation de lignes
Dy=[coef_smile2]*(x-[xcenter])^2+[coef_smile4]*(x-[xcenter])^4
pour corriger les effets de distorsions de type smile des raies
dans un spectre.</p>
  </li>
  <li>
    <h3><a name="LOPT" id="LOPT" />Fonction LOPT</h3>
    <p>Calcul la somme normalis&#233;e &#224; 32767 et optimis&#233;e
entre les lignes [y1] et [y2] d'apr&#232;s J. G. Robertson, PASP
98, 1220-1231, November 1986. Le code est copi&#233; du logiciel
IRIS. L'image finale comporte [height] lignes (20 par
d&#233;faut).<br />
    </p>
  </li>
</ol>
<h2>3.10. Les fonctions 'utilitaires'</h2>
<ol>
  <li>
    <h3><a name="COPY" id="COPY" />Fonction COPY</h3>
    <p>Recopie sans rien changer, les images vers un autre nom,
r&#233;pertoire, suffixe.</p>
    <p>Il est possible de changer le num&#233;ro d'ordre des indices
des fichiers de sortie en sp&#233;cifiant le nombre de sous
s&#233;ries (param&#232;tre [nbsubseries]=1 par d&#233;faut). Par
exemple, si l'on a r&#233;alis&#233; douze images i1 &#224; i12
en quatre sous s&#233;ries de trois images ([nbsubseries]=4)
l'indexation des images de sortie (j1 &#224; j12) sera faite
ainsi :</p>
    <p>entr&#233;e (1 2 3) (4 5 6) (7 8 9) (10 11 12)<br />
sortie (1 4 7 10) (2 5 8 11) (3 6 9 12)</p>
    <p>De cette fa&#231;on, la premi&#232;re s&#233;rie en sortie
contient les premi&#232;res images de chaque s&#233;rie
d'entr&#233;e, le deuxi&#232;me s&#233;rie en sortie contient les
deuxi&#232;mes images de chaque s&#233;rie d'entr&#233;e et ainsi
de suite. En pratique, cela permet de trier les images en vue de
la r&#233;alisation d'un superflat &#224; partir de s&#233;ries
d'images. Dans notre exemple, (1 2 3) sont trois images du
m&#234;me champ, (4 5 6) trois images d'un autre champ, etc. La
s&#233;rie de sortie (1 4 7 10) c'est &#224; dire j1 &#224; j4
contient les images de champs diff&#233;rents et peuvent
synth&#233;tiser un superflat. La deuxi&#232;me s&#233;rie de
sortie (2 5 8 11) permet de r&#233;aliser un deuxi&#232;me
superflat et ainsi de suite. Il suffit ensuite de combiner les
superflats pour r&#233;aliser un superflat total.</p>
    <p>Exemple de script pour copier un fichier d'un r&#233;pertoire
externe au r&#233;pertoire de travail :</p>
    <pre>ttscript2 "IMA/SERIES \"$dir\" $in . . $ext . $in . $ext COPY"<br />   <br /></pre>
  </li>
  <li>
    <h3><a name="DELETE" id="DELETE" />Fonction DELETE</h3>
    <p>Efface les fichiers.</p>
    <p>Exemple de script pour effacer une liste de fichiers de noms
d&#233;pareill&#233;s :</p>
    <pre>ttscript2 "IMA/SERIES .  \"$liste_de_noms_courts_sans_extension\" * * $ext . . . . DELETE"<br />  <br /></pre>
  </li>
</ol>
<h1>4. Exemples de scripts</h1>
<p>Nous allons &#233;tudier ici quelques cas classiques de
traitement d'images astronomiques.</p>
<h2>4.1. Pr&#233;traitement des images CCD</h2>
Le pr&#233;traitement des images consiste &#224; soustraire le
dark aux images brutes puis de diviser par le flatfield. Tout cet
exemple traite des images acquises suivantes :
<p>images de bias : de bias-1.fit &#224; bias-9.fit dans le
chemin ./bias</p>
<p>images de dark : de dark-1.fit &#224; dark-9.fit dans le
chemin ./dark</p>
<p>images de flat : de flat-1.fit &#224; flat-9.fit dans le
chemin ./flat</p>
<p>images &#224; pr&#233;traiter : de sky-1.fit &#224; sky-9.fit
dans le chemin ./sky</p>
<p>Nous allons d'abord pr&#233;parer des images synth&#233;tiques
de bias, dark et flat, r&#233;sultant d'empilements, afin
d'att&#233;nuer le bruit. Enfin, nous allons pr&#233;traiter les
images en utilisant la m&#233;thode de l'optimisation du
thermique. Les images pr&#233;trait&#233;es seront plac&#233;es
dans le chemin ./prt</p>
<ol>
  <li>
    <h3>Pr&#233;paration du bias</h3>
    <p>Le bias est une image de tr&#232;s court temps
d'int&#233;gration, obtenue dans le noir absolu. Le
pr&#233;traitement propos&#233; consiste &#224; faire une pile
m&#233;diane : IMA/STACK ./bias/ bias- 1 9 .fit ./bias/ bias .
.fit MED</p>
  </li>
  <li>
    <h3>Pr&#233;paration du dark</h3>
    <p>Le dark est une image de temps d'int&#233;gration proche de
celui des images sky, obtenue dans le noir absolu. Le
pr&#233;traitement propos&#233; consiste &#224; faire une pile
m&#233;diane : IMA/STACK ./bias/ bias- 1 9 .fit ./bias/ bias .
.fit MED</p>
    <p>Le dark est une image de temps d'int&#233;gration proche dark
. .fit MED</p>
  </li>
  <li>
    <h3>Pr&#233;paration du flat</h3>
    <p>Le bias est une image obtenue sur une surface lumineuse la
plus uniforme possible. Le pr&#233;traitement propos&#233;
consiste &#224; faire une correction de dark, suivie d'une
normalisation en gain et d'une pile m&#233;diane.SET/VAR
$smearing 0</p>
    <p>IMA/SERIES ./flat/ flat- 1 9 .fit ./flat/ f . .fit OPT
bias=./bias/bias.fit dark=./dark/dark.fit
unsmearing=$smearing</p>
    <p>IMA/SERIES ./flat/ f- 1 9 .fit ./flat/ f . .fit NORMGAIN
normgain_value=10000</p>
    <p>IMA/STACK ./flat/ f- 1 9 .fit ./flat/ flat . .fit MED</p>
    <p>IMA/SERIES ./flat/ f- 1 9 .fit . . . .fit DELETE</p>
    <p>Si les images ont &#233;t&#233; obtenues avec un obturateur,
la valeur de $smearing doit &#234;tre &#233;gale &#224;
z&#233;ro. Avec des images obtenues sans obturateur, il est
n&#233;cessaire de placer une valeur non nulle &#224;
$smearing.</p>
  </li>
  <li>
    <h3>Pr&#233;traitement des images brutes</h3>
    <p>SET/VAR $sky sky<br />
SET/VAR $smearing 0<br />
IMA/SERIES ./sky/ $sky- 1 9 .fit ./prt/ i . .fit OPT
bias=./bias/bias.fit dark=./dark/dark.fit
unsmearing=$smearing<br />
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit DIV
file=./flat/flat.fit constant=10000<br />
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit NORMOFFSET
normoffset_value=200 skylevel Si les images ont &#233;t&#233;
obtenues avec un obturateur, la valeur de $smearing doit
&#234;tre &#233;gale &#224; z&#233;ro. Avec des images obtenues
sans obturateur, il est n&#233;cessaire de placer une valeur non
nulle &#224; $smearing.</p>
  </li>
  <li>
    <h3>R&#233;gistration et empilement des images
pr&#233;trait&#233;es</h3>
    <p>SET/VAR $sky sky<br />
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit STAT
objefile=./prt/x$sky.fit<br />
IMA/SERIES ./prt/ i- 1 9 .fit ./prt/ i . .fit REGISTER
translate=before nullpixel=-1000<br />
IMA/STACK ./prt/ i- 1 9 .fit ./prt/ $sky . .fit MED
nullpixel=-1000<br />
IMA/SERIES ./prt/ i- 1 9 .fit . . . .fit DELETE<br />
IMA/SERIES ./prt/ x$sky . . .fit . . . .fit DELETE</p>
  </li>
  <li>
    <h3>Mise en forme de l'image pr&#233;trait&#233;e</h3>
SET/VAR $sky sky<br />
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit STAT fwhm
jpegfile=./prt/$sky.jpg</li>
</ol>
<h2>4.2. Calibration astrom&#233;trique d'une image
pr&#233;trait&#233;e</h2>
<p>IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit STAT
objefile=./prt/x$sky.fit<br />
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit CATCHART
path_astromcatalog=/cdrom/ astromcatalog=Microcat
catafile=./prt/c$sky.fit<br />
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit
ASTROMETRY<br />
IMA/SERIES ./prt/ $sky . . .fit ./prt/ $sky . .fit CATCHART
path_astromcatalog=/cdrom/ astromcatalog=Microcat
catafile=./prt/c$sky.fit jpegfile_chart2=./prt/$skyb.jpg<br />
IMA/SERIES ./prt/ x$sky . . .fit . . . .fit DELETE<br />
IMA/SERIES ./prt/ c$sky . . .fit . . . .fit DELETE<br />
</p>

</body></html>